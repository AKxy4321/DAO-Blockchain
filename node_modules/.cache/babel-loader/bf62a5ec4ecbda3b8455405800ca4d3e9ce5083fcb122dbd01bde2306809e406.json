{"ast":null,"code":"import destr from 'destr';\nimport { n as normalizeBaseKey, a as normalizeKey, b as asyncCall, d as deserializeRaw, s as stringify, c as serializeRaw, j as joinKeys } from './shared/unstorage.8581f561.mjs';\nexport { p as prefixStorage } from './shared/unstorage.8581f561.mjs';\nfunction defineDriver(factory) {\n  return factory;\n}\nconst DRIVER_NAME = \"memory\";\nconst memory = defineDriver(() => {\n  const data = /* @__PURE__ */new Map();\n  return {\n    name: DRIVER_NAME,\n    options: {},\n    hasItem(key) {\n      return data.has(key);\n    },\n    getItem(key) {\n      var _data$get;\n      return (_data$get = data.get(key)) !== null && _data$get !== void 0 ? _data$get : null;\n    },\n    getItemRaw(key) {\n      var _data$get2;\n      return (_data$get2 = data.get(key)) !== null && _data$get2 !== void 0 ? _data$get2 : null;\n    },\n    setItem(key, value) {\n      data.set(key, value);\n    },\n    setItemRaw(key, value) {\n      data.set(key, value);\n    },\n    removeItem(key) {\n      data.delete(key);\n    },\n    getKeys() {\n      return Array.from(data.keys());\n    },\n    clear() {\n      data.clear();\n    },\n    dispose() {\n      data.clear();\n    }\n  };\n});\nfunction createStorage() {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const context = {\n    mounts: {\n      \"\": options.driver || memory()\n    },\n    mountpoints: [\"\"],\n    watching: false,\n    watchListeners: [],\n    unwatch: {}\n  };\n  const getMount = key => {\n    for (const base of context.mountpoints) {\n      if (key.startsWith(base)) {\n        return {\n          base,\n          relativeKey: key.slice(base.length),\n          driver: context.mounts[base]\n        };\n      }\n    }\n    return {\n      base: \"\",\n      relativeKey: key,\n      driver: context.mounts[\"\"]\n    };\n  };\n  const getMounts = (base, includeParent) => {\n    return context.mountpoints.filter(mountpoint => mountpoint.startsWith(base) || includeParent && base.startsWith(mountpoint)).map(mountpoint => ({\n      relativeBase: base.length > mountpoint.length ? base.slice(mountpoint.length) : void 0,\n      mountpoint,\n      driver: context.mounts[mountpoint]\n    }));\n  };\n  const onChange = (event, key) => {\n    if (!context.watching) {\n      return;\n    }\n    key = normalizeKey(key);\n    for (const listener of context.watchListeners) {\n      listener(event, key);\n    }\n  };\n  const startWatch = async () => {\n    if (context.watching) {\n      return;\n    }\n    context.watching = true;\n    for (const mountpoint in context.mounts) {\n      context.unwatch[mountpoint] = await watch(context.mounts[mountpoint], onChange, mountpoint);\n    }\n  };\n  const stopWatch = async () => {\n    if (!context.watching) {\n      return;\n    }\n    for (const mountpoint in context.unwatch) {\n      await context.unwatch[mountpoint]();\n    }\n    context.unwatch = {};\n    context.watching = false;\n  };\n  const runBatch = (items, commonOptions, cb) => {\n    const batches = /* @__PURE__ */new Map();\n    const getBatch = mount => {\n      let batch = batches.get(mount.base);\n      if (!batch) {\n        batch = {\n          driver: mount.driver,\n          base: mount.base,\n          items: []\n        };\n        batches.set(mount.base, batch);\n      }\n      return batch;\n    };\n    for (const item of items) {\n      const isStringItem = typeof item === \"string\";\n      const key = normalizeKey(isStringItem ? item : item.key);\n      const value = isStringItem ? void 0 : item.value;\n      const options2 = isStringItem || !item.options ? commonOptions : {\n        ...commonOptions,\n        ...item.options\n      };\n      const mount = getMount(key);\n      getBatch(mount).items.push({\n        key,\n        value,\n        relativeKey: mount.relativeKey,\n        options: options2\n      });\n    }\n    return Promise.all([...batches.values()].map(batch => cb(batch))).then(r => r.flat());\n  };\n  const storage = {\n    // Item\n    hasItem(key) {\n      let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      key = normalizeKey(key);\n      const {\n        relativeKey,\n        driver\n      } = getMount(key);\n      return asyncCall(driver.hasItem, relativeKey, opts);\n    },\n    getItem(key) {\n      let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      key = normalizeKey(key);\n      const {\n        relativeKey,\n        driver\n      } = getMount(key);\n      return asyncCall(driver.getItem, relativeKey, opts).then(value => destr(value));\n    },\n    getItems(items, commonOptions) {\n      return runBatch(items, commonOptions, batch => {\n        if (batch.driver.getItems) {\n          return asyncCall(batch.driver.getItems, batch.items.map(item => ({\n            key: item.relativeKey,\n            options: item.options\n          })), commonOptions).then(r => r.map(item => ({\n            key: joinKeys(batch.base, item.key),\n            value: destr(item.value)\n          })));\n        }\n        return Promise.all(batch.items.map(item => {\n          return asyncCall(batch.driver.getItem, item.relativeKey, item.options).then(value => ({\n            key: item.key,\n            value: destr(value)\n          }));\n        }));\n      });\n    },\n    getItemRaw(key) {\n      let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      key = normalizeKey(key);\n      const {\n        relativeKey,\n        driver\n      } = getMount(key);\n      if (driver.getItemRaw) {\n        return asyncCall(driver.getItemRaw, relativeKey, opts);\n      }\n      return asyncCall(driver.getItem, relativeKey, opts).then(value => deserializeRaw(value));\n    },\n    async setItem(key, value) {\n      let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      if (value === void 0) {\n        return storage.removeItem(key);\n      }\n      key = normalizeKey(key);\n      const {\n        relativeKey,\n        driver\n      } = getMount(key);\n      if (!driver.setItem) {\n        return;\n      }\n      await asyncCall(driver.setItem, relativeKey, stringify(value), opts);\n      if (!driver.watch) {\n        onChange(\"update\", key);\n      }\n    },\n    async setItems(items, commonOptions) {\n      await runBatch(items, commonOptions, async batch => {\n        if (batch.driver.setItems) {\n          await asyncCall(batch.driver.setItems, batch.items.map(item => ({\n            key: item.relativeKey,\n            value: stringify(item.value),\n            options: item.options\n          })), commonOptions);\n        }\n        if (!batch.driver.setItem) {\n          return;\n        }\n        await Promise.all(batch.items.map(item => {\n          return asyncCall(batch.driver.setItem, item.relativeKey, stringify(item.value), item.options);\n        }));\n      });\n    },\n    async setItemRaw(key, value) {\n      let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      if (value === void 0) {\n        return storage.removeItem(key, opts);\n      }\n      key = normalizeKey(key);\n      const {\n        relativeKey,\n        driver\n      } = getMount(key);\n      if (driver.setItemRaw) {\n        await asyncCall(driver.setItemRaw, relativeKey, value, opts);\n      } else if (driver.setItem) {\n        await asyncCall(driver.setItem, relativeKey, serializeRaw(value), opts);\n      } else {\n        return;\n      }\n      if (!driver.watch) {\n        onChange(\"update\", key);\n      }\n    },\n    async removeItem(key) {\n      let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      if (typeof opts === \"boolean\") {\n        opts = {\n          removeMeta: opts\n        };\n      }\n      key = normalizeKey(key);\n      const {\n        relativeKey,\n        driver\n      } = getMount(key);\n      if (!driver.removeItem) {\n        return;\n      }\n      await asyncCall(driver.removeItem, relativeKey, opts);\n      if (opts.removeMeta || opts.removeMata) {\n        await asyncCall(driver.removeItem, relativeKey + \"$\", opts);\n      }\n      if (!driver.watch) {\n        onChange(\"remove\", key);\n      }\n    },\n    // Meta\n    async getMeta(key) {\n      let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      if (typeof opts === \"boolean\") {\n        opts = {\n          nativeOnly: opts\n        };\n      }\n      key = normalizeKey(key);\n      const {\n        relativeKey,\n        driver\n      } = getMount(key);\n      const meta = /* @__PURE__ */Object.create(null);\n      if (driver.getMeta) {\n        Object.assign(meta, await asyncCall(driver.getMeta, relativeKey, opts));\n      }\n      if (!opts.nativeOnly) {\n        const value = await asyncCall(driver.getItem, relativeKey + \"$\", opts).then(value_ => destr(value_));\n        if (value && typeof value === \"object\") {\n          if (typeof value.atime === \"string\") {\n            value.atime = new Date(value.atime);\n          }\n          if (typeof value.mtime === \"string\") {\n            value.mtime = new Date(value.mtime);\n          }\n          Object.assign(meta, value);\n        }\n      }\n      return meta;\n    },\n    setMeta(key, value) {\n      let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      return this.setItem(key + \"$\", value, opts);\n    },\n    removeMeta(key) {\n      let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.removeItem(key + \"$\", opts);\n    },\n    // Keys\n    async getKeys(base) {\n      let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      base = normalizeBaseKey(base);\n      const mounts = getMounts(base, true);\n      let maskedMounts = [];\n      const allKeys = [];\n      for (const mount of mounts) {\n        const rawKeys = await asyncCall(mount.driver.getKeys, mount.relativeBase, opts);\n        const keys = rawKeys.map(key => mount.mountpoint + normalizeKey(key)).filter(key => !maskedMounts.some(p => key.startsWith(p)));\n        allKeys.push(...keys);\n        maskedMounts = [mount.mountpoint, ...maskedMounts.filter(p => !p.startsWith(mount.mountpoint))];\n      }\n      return base ? allKeys.filter(key => key.startsWith(base) && !key.endsWith(\"$\")) : allKeys.filter(key => !key.endsWith(\"$\"));\n    },\n    // Utils\n    async clear(base) {\n      let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      base = normalizeBaseKey(base);\n      await Promise.all(getMounts(base, false).map(async m => {\n        if (m.driver.clear) {\n          return asyncCall(m.driver.clear, m.relativeBase, opts);\n        }\n        if (m.driver.removeItem) {\n          const keys = await m.driver.getKeys(m.relativeBase || \"\", opts);\n          return Promise.all(keys.map(key => m.driver.removeItem(key, opts)));\n        }\n      }));\n    },\n    async dispose() {\n      await Promise.all(Object.values(context.mounts).map(driver => dispose(driver)));\n    },\n    async watch(callback) {\n      await startWatch();\n      context.watchListeners.push(callback);\n      return async () => {\n        context.watchListeners = context.watchListeners.filter(listener => listener !== callback);\n        if (context.watchListeners.length === 0) {\n          await stopWatch();\n        }\n      };\n    },\n    async unwatch() {\n      context.watchListeners = [];\n      await stopWatch();\n    },\n    // Mount\n    mount(base, driver) {\n      base = normalizeBaseKey(base);\n      if (base && context.mounts[base]) {\n        throw new Error(\"already mounted at \".concat(base));\n      }\n      if (base) {\n        context.mountpoints.push(base);\n        context.mountpoints.sort((a, b) => b.length - a.length);\n      }\n      context.mounts[base] = driver;\n      if (context.watching) {\n        Promise.resolve(watch(driver, onChange, base)).then(unwatcher => {\n          context.unwatch[base] = unwatcher;\n        }).catch(console.error);\n      }\n      return storage;\n    },\n    async unmount(base) {\n      let _dispose = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      base = normalizeBaseKey(base);\n      if (!base || !context.mounts[base]) {\n        return;\n      }\n      if (context.watching && base in context.unwatch) {\n        context.unwatch[base]();\n        delete context.unwatch[base];\n      }\n      if (_dispose) {\n        await dispose(context.mounts[base]);\n      }\n      context.mountpoints = context.mountpoints.filter(key => key !== base);\n      delete context.mounts[base];\n    },\n    getMount() {\n      let key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n      key = normalizeKey(key) + \":\";\n      const m = getMount(key);\n      return {\n        driver: m.driver,\n        base: m.base\n      };\n    },\n    getMounts() {\n      let base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n      let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      base = normalizeKey(base);\n      const mounts = getMounts(base, opts.parents);\n      return mounts.map(m => ({\n        driver: m.driver,\n        base: m.mountpoint\n      }));\n    }\n  };\n  return storage;\n}\nasync function snapshot(storage, base) {\n  base = normalizeBaseKey(base);\n  const keys = await storage.getKeys(base);\n  const snapshot2 = {};\n  await Promise.all(keys.map(async key => {\n    snapshot2[key.slice(base.length)] = await storage.getItem(key);\n  }));\n  return snapshot2;\n}\nasync function restoreSnapshot(driver, snapshot2) {\n  let base = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n  base = normalizeBaseKey(base);\n  await Promise.all(Object.entries(snapshot2).map(e => driver.setItem(base + e[0], e[1])));\n}\nfunction watch(driver, onChange, base) {\n  return driver.watch ? driver.watch((event, key) => onChange(event, base + key)) : () => {};\n}\nasync function dispose(driver) {\n  if (typeof driver.dispose === \"function\") {\n    await asyncCall(driver.dispose);\n  }\n}\nconst builtinDrivers = {\n  azureAppConfiguration: \"unstorage/drivers/azure-app-configuration\",\n  azureCosmos: \"unstorage/drivers/azure-cosmos\",\n  azureKeyVault: \"unstorage/drivers/azure-key-vault\",\n  azureStorageBlob: \"unstorage/drivers/azure-storage-blob\",\n  azureStorageTable: \"unstorage/drivers/azure-storage-table\",\n  cloudflareKVBinding: \"unstorage/drivers/cloudflare-kv-binding\",\n  cloudflareKVHTTP: \"unstorage/drivers/cloudflare-kv-http\",\n  cloudflareR2Binding: \"unstorage/drivers/cloudflare-r2-binding\",\n  fs: \"unstorage/drivers/fs\",\n  fsLite: \"unstorage/drivers/fs-lite\",\n  github: \"unstorage/drivers/github\",\n  http: \"unstorage/drivers/http\",\n  indexedb: \"unstorage/drivers/indexedb\",\n  localStorage: \"unstorage/drivers/localstorage\",\n  lruCache: \"unstorage/drivers/lru-cache\",\n  memory: \"unstorage/drivers/memory\",\n  mongodb: \"unstorage/drivers/mongodb\",\n  netlifyBlobs: \"unstorage/drivers/netlify-blobs\",\n  overlay: \"unstorage/drivers/overlay\",\n  planetscale: \"unstorage/drivers/planetscale\",\n  redis: \"unstorage/drivers/redis\",\n  sessionStorage: \"unstorage/drivers/session-storage\",\n  vercelKV: \"unstorage/drivers/vercel-kv\",\n  /** @deprecated */\n  \"cloudflare-kv-binding\": \"unstorage/drivers/cloudflare-kv-binding\",\n  /** @deprecated */\n  \"cloudflare-kv-http\": \"unstorage/drivers/cloudflare-kv-http\"\n};\nexport { builtinDrivers, createStorage, defineDriver, joinKeys, normalizeBaseKey, normalizeKey, restoreSnapshot, snapshot };","map":{"version":3,"names":["destr","n","normalizeBaseKey","a","normalizeKey","b","asyncCall","d","deserializeRaw","s","stringify","c","serializeRaw","j","joinKeys","p","prefixStorage","defineDriver","factory","DRIVER_NAME","memory","data","Map","name","options","hasItem","key","has","getItem","_data$get","get","getItemRaw","_data$get2","setItem","value","set","setItemRaw","removeItem","delete","getKeys","Array","from","keys","clear","dispose","createStorage","arguments","length","undefined","context","mounts","driver","mountpoints","watching","watchListeners","unwatch","getMount","base","startsWith","relativeKey","slice","getMounts","includeParent","filter","mountpoint","map","relativeBase","onChange","event","listener","startWatch","watch","stopWatch","runBatch","items","commonOptions","cb","batches","getBatch","mount","batch","item","isStringItem","options2","push","Promise","all","values","then","r","flat","storage","opts","getItems","setItems","removeMeta","removeMata","getMeta","nativeOnly","meta","Object","create","assign","value_","atime","Date","mtime","setMeta","maskedMounts","allKeys","rawKeys","some","endsWith","m","callback","Error","concat","sort","resolve","unwatcher","catch","console","error","unmount","_dispose","parents","snapshot","snapshot2","restoreSnapshot","entries","e","builtinDrivers","azureAppConfiguration","azureCosmos","azureKeyVault","azureStorageBlob","azureStorageTable","cloudflareKVBinding","cloudflareKVHTTP","cloudflareR2Binding","fs","fsLite","github","http","indexedb","localStorage","lruCache","mongodb","netlifyBlobs","overlay","planetscale","redis","sessionStorage","vercelKV"],"sources":["C:/Misc/Documents/Career/FinTech/BlockChain/FrontEnd/buildspace-dao-starter/node_modules/unstorage/dist/index.mjs"],"sourcesContent":["import destr from 'destr';\nimport { n as normalizeBaseKey, a as normalizeKey, b as asyncCall, d as deserializeRaw, s as stringify, c as serializeRaw, j as joinKeys } from './shared/unstorage.8581f561.mjs';\nexport { p as prefixStorage } from './shared/unstorage.8581f561.mjs';\n\nfunction defineDriver(factory) {\n  return factory;\n}\n\nconst DRIVER_NAME = \"memory\";\nconst memory = defineDriver(() => {\n  const data = /* @__PURE__ */ new Map();\n  return {\n    name: DRIVER_NAME,\n    options: {},\n    hasItem(key) {\n      return data.has(key);\n    },\n    getItem(key) {\n      return data.get(key) ?? null;\n    },\n    getItemRaw(key) {\n      return data.get(key) ?? null;\n    },\n    setItem(key, value) {\n      data.set(key, value);\n    },\n    setItemRaw(key, value) {\n      data.set(key, value);\n    },\n    removeItem(key) {\n      data.delete(key);\n    },\n    getKeys() {\n      return Array.from(data.keys());\n    },\n    clear() {\n      data.clear();\n    },\n    dispose() {\n      data.clear();\n    }\n  };\n});\n\nfunction createStorage(options = {}) {\n  const context = {\n    mounts: { \"\": options.driver || memory() },\n    mountpoints: [\"\"],\n    watching: false,\n    watchListeners: [],\n    unwatch: {}\n  };\n  const getMount = (key) => {\n    for (const base of context.mountpoints) {\n      if (key.startsWith(base)) {\n        return {\n          base,\n          relativeKey: key.slice(base.length),\n          driver: context.mounts[base]\n        };\n      }\n    }\n    return {\n      base: \"\",\n      relativeKey: key,\n      driver: context.mounts[\"\"]\n    };\n  };\n  const getMounts = (base, includeParent) => {\n    return context.mountpoints.filter(\n      (mountpoint) => mountpoint.startsWith(base) || includeParent && base.startsWith(mountpoint)\n    ).map((mountpoint) => ({\n      relativeBase: base.length > mountpoint.length ? base.slice(mountpoint.length) : void 0,\n      mountpoint,\n      driver: context.mounts[mountpoint]\n    }));\n  };\n  const onChange = (event, key) => {\n    if (!context.watching) {\n      return;\n    }\n    key = normalizeKey(key);\n    for (const listener of context.watchListeners) {\n      listener(event, key);\n    }\n  };\n  const startWatch = async () => {\n    if (context.watching) {\n      return;\n    }\n    context.watching = true;\n    for (const mountpoint in context.mounts) {\n      context.unwatch[mountpoint] = await watch(\n        context.mounts[mountpoint],\n        onChange,\n        mountpoint\n      );\n    }\n  };\n  const stopWatch = async () => {\n    if (!context.watching) {\n      return;\n    }\n    for (const mountpoint in context.unwatch) {\n      await context.unwatch[mountpoint]();\n    }\n    context.unwatch = {};\n    context.watching = false;\n  };\n  const runBatch = (items, commonOptions, cb) => {\n    const batches = /* @__PURE__ */ new Map();\n    const getBatch = (mount) => {\n      let batch = batches.get(mount.base);\n      if (!batch) {\n        batch = {\n          driver: mount.driver,\n          base: mount.base,\n          items: []\n        };\n        batches.set(mount.base, batch);\n      }\n      return batch;\n    };\n    for (const item of items) {\n      const isStringItem = typeof item === \"string\";\n      const key = normalizeKey(isStringItem ? item : item.key);\n      const value = isStringItem ? void 0 : item.value;\n      const options2 = isStringItem || !item.options ? commonOptions : { ...commonOptions, ...item.options };\n      const mount = getMount(key);\n      getBatch(mount).items.push({\n        key,\n        value,\n        relativeKey: mount.relativeKey,\n        options: options2\n      });\n    }\n    return Promise.all([...batches.values()].map((batch) => cb(batch))).then(\n      (r) => r.flat()\n    );\n  };\n  const storage = {\n    // Item\n    hasItem(key, opts = {}) {\n      key = normalizeKey(key);\n      const { relativeKey, driver } = getMount(key);\n      return asyncCall(driver.hasItem, relativeKey, opts);\n    },\n    getItem(key, opts = {}) {\n      key = normalizeKey(key);\n      const { relativeKey, driver } = getMount(key);\n      return asyncCall(driver.getItem, relativeKey, opts).then(\n        (value) => destr(value)\n      );\n    },\n    getItems(items, commonOptions) {\n      return runBatch(items, commonOptions, (batch) => {\n        if (batch.driver.getItems) {\n          return asyncCall(\n            batch.driver.getItems,\n            batch.items.map((item) => ({\n              key: item.relativeKey,\n              options: item.options\n            })),\n            commonOptions\n          ).then(\n            (r) => r.map((item) => ({\n              key: joinKeys(batch.base, item.key),\n              value: destr(item.value)\n            }))\n          );\n        }\n        return Promise.all(\n          batch.items.map((item) => {\n            return asyncCall(\n              batch.driver.getItem,\n              item.relativeKey,\n              item.options\n            ).then((value) => ({\n              key: item.key,\n              value: destr(value)\n            }));\n          })\n        );\n      });\n    },\n    getItemRaw(key, opts = {}) {\n      key = normalizeKey(key);\n      const { relativeKey, driver } = getMount(key);\n      if (driver.getItemRaw) {\n        return asyncCall(driver.getItemRaw, relativeKey, opts);\n      }\n      return asyncCall(driver.getItem, relativeKey, opts).then(\n        (value) => deserializeRaw(value)\n      );\n    },\n    async setItem(key, value, opts = {}) {\n      if (value === void 0) {\n        return storage.removeItem(key);\n      }\n      key = normalizeKey(key);\n      const { relativeKey, driver } = getMount(key);\n      if (!driver.setItem) {\n        return;\n      }\n      await asyncCall(driver.setItem, relativeKey, stringify(value), opts);\n      if (!driver.watch) {\n        onChange(\"update\", key);\n      }\n    },\n    async setItems(items, commonOptions) {\n      await runBatch(items, commonOptions, async (batch) => {\n        if (batch.driver.setItems) {\n          await asyncCall(\n            batch.driver.setItems,\n            batch.items.map((item) => ({\n              key: item.relativeKey,\n              value: stringify(item.value),\n              options: item.options\n            })),\n            commonOptions\n          );\n        }\n        if (!batch.driver.setItem) {\n          return;\n        }\n        await Promise.all(\n          batch.items.map((item) => {\n            return asyncCall(\n              batch.driver.setItem,\n              item.relativeKey,\n              stringify(item.value),\n              item.options\n            );\n          })\n        );\n      });\n    },\n    async setItemRaw(key, value, opts = {}) {\n      if (value === void 0) {\n        return storage.removeItem(key, opts);\n      }\n      key = normalizeKey(key);\n      const { relativeKey, driver } = getMount(key);\n      if (driver.setItemRaw) {\n        await asyncCall(driver.setItemRaw, relativeKey, value, opts);\n      } else if (driver.setItem) {\n        await asyncCall(driver.setItem, relativeKey, serializeRaw(value), opts);\n      } else {\n        return;\n      }\n      if (!driver.watch) {\n        onChange(\"update\", key);\n      }\n    },\n    async removeItem(key, opts = {}) {\n      if (typeof opts === \"boolean\") {\n        opts = { removeMeta: opts };\n      }\n      key = normalizeKey(key);\n      const { relativeKey, driver } = getMount(key);\n      if (!driver.removeItem) {\n        return;\n      }\n      await asyncCall(driver.removeItem, relativeKey, opts);\n      if (opts.removeMeta || opts.removeMata) {\n        await asyncCall(driver.removeItem, relativeKey + \"$\", opts);\n      }\n      if (!driver.watch) {\n        onChange(\"remove\", key);\n      }\n    },\n    // Meta\n    async getMeta(key, opts = {}) {\n      if (typeof opts === \"boolean\") {\n        opts = { nativeOnly: opts };\n      }\n      key = normalizeKey(key);\n      const { relativeKey, driver } = getMount(key);\n      const meta = /* @__PURE__ */ Object.create(null);\n      if (driver.getMeta) {\n        Object.assign(meta, await asyncCall(driver.getMeta, relativeKey, opts));\n      }\n      if (!opts.nativeOnly) {\n        const value = await asyncCall(\n          driver.getItem,\n          relativeKey + \"$\",\n          opts\n        ).then((value_) => destr(value_));\n        if (value && typeof value === \"object\") {\n          if (typeof value.atime === \"string\") {\n            value.atime = new Date(value.atime);\n          }\n          if (typeof value.mtime === \"string\") {\n            value.mtime = new Date(value.mtime);\n          }\n          Object.assign(meta, value);\n        }\n      }\n      return meta;\n    },\n    setMeta(key, value, opts = {}) {\n      return this.setItem(key + \"$\", value, opts);\n    },\n    removeMeta(key, opts = {}) {\n      return this.removeItem(key + \"$\", opts);\n    },\n    // Keys\n    async getKeys(base, opts = {}) {\n      base = normalizeBaseKey(base);\n      const mounts = getMounts(base, true);\n      let maskedMounts = [];\n      const allKeys = [];\n      for (const mount of mounts) {\n        const rawKeys = await asyncCall(\n          mount.driver.getKeys,\n          mount.relativeBase,\n          opts\n        );\n        const keys = rawKeys.map((key) => mount.mountpoint + normalizeKey(key)).filter((key) => !maskedMounts.some((p) => key.startsWith(p)));\n        allKeys.push(...keys);\n        maskedMounts = [\n          mount.mountpoint,\n          ...maskedMounts.filter((p) => !p.startsWith(mount.mountpoint))\n        ];\n      }\n      return base ? allKeys.filter((key) => key.startsWith(base) && !key.endsWith(\"$\")) : allKeys.filter((key) => !key.endsWith(\"$\"));\n    },\n    // Utils\n    async clear(base, opts = {}) {\n      base = normalizeBaseKey(base);\n      await Promise.all(\n        getMounts(base, false).map(async (m) => {\n          if (m.driver.clear) {\n            return asyncCall(m.driver.clear, m.relativeBase, opts);\n          }\n          if (m.driver.removeItem) {\n            const keys = await m.driver.getKeys(m.relativeBase || \"\", opts);\n            return Promise.all(\n              keys.map((key) => m.driver.removeItem(key, opts))\n            );\n          }\n        })\n      );\n    },\n    async dispose() {\n      await Promise.all(\n        Object.values(context.mounts).map((driver) => dispose(driver))\n      );\n    },\n    async watch(callback) {\n      await startWatch();\n      context.watchListeners.push(callback);\n      return async () => {\n        context.watchListeners = context.watchListeners.filter(\n          (listener) => listener !== callback\n        );\n        if (context.watchListeners.length === 0) {\n          await stopWatch();\n        }\n      };\n    },\n    async unwatch() {\n      context.watchListeners = [];\n      await stopWatch();\n    },\n    // Mount\n    mount(base, driver) {\n      base = normalizeBaseKey(base);\n      if (base && context.mounts[base]) {\n        throw new Error(`already mounted at ${base}`);\n      }\n      if (base) {\n        context.mountpoints.push(base);\n        context.mountpoints.sort((a, b) => b.length - a.length);\n      }\n      context.mounts[base] = driver;\n      if (context.watching) {\n        Promise.resolve(watch(driver, onChange, base)).then((unwatcher) => {\n          context.unwatch[base] = unwatcher;\n        }).catch(console.error);\n      }\n      return storage;\n    },\n    async unmount(base, _dispose = true) {\n      base = normalizeBaseKey(base);\n      if (!base || !context.mounts[base]) {\n        return;\n      }\n      if (context.watching && base in context.unwatch) {\n        context.unwatch[base]();\n        delete context.unwatch[base];\n      }\n      if (_dispose) {\n        await dispose(context.mounts[base]);\n      }\n      context.mountpoints = context.mountpoints.filter((key) => key !== base);\n      delete context.mounts[base];\n    },\n    getMount(key = \"\") {\n      key = normalizeKey(key) + \":\";\n      const m = getMount(key);\n      return {\n        driver: m.driver,\n        base: m.base\n      };\n    },\n    getMounts(base = \"\", opts = {}) {\n      base = normalizeKey(base);\n      const mounts = getMounts(base, opts.parents);\n      return mounts.map((m) => ({\n        driver: m.driver,\n        base: m.mountpoint\n      }));\n    }\n  };\n  return storage;\n}\nasync function snapshot(storage, base) {\n  base = normalizeBaseKey(base);\n  const keys = await storage.getKeys(base);\n  const snapshot2 = {};\n  await Promise.all(\n    keys.map(async (key) => {\n      snapshot2[key.slice(base.length)] = await storage.getItem(key);\n    })\n  );\n  return snapshot2;\n}\nasync function restoreSnapshot(driver, snapshot2, base = \"\") {\n  base = normalizeBaseKey(base);\n  await Promise.all(\n    Object.entries(snapshot2).map((e) => driver.setItem(base + e[0], e[1]))\n  );\n}\nfunction watch(driver, onChange, base) {\n  return driver.watch ? driver.watch((event, key) => onChange(event, base + key)) : () => {\n  };\n}\nasync function dispose(driver) {\n  if (typeof driver.dispose === \"function\") {\n    await asyncCall(driver.dispose);\n  }\n}\n\nconst builtinDrivers = {\n  azureAppConfiguration: \"unstorage/drivers/azure-app-configuration\",\n  azureCosmos: \"unstorage/drivers/azure-cosmos\",\n  azureKeyVault: \"unstorage/drivers/azure-key-vault\",\n  azureStorageBlob: \"unstorage/drivers/azure-storage-blob\",\n  azureStorageTable: \"unstorage/drivers/azure-storage-table\",\n  cloudflareKVBinding: \"unstorage/drivers/cloudflare-kv-binding\",\n  cloudflareKVHTTP: \"unstorage/drivers/cloudflare-kv-http\",\n  cloudflareR2Binding: \"unstorage/drivers/cloudflare-r2-binding\",\n  fs: \"unstorage/drivers/fs\",\n  fsLite: \"unstorage/drivers/fs-lite\",\n  github: \"unstorage/drivers/github\",\n  http: \"unstorage/drivers/http\",\n  indexedb: \"unstorage/drivers/indexedb\",\n  localStorage: \"unstorage/drivers/localstorage\",\n  lruCache: \"unstorage/drivers/lru-cache\",\n  memory: \"unstorage/drivers/memory\",\n  mongodb: \"unstorage/drivers/mongodb\",\n  netlifyBlobs: \"unstorage/drivers/netlify-blobs\",\n  overlay: \"unstorage/drivers/overlay\",\n  planetscale: \"unstorage/drivers/planetscale\",\n  redis: \"unstorage/drivers/redis\",\n  sessionStorage: \"unstorage/drivers/session-storage\",\n  vercelKV: \"unstorage/drivers/vercel-kv\",\n  /** @deprecated */\n  \"cloudflare-kv-binding\": \"unstorage/drivers/cloudflare-kv-binding\",\n  /** @deprecated */\n  \"cloudflare-kv-http\": \"unstorage/drivers/cloudflare-kv-http\"\n};\n\nexport { builtinDrivers, createStorage, defineDriver, joinKeys, normalizeBaseKey, normalizeKey, restoreSnapshot, snapshot };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}