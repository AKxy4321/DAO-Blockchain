{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MerkleMountainRange = void 0;\nconst buffer_1 = require(\"buffer\");\nconst sha256_1 = __importDefault(require(\"crypto-js/sha256\"));\nconst Base_1 = __importDefault(require(\"./Base\"));\n// @credit: https://github.com/wanseob/solidity-mmr\n/**\n * @desc The index of this MMR implementation starts from 1 not 0.\n */\nclass MerkleMountainRange extends Base_1.default {\n  constructor() {\n    let hashFn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : sha256_1.default;\n    let leaves = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    let hashLeafFn = arguments.length > 2 ? arguments[2] : undefined;\n    let peakBaggingFn = arguments.length > 3 ? arguments[3] : undefined;\n    let hashBranchFn = arguments.length > 4 ? arguments[4] : undefined;\n    super();\n    this.root = buffer_1.Buffer.alloc(0);\n    this.size = 0;\n    this.width = 0;\n    this.hashes = {};\n    this.data = {};\n    leaves = leaves.map(this.bufferify);\n    this.hashFn = this.bufferifyFn(hashFn);\n    this.hashLeafFn = hashLeafFn;\n    this.peakBaggingFn = peakBaggingFn;\n    this.hashBranchFn = hashBranchFn;\n    for (const leaf of leaves) {\n      this.append(leaf);\n    }\n  }\n  /**\n   * @desc This only stores the hashed value of the leaf.\n   * If you need to retrieve the detail data later, use a map to store them.\n   */\n  append(data) {\n    data = this.bufferify(data);\n    const dataHash = this.hashFn(data);\n    const dataHashHex = this.bufferToHex(dataHash);\n    if (!this.data[dataHashHex] || this.bufferToHex(this.hashFn(this.data[dataHashHex])) !== dataHashHex) {\n      this.data[dataHashHex] = data;\n    }\n    const leaf = this.hashLeaf(this.size + 1, dataHash);\n    this.hashes[this.size + 1] = leaf;\n    this.width += 1;\n    // find peaks for enlarged tree\n    const peakIndexes = this.getPeakIndexes(this.width);\n    // the right most peak's value is the new size of the updated tree\n    this.size = this.getSize(this.width);\n    // starting from the left-most peak, get all peak hashes\n    const peaks = [];\n    for (let i = 0; i < peakIndexes.length; i++) {\n      peaks[i] = this._getOrCreateNode(peakIndexes[i]);\n    }\n    // update the tree root hash\n    this.root = this.peakBagging(this.width, peaks);\n  }\n  /**\n   * @desc It returns the hash of a leaf node with hash(M | DATA )\n   *       M is the index of the node.\n   */\n  hashLeaf(index, dataHash) {\n    dataHash = this.bufferify(dataHash);\n    if (this.hashLeafFn) {\n      return this.bufferify(this.hashLeafFn(index, dataHash));\n    }\n    return this.hashFn(buffer_1.Buffer.concat([this.bufferify(index), dataHash]));\n  }\n  /**\n   * @desc It returns the hash a parent node with hash(M | Left child | Right child)\n   *       M is the index of the node.\n   */\n  hashBranch(index, left, right) {\n    if (this.hashBranchFn) {\n      return this.bufferify(this.hashBranchFn(index, left, right));\n    }\n    return this.hashFn(buffer_1.Buffer.concat([this.bufferify(index), this.bufferify(left), this.bufferify(right)]));\n  }\n  getPeaks() {\n    const peakIndexes = this.getPeakIndexes(this.width);\n    const peaks = [];\n    for (let i = 0; i < peakIndexes.length; i++) {\n      peaks[i] = this.hashes[peakIndexes[i]];\n    }\n    return peaks;\n  }\n  getLeafIndex(width) {\n    if (width % 2 === 1) {\n      return this.getSize(width);\n    }\n    return this.getSize(width - 1) + 1;\n  }\n  /**\n   * @desc It returns all peaks of the smallest merkle mountain range tree which includes\n   *       the given index(size).\n   */\n  getPeakIndexes(width) {\n    const numPeaks = this.numOfPeaks(width);\n    const peakIndexes = [];\n    let count = 0;\n    let size = 0;\n    for (let i = 255; i > 0; i--) {\n      if ((width & 1 << i - 1) !== 0) {\n        // peak exists\n        size = size + (1 << i) - 1;\n        peakIndexes[count++] = size;\n        if (peakIndexes.length >= numPeaks) {\n          break;\n        }\n      }\n    }\n    if (count !== peakIndexes.length) {\n      throw new Error('invalid bit calculation');\n    }\n    return peakIndexes;\n  }\n  numOfPeaks(width) {\n    let bits = width;\n    let num = 0;\n    while (bits > 0) {\n      if (bits % 2 === 1) {\n        num++;\n      }\n      bits = bits >> 1;\n    }\n    return num;\n  }\n  peakBagging(width, peaks) {\n    const size = this.getSize(width);\n    if (this.numOfPeaks(width) !== peaks.length) {\n      throw new Error('received invalid number of peaks');\n    }\n    if (width === 0 && !peaks.length) {\n      return buffer_1.Buffer.alloc(0);\n    }\n    if (this.peakBaggingFn) {\n      return this.bufferify(this.peakBaggingFn(size, peaks));\n    }\n    return this.hashFn(buffer_1.Buffer.concat([this.bufferify(size), ...peaks.map(this.bufferify)]));\n  }\n  /**\n   * @desc It returns the size of the tree.\n   */\n  getSize(width) {\n    return (width << 1) - this.numOfPeaks(width);\n  }\n  /**\n   * @desc It returns the root value of the tree.\n   */\n  getRoot() {\n    return this.root;\n  }\n  getHexRoot() {\n    return this.bufferToHex(this.getRoot());\n  }\n  /**\n   * @dev It returns the hash value of a node for the given position. Note that the index starts from 1.\n   */\n  getNode(index) {\n    return this.hashes[index];\n  }\n  /**\n   * @desc It returns the height of the highest peak.\n   */\n  mountainHeight(size) {\n    let height = 1;\n    while (1 << height <= size + height) {\n      height++;\n    }\n    return height - 1;\n  }\n  /**\n   * @desc It returns the height of the index.\n   */\n  heightAt(index) {\n    let reducedIndex = index;\n    let peakIndex = 0;\n    let height = 0;\n    // if an index has a left mountain then subtract the mountain\n    while (reducedIndex > peakIndex) {\n      reducedIndex -= (1 << height) - 1;\n      height = this.mountainHeight(reducedIndex);\n      peakIndex = (1 << height) - 1;\n    }\n    // index is on the right slope\n    return height - (peakIndex - reducedIndex);\n  }\n  /**\n   * @desc It returns whether the index is the leaf node or not\n   */\n  isLeaf(index) {\n    return this.heightAt(index) === 1;\n  }\n  /**\n   * @desc It returns the children when it is a parent node.\n   */\n  getChildren(index) {\n    const left = index - (1 << this.heightAt(index) - 1);\n    const right = index - 1;\n    if (left === right) {\n      throw new Error('not a parent');\n    }\n    return [left, right];\n  }\n  /**\n   * @desc It returns a merkle proof for a leaf. Note that the index starts from 1.\n   */\n  getMerkleProof(index) {\n    if (index > this.size) {\n      throw new Error('out of range');\n    }\n    if (!this.isLeaf(index)) {\n      throw new Error('not a leaf');\n    }\n    const root = this.root;\n    const width = this.width;\n    // find all peaks for bagging\n    const peaks = this.getPeakIndexes(this.width);\n    const peakBagging = [];\n    let cursor = 0;\n    for (let i = 0; i < peaks.length; i++) {\n      // collect the hash of all peaks\n      peakBagging[i] = this.hashes[peaks[i]];\n      // find the peak which includes the target index\n      if (peaks[i] >= index && cursor === 0) {\n        cursor = peaks[i];\n      }\n    }\n    let left = 0;\n    let right = 0;\n    // get hashes of the siblings in the mountain which the index belgons to.\n    // it moves the cursor from the summit of the mountain down to the target index\n    let height = this.heightAt(cursor);\n    const siblings = [];\n    while (cursor !== index) {\n      height--;\n      [left, right] = this.getChildren(cursor);\n      // move the cursor down to the left size or right size\n      cursor = index <= left ? left : right;\n      // remaining node is the sibling\n      siblings[height - 1] = this.hashes[index <= left ? right : left];\n    }\n    return {\n      root,\n      width,\n      peakBagging,\n      siblings\n    };\n  }\n  /**\n   * @desc It returns true when the given params verifies that the given value exists in the tree or reverts the transaction.\n   */\n  verify(root, width, index, value, peaks, siblings) {\n    value = this.bufferify(value);\n    const size = this.getSize(width);\n    if (size < index) {\n      throw new Error('index is out of range');\n    }\n    // check the root equals the peak bagging hash\n    if (!root.equals(this.peakBagging(width, peaks))) {\n      throw new Error('invalid root hash from the peaks');\n    }\n    // find the mountain where the target index belongs to\n    let cursor = 0;\n    let targetPeak;\n    const peakIndexes = this.getPeakIndexes(width);\n    for (let i = 0; i < peakIndexes.length; i++) {\n      if (peakIndexes[i] >= index) {\n        targetPeak = peaks[i];\n        cursor = peakIndexes[i];\n        break;\n      }\n    }\n    if (!targetPeak) {\n      throw new Error('target not found');\n    }\n    // find the path climbing down\n    let height = siblings.length + 1;\n    const path = new Array(height);\n    let left = 0;\n    let right = 0;\n    while (height > 0) {\n      // record the current cursor and climb down\n      path[--height] = cursor;\n      if (cursor === index) {\n        // on the leaf node. Stop climbing down\n        break;\n      } else {\n        // on the parent node. Go left or right\n        [left, right] = this.getChildren(cursor);\n        cursor = index > left ? right : left;\n        continue;\n      }\n    }\n    // calculate the summit hash climbing up again\n    let node;\n    while (height < path.length) {\n      // move cursor\n      cursor = path[height];\n      if (height === 0) {\n        // cusor is on the leaf\n        node = this.hashLeaf(cursor, this.hashFn(value));\n      } else if (cursor - 1 === path[height - 1]) {\n        // cursor is on a parent and a siblings is on the left\n        node = this.hashBranch(cursor, siblings[height - 1], node);\n      } else {\n        // cursor is on a parent and a siblings is on the right\n        node = this.hashBranch(cursor, node, siblings[height - 1]);\n      }\n      // climb up\n      height++;\n    }\n    // computed hash value of the summit should equal to the target peak hash\n    if (!node.equals(targetPeak)) {\n      throw new Error('hashed peak is invalid');\n    }\n    return true;\n  }\n  peaksToPeakMap(width, peaks) {\n    const peakMap = {};\n    let bitIndex = 0;\n    let peakRef = 0;\n    let count = peaks.length;\n    for (let height = 1; height <= 32; height++) {\n      // index starts from the right most bit\n      bitIndex = 32 - height;\n      peakRef = 1 << height - 1;\n      if ((width & peakRef) !== 0) {\n        peakMap[bitIndex] = peaks[--count];\n      } else {\n        peakMap[bitIndex] = 0;\n      }\n    }\n    if (count !== 0) {\n      throw new Error('invalid number of peaks');\n    }\n    return peakMap;\n  }\n  peakMapToPeaks(width, peakMap) {\n    const arrLength = this.numOfPeaks(width);\n    const peaks = new Array(arrLength);\n    let count = 0;\n    for (let i = 0; i < 32; i++) {\n      if (peakMap[i] !== 0) {\n        peaks[count++] = peakMap[i];\n      }\n    }\n    if (count !== arrLength) {\n      throw new Error('invalid number of peaks');\n    }\n    return peaks;\n  }\n  peakUpdate(width, prevPeakMap, itemHash) {\n    const nextPeakMap = {};\n    const newWidth = width + 1;\n    let cursorIndex = this.getLeafIndex(newWidth);\n    let cursorNode = this.hashLeaf(cursorIndex, itemHash);\n    let bitIndex = 0;\n    let peakRef = 0;\n    let prevPeakExist = false;\n    let nextPeakExist = false;\n    let obtained = false;\n    for (let height = 1; height <= 32; height++) {\n      // index starts from the right most bit\n      bitIndex = 32 - height;\n      if (obtained) {\n        nextPeakMap[bitIndex] = prevPeakMap[bitIndex];\n      } else {\n        peakRef = 1 << height - 1;\n        prevPeakExist = (width & peakRef) !== 0;\n        nextPeakExist = (newWidth & peakRef) !== 0;\n        // get new cursor node with hashing the peak and the current cursor\n        cursorIndex++;\n        if (prevPeakExist) {\n          cursorNode = this.hashBranch(cursorIndex, prevPeakMap[bitIndex], cursorNode);\n        }\n        // if new peak exists for the bit index\n        if (nextPeakExist) {\n          // if prev peak exists for the bit index\n          if (prevPeakExist) {\n            nextPeakMap[bitIndex] = prevPeakMap[bitIndex];\n          } else {\n            nextPeakMap[bitIndex] = cursorNode;\n          }\n          obtained = true;\n        } else {\n          nextPeakMap[bitIndex] = 0;\n        }\n      }\n    }\n    return nextPeakMap;\n  }\n  rollUp(root, width, peaks, itemHashes) {\n    // check the root equals the peak bagging hash\n    if (!root.equals(this.peakBagging(width, peaks))) {\n      throw new Error('invalid root hash from the peaks');\n    }\n    let tmpWidth = width;\n    let tmpPeakMap = this.peaksToPeakMap(width, peaks);\n    for (let i = 0; i < itemHashes.length; i++) {\n      tmpPeakMap = this.peakUpdate(tmpWidth, tmpPeakMap, itemHashes[i]);\n      tmpWidth++;\n    }\n    return this.peakBagging(tmpWidth, this.peakMapToPeaks(tmpWidth, tmpPeakMap));\n  }\n  /**\n   * @desc It returns the hash value of the node for the index.\n   *      If the hash already exists it simply returns the stored value. On the other hand,\n   *      it computes hashes recursively downward.\n   *      Only appending an item calls this function.\n   */\n  _getOrCreateNode(index) {\n    if (index > this.size) {\n      throw new Error('out of range');\n    }\n    if (!this.hashes[index]) {\n      const [leftIndex, rightIndex] = this.getChildren(index);\n      const leftHash = this._getOrCreateNode(leftIndex);\n      const rightHash = this._getOrCreateNode(rightIndex);\n      this.hashes[index] = this.hashBranch(index, leftHash, rightHash);\n    }\n    return this.hashes[index];\n  }\n}\nexports.MerkleMountainRange = MerkleMountainRange;\nexports.default = MerkleMountainRange;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","MerkleMountainRange","buffer_1","require","sha256_1","Base_1","default","constructor","hashFn","arguments","length","undefined","leaves","hashLeafFn","peakBaggingFn","hashBranchFn","root","Buffer","alloc","size","width","hashes","data","map","bufferify","bufferifyFn","leaf","append","dataHash","dataHashHex","bufferToHex","hashLeaf","peakIndexes","getPeakIndexes","getSize","peaks","i","_getOrCreateNode","peakBagging","index","concat","hashBranch","left","right","getPeaks","getLeafIndex","numPeaks","numOfPeaks","count","Error","bits","num","getRoot","getHexRoot","getNode","mountainHeight","height","heightAt","reducedIndex","peakIndex","isLeaf","getChildren","getMerkleProof","cursor","siblings","verify","equals","targetPeak","path","Array","node","peaksToPeakMap","peakMap","bitIndex","peakRef","peakMapToPeaks","arrLength","peakUpdate","prevPeakMap","itemHash","nextPeakMap","newWidth","cursorIndex","cursorNode","prevPeakExist","nextPeakExist","obtained","rollUp","itemHashes","tmpWidth","tmpPeakMap","leftIndex","rightIndex","leftHash","rightHash"],"sources":["C:/Misc/Documents/Career/FinTech/BlockChain/FrontEnd/buildspace-dao-starter/node_modules/merkletreejs/dist/MerkleMountainRange.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MerkleMountainRange = void 0;\nconst buffer_1 = require(\"buffer\");\nconst sha256_1 = __importDefault(require(\"crypto-js/sha256\"));\nconst Base_1 = __importDefault(require(\"./Base\"));\n// @credit: https://github.com/wanseob/solidity-mmr\n/**\n * @desc The index of this MMR implementation starts from 1 not 0.\n */\nclass MerkleMountainRange extends Base_1.default {\n    constructor(hashFn = sha256_1.default, leaves = [], hashLeafFn, peakBaggingFn, hashBranchFn) {\n        super();\n        this.root = buffer_1.Buffer.alloc(0);\n        this.size = 0;\n        this.width = 0;\n        this.hashes = {};\n        this.data = {};\n        leaves = leaves.map(this.bufferify);\n        this.hashFn = this.bufferifyFn(hashFn);\n        this.hashLeafFn = hashLeafFn;\n        this.peakBaggingFn = peakBaggingFn;\n        this.hashBranchFn = hashBranchFn;\n        for (const leaf of leaves) {\n            this.append(leaf);\n        }\n    }\n    /**\n     * @desc This only stores the hashed value of the leaf.\n     * If you need to retrieve the detail data later, use a map to store them.\n     */\n    append(data) {\n        data = this.bufferify(data);\n        const dataHash = this.hashFn(data);\n        const dataHashHex = this.bufferToHex(dataHash);\n        if (!this.data[dataHashHex] || this.bufferToHex(this.hashFn(this.data[dataHashHex])) !== dataHashHex) {\n            this.data[dataHashHex] = data;\n        }\n        const leaf = this.hashLeaf(this.size + 1, dataHash);\n        this.hashes[this.size + 1] = leaf;\n        this.width += 1;\n        // find peaks for enlarged tree\n        const peakIndexes = this.getPeakIndexes(this.width);\n        // the right most peak's value is the new size of the updated tree\n        this.size = this.getSize(this.width);\n        // starting from the left-most peak, get all peak hashes\n        const peaks = [];\n        for (let i = 0; i < peakIndexes.length; i++) {\n            peaks[i] = this._getOrCreateNode(peakIndexes[i]);\n        }\n        // update the tree root hash\n        this.root = this.peakBagging(this.width, peaks);\n    }\n    /**\n     * @desc It returns the hash of a leaf node with hash(M | DATA )\n     *       M is the index of the node.\n     */\n    hashLeaf(index, dataHash) {\n        dataHash = this.bufferify(dataHash);\n        if (this.hashLeafFn) {\n            return this.bufferify(this.hashLeafFn(index, dataHash));\n        }\n        return this.hashFn(buffer_1.Buffer.concat([this.bufferify(index), dataHash]));\n    }\n    /**\n     * @desc It returns the hash a parent node with hash(M | Left child | Right child)\n     *       M is the index of the node.\n     */\n    hashBranch(index, left, right) {\n        if (this.hashBranchFn) {\n            return this.bufferify(this.hashBranchFn(index, left, right));\n        }\n        return this.hashFn(buffer_1.Buffer.concat([this.bufferify(index), this.bufferify(left), this.bufferify(right)]));\n    }\n    getPeaks() {\n        const peakIndexes = this.getPeakIndexes(this.width);\n        const peaks = [];\n        for (let i = 0; i < peakIndexes.length; i++) {\n            peaks[i] = this.hashes[peakIndexes[i]];\n        }\n        return peaks;\n    }\n    getLeafIndex(width) {\n        if (width % 2 === 1) {\n            return this.getSize(width);\n        }\n        return this.getSize(width - 1) + 1;\n    }\n    /**\n     * @desc It returns all peaks of the smallest merkle mountain range tree which includes\n     *       the given index(size).\n     */\n    getPeakIndexes(width) {\n        const numPeaks = this.numOfPeaks(width);\n        const peakIndexes = [];\n        let count = 0;\n        let size = 0;\n        for (let i = 255; i > 0; i--) {\n            if ((width & (1 << (i - 1))) !== 0) {\n                // peak exists\n                size = size + (1 << i) - 1;\n                peakIndexes[count++] = size;\n                if (peakIndexes.length >= numPeaks) {\n                    break;\n                }\n            }\n        }\n        if (count !== peakIndexes.length) {\n            throw new Error('invalid bit calculation');\n        }\n        return peakIndexes;\n    }\n    numOfPeaks(width) {\n        let bits = width;\n        let num = 0;\n        while (bits > 0) {\n            if (bits % 2 === 1) {\n                num++;\n            }\n            bits = bits >> 1;\n        }\n        return num;\n    }\n    peakBagging(width, peaks) {\n        const size = this.getSize(width);\n        if (this.numOfPeaks(width) !== peaks.length) {\n            throw new Error('received invalid number of peaks');\n        }\n        if (width === 0 && !peaks.length) {\n            return buffer_1.Buffer.alloc(0);\n        }\n        if (this.peakBaggingFn) {\n            return this.bufferify(this.peakBaggingFn(size, peaks));\n        }\n        return this.hashFn(buffer_1.Buffer.concat([this.bufferify(size), ...peaks.map(this.bufferify)]));\n    }\n    /**\n     * @desc It returns the size of the tree.\n     */\n    getSize(width) {\n        return (width << 1) - this.numOfPeaks(width);\n    }\n    /**\n     * @desc It returns the root value of the tree.\n     */\n    getRoot() {\n        return this.root;\n    }\n    getHexRoot() {\n        return this.bufferToHex(this.getRoot());\n    }\n    /**\n     * @dev It returns the hash value of a node for the given position. Note that the index starts from 1.\n     */\n    getNode(index) {\n        return this.hashes[index];\n    }\n    /**\n     * @desc It returns the height of the highest peak.\n     */\n    mountainHeight(size) {\n        let height = 1;\n        while (1 << height <= size + height) {\n            height++;\n        }\n        return height - 1;\n    }\n    /**\n     * @desc It returns the height of the index.\n     */\n    heightAt(index) {\n        let reducedIndex = index;\n        let peakIndex = 0;\n        let height = 0;\n        // if an index has a left mountain then subtract the mountain\n        while (reducedIndex > peakIndex) {\n            reducedIndex -= (1 << height) - 1;\n            height = this.mountainHeight(reducedIndex);\n            peakIndex = (1 << height) - 1;\n        }\n        // index is on the right slope\n        return height - (peakIndex - reducedIndex);\n    }\n    /**\n     * @desc It returns whether the index is the leaf node or not\n     */\n    isLeaf(index) {\n        return this.heightAt(index) === 1;\n    }\n    /**\n     * @desc It returns the children when it is a parent node.\n     */\n    getChildren(index) {\n        const left = index - (1 << (this.heightAt(index) - 1));\n        const right = index - 1;\n        if (left === right) {\n            throw new Error('not a parent');\n        }\n        return [left, right];\n    }\n    /**\n     * @desc It returns a merkle proof for a leaf. Note that the index starts from 1.\n     */\n    getMerkleProof(index) {\n        if (index > this.size) {\n            throw new Error('out of range');\n        }\n        if (!this.isLeaf(index)) {\n            throw new Error('not a leaf');\n        }\n        const root = this.root;\n        const width = this.width;\n        // find all peaks for bagging\n        const peaks = this.getPeakIndexes(this.width);\n        const peakBagging = [];\n        let cursor = 0;\n        for (let i = 0; i < peaks.length; i++) {\n            // collect the hash of all peaks\n            peakBagging[i] = this.hashes[peaks[i]];\n            // find the peak which includes the target index\n            if (peaks[i] >= index && cursor === 0) {\n                cursor = peaks[i];\n            }\n        }\n        let left = 0;\n        let right = 0;\n        // get hashes of the siblings in the mountain which the index belgons to.\n        // it moves the cursor from the summit of the mountain down to the target index\n        let height = this.heightAt(cursor);\n        const siblings = [];\n        while (cursor !== index) {\n            height--;\n            ([left, right] = this.getChildren(cursor));\n            // move the cursor down to the left size or right size\n            cursor = index <= left ? left : right;\n            // remaining node is the sibling\n            siblings[height - 1] = this.hashes[index <= left ? right : left];\n        }\n        return {\n            root,\n            width,\n            peakBagging,\n            siblings\n        };\n    }\n    /**\n     * @desc It returns true when the given params verifies that the given value exists in the tree or reverts the transaction.\n     */\n    verify(root, width, index, value, peaks, siblings) {\n        value = this.bufferify(value);\n        const size = this.getSize(width);\n        if (size < index) {\n            throw new Error('index is out of range');\n        }\n        // check the root equals the peak bagging hash\n        if (!root.equals(this.peakBagging(width, peaks))) {\n            throw new Error('invalid root hash from the peaks');\n        }\n        // find the mountain where the target index belongs to\n        let cursor = 0;\n        let targetPeak;\n        const peakIndexes = this.getPeakIndexes(width);\n        for (let i = 0; i < peakIndexes.length; i++) {\n            if (peakIndexes[i] >= index) {\n                targetPeak = peaks[i];\n                cursor = peakIndexes[i];\n                break;\n            }\n        }\n        if (!targetPeak) {\n            throw new Error('target not found');\n        }\n        // find the path climbing down\n        let height = siblings.length + 1;\n        const path = new Array(height);\n        let left = 0;\n        let right = 0;\n        while (height > 0) {\n            // record the current cursor and climb down\n            path[--height] = cursor;\n            if (cursor === index) {\n                // on the leaf node. Stop climbing down\n                break;\n            }\n            else {\n                // on the parent node. Go left or right\n                ([left, right] = this.getChildren(cursor));\n                cursor = index > left ? right : left;\n                continue;\n            }\n        }\n        // calculate the summit hash climbing up again\n        let node;\n        while (height < path.length) {\n            // move cursor\n            cursor = path[height];\n            if (height === 0) {\n                // cusor is on the leaf\n                node = this.hashLeaf(cursor, this.hashFn(value));\n            }\n            else if (cursor - 1 === path[height - 1]) {\n                // cursor is on a parent and a siblings is on the left\n                node = this.hashBranch(cursor, siblings[height - 1], node);\n            }\n            else {\n                // cursor is on a parent and a siblings is on the right\n                node = this.hashBranch(cursor, node, siblings[height - 1]);\n            }\n            // climb up\n            height++;\n        }\n        // computed hash value of the summit should equal to the target peak hash\n        if (!node.equals(targetPeak)) {\n            throw new Error('hashed peak is invalid');\n        }\n        return true;\n    }\n    peaksToPeakMap(width, peaks) {\n        const peakMap = {};\n        let bitIndex = 0;\n        let peakRef = 0;\n        let count = peaks.length;\n        for (let height = 1; height <= 32; height++) {\n            // index starts from the right most bit\n            bitIndex = 32 - height;\n            peakRef = 1 << (height - 1);\n            if ((width & peakRef) !== 0) {\n                peakMap[bitIndex] = peaks[--count];\n            }\n            else {\n                peakMap[bitIndex] = 0;\n            }\n        }\n        if (count !== 0) {\n            throw new Error('invalid number of peaks');\n        }\n        return peakMap;\n    }\n    peakMapToPeaks(width, peakMap) {\n        const arrLength = this.numOfPeaks(width);\n        const peaks = new Array(arrLength);\n        let count = 0;\n        for (let i = 0; i < 32; i++) {\n            if (peakMap[i] !== 0) {\n                peaks[count++] = peakMap[i];\n            }\n        }\n        if (count !== arrLength) {\n            throw new Error('invalid number of peaks');\n        }\n        return peaks;\n    }\n    peakUpdate(width, prevPeakMap, itemHash) {\n        const nextPeakMap = {};\n        const newWidth = width + 1;\n        let cursorIndex = this.getLeafIndex(newWidth);\n        let cursorNode = this.hashLeaf(cursorIndex, itemHash);\n        let bitIndex = 0;\n        let peakRef = 0;\n        let prevPeakExist = false;\n        let nextPeakExist = false;\n        let obtained = false;\n        for (let height = 1; height <= 32; height++) {\n            // index starts from the right most bit\n            bitIndex = 32 - height;\n            if (obtained) {\n                nextPeakMap[bitIndex] = prevPeakMap[bitIndex];\n            }\n            else {\n                peakRef = 1 << (height - 1);\n                prevPeakExist = (width & peakRef) !== 0;\n                nextPeakExist = (newWidth & peakRef) !== 0;\n                // get new cursor node with hashing the peak and the current cursor\n                cursorIndex++;\n                if (prevPeakExist) {\n                    cursorNode = this.hashBranch(cursorIndex, prevPeakMap[bitIndex], cursorNode);\n                }\n                // if new peak exists for the bit index\n                if (nextPeakExist) {\n                    // if prev peak exists for the bit index\n                    if (prevPeakExist) {\n                        nextPeakMap[bitIndex] = prevPeakMap[bitIndex];\n                    }\n                    else {\n                        nextPeakMap[bitIndex] = cursorNode;\n                    }\n                    obtained = true;\n                }\n                else {\n                    nextPeakMap[bitIndex] = 0;\n                }\n            }\n        }\n        return nextPeakMap;\n    }\n    rollUp(root, width, peaks, itemHashes) {\n        // check the root equals the peak bagging hash\n        if (!root.equals(this.peakBagging(width, peaks))) {\n            throw new Error('invalid root hash from the peaks');\n        }\n        let tmpWidth = width;\n        let tmpPeakMap = this.peaksToPeakMap(width, peaks);\n        for (let i = 0; i < itemHashes.length; i++) {\n            tmpPeakMap = this.peakUpdate(tmpWidth, tmpPeakMap, itemHashes[i]);\n            tmpWidth++;\n        }\n        return this.peakBagging(tmpWidth, this.peakMapToPeaks(tmpWidth, tmpPeakMap));\n    }\n    /**\n     * @desc It returns the hash value of the node for the index.\n     *      If the hash already exists it simply returns the stored value. On the other hand,\n     *      it computes hashes recursively downward.\n     *      Only appending an item calls this function.\n     */\n    _getOrCreateNode(index) {\n        if (index > this.size) {\n            throw new Error('out of range');\n        }\n        if (!this.hashes[index]) {\n            const [leftIndex, rightIndex] = this.getChildren(index);\n            const leftHash = this._getOrCreateNode(leftIndex);\n            const rightHash = this._getOrCreateNode(rightIndex);\n            this.hashes[index] = this.hashBranch(index, leftHash, rightHash);\n        }\n        return this.hashes[index];\n    }\n}\nexports.MerkleMountainRange = MerkleMountainRange;\nexports.default = MerkleMountainRange;\n"],"mappings":"AAAA,YAAY;;AACZ,IAAIA,eAAe,GAAI,IAAI,IAAI,IAAI,CAACA,eAAe,IAAK,UAAUC,GAAG,EAAE;EACnE,OAAQA,GAAG,IAAIA,GAAG,CAACC,UAAU,GAAID,GAAG,GAAG;IAAE,SAAS,EAAEA;EAAI,CAAC;AAC7D,CAAC;AACDE,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,mBAAmB,GAAG,KAAK,CAAC;AACpC,MAAMC,QAAQ,GAAGC,OAAO,CAAC,QAAQ,CAAC;AAClC,MAAMC,QAAQ,GAAGV,eAAe,CAACS,OAAO,CAAC,kBAAkB,CAAC,CAAC;AAC7D,MAAME,MAAM,GAAGX,eAAe,CAACS,OAAO,CAAC,QAAQ,CAAC,CAAC;AACjD;AACA;AACA;AACA;AACA,MAAMF,mBAAmB,SAASI,MAAM,CAACC,OAAO,CAAC;EAC7CC,WAAWA,CAAA,EAAkF;IAAA,IAAjFC,MAAM,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAGL,QAAQ,CAACE,OAAO;IAAA,IAAEM,MAAM,GAAAH,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,EAAE;IAAA,IAAEI,UAAU,GAAAJ,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAE,SAAA;IAAA,IAAEG,aAAa,GAAAL,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAE,SAAA;IAAA,IAAEI,YAAY,GAAAN,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAE,SAAA;IACvF,KAAK,CAAC,CAAC;IACP,IAAI,CAACK,IAAI,GAAGd,QAAQ,CAACe,MAAM,CAACC,KAAK,CAAC,CAAC,CAAC;IACpC,IAAI,CAACC,IAAI,GAAG,CAAC;IACb,IAAI,CAACC,KAAK,GAAG,CAAC;IACd,IAAI,CAACC,MAAM,GAAG,CAAC,CAAC;IAChB,IAAI,CAACC,IAAI,GAAG,CAAC,CAAC;IACdV,MAAM,GAAGA,MAAM,CAACW,GAAG,CAAC,IAAI,CAACC,SAAS,CAAC;IACnC,IAAI,CAAChB,MAAM,GAAG,IAAI,CAACiB,WAAW,CAACjB,MAAM,CAAC;IACtC,IAAI,CAACK,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACC,aAAa,GAAGA,aAAa;IAClC,IAAI,CAACC,YAAY,GAAGA,YAAY;IAChC,KAAK,MAAMW,IAAI,IAAId,MAAM,EAAE;MACvB,IAAI,CAACe,MAAM,CAACD,IAAI,CAAC;IACrB;EACJ;EACA;AACJ;AACA;AACA;EACIC,MAAMA,CAACL,IAAI,EAAE;IACTA,IAAI,GAAG,IAAI,CAACE,SAAS,CAACF,IAAI,CAAC;IAC3B,MAAMM,QAAQ,GAAG,IAAI,CAACpB,MAAM,CAACc,IAAI,CAAC;IAClC,MAAMO,WAAW,GAAG,IAAI,CAACC,WAAW,CAACF,QAAQ,CAAC;IAC9C,IAAI,CAAC,IAAI,CAACN,IAAI,CAACO,WAAW,CAAC,IAAI,IAAI,CAACC,WAAW,CAAC,IAAI,CAACtB,MAAM,CAAC,IAAI,CAACc,IAAI,CAACO,WAAW,CAAC,CAAC,CAAC,KAAKA,WAAW,EAAE;MAClG,IAAI,CAACP,IAAI,CAACO,WAAW,CAAC,GAAGP,IAAI;IACjC;IACA,MAAMI,IAAI,GAAG,IAAI,CAACK,QAAQ,CAAC,IAAI,CAACZ,IAAI,GAAG,CAAC,EAAES,QAAQ,CAAC;IACnD,IAAI,CAACP,MAAM,CAAC,IAAI,CAACF,IAAI,GAAG,CAAC,CAAC,GAAGO,IAAI;IACjC,IAAI,CAACN,KAAK,IAAI,CAAC;IACf;IACA,MAAMY,WAAW,GAAG,IAAI,CAACC,cAAc,CAAC,IAAI,CAACb,KAAK,CAAC;IACnD;IACA,IAAI,CAACD,IAAI,GAAG,IAAI,CAACe,OAAO,CAAC,IAAI,CAACd,KAAK,CAAC;IACpC;IACA,MAAMe,KAAK,GAAG,EAAE;IAChB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,WAAW,CAACtB,MAAM,EAAE0B,CAAC,EAAE,EAAE;MACzCD,KAAK,CAACC,CAAC,CAAC,GAAG,IAAI,CAACC,gBAAgB,CAACL,WAAW,CAACI,CAAC,CAAC,CAAC;IACpD;IACA;IACA,IAAI,CAACpB,IAAI,GAAG,IAAI,CAACsB,WAAW,CAAC,IAAI,CAAClB,KAAK,EAAEe,KAAK,CAAC;EACnD;EACA;AACJ;AACA;AACA;EACIJ,QAAQA,CAACQ,KAAK,EAAEX,QAAQ,EAAE;IACtBA,QAAQ,GAAG,IAAI,CAACJ,SAAS,CAACI,QAAQ,CAAC;IACnC,IAAI,IAAI,CAACf,UAAU,EAAE;MACjB,OAAO,IAAI,CAACW,SAAS,CAAC,IAAI,CAACX,UAAU,CAAC0B,KAAK,EAAEX,QAAQ,CAAC,CAAC;IAC3D;IACA,OAAO,IAAI,CAACpB,MAAM,CAACN,QAAQ,CAACe,MAAM,CAACuB,MAAM,CAAC,CAAC,IAAI,CAAChB,SAAS,CAACe,KAAK,CAAC,EAAEX,QAAQ,CAAC,CAAC,CAAC;EACjF;EACA;AACJ;AACA;AACA;EACIa,UAAUA,CAACF,KAAK,EAAEG,IAAI,EAAEC,KAAK,EAAE;IAC3B,IAAI,IAAI,CAAC5B,YAAY,EAAE;MACnB,OAAO,IAAI,CAACS,SAAS,CAAC,IAAI,CAACT,YAAY,CAACwB,KAAK,EAAEG,IAAI,EAAEC,KAAK,CAAC,CAAC;IAChE;IACA,OAAO,IAAI,CAACnC,MAAM,CAACN,QAAQ,CAACe,MAAM,CAACuB,MAAM,CAAC,CAAC,IAAI,CAAChB,SAAS,CAACe,KAAK,CAAC,EAAE,IAAI,CAACf,SAAS,CAACkB,IAAI,CAAC,EAAE,IAAI,CAAClB,SAAS,CAACmB,KAAK,CAAC,CAAC,CAAC,CAAC;EACpH;EACAC,QAAQA,CAAA,EAAG;IACP,MAAMZ,WAAW,GAAG,IAAI,CAACC,cAAc,CAAC,IAAI,CAACb,KAAK,CAAC;IACnD,MAAMe,KAAK,GAAG,EAAE;IAChB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,WAAW,CAACtB,MAAM,EAAE0B,CAAC,EAAE,EAAE;MACzCD,KAAK,CAACC,CAAC,CAAC,GAAG,IAAI,CAACf,MAAM,CAACW,WAAW,CAACI,CAAC,CAAC,CAAC;IAC1C;IACA,OAAOD,KAAK;EAChB;EACAU,YAAYA,CAACzB,KAAK,EAAE;IAChB,IAAIA,KAAK,GAAG,CAAC,KAAK,CAAC,EAAE;MACjB,OAAO,IAAI,CAACc,OAAO,CAACd,KAAK,CAAC;IAC9B;IACA,OAAO,IAAI,CAACc,OAAO,CAACd,KAAK,GAAG,CAAC,CAAC,GAAG,CAAC;EACtC;EACA;AACJ;AACA;AACA;EACIa,cAAcA,CAACb,KAAK,EAAE;IAClB,MAAM0B,QAAQ,GAAG,IAAI,CAACC,UAAU,CAAC3B,KAAK,CAAC;IACvC,MAAMY,WAAW,GAAG,EAAE;IACtB,IAAIgB,KAAK,GAAG,CAAC;IACb,IAAI7B,IAAI,GAAG,CAAC;IACZ,KAAK,IAAIiB,CAAC,GAAG,GAAG,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;MAC1B,IAAI,CAAChB,KAAK,GAAI,CAAC,IAAKgB,CAAC,GAAG,CAAG,MAAM,CAAC,EAAE;QAChC;QACAjB,IAAI,GAAGA,IAAI,IAAI,CAAC,IAAIiB,CAAC,CAAC,GAAG,CAAC;QAC1BJ,WAAW,CAACgB,KAAK,EAAE,CAAC,GAAG7B,IAAI;QAC3B,IAAIa,WAAW,CAACtB,MAAM,IAAIoC,QAAQ,EAAE;UAChC;QACJ;MACJ;IACJ;IACA,IAAIE,KAAK,KAAKhB,WAAW,CAACtB,MAAM,EAAE;MAC9B,MAAM,IAAIuC,KAAK,CAAC,yBAAyB,CAAC;IAC9C;IACA,OAAOjB,WAAW;EACtB;EACAe,UAAUA,CAAC3B,KAAK,EAAE;IACd,IAAI8B,IAAI,GAAG9B,KAAK;IAChB,IAAI+B,GAAG,GAAG,CAAC;IACX,OAAOD,IAAI,GAAG,CAAC,EAAE;MACb,IAAIA,IAAI,GAAG,CAAC,KAAK,CAAC,EAAE;QAChBC,GAAG,EAAE;MACT;MACAD,IAAI,GAAGA,IAAI,IAAI,CAAC;IACpB;IACA,OAAOC,GAAG;EACd;EACAb,WAAWA,CAAClB,KAAK,EAAEe,KAAK,EAAE;IACtB,MAAMhB,IAAI,GAAG,IAAI,CAACe,OAAO,CAACd,KAAK,CAAC;IAChC,IAAI,IAAI,CAAC2B,UAAU,CAAC3B,KAAK,CAAC,KAAKe,KAAK,CAACzB,MAAM,EAAE;MACzC,MAAM,IAAIuC,KAAK,CAAC,kCAAkC,CAAC;IACvD;IACA,IAAI7B,KAAK,KAAK,CAAC,IAAI,CAACe,KAAK,CAACzB,MAAM,EAAE;MAC9B,OAAOR,QAAQ,CAACe,MAAM,CAACC,KAAK,CAAC,CAAC,CAAC;IACnC;IACA,IAAI,IAAI,CAACJ,aAAa,EAAE;MACpB,OAAO,IAAI,CAACU,SAAS,CAAC,IAAI,CAACV,aAAa,CAACK,IAAI,EAAEgB,KAAK,CAAC,CAAC;IAC1D;IACA,OAAO,IAAI,CAAC3B,MAAM,CAACN,QAAQ,CAACe,MAAM,CAACuB,MAAM,CAAC,CAAC,IAAI,CAAChB,SAAS,CAACL,IAAI,CAAC,EAAE,GAAGgB,KAAK,CAACZ,GAAG,CAAC,IAAI,CAACC,SAAS,CAAC,CAAC,CAAC,CAAC;EACpG;EACA;AACJ;AACA;EACIU,OAAOA,CAACd,KAAK,EAAE;IACX,OAAO,CAACA,KAAK,IAAI,CAAC,IAAI,IAAI,CAAC2B,UAAU,CAAC3B,KAAK,CAAC;EAChD;EACA;AACJ;AACA;EACIgC,OAAOA,CAAA,EAAG;IACN,OAAO,IAAI,CAACpC,IAAI;EACpB;EACAqC,UAAUA,CAAA,EAAG;IACT,OAAO,IAAI,CAACvB,WAAW,CAAC,IAAI,CAACsB,OAAO,CAAC,CAAC,CAAC;EAC3C;EACA;AACJ;AACA;EACIE,OAAOA,CAACf,KAAK,EAAE;IACX,OAAO,IAAI,CAAClB,MAAM,CAACkB,KAAK,CAAC;EAC7B;EACA;AACJ;AACA;EACIgB,cAAcA,CAACpC,IAAI,EAAE;IACjB,IAAIqC,MAAM,GAAG,CAAC;IACd,OAAO,CAAC,IAAIA,MAAM,IAAIrC,IAAI,GAAGqC,MAAM,EAAE;MACjCA,MAAM,EAAE;IACZ;IACA,OAAOA,MAAM,GAAG,CAAC;EACrB;EACA;AACJ;AACA;EACIC,QAAQA,CAAClB,KAAK,EAAE;IACZ,IAAImB,YAAY,GAAGnB,KAAK;IACxB,IAAIoB,SAAS,GAAG,CAAC;IACjB,IAAIH,MAAM,GAAG,CAAC;IACd;IACA,OAAOE,YAAY,GAAGC,SAAS,EAAE;MAC7BD,YAAY,IAAI,CAAC,CAAC,IAAIF,MAAM,IAAI,CAAC;MACjCA,MAAM,GAAG,IAAI,CAACD,cAAc,CAACG,YAAY,CAAC;MAC1CC,SAAS,GAAG,CAAC,CAAC,IAAIH,MAAM,IAAI,CAAC;IACjC;IACA;IACA,OAAOA,MAAM,IAAIG,SAAS,GAAGD,YAAY,CAAC;EAC9C;EACA;AACJ;AACA;EACIE,MAAMA,CAACrB,KAAK,EAAE;IACV,OAAO,IAAI,CAACkB,QAAQ,CAAClB,KAAK,CAAC,KAAK,CAAC;EACrC;EACA;AACJ;AACA;EACIsB,WAAWA,CAACtB,KAAK,EAAE;IACf,MAAMG,IAAI,GAAGH,KAAK,IAAI,CAAC,IAAK,IAAI,CAACkB,QAAQ,CAAClB,KAAK,CAAC,GAAG,CAAE,CAAC;IACtD,MAAMI,KAAK,GAAGJ,KAAK,GAAG,CAAC;IACvB,IAAIG,IAAI,KAAKC,KAAK,EAAE;MAChB,MAAM,IAAIM,KAAK,CAAC,cAAc,CAAC;IACnC;IACA,OAAO,CAACP,IAAI,EAAEC,KAAK,CAAC;EACxB;EACA;AACJ;AACA;EACImB,cAAcA,CAACvB,KAAK,EAAE;IAClB,IAAIA,KAAK,GAAG,IAAI,CAACpB,IAAI,EAAE;MACnB,MAAM,IAAI8B,KAAK,CAAC,cAAc,CAAC;IACnC;IACA,IAAI,CAAC,IAAI,CAACW,MAAM,CAACrB,KAAK,CAAC,EAAE;MACrB,MAAM,IAAIU,KAAK,CAAC,YAAY,CAAC;IACjC;IACA,MAAMjC,IAAI,GAAG,IAAI,CAACA,IAAI;IACtB,MAAMI,KAAK,GAAG,IAAI,CAACA,KAAK;IACxB;IACA,MAAMe,KAAK,GAAG,IAAI,CAACF,cAAc,CAAC,IAAI,CAACb,KAAK,CAAC;IAC7C,MAAMkB,WAAW,GAAG,EAAE;IACtB,IAAIyB,MAAM,GAAG,CAAC;IACd,KAAK,IAAI3B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,KAAK,CAACzB,MAAM,EAAE0B,CAAC,EAAE,EAAE;MACnC;MACAE,WAAW,CAACF,CAAC,CAAC,GAAG,IAAI,CAACf,MAAM,CAACc,KAAK,CAACC,CAAC,CAAC,CAAC;MACtC;MACA,IAAID,KAAK,CAACC,CAAC,CAAC,IAAIG,KAAK,IAAIwB,MAAM,KAAK,CAAC,EAAE;QACnCA,MAAM,GAAG5B,KAAK,CAACC,CAAC,CAAC;MACrB;IACJ;IACA,IAAIM,IAAI,GAAG,CAAC;IACZ,IAAIC,KAAK,GAAG,CAAC;IACb;IACA;IACA,IAAIa,MAAM,GAAG,IAAI,CAACC,QAAQ,CAACM,MAAM,CAAC;IAClC,MAAMC,QAAQ,GAAG,EAAE;IACnB,OAAOD,MAAM,KAAKxB,KAAK,EAAE;MACrBiB,MAAM,EAAE;MACP,CAACd,IAAI,EAAEC,KAAK,CAAC,GAAG,IAAI,CAACkB,WAAW,CAACE,MAAM,CAAC;MACzC;MACAA,MAAM,GAAGxB,KAAK,IAAIG,IAAI,GAAGA,IAAI,GAAGC,KAAK;MACrC;MACAqB,QAAQ,CAACR,MAAM,GAAG,CAAC,CAAC,GAAG,IAAI,CAACnC,MAAM,CAACkB,KAAK,IAAIG,IAAI,GAAGC,KAAK,GAAGD,IAAI,CAAC;IACpE;IACA,OAAO;MACH1B,IAAI;MACJI,KAAK;MACLkB,WAAW;MACX0B;IACJ,CAAC;EACL;EACA;AACJ;AACA;EACIC,MAAMA,CAACjD,IAAI,EAAEI,KAAK,EAAEmB,KAAK,EAAEvC,KAAK,EAAEmC,KAAK,EAAE6B,QAAQ,EAAE;IAC/ChE,KAAK,GAAG,IAAI,CAACwB,SAAS,CAACxB,KAAK,CAAC;IAC7B,MAAMmB,IAAI,GAAG,IAAI,CAACe,OAAO,CAACd,KAAK,CAAC;IAChC,IAAID,IAAI,GAAGoB,KAAK,EAAE;MACd,MAAM,IAAIU,KAAK,CAAC,uBAAuB,CAAC;IAC5C;IACA;IACA,IAAI,CAACjC,IAAI,CAACkD,MAAM,CAAC,IAAI,CAAC5B,WAAW,CAAClB,KAAK,EAAEe,KAAK,CAAC,CAAC,EAAE;MAC9C,MAAM,IAAIc,KAAK,CAAC,kCAAkC,CAAC;IACvD;IACA;IACA,IAAIc,MAAM,GAAG,CAAC;IACd,IAAII,UAAU;IACd,MAAMnC,WAAW,GAAG,IAAI,CAACC,cAAc,CAACb,KAAK,CAAC;IAC9C,KAAK,IAAIgB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,WAAW,CAACtB,MAAM,EAAE0B,CAAC,EAAE,EAAE;MACzC,IAAIJ,WAAW,CAACI,CAAC,CAAC,IAAIG,KAAK,EAAE;QACzB4B,UAAU,GAAGhC,KAAK,CAACC,CAAC,CAAC;QACrB2B,MAAM,GAAG/B,WAAW,CAACI,CAAC,CAAC;QACvB;MACJ;IACJ;IACA,IAAI,CAAC+B,UAAU,EAAE;MACb,MAAM,IAAIlB,KAAK,CAAC,kBAAkB,CAAC;IACvC;IACA;IACA,IAAIO,MAAM,GAAGQ,QAAQ,CAACtD,MAAM,GAAG,CAAC;IAChC,MAAM0D,IAAI,GAAG,IAAIC,KAAK,CAACb,MAAM,CAAC;IAC9B,IAAId,IAAI,GAAG,CAAC;IACZ,IAAIC,KAAK,GAAG,CAAC;IACb,OAAOa,MAAM,GAAG,CAAC,EAAE;MACf;MACAY,IAAI,CAAC,EAAEZ,MAAM,CAAC,GAAGO,MAAM;MACvB,IAAIA,MAAM,KAAKxB,KAAK,EAAE;QAClB;QACA;MACJ,CAAC,MACI;QACD;QACC,CAACG,IAAI,EAAEC,KAAK,CAAC,GAAG,IAAI,CAACkB,WAAW,CAACE,MAAM,CAAC;QACzCA,MAAM,GAAGxB,KAAK,GAAGG,IAAI,GAAGC,KAAK,GAAGD,IAAI;QACpC;MACJ;IACJ;IACA;IACA,IAAI4B,IAAI;IACR,OAAOd,MAAM,GAAGY,IAAI,CAAC1D,MAAM,EAAE;MACzB;MACAqD,MAAM,GAAGK,IAAI,CAACZ,MAAM,CAAC;MACrB,IAAIA,MAAM,KAAK,CAAC,EAAE;QACd;QACAc,IAAI,GAAG,IAAI,CAACvC,QAAQ,CAACgC,MAAM,EAAE,IAAI,CAACvD,MAAM,CAACR,KAAK,CAAC,CAAC;MACpD,CAAC,MACI,IAAI+D,MAAM,GAAG,CAAC,KAAKK,IAAI,CAACZ,MAAM,GAAG,CAAC,CAAC,EAAE;QACtC;QACAc,IAAI,GAAG,IAAI,CAAC7B,UAAU,CAACsB,MAAM,EAAEC,QAAQ,CAACR,MAAM,GAAG,CAAC,CAAC,EAAEc,IAAI,CAAC;MAC9D,CAAC,MACI;QACD;QACAA,IAAI,GAAG,IAAI,CAAC7B,UAAU,CAACsB,MAAM,EAAEO,IAAI,EAAEN,QAAQ,CAACR,MAAM,GAAG,CAAC,CAAC,CAAC;MAC9D;MACA;MACAA,MAAM,EAAE;IACZ;IACA;IACA,IAAI,CAACc,IAAI,CAACJ,MAAM,CAACC,UAAU,CAAC,EAAE;MAC1B,MAAM,IAAIlB,KAAK,CAAC,wBAAwB,CAAC;IAC7C;IACA,OAAO,IAAI;EACf;EACAsB,cAAcA,CAACnD,KAAK,EAAEe,KAAK,EAAE;IACzB,MAAMqC,OAAO,GAAG,CAAC,CAAC;IAClB,IAAIC,QAAQ,GAAG,CAAC;IAChB,IAAIC,OAAO,GAAG,CAAC;IACf,IAAI1B,KAAK,GAAGb,KAAK,CAACzB,MAAM;IACxB,KAAK,IAAI8C,MAAM,GAAG,CAAC,EAAEA,MAAM,IAAI,EAAE,EAAEA,MAAM,EAAE,EAAE;MACzC;MACAiB,QAAQ,GAAG,EAAE,GAAGjB,MAAM;MACtBkB,OAAO,GAAG,CAAC,IAAKlB,MAAM,GAAG,CAAE;MAC3B,IAAI,CAACpC,KAAK,GAAGsD,OAAO,MAAM,CAAC,EAAE;QACzBF,OAAO,CAACC,QAAQ,CAAC,GAAGtC,KAAK,CAAC,EAAEa,KAAK,CAAC;MACtC,CAAC,MACI;QACDwB,OAAO,CAACC,QAAQ,CAAC,GAAG,CAAC;MACzB;IACJ;IACA,IAAIzB,KAAK,KAAK,CAAC,EAAE;MACb,MAAM,IAAIC,KAAK,CAAC,yBAAyB,CAAC;IAC9C;IACA,OAAOuB,OAAO;EAClB;EACAG,cAAcA,CAACvD,KAAK,EAAEoD,OAAO,EAAE;IAC3B,MAAMI,SAAS,GAAG,IAAI,CAAC7B,UAAU,CAAC3B,KAAK,CAAC;IACxC,MAAMe,KAAK,GAAG,IAAIkC,KAAK,CAACO,SAAS,CAAC;IAClC,IAAI5B,KAAK,GAAG,CAAC;IACb,KAAK,IAAIZ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,EAAE,EAAEA,CAAC,EAAE,EAAE;MACzB,IAAIoC,OAAO,CAACpC,CAAC,CAAC,KAAK,CAAC,EAAE;QAClBD,KAAK,CAACa,KAAK,EAAE,CAAC,GAAGwB,OAAO,CAACpC,CAAC,CAAC;MAC/B;IACJ;IACA,IAAIY,KAAK,KAAK4B,SAAS,EAAE;MACrB,MAAM,IAAI3B,KAAK,CAAC,yBAAyB,CAAC;IAC9C;IACA,OAAOd,KAAK;EAChB;EACA0C,UAAUA,CAACzD,KAAK,EAAE0D,WAAW,EAAEC,QAAQ,EAAE;IACrC,MAAMC,WAAW,GAAG,CAAC,CAAC;IACtB,MAAMC,QAAQ,GAAG7D,KAAK,GAAG,CAAC;IAC1B,IAAI8D,WAAW,GAAG,IAAI,CAACrC,YAAY,CAACoC,QAAQ,CAAC;IAC7C,IAAIE,UAAU,GAAG,IAAI,CAACpD,QAAQ,CAACmD,WAAW,EAAEH,QAAQ,CAAC;IACrD,IAAIN,QAAQ,GAAG,CAAC;IAChB,IAAIC,OAAO,GAAG,CAAC;IACf,IAAIU,aAAa,GAAG,KAAK;IACzB,IAAIC,aAAa,GAAG,KAAK;IACzB,IAAIC,QAAQ,GAAG,KAAK;IACpB,KAAK,IAAI9B,MAAM,GAAG,CAAC,EAAEA,MAAM,IAAI,EAAE,EAAEA,MAAM,EAAE,EAAE;MACzC;MACAiB,QAAQ,GAAG,EAAE,GAAGjB,MAAM;MACtB,IAAI8B,QAAQ,EAAE;QACVN,WAAW,CAACP,QAAQ,CAAC,GAAGK,WAAW,CAACL,QAAQ,CAAC;MACjD,CAAC,MACI;QACDC,OAAO,GAAG,CAAC,IAAKlB,MAAM,GAAG,CAAE;QAC3B4B,aAAa,GAAG,CAAChE,KAAK,GAAGsD,OAAO,MAAM,CAAC;QACvCW,aAAa,GAAG,CAACJ,QAAQ,GAAGP,OAAO,MAAM,CAAC;QAC1C;QACAQ,WAAW,EAAE;QACb,IAAIE,aAAa,EAAE;UACfD,UAAU,GAAG,IAAI,CAAC1C,UAAU,CAACyC,WAAW,EAAEJ,WAAW,CAACL,QAAQ,CAAC,EAAEU,UAAU,CAAC;QAChF;QACA;QACA,IAAIE,aAAa,EAAE;UACf;UACA,IAAID,aAAa,EAAE;YACfJ,WAAW,CAACP,QAAQ,CAAC,GAAGK,WAAW,CAACL,QAAQ,CAAC;UACjD,CAAC,MACI;YACDO,WAAW,CAACP,QAAQ,CAAC,GAAGU,UAAU;UACtC;UACAG,QAAQ,GAAG,IAAI;QACnB,CAAC,MACI;UACDN,WAAW,CAACP,QAAQ,CAAC,GAAG,CAAC;QAC7B;MACJ;IACJ;IACA,OAAOO,WAAW;EACtB;EACAO,MAAMA,CAACvE,IAAI,EAAEI,KAAK,EAAEe,KAAK,EAAEqD,UAAU,EAAE;IACnC;IACA,IAAI,CAACxE,IAAI,CAACkD,MAAM,CAAC,IAAI,CAAC5B,WAAW,CAAClB,KAAK,EAAEe,KAAK,CAAC,CAAC,EAAE;MAC9C,MAAM,IAAIc,KAAK,CAAC,kCAAkC,CAAC;IACvD;IACA,IAAIwC,QAAQ,GAAGrE,KAAK;IACpB,IAAIsE,UAAU,GAAG,IAAI,CAACnB,cAAc,CAACnD,KAAK,EAAEe,KAAK,CAAC;IAClD,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGoD,UAAU,CAAC9E,MAAM,EAAE0B,CAAC,EAAE,EAAE;MACxCsD,UAAU,GAAG,IAAI,CAACb,UAAU,CAACY,QAAQ,EAAEC,UAAU,EAAEF,UAAU,CAACpD,CAAC,CAAC,CAAC;MACjEqD,QAAQ,EAAE;IACd;IACA,OAAO,IAAI,CAACnD,WAAW,CAACmD,QAAQ,EAAE,IAAI,CAACd,cAAc,CAACc,QAAQ,EAAEC,UAAU,CAAC,CAAC;EAChF;EACA;AACJ;AACA;AACA;AACA;AACA;EACIrD,gBAAgBA,CAACE,KAAK,EAAE;IACpB,IAAIA,KAAK,GAAG,IAAI,CAACpB,IAAI,EAAE;MACnB,MAAM,IAAI8B,KAAK,CAAC,cAAc,CAAC;IACnC;IACA,IAAI,CAAC,IAAI,CAAC5B,MAAM,CAACkB,KAAK,CAAC,EAAE;MACrB,MAAM,CAACoD,SAAS,EAAEC,UAAU,CAAC,GAAG,IAAI,CAAC/B,WAAW,CAACtB,KAAK,CAAC;MACvD,MAAMsD,QAAQ,GAAG,IAAI,CAACxD,gBAAgB,CAACsD,SAAS,CAAC;MACjD,MAAMG,SAAS,GAAG,IAAI,CAACzD,gBAAgB,CAACuD,UAAU,CAAC;MACnD,IAAI,CAACvE,MAAM,CAACkB,KAAK,CAAC,GAAG,IAAI,CAACE,UAAU,CAACF,KAAK,EAAEsD,QAAQ,EAAEC,SAAS,CAAC;IACpE;IACA,OAAO,IAAI,CAACzE,MAAM,CAACkB,KAAK,CAAC;EAC7B;AACJ;AACAxC,OAAO,CAACE,mBAAmB,GAAGA,mBAAmB;AACjDF,OAAO,CAACO,OAAO,GAAGL,mBAAmB"},"metadata":{},"sourceType":"script","externalDependencies":[]}