{"ast":null,"code":"import { z } from 'zod';\nimport { v4 } from 'uuid';\nimport { utils } from 'ethers';\nconst literalSchema = z.union([z.string(), z.number(), z.boolean(), z.null()]);\nconst JsonSchema = z.lazy(() => z.union([literalSchema, z.array(JsonSchema), z.record(JsonSchema)]), {\n  invalid_type_error: \"Provided value was not valid JSON\"\n});\nconst AddressSchema = z.string().refine(arg => utils.isAddress(arg), out => {\n  return {\n    message: \"\".concat(out, \" is not a valid address\")\n  };\n});\nconst RawDateSchema = z.date().transform(i => {\n  return Math.floor(i.getTime() / 1000);\n});\nconst AccountTypeSchema = z.union([z.literal(\"evm\"), z.literal(\"solana\")]);\nconst AuthenticationPayloadDataSchema = z.object({\n  iss: z.string(),\n  sub: z.string(),\n  aud: z.string(),\n  exp: RawDateSchema,\n  nbf: RawDateSchema,\n  iat: RawDateSchema,\n  jti: z.string().default(v4()),\n  ctx: JsonSchema.optional()\n});\nconst AuthenticationPayloadSchema = z.object({\n  payload: AuthenticationPayloadDataSchema,\n  signature: z.string()\n});\nconst AuthenticateOptionsSchema = z.object({\n  domain: z.string(),\n  issuerAddress: AddressSchema.optional(),\n  validateTokenId: z.function().args(z.string()).optional()\n});\nconst VerifyOptionsSchema = z.object({\n  domain: z.string(),\n  statement: z.string().optional(),\n  uri: z.string().optional(),\n  version: z.string().optional(),\n  chainId: z.string().optional(),\n  validateNonce: z.function().args(z.string()).optional(),\n  resources: z.array(z.string()).optional()\n});\nconst THIRDWEB_AUTH_COOKIE_PREFIX = \"thirdweb_auth\";\nconst THIRDWEB_AUTH_TOKEN_COOKIE_PREFIX = \"\".concat(THIRDWEB_AUTH_COOKIE_PREFIX, \"_token\");\nconst THIRDWEB_AUTH_ACTIVE_ACCOUNT_COOKIE = \"\".concat(THIRDWEB_AUTH_COOKIE_PREFIX, \"_active_account\");\nconst THIRDWEB_AUTH_DEFAULT_LOGIN_PAYLOAD_DURATION_IN_SECONDS = 60 * 10;\nconst THIRDWEB_AUTH_DEFAULT_TOKEN_DURATION_IN_SECONDS = 60 * 60 * 24;\nconst THIRDWEB_AUTH_DEFAULT_REFRESH_INTERVAL_IN_SECONDS = 5;\nconst GenerateOptionsSchema = z.object({\n  domain: z.string(),\n  tokenId: z.string().optional(),\n  expirationTime: z.date().default(() => new Date(Date.now() + 1000 * THIRDWEB_AUTH_DEFAULT_TOKEN_DURATION_IN_SECONDS)),\n  invalidBefore: z.date().optional(),\n  session: z.union([JsonSchema, z.function().args(z.string())]).optional(),\n  verifyOptions: VerifyOptionsSchema.omit({\n    domain: true\n  }).optional()\n});\nconst RefreshOptionsSchema = z.object({\n  expirationTime: z.date().default(() => new Date(Date.now() + 1000 * THIRDWEB_AUTH_DEFAULT_TOKEN_DURATION_IN_SECONDS))\n});\nconst LoginOptionsSchema = z.object({\n  domain: z.string(),\n  address: z.string().optional(),\n  statement: z.string().optional(),\n  uri: z.string().optional(),\n  version: z.string().optional(),\n  chainId: z.string().optional(),\n  nonce: z.string().optional(),\n  expirationTime: z.date().default(() => new Date(Date.now() + 1000 * THIRDWEB_AUTH_DEFAULT_LOGIN_PAYLOAD_DURATION_IN_SECONDS)),\n  invalidBefore: z.date().default(() => new Date(Date.now() - 1000 * THIRDWEB_AUTH_DEFAULT_LOGIN_PAYLOAD_DURATION_IN_SECONDS)),\n  resources: z.array(z.string()).optional()\n});\nconst LoginPayloadDataSchema = z.object({\n  type: AccountTypeSchema,\n  domain: z.string(),\n  address: z.string(),\n  statement: z.string().default(\"Please ensure that the domain above matches the URL of the current website.\"),\n  uri: z.string().optional(),\n  version: z.string().default(\"1\"),\n  chain_id: z.string().optional(),\n  nonce: z.string().default(v4()),\n  issued_at: z.date().default(new Date()).transform(d => d.toISOString()),\n  expiration_time: z.date().transform(d => d.toISOString()),\n  invalid_before: z.date().default(new Date()).transform(d => d.toISOString()),\n  resources: z.array(z.string()).optional()\n});\nconst LoginPayloadSchema = z.object({\n  payload: LoginPayloadDataSchema,\n  signature: z.string()\n});\nconst LoginPayloadOutputSchema = LoginPayloadSchema.extend({\n  payload: LoginPayloadDataSchema.extend({\n    issued_at: z.string(),\n    expiration_time: z.string(),\n    invalid_before: z.string()\n  })\n});\n\n/**\n * Create an EIP-4361 & CAIP-122 compliant message to sign based on the login payload\n */\nfunction createLoginMessage(payload) {\n  const typeField = payload.type === \"evm\" ? \"Ethereum\" : \"Solana\";\n  const header = \"\".concat(payload.domain, \" wants you to sign in with your \").concat(typeField, \" account:\");\n  let prefix = [header, payload.address].join(\"\\n\");\n  prefix = [prefix, payload.statement].join(\"\\n\\n\");\n  if (payload.statement) {\n    prefix += \"\\n\";\n  }\n  const suffixArray = [];\n  if (payload.uri) {\n    const uriField = \"URI: \".concat(payload.uri);\n    suffixArray.push(uriField);\n  }\n  const versionField = \"Version: \".concat(payload.version);\n  suffixArray.push(versionField);\n  if (payload.chain_id) {\n    const chainField = \"Chain ID: \" + payload.chain_id || \"1\";\n    suffixArray.push(chainField);\n  }\n  const nonceField = \"Nonce: \".concat(payload.nonce);\n  suffixArray.push(nonceField);\n  const issuedAtField = \"Issued At: \".concat(payload.issued_at);\n  suffixArray.push(issuedAtField);\n  const expiryField = \"Expiration Time: \".concat(payload.expiration_time);\n  suffixArray.push(expiryField);\n  if (payload.invalid_before) {\n    const invalidBeforeField = \"Not Before: \".concat(payload.invalid_before);\n    suffixArray.push(invalidBeforeField);\n  }\n  if (payload.resources) {\n    suffixArray.push([\"Resources:\", ...payload.resources.map(x => \"- \".concat(x))].join(\"\\n\"));\n  }\n  const suffix = suffixArray.join(\"\\n\");\n  return [prefix, suffix].join(\"\\n\");\n}\nasync function buildLoginPayload(_ref) {\n  let {\n    wallet,\n    options\n  } = _ref;\n  const parsedOptions = LoginOptionsSchema.parse(options);\n  let chainId = parsedOptions === null || parsedOptions === void 0 ? void 0 : parsedOptions.chainId;\n  if (!chainId && wallet.getChainId) {\n    try {\n      chainId = (await wallet.getChainId()).toString();\n    } catch {\n      // ignore error\n    }\n  }\n  return LoginPayloadDataSchema.parse({\n    type: wallet.type,\n    domain: parsedOptions.domain,\n    address: (parsedOptions === null || parsedOptions === void 0 ? void 0 : parsedOptions.address) || (await wallet.getAddress()),\n    statement: parsedOptions === null || parsedOptions === void 0 ? void 0 : parsedOptions.statement,\n    version: parsedOptions === null || parsedOptions === void 0 ? void 0 : parsedOptions.version,\n    uri: parsedOptions === null || parsedOptions === void 0 ? void 0 : parsedOptions.uri,\n    chain_id: chainId,\n    nonce: parsedOptions === null || parsedOptions === void 0 ? void 0 : parsedOptions.nonce,\n    expiration_time: parsedOptions.expirationTime,\n    invalid_before: parsedOptions.invalidBefore,\n    resources: parsedOptions === null || parsedOptions === void 0 ? void 0 : parsedOptions.resources\n  });\n}\nasync function signLoginPayload(_ref2) {\n  let {\n    wallet,\n    payload\n  } = _ref2;\n  const message = createLoginMessage(payload);\n  const signature = await wallet.signMessage(message);\n  return {\n    payload,\n    signature\n  };\n}\nasync function buildAndSignLoginPayload(_ref3) {\n  let {\n    wallet,\n    options\n  } = _ref3;\n  const payload = await buildLoginPayload({\n    wallet,\n    options\n  });\n  return signLoginPayload({\n    wallet,\n    payload\n  });\n}\nasync function verifyLoginPayload(_ref4) {\n  let {\n    wallet,\n    payload,\n    options\n  } = _ref4;\n  const parsedOptions = VerifyOptionsSchema.parse(options);\n  if (payload.payload.type !== wallet.type) {\n    throw new Error(\"Expected chain type '\".concat(wallet.type, \"' does not match chain type on payload '\").concat(payload.payload.type, \"'\"));\n  }\n\n  // Check that the intended domain matches the domain of the payload\n  if (payload.payload.domain !== parsedOptions.domain) {\n    throw new Error(\"Expected domain '\".concat(parsedOptions.domain, \"' does not match domain on payload '\").concat(payload.payload.domain, \"'\"));\n  }\n\n  // Check that the payload statement matches the expected statement\n  if (parsedOptions !== null && parsedOptions !== void 0 && parsedOptions.statement) {\n    if (payload.payload.statement !== parsedOptions.statement) {\n      throw new Error(\"Expected statement '\".concat(parsedOptions.statement, \"' does not match statement on payload '\").concat(payload.payload.statement, \"'\"));\n    }\n  }\n\n  // Check that the intended URI matches the URI of the payload\n  if (parsedOptions !== null && parsedOptions !== void 0 && parsedOptions.uri) {\n    if (payload.payload.uri !== parsedOptions.uri) {\n      throw new Error(\"Expected URI '\".concat(parsedOptions.uri, \"' does not match URI on payload '\").concat(payload.payload.uri, \"'\"));\n    }\n  }\n\n  // Check that the intended version matches the version of the payload\n  if (parsedOptions !== null && parsedOptions !== void 0 && parsedOptions.version) {\n    if (payload.payload.version !== parsedOptions.version) {\n      throw new Error(\"Expected version '\".concat(parsedOptions.version, \"' does not match version on payload '\").concat(payload.payload.version, \"'\"));\n    }\n  }\n\n  // Check that the intended chain ID matches the chain ID of the payload\n  if (parsedOptions !== null && parsedOptions !== void 0 && parsedOptions.chainId) {\n    if (payload.payload.chain_id !== parsedOptions.chainId) {\n      throw new Error(\"Expected chain ID '\".concat(parsedOptions.chainId, \"' does not match chain ID on payload '\").concat(payload.payload.chain_id, \"'\"));\n    }\n  }\n\n  // Check that the payload nonce is valid\n  if ((parsedOptions === null || parsedOptions === void 0 ? void 0 : parsedOptions.validateNonce) !== undefined) {\n    try {\n      await parsedOptions.validateNonce(payload.payload.nonce);\n    } catch (err) {\n      throw new Error(\"Login request nonce is invalid\");\n    }\n  }\n\n  // Check that it isn't before the invalid before time\n  const currentTime = new Date();\n  if (currentTime < new Date(payload.payload.invalid_before)) {\n    throw new Error(\"Login request is not yet valid\");\n  }\n\n  // Check that the payload hasn't expired\n  if (currentTime > new Date(payload.payload.expiration_time)) {\n    throw new Error(\"Login request has expired\");\n  }\n\n  // Check that the specified resources are present on the payload\n  if (parsedOptions !== null && parsedOptions !== void 0 && parsedOptions.resources) {\n    const missingResources = parsedOptions.resources.filter(resource => {\n      var _payload$payload$reso;\n      return !((_payload$payload$reso = payload.payload.resources) !== null && _payload$payload$reso !== void 0 && _payload$payload$reso.includes(resource));\n    });\n    if (missingResources.length > 0) {\n      throw new Error(\"Login request is missing required resources: \".concat(missingResources.join(\", \")));\n    }\n  }\n\n  // Check that the signing address is the claimed wallet address\n  const message = createLoginMessage(payload.payload);\n  const chainId = wallet.type === \"evm\" && payload.payload.chain_id ? parseInt(payload.payload.chain_id) : undefined;\n  const verified = await wallet.verifySignature(message, payload.signature, payload.payload.address, chainId);\n  if (!verified) {\n    throw new Error(\"Signer address does not match payload address '\".concat(payload.payload.address.toLowerCase(), \"'\"));\n  }\n  return payload.payload.address;\n}\nfunction base64encode(data) {\n  {\n    return window.btoa(data);\n  }\n}\nfunction base64decode(data) {\n  {\n    return window.atob(data);\n  }\n}\n\n/**\n * Build JWT token based on the authentication payload\n */\nasync function buildJWT(_ref) {\n  let {\n    wallet,\n    payload\n  } = _ref;\n  const payloadData = AuthenticationPayloadDataSchema.parse(payload);\n  const message = JSON.stringify(payloadData);\n  const signature = await wallet.signMessage(message);\n\n  // Header used for JWT token specifying hash algorithm\n  const header = {\n    // Specify ECDSA with SHA-256 for hashing algorithm\n    alg: \"ES256\",\n    typ: \"JWT\"\n  };\n  const encodedHeader = base64encode(JSON.stringify(header));\n  const encodedData = base64encode(JSON.stringify(payloadData));\n  const encodedSignature = base64encode(signature);\n\n  // Generate a JWT with base64 encoded header, payload, and signature\n  const jwt = \"\".concat(encodedHeader, \".\").concat(encodedData, \".\").concat(encodedSignature);\n  return jwt;\n}\n\n/**\n * Generate a new JWT using a login payload\n */\nasync function generateJWT(_ref2) {\n  let {\n    wallet,\n    payload,\n    options\n  } = _ref2;\n  const parsedOptions = GenerateOptionsSchema.parse(options);\n  const userAddress = await verifyLoginPayload({\n    wallet,\n    payload,\n    options: {\n      domain: parsedOptions.domain,\n      ...parsedOptions.verifyOptions\n    }\n  });\n  let session = undefined;\n  if (typeof (parsedOptions === null || parsedOptions === void 0 ? void 0 : parsedOptions.session) === \"function\") {\n    const sessionTrigger = await parsedOptions.session(userAddress);\n    if (sessionTrigger) {\n      session = sessionTrigger;\n    }\n  } else {\n    session = parsedOptions === null || parsedOptions === void 0 ? void 0 : parsedOptions.session;\n  }\n  const adminAddress = await wallet.getAddress();\n  return buildJWT({\n    wallet,\n    payload: {\n      iss: adminAddress,\n      sub: userAddress,\n      aud: parsedOptions.domain,\n      nbf: (parsedOptions === null || parsedOptions === void 0 ? void 0 : parsedOptions.invalidBefore) || new Date(),\n      exp: parsedOptions.expirationTime,\n      iat: new Date(),\n      jti: parsedOptions === null || parsedOptions === void 0 ? void 0 : parsedOptions.tokenId,\n      ctx: session\n    }\n  });\n}\n\n/**\n * Parse data from an encoded auth JWT\n */\nfunction parseJWT(jwt) {\n  const encodedPayload = jwt.split(\".\")[1];\n  const encodedSignature = jwt.split(\".\")[2];\n  const payload = JSON.parse(base64decode(encodedPayload));\n  const signature = base64decode(encodedSignature);\n  return {\n    payload,\n    signature\n  };\n}\n\n/**\n * Refresh an existing JWT\n */\nasync function refreshJWT(_ref3) {\n  let {\n    wallet,\n    jwt,\n    options\n  } = _ref3;\n  const {\n    payload\n  } = parseJWT(jwt);\n  const parsedOptions = RefreshOptionsSchema.parse(options);\n  return buildJWT({\n    wallet,\n    payload: {\n      iss: payload.iss,\n      sub: payload.sub,\n      aud: payload.aud,\n      nbf: new Date(),\n      exp: parsedOptions.expirationTime,\n      iat: new Date(),\n      ctx: payload.ctx\n    }\n  });\n}\n\n/**\n * Validate a JWT and extract the user's info\n */\nasync function authenticateJWT(_ref4) {\n  let {\n    wallet,\n    jwt,\n    options\n  } = _ref4;\n  const parsedOptions = AuthenticateOptionsSchema.parse(options);\n  const {\n    payload,\n    signature\n  } = parseJWT(jwt);\n\n  // Check that the payload unique ID is valid\n  if ((parsedOptions === null || parsedOptions === void 0 ? void 0 : parsedOptions.validateTokenId) !== undefined) {\n    try {\n      await parsedOptions.validateTokenId(payload.jti);\n    } catch (err) {\n      throw new Error(\"Token ID is invalid\");\n    }\n  }\n\n  // Check that the token audience matches the domain\n  if (payload.aud !== parsedOptions.domain) {\n    throw new Error(\"Expected token to be for the domain '\".concat(parsedOptions.domain, \"', but found token with domain '\").concat(payload.aud, \"'\"));\n  }\n\n  // Check that the token is past the invalid before time\n  const currentTime = Math.floor(new Date().getTime() / 1000);\n  if (currentTime < payload.nbf) {\n    throw new Error(\"This token is invalid before epoch time '\".concat(payload.nbf, \"', current epoch time is '\").concat(currentTime, \"'\"));\n  }\n\n  // Check that the token hasn't expired\n  if (currentTime > payload.exp) {\n    throw new Error(\"This token expired at epoch time '\".concat(payload.exp, \"', current epoch time is '\").concat(currentTime, \"'\"));\n  }\n\n  // Check that the connected wallet matches the token issuer\n  const issuerAddress = parsedOptions.issuerAddress ? parsedOptions.issuerAddress : await wallet.getAddress();\n  if (issuerAddress.toLowerCase() !== payload.iss.toLowerCase()) {\n    throw new Error(\"The expected issuer address '\".concat(issuerAddress, \"' did not match the token issuer address '\").concat(payload.iss, \"'\"));\n  }\n  let chainId = undefined;\n  if (wallet.getChainId) {\n    try {\n      chainId = await wallet.getChainId();\n    } catch {\n      // ignore error\n    }\n  }\n  const verified = await wallet.verifySignature(JSON.stringify(payload), signature, issuerAddress, chainId);\n  if (!verified) {\n    throw new Error(\"The expected signer address '\".concat(issuerAddress, \"' did not sign the token\"));\n  }\n  return {\n    address: payload.sub,\n    session: payload.ctx\n  };\n}\nclass ThirdwebAuth {\n  constructor(wallet, domain) {\n    this.wallet = wallet;\n    this.domain = domain;\n  }\n  updateWallet(wallet) {\n    this.wallet = wallet;\n  }\n  async payload(options) {\n    return buildLoginPayload({\n      wallet: this.wallet,\n      options: this.formatOptions(options)\n    });\n  }\n  async loginWithPayload(payload) {\n    return signLoginPayload({\n      wallet: this.wallet,\n      payload\n    });\n  }\n  async login(options) {\n    return buildAndSignLoginPayload({\n      wallet: this.wallet,\n      options: this.formatOptions(options)\n    });\n  }\n  async verify(payload, options) {\n    return verifyLoginPayload({\n      wallet: this.wallet,\n      payload,\n      options: this.formatOptions(options)\n    });\n  }\n  async generate(payload, options) {\n    return generateJWT({\n      wallet: this.wallet,\n      payload,\n      options: this.formatOptions(options)\n    });\n  }\n  async refresh(jwt, expirationTime) {\n    return refreshJWT({\n      wallet: this.wallet,\n      jwt,\n      options: {\n        expirationTime\n      }\n    });\n  }\n  async authenticate(jwt, options) {\n    return authenticateJWT({\n      wallet: this.wallet,\n      jwt,\n      options: this.formatOptions(options)\n    });\n  }\n  parseToken(jwt) {\n    return parseJWT(jwt);\n  }\n  formatOptions(options) {\n    return options ? {\n      ...options,\n      domain: (options === null || options === void 0 ? void 0 : options.domain) || this.domain\n    } : {\n      domain: this.domain\n    };\n  }\n}\nexport { AuthenticationPayloadDataSchema as A, GenerateOptionsSchema as G, JsonSchema as J, LoginOptionsSchema as L, RawDateSchema as R, ThirdwebAuth as T, VerifyOptionsSchema as V, authenticateJWT as a, buildLoginPayload as b, buildAndSignLoginPayload as c, AuthenticationPayloadSchema as d, AuthenticateOptionsSchema as e, AddressSchema as f, generateJWT as g, AccountTypeSchema as h, LoginPayloadDataSchema as i, LoginPayloadSchema as j, LoginPayloadOutputSchema as k, RefreshOptionsSchema as l, THIRDWEB_AUTH_ACTIVE_ACCOUNT_COOKIE as m, THIRDWEB_AUTH_TOKEN_COOKIE_PREFIX as n, THIRDWEB_AUTH_DEFAULT_REFRESH_INTERVAL_IN_SECONDS as o, parseJWT as p, THIRDWEB_AUTH_DEFAULT_TOKEN_DURATION_IN_SECONDS as q, refreshJWT as r, signLoginPayload as s, verifyLoginPayload as v };","map":{"version":3,"names":["z","v4","utils","literalSchema","union","string","number","boolean","null","JsonSchema","lazy","array","record","invalid_type_error","AddressSchema","refine","arg","isAddress","out","message","concat","RawDateSchema","date","transform","i","Math","floor","getTime","AccountTypeSchema","literal","AuthenticationPayloadDataSchema","object","iss","sub","aud","exp","nbf","iat","jti","default","ctx","optional","AuthenticationPayloadSchema","payload","signature","AuthenticateOptionsSchema","domain","issuerAddress","validateTokenId","function","args","VerifyOptionsSchema","statement","uri","version","chainId","validateNonce","resources","THIRDWEB_AUTH_COOKIE_PREFIX","THIRDWEB_AUTH_TOKEN_COOKIE_PREFIX","THIRDWEB_AUTH_ACTIVE_ACCOUNT_COOKIE","THIRDWEB_AUTH_DEFAULT_LOGIN_PAYLOAD_DURATION_IN_SECONDS","THIRDWEB_AUTH_DEFAULT_TOKEN_DURATION_IN_SECONDS","THIRDWEB_AUTH_DEFAULT_REFRESH_INTERVAL_IN_SECONDS","GenerateOptionsSchema","tokenId","expirationTime","Date","now","invalidBefore","session","verifyOptions","omit","RefreshOptionsSchema","LoginOptionsSchema","address","nonce","LoginPayloadDataSchema","type","chain_id","issued_at","d","toISOString","expiration_time","invalid_before","LoginPayloadSchema","LoginPayloadOutputSchema","extend","createLoginMessage","typeField","header","prefix","join","suffixArray","uriField","push","versionField","chainField","nonceField","issuedAtField","expiryField","invalidBeforeField","map","x","suffix","buildLoginPayload","_ref","wallet","options","parsedOptions","parse","getChainId","toString","getAddress","signLoginPayload","_ref2","signMessage","buildAndSignLoginPayload","_ref3","verifyLoginPayload","_ref4","Error","undefined","err","currentTime","missingResources","filter","resource","_payload$payload$reso","includes","length","parseInt","verified","verifySignature","toLowerCase","base64encode","data","window","btoa","base64decode","atob","buildJWT","payloadData","JSON","stringify","alg","typ","encodedHeader","encodedData","encodedSignature","jwt","generateJWT","userAddress","sessionTrigger","adminAddress","parseJWT","encodedPayload","split","refreshJWT","authenticateJWT","ThirdwebAuth","constructor","updateWallet","formatOptions","loginWithPayload","login","verify","generate","refresh","authenticate","parseToken","A","G","J","L","R","T","V","a","b","c","e","f","g","h","j","k","l","m","n","o","p","q","r","s","v"],"sources":["C:/Misc/Documents/Career/FinTech/BlockChain/FrontEnd/buildspace-dao-starter/node_modules/@thirdweb-dev/auth/dist/auth-05a8826c.browser.esm.js"],"sourcesContent":["import { z } from 'zod';\nimport { v4 } from 'uuid';\nimport { utils } from 'ethers';\n\nconst literalSchema = z.union([z.string(), z.number(), z.boolean(), z.null()]);\nconst JsonSchema = z.lazy(() => z.union([literalSchema, z.array(JsonSchema), z.record(JsonSchema)]), {\n  invalid_type_error: \"Provided value was not valid JSON\"\n});\nconst AddressSchema = z.string().refine(arg => utils.isAddress(arg), out => {\n  return {\n    message: `${out} is not a valid address`\n  };\n});\nconst RawDateSchema = z.date().transform(i => {\n  return Math.floor(i.getTime() / 1000);\n});\nconst AccountTypeSchema = z.union([z.literal(\"evm\"), z.literal(\"solana\")]);\n\nconst AuthenticationPayloadDataSchema = z.object({\n  iss: z.string(),\n  sub: z.string(),\n  aud: z.string(),\n  exp: RawDateSchema,\n  nbf: RawDateSchema,\n  iat: RawDateSchema,\n  jti: z.string().default(v4()),\n  ctx: JsonSchema.optional()\n});\nconst AuthenticationPayloadSchema = z.object({\n  payload: AuthenticationPayloadDataSchema,\n  signature: z.string()\n});\nconst AuthenticateOptionsSchema = z.object({\n  domain: z.string(),\n  issuerAddress: AddressSchema.optional(),\n  validateTokenId: z.function().args(z.string()).optional()\n});\n\nconst VerifyOptionsSchema = z.object({\n  domain: z.string(),\n  statement: z.string().optional(),\n  uri: z.string().optional(),\n  version: z.string().optional(),\n  chainId: z.string().optional(),\n  validateNonce: z.function().args(z.string()).optional(),\n  resources: z.array(z.string()).optional()\n});\n\nconst THIRDWEB_AUTH_COOKIE_PREFIX = `thirdweb_auth`;\nconst THIRDWEB_AUTH_TOKEN_COOKIE_PREFIX = `${THIRDWEB_AUTH_COOKIE_PREFIX}_token`;\nconst THIRDWEB_AUTH_ACTIVE_ACCOUNT_COOKIE = `${THIRDWEB_AUTH_COOKIE_PREFIX}_active_account`;\nconst THIRDWEB_AUTH_DEFAULT_LOGIN_PAYLOAD_DURATION_IN_SECONDS = 60 * 10;\nconst THIRDWEB_AUTH_DEFAULT_TOKEN_DURATION_IN_SECONDS = 60 * 60 * 24;\nconst THIRDWEB_AUTH_DEFAULT_REFRESH_INTERVAL_IN_SECONDS = 5;\n\nconst GenerateOptionsSchema = z.object({\n  domain: z.string(),\n  tokenId: z.string().optional(),\n  expirationTime: z.date().default(() => new Date(Date.now() + 1000 * THIRDWEB_AUTH_DEFAULT_TOKEN_DURATION_IN_SECONDS)),\n  invalidBefore: z.date().optional(),\n  session: z.union([JsonSchema, z.function().args(z.string())]).optional(),\n  verifyOptions: VerifyOptionsSchema.omit({\n    domain: true\n  }).optional()\n});\n\nconst RefreshOptionsSchema = z.object({\n  expirationTime: z.date().default(() => new Date(Date.now() + 1000 * THIRDWEB_AUTH_DEFAULT_TOKEN_DURATION_IN_SECONDS))\n});\n\nconst LoginOptionsSchema = z.object({\n  domain: z.string(),\n  address: z.string().optional(),\n  statement: z.string().optional(),\n  uri: z.string().optional(),\n  version: z.string().optional(),\n  chainId: z.string().optional(),\n  nonce: z.string().optional(),\n  expirationTime: z.date().default(() => new Date(Date.now() + 1000 * THIRDWEB_AUTH_DEFAULT_LOGIN_PAYLOAD_DURATION_IN_SECONDS)),\n  invalidBefore: z.date().default(() => new Date(Date.now() - 1000 * THIRDWEB_AUTH_DEFAULT_LOGIN_PAYLOAD_DURATION_IN_SECONDS)),\n  resources: z.array(z.string()).optional()\n});\nconst LoginPayloadDataSchema = z.object({\n  type: AccountTypeSchema,\n  domain: z.string(),\n  address: z.string(),\n  statement: z.string().default(\"Please ensure that the domain above matches the URL of the current website.\"),\n  uri: z.string().optional(),\n  version: z.string().default(\"1\"),\n  chain_id: z.string().optional(),\n  nonce: z.string().default(v4()),\n  issued_at: z.date().default(new Date()).transform(d => d.toISOString()),\n  expiration_time: z.date().transform(d => d.toISOString()),\n  invalid_before: z.date().default(new Date()).transform(d => d.toISOString()),\n  resources: z.array(z.string()).optional()\n});\nconst LoginPayloadSchema = z.object({\n  payload: LoginPayloadDataSchema,\n  signature: z.string()\n});\nconst LoginPayloadOutputSchema = LoginPayloadSchema.extend({\n  payload: LoginPayloadDataSchema.extend({\n    issued_at: z.string(),\n    expiration_time: z.string(),\n    invalid_before: z.string()\n  })\n});\n\n/**\n * Create an EIP-4361 & CAIP-122 compliant message to sign based on the login payload\n */\nfunction createLoginMessage(payload) {\n  const typeField = payload.type === \"evm\" ? \"Ethereum\" : \"Solana\";\n  const header = `${payload.domain} wants you to sign in with your ${typeField} account:`;\n  let prefix = [header, payload.address].join(\"\\n\");\n  prefix = [prefix, payload.statement].join(\"\\n\\n\");\n  if (payload.statement) {\n    prefix += \"\\n\";\n  }\n  const suffixArray = [];\n  if (payload.uri) {\n    const uriField = `URI: ${payload.uri}`;\n    suffixArray.push(uriField);\n  }\n  const versionField = `Version: ${payload.version}`;\n  suffixArray.push(versionField);\n  if (payload.chain_id) {\n    const chainField = `Chain ID: ` + payload.chain_id || \"1\";\n    suffixArray.push(chainField);\n  }\n  const nonceField = `Nonce: ${payload.nonce}`;\n  suffixArray.push(nonceField);\n  const issuedAtField = `Issued At: ${payload.issued_at}`;\n  suffixArray.push(issuedAtField);\n  const expiryField = `Expiration Time: ${payload.expiration_time}`;\n  suffixArray.push(expiryField);\n  if (payload.invalid_before) {\n    const invalidBeforeField = `Not Before: ${payload.invalid_before}`;\n    suffixArray.push(invalidBeforeField);\n  }\n  if (payload.resources) {\n    suffixArray.push([`Resources:`, ...payload.resources.map(x => `- ${x}`)].join(\"\\n\"));\n  }\n  const suffix = suffixArray.join(\"\\n\");\n  return [prefix, suffix].join(\"\\n\");\n}\nasync function buildLoginPayload(_ref) {\n  let {\n    wallet,\n    options\n  } = _ref;\n  const parsedOptions = LoginOptionsSchema.parse(options);\n  let chainId = parsedOptions?.chainId;\n  if (!chainId && wallet.getChainId) {\n    try {\n      chainId = (await wallet.getChainId()).toString();\n    } catch {\n      // ignore error\n    }\n  }\n  return LoginPayloadDataSchema.parse({\n    type: wallet.type,\n    domain: parsedOptions.domain,\n    address: parsedOptions?.address || (await wallet.getAddress()),\n    statement: parsedOptions?.statement,\n    version: parsedOptions?.version,\n    uri: parsedOptions?.uri,\n    chain_id: chainId,\n    nonce: parsedOptions?.nonce,\n    expiration_time: parsedOptions.expirationTime,\n    invalid_before: parsedOptions.invalidBefore,\n    resources: parsedOptions?.resources\n  });\n}\nasync function signLoginPayload(_ref2) {\n  let {\n    wallet,\n    payload\n  } = _ref2;\n  const message = createLoginMessage(payload);\n  const signature = await wallet.signMessage(message);\n  return {\n    payload,\n    signature\n  };\n}\nasync function buildAndSignLoginPayload(_ref3) {\n  let {\n    wallet,\n    options\n  } = _ref3;\n  const payload = await buildLoginPayload({\n    wallet,\n    options\n  });\n  return signLoginPayload({\n    wallet,\n    payload\n  });\n}\nasync function verifyLoginPayload(_ref4) {\n  let {\n    wallet,\n    payload,\n    options\n  } = _ref4;\n  const parsedOptions = VerifyOptionsSchema.parse(options);\n  if (payload.payload.type !== wallet.type) {\n    throw new Error(`Expected chain type '${wallet.type}' does not match chain type on payload '${payload.payload.type}'`);\n  }\n\n  // Check that the intended domain matches the domain of the payload\n  if (payload.payload.domain !== parsedOptions.domain) {\n    throw new Error(`Expected domain '${parsedOptions.domain}' does not match domain on payload '${payload.payload.domain}'`);\n  }\n\n  // Check that the payload statement matches the expected statement\n  if (parsedOptions?.statement) {\n    if (payload.payload.statement !== parsedOptions.statement) {\n      throw new Error(`Expected statement '${parsedOptions.statement}' does not match statement on payload '${payload.payload.statement}'`);\n    }\n  }\n\n  // Check that the intended URI matches the URI of the payload\n  if (parsedOptions?.uri) {\n    if (payload.payload.uri !== parsedOptions.uri) {\n      throw new Error(`Expected URI '${parsedOptions.uri}' does not match URI on payload '${payload.payload.uri}'`);\n    }\n  }\n\n  // Check that the intended version matches the version of the payload\n  if (parsedOptions?.version) {\n    if (payload.payload.version !== parsedOptions.version) {\n      throw new Error(`Expected version '${parsedOptions.version}' does not match version on payload '${payload.payload.version}'`);\n    }\n  }\n\n  // Check that the intended chain ID matches the chain ID of the payload\n  if (parsedOptions?.chainId) {\n    if (payload.payload.chain_id !== parsedOptions.chainId) {\n      throw new Error(`Expected chain ID '${parsedOptions.chainId}' does not match chain ID on payload '${payload.payload.chain_id}'`);\n    }\n  }\n\n  // Check that the payload nonce is valid\n  if (parsedOptions?.validateNonce !== undefined) {\n    try {\n      await parsedOptions.validateNonce(payload.payload.nonce);\n    } catch (err) {\n      throw new Error(`Login request nonce is invalid`);\n    }\n  }\n\n  // Check that it isn't before the invalid before time\n  const currentTime = new Date();\n  if (currentTime < new Date(payload.payload.invalid_before)) {\n    throw new Error(`Login request is not yet valid`);\n  }\n\n  // Check that the payload hasn't expired\n  if (currentTime > new Date(payload.payload.expiration_time)) {\n    throw new Error(`Login request has expired`);\n  }\n\n  // Check that the specified resources are present on the payload\n  if (parsedOptions?.resources) {\n    const missingResources = parsedOptions.resources.filter(resource => !payload.payload.resources?.includes(resource));\n    if (missingResources.length > 0) {\n      throw new Error(`Login request is missing required resources: ${missingResources.join(\", \")}`);\n    }\n  }\n\n  // Check that the signing address is the claimed wallet address\n  const message = createLoginMessage(payload.payload);\n  const chainId = wallet.type === \"evm\" && payload.payload.chain_id ? parseInt(payload.payload.chain_id) : undefined;\n  const verified = await wallet.verifySignature(message, payload.signature, payload.payload.address, chainId);\n  if (!verified) {\n    throw new Error(`Signer address does not match payload address '${payload.payload.address.toLowerCase()}'`);\n  }\n  return payload.payload.address;\n}\n\nfunction base64encode(data) {\n  {\n    return window.btoa(data);\n  }\n}\nfunction base64decode(data) {\n  {\n    return window.atob(data);\n  }\n}\n\n/**\n * Build JWT token based on the authentication payload\n */\nasync function buildJWT(_ref) {\n  let {\n    wallet,\n    payload\n  } = _ref;\n  const payloadData = AuthenticationPayloadDataSchema.parse(payload);\n  const message = JSON.stringify(payloadData);\n  const signature = await wallet.signMessage(message);\n\n  // Header used for JWT token specifying hash algorithm\n  const header = {\n    // Specify ECDSA with SHA-256 for hashing algorithm\n    alg: \"ES256\",\n    typ: \"JWT\"\n  };\n  const encodedHeader = base64encode(JSON.stringify(header));\n  const encodedData = base64encode(JSON.stringify(payloadData));\n  const encodedSignature = base64encode(signature);\n\n  // Generate a JWT with base64 encoded header, payload, and signature\n  const jwt = `${encodedHeader}.${encodedData}.${encodedSignature}`;\n  return jwt;\n}\n\n/**\n * Generate a new JWT using a login payload\n */\nasync function generateJWT(_ref2) {\n  let {\n    wallet,\n    payload,\n    options\n  } = _ref2;\n  const parsedOptions = GenerateOptionsSchema.parse(options);\n  const userAddress = await verifyLoginPayload({\n    wallet,\n    payload,\n    options: {\n      domain: parsedOptions.domain,\n      ...parsedOptions.verifyOptions\n    }\n  });\n  let session = undefined;\n  if (typeof parsedOptions?.session === \"function\") {\n    const sessionTrigger = await parsedOptions.session(userAddress);\n    if (sessionTrigger) {\n      session = sessionTrigger;\n    }\n  } else {\n    session = parsedOptions?.session;\n  }\n  const adminAddress = await wallet.getAddress();\n  return buildJWT({\n    wallet,\n    payload: {\n      iss: adminAddress,\n      sub: userAddress,\n      aud: parsedOptions.domain,\n      nbf: parsedOptions?.invalidBefore || new Date(),\n      exp: parsedOptions.expirationTime,\n      iat: new Date(),\n      jti: parsedOptions?.tokenId,\n      ctx: session\n    }\n  });\n}\n\n/**\n * Parse data from an encoded auth JWT\n */\nfunction parseJWT(jwt) {\n  const encodedPayload = jwt.split(\".\")[1];\n  const encodedSignature = jwt.split(\".\")[2];\n  const payload = JSON.parse(base64decode(encodedPayload));\n  const signature = base64decode(encodedSignature);\n  return {\n    payload,\n    signature\n  };\n}\n\n/**\n * Refresh an existing JWT\n */\nasync function refreshJWT(_ref3) {\n  let {\n    wallet,\n    jwt,\n    options\n  } = _ref3;\n  const {\n    payload\n  } = parseJWT(jwt);\n  const parsedOptions = RefreshOptionsSchema.parse(options);\n  return buildJWT({\n    wallet,\n    payload: {\n      iss: payload.iss,\n      sub: payload.sub,\n      aud: payload.aud,\n      nbf: new Date(),\n      exp: parsedOptions.expirationTime,\n      iat: new Date(),\n      ctx: payload.ctx\n    }\n  });\n}\n\n/**\n * Validate a JWT and extract the user's info\n */\nasync function authenticateJWT(_ref4) {\n  let {\n    wallet,\n    jwt,\n    options\n  } = _ref4;\n  const parsedOptions = AuthenticateOptionsSchema.parse(options);\n  const {\n    payload,\n    signature\n  } = parseJWT(jwt);\n\n  // Check that the payload unique ID is valid\n  if (parsedOptions?.validateTokenId !== undefined) {\n    try {\n      await parsedOptions.validateTokenId(payload.jti);\n    } catch (err) {\n      throw new Error(`Token ID is invalid`);\n    }\n  }\n\n  // Check that the token audience matches the domain\n  if (payload.aud !== parsedOptions.domain) {\n    throw new Error(`Expected token to be for the domain '${parsedOptions.domain}', but found token with domain '${payload.aud}'`);\n  }\n\n  // Check that the token is past the invalid before time\n  const currentTime = Math.floor(new Date().getTime() / 1000);\n  if (currentTime < payload.nbf) {\n    throw new Error(`This token is invalid before epoch time '${payload.nbf}', current epoch time is '${currentTime}'`);\n  }\n\n  // Check that the token hasn't expired\n  if (currentTime > payload.exp) {\n    throw new Error(`This token expired at epoch time '${payload.exp}', current epoch time is '${currentTime}'`);\n  }\n\n  // Check that the connected wallet matches the token issuer\n  const issuerAddress = parsedOptions.issuerAddress ? parsedOptions.issuerAddress : await wallet.getAddress();\n  if (issuerAddress.toLowerCase() !== payload.iss.toLowerCase()) {\n    throw new Error(`The expected issuer address '${issuerAddress}' did not match the token issuer address '${payload.iss}'`);\n  }\n  let chainId = undefined;\n  if (wallet.getChainId) {\n    try {\n      chainId = await wallet.getChainId();\n    } catch {\n      // ignore error\n    }\n  }\n  const verified = await wallet.verifySignature(JSON.stringify(payload), signature, issuerAddress, chainId);\n  if (!verified) {\n    throw new Error(`The expected signer address '${issuerAddress}' did not sign the token`);\n  }\n  return {\n    address: payload.sub,\n    session: payload.ctx\n  };\n}\n\nclass ThirdwebAuth {\n  constructor(wallet, domain) {\n    this.wallet = wallet;\n    this.domain = domain;\n  }\n  updateWallet(wallet) {\n    this.wallet = wallet;\n  }\n  async payload(options) {\n    return buildLoginPayload({\n      wallet: this.wallet,\n      options: this.formatOptions(options)\n    });\n  }\n  async loginWithPayload(payload) {\n    return signLoginPayload({\n      wallet: this.wallet,\n      payload\n    });\n  }\n  async login(options) {\n    return buildAndSignLoginPayload({\n      wallet: this.wallet,\n      options: this.formatOptions(options)\n    });\n  }\n  async verify(payload, options) {\n    return verifyLoginPayload({\n      wallet: this.wallet,\n      payload,\n      options: this.formatOptions(options)\n    });\n  }\n  async generate(payload, options) {\n    return generateJWT({\n      wallet: this.wallet,\n      payload,\n      options: this.formatOptions(options)\n    });\n  }\n  async refresh(jwt, expirationTime) {\n    return refreshJWT({\n      wallet: this.wallet,\n      jwt,\n      options: {\n        expirationTime\n      }\n    });\n  }\n  async authenticate(jwt, options) {\n    return authenticateJWT({\n      wallet: this.wallet,\n      jwt,\n      options: this.formatOptions(options)\n    });\n  }\n  parseToken(jwt) {\n    return parseJWT(jwt);\n  }\n  formatOptions(options) {\n    return options ? {\n      ...options,\n      domain: options?.domain || this.domain\n    } : {\n      domain: this.domain\n    };\n  }\n}\n\nexport { AuthenticationPayloadDataSchema as A, GenerateOptionsSchema as G, JsonSchema as J, LoginOptionsSchema as L, RawDateSchema as R, ThirdwebAuth as T, VerifyOptionsSchema as V, authenticateJWT as a, buildLoginPayload as b, buildAndSignLoginPayload as c, AuthenticationPayloadSchema as d, AuthenticateOptionsSchema as e, AddressSchema as f, generateJWT as g, AccountTypeSchema as h, LoginPayloadDataSchema as i, LoginPayloadSchema as j, LoginPayloadOutputSchema as k, RefreshOptionsSchema as l, THIRDWEB_AUTH_ACTIVE_ACCOUNT_COOKIE as m, THIRDWEB_AUTH_TOKEN_COOKIE_PREFIX as n, THIRDWEB_AUTH_DEFAULT_REFRESH_INTERVAL_IN_SECONDS as o, parseJWT as p, THIRDWEB_AUTH_DEFAULT_TOKEN_DURATION_IN_SECONDS as q, refreshJWT as r, signLoginPayload as s, verifyLoginPayload as v };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}