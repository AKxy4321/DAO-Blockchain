{"ast":null,"code":"import _defineProperty from \"C:/Misc/Documents/Career/FinTech/BlockChain/FrontEnd/buildspace-dao-starter/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport CIDTool from 'cid-tool';\nimport fetch, { Response } from 'cross-fetch';\nimport FormData from 'form-data';\nimport { v4 } from 'uuid';\nfunction getProcessEnv(key) {\n  let defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n  if (typeof process !== \"undefined\") {\n    if (process.env[key]) {\n      return process.env[key];\n    }\n  }\n  return defaultValue;\n}\nconst TW_HOSTNAME_SUFFIX = \".ipfscdn.io\";\nconst TW_STAGINGHOSTNAME_SUFFIX = \".thirdwebstorage-staging.com\";\nconst TW_GATEWAY_URLS = [\"https://{clientId}\".concat(TW_HOSTNAME_SUFFIX, \"/ipfs/{cid}/{path}\")];\n\n/**\n * @internal\n * @param url\n * @returns\n */\nfunction isTwGatewayUrl(url) {\n  const hostname = new URL(url).hostname;\n  const isProd = hostname.endsWith(TW_HOSTNAME_SUFFIX);\n  if (isProd) {\n    return true;\n  }\n  // fall back to also handle staging urls\n  return hostname.endsWith(TW_STAGINGHOSTNAME_SUFFIX);\n}\nconst PUBLIC_GATEWAY_URLS = [\"https://{cid}.ipfs.cf-ipfs.com/{path}\", \"https://{cid}.ipfs.dweb.link/{path}\", \"https://ipfs.io/ipfs/{cid}/{path}\", \"https://cloudflare-ipfs.com/ipfs/{cid}/{path}\", \"https://{cid}.ipfs.w3s.link/{path}\", \"https://w3s.link/ipfs/{cid}/{path}\", \"https://nftstorage.link/ipfs/{cid}/{path}\", \"https://gateway.pinata.cloud/ipfs/{cid}/{path}\"];\n\n/**\n * @internal\n */\nconst DEFAULT_GATEWAY_URLS = {\n  // Note: Gateway URLs should have trailing slashes (we clean this on user input)\n  \"ipfs://\": [...TW_GATEWAY_URLS, ...PUBLIC_GATEWAY_URLS]\n};\n\n/**\n * @internal\n */\nconst TW_UPLOAD_SERVER_URL = getProcessEnv(\"CUSTOM_UPLOAD_SERVER_URL\", \"https://storage.thirdweb.com\");\n\n/**\n * @internal\n */\nconst PINATA_IPFS_URL = \"https://api.pinata.cloud/pinning/pinFileToIPFS\";\n\n/**\n * @internal\n */\nfunction parseGatewayUrls(gatewayUrls) {\n  if (Array.isArray(gatewayUrls)) {\n    return {\n      \"ipfs://\": gatewayUrls\n    };\n  }\n  return gatewayUrls || {};\n}\n\n/**\n * @internal\n */\nfunction getGatewayUrlForCid(gatewayUrl, cid, clientId) {\n  const parts = cid.split(\"/\");\n  const hash = convertCidToV1(parts[0]);\n  const filePath = parts.slice(1).join(\"/\");\n  let url = gatewayUrl;\n\n  // If the URL contains {cid} or {path} tokens, replace them with the CID and path\n  // Both tokens must be present for the URL to be valid\n  if (gatewayUrl.includes(\"{cid}\") && gatewayUrl.includes(\"{path}\")) {\n    url = url.replace(\"{cid}\", hash).replace(\"{path}\", filePath);\n  }\n  // If the URL contains only the {cid} token, replace it with the CID\n  else if (gatewayUrl.includes(\"{cid}\")) {\n    url = url.replace(\"{cid}\", hash);\n  }\n  // If those tokens don't exist, use the canonical gateway URL format\n  else {\n    url += \"\".concat(hash, \"/\").concat(filePath);\n  }\n  // if the URL contains the {clientId} token, replace it with the client ID\n  if (gatewayUrl.includes(\"{clientId}\")) {\n    if (!clientId) {\n      throw new Error(\"Cannot use {clientId} in gateway URL without providing a client ID\");\n    }\n    url = url.replace(\"{clientId}\", clientId);\n  }\n  return url;\n}\n\n/**\n * @internal\n */\nfunction prepareGatewayUrls(gatewayUrls, clientId, secretKey) {\n  const allGatewayUrls = {\n    ...DEFAULT_GATEWAY_URLS,\n    ...gatewayUrls\n  };\n  for (const key of Object.keys(allGatewayUrls)) {\n    const cleanedGatewayUrls = allGatewayUrls[key].map(url => {\n      // inject clientId when present\n      if (clientId && url.includes(\"{clientId}\")) {\n        return url.replace(\"{clientId}\", clientId);\n      } else if (secretKey && url.includes(\"{clientId}\")) {\n        // should only be used on Node.js in a backend/script context\n        {\n          throw new Error(\"Cannot use secretKey in browser context\");\n        }\n      } else if (url.includes(\"{clientId}\")) {\n        // if no client id passed, filter out the url\n        return undefined;\n      } else {\n        return url;\n      }\n    }).filter(url => url !== undefined);\n    allGatewayUrls[key] = cleanedGatewayUrls;\n  }\n  return allGatewayUrls;\n}\n\n/**\n * @internal\n */\nfunction convertCidToV1(cid) {\n  let normalized;\n  try {\n    const hash = cid.split(\"/\")[0];\n    normalized = CIDTool.base32(hash);\n  } catch (e) {\n    throw new Error(\"The CID \".concat(cid, \" is not valid.\"));\n  }\n  return normalized;\n}\n\n/**\n * @internal\n */\nfunction isBrowser() {\n  return \"object\" !== \"undefined\";\n}\n\n/**\n * @internal\n */\nfunction isFileInstance(data) {\n  return global.File && data instanceof File;\n}\n\n/**\n * @internal\n */\nfunction isBufferInstance(data) {\n  return global.Buffer && data instanceof Buffer;\n}\n\n/**\n * @internal\n */\nfunction isBufferOrStringWithName(data) {\n  return !!(data && data.name && data.data && typeof data.name === \"string\" && (typeof data.data === \"string\" || isBufferInstance(data.data)));\n}\nfunction isFileOrBuffer(data) {\n  return isFileInstance(data) || isBufferInstance(data) || isBufferOrStringWithName(data);\n}\n\n/**\n * @internal\n */\nfunction isFileBufferOrStringEqual(input1, input2) {\n  if (isFileInstance(input1) && isFileInstance(input2)) {\n    // if both are File types, compare the name, size, and last modified date (best guess that these are the same files)\n    if (input1.name === input2.name && input1.lastModified === input2.lastModified && input1.size === input2.size) {\n      return true;\n    }\n  } else if (isBufferInstance(input1) && isBufferInstance(input2)) {\n    // buffer gives us an easy way to compare the contents!\n\n    return input1.equals(input2);\n  } else if (isBufferOrStringWithName(input1) && isBufferOrStringWithName(input2)) {\n    // first check the names\n    if (input1.name === input2.name) {\n      // if the data for both is a string, compare the strings\n      if (typeof input1.data === \"string\" && typeof input2.data === \"string\") {\n        return input1.data === input2.data;\n      } else if (isBufferInstance(input1.data) && isBufferInstance(input2.data)) {\n        // otherwise we know it's buffers, so compare the buffers\n        return input1.data.equals(input2.data);\n      }\n    }\n  }\n  // otherwise if we have not found a match, return false\n  return false;\n}\n\n/**\n * @internal\n */\nfunction parseCidAndPath(gatewayUrl, uri) {\n  const regexString = gatewayUrl.replace(\"{cid}\", \"(?<hash>[^/]+)\").replace(\"{path}\", \"(?<path>[^?#]+)\");\n  const regex = new RegExp(regexString);\n  const match = uri.match(regex);\n  if (match) {\n    var _match$groups, _match$groups2;\n    const hash = (_match$groups = match.groups) === null || _match$groups === void 0 ? void 0 : _match$groups.hash;\n    const path = (_match$groups2 = match.groups) === null || _match$groups2 === void 0 ? void 0 : _match$groups2.path;\n    const queryString = uri.includes(\"?\") ? uri.substring(uri.indexOf(\"?\") + 1) : \"\";\n    return {\n      hash,\n      path,\n      query: queryString\n    };\n  }\n}\n\n/**\n * @internal\n */\nfunction replaceGatewayUrlWithScheme(uri, gatewayUrls) {\n  for (const scheme of Object.keys(gatewayUrls)) {\n    for (const gatewayUrl of gatewayUrls[scheme]) {\n      // If the url is a tokenized url, we need to convert it to a canonical url\n      // Otherwise, we just need to check if the url is a prefix of the uri\n      if (gatewayUrl.includes(\"{cid}\")) {\n        // Given the url is a tokenized url, we need to lift the cid and the path from the uri\n        const parsed = parseCidAndPath(gatewayUrl, uri);\n        if (parsed !== null && parsed !== void 0 && parsed.hash && parsed !== null && parsed !== void 0 && parsed.path) {\n          const queryString = parsed !== null && parsed !== void 0 && parsed.query ? \"?\".concat(parsed === null || parsed === void 0 ? void 0 : parsed.query) : \"\";\n          return \"\".concat(scheme).concat(parsed === null || parsed === void 0 ? void 0 : parsed.hash, \"/\").concat(parsed === null || parsed === void 0 ? void 0 : parsed.path).concat(queryString);\n        } else {\n          // If we can't lift the cid and path from the uri, we can't replace the gateway url, return the orig string\n          return uri;\n        }\n      } else if (uri.startsWith(gatewayUrl)) {\n        return uri.replace(gatewayUrl, scheme);\n      }\n    }\n  }\n  return uri;\n}\n\n/**\n * @internal\n */\nfunction replaceSchemeWithGatewayUrl(uri, gatewayUrls) {\n  let index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  let clientId = arguments.length > 3 ? arguments[3] : undefined;\n  const scheme = Object.keys(gatewayUrls).find(s => uri.startsWith(s));\n  const schemeGatewayUrls = scheme ? gatewayUrls[scheme] : [];\n  if (!scheme && index > 0 || scheme && index >= schemeGatewayUrls.length) {\n    return undefined;\n  }\n  if (!scheme) {\n    return uri;\n  }\n  const path = uri.replace(scheme, \"\");\n  return getGatewayUrlForCid(schemeGatewayUrls[index], path, clientId);\n}\n\n/**\n * @internal\n */\nfunction replaceObjectGatewayUrlsWithSchemes(data, gatewayUrls) {\n  if (typeof data === \"string\") {\n    return replaceGatewayUrlWithScheme(data, gatewayUrls);\n  }\n  if (typeof data === \"object\") {\n    if (!data) {\n      return data;\n    }\n    if (isFileOrBuffer(data)) {\n      return data;\n    }\n    if (Array.isArray(data)) {\n      return data.map(entry => replaceObjectGatewayUrlsWithSchemes(entry, gatewayUrls));\n    }\n    return Object.fromEntries(Object.entries(data).map(_ref => {\n      let [key, value] = _ref;\n      return [key, replaceObjectGatewayUrlsWithSchemes(value, gatewayUrls)];\n    }));\n  }\n  return data;\n}\n\n/**\n * @internal\n */\nfunction replaceObjectSchemesWithGatewayUrls(data, gatewayUrls, clientId) {\n  if (typeof data === \"string\") {\n    return replaceSchemeWithGatewayUrl(data, gatewayUrls, 0, clientId);\n  }\n  if (typeof data === \"object\") {\n    if (!data) {\n      return data;\n    }\n    if (isFileOrBuffer(data)) {\n      return data;\n    }\n    if (Array.isArray(data)) {\n      return data.map(entry => replaceObjectSchemesWithGatewayUrls(entry, gatewayUrls, clientId));\n    }\n    return Object.fromEntries(Object.entries(data).map(_ref2 => {\n      let [key, value] = _ref2;\n      return [key, replaceObjectSchemesWithGatewayUrls(value, gatewayUrls, clientId)];\n    }));\n  }\n  return data;\n}\n\n/**\n * @internal\n */\nfunction extractObjectFiles(data) {\n  let files = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  // If item is a FileOrBuffer add it to our list of files\n  if (isFileOrBuffer(data)) {\n    files.push(data);\n    return files;\n  }\n  if (typeof data === \"object\") {\n    if (!data) {\n      return files;\n    }\n    if (Array.isArray(data)) {\n      data.forEach(entry => extractObjectFiles(entry, files));\n    } else {\n      Object.keys(data).map(key => extractObjectFiles(data[key], files));\n    }\n  }\n  return files;\n}\n\n/**\n * @internal\n */\nfunction replaceObjectFilesWithUris(data, uris) {\n  if (isFileOrBuffer(data)) {\n    if (uris.length) {\n      data = uris.shift();\n      return data;\n    } else {\n      console.warn(\"Not enough URIs to replace all files in object.\");\n    }\n  }\n  if (typeof data === \"object\") {\n    if (!data) {\n      return data;\n    }\n    if (Array.isArray(data)) {\n      return data.map(entry => replaceObjectFilesWithUris(entry, uris));\n    } else {\n      return Object.fromEntries(Object.entries(data).map(_ref3 => {\n        let [key, value] = _ref3;\n        return [key, replaceObjectFilesWithUris(value, uris)];\n      }));\n    }\n  }\n  return data;\n}\nvar pkg = {\n  name: \"@thirdweb-dev/storage\",\n  version: \"1.2.11\",\n  main: \"dist/thirdweb-dev-storage.cjs.js\",\n  module: \"dist/thirdweb-dev-storage.esm.js\",\n  browser: {\n    \"./dist/thirdweb-dev-storage.esm.js\": \"./dist/thirdweb-dev-storage.browser.esm.js\"\n  },\n  exports: {\n    \".\": {\n      module: {\n        browser: \"./dist/thirdweb-dev-storage.browser.esm.js\",\n        \"default\": \"./dist/thirdweb-dev-storage.esm.js\"\n      },\n      \"default\": \"./dist/thirdweb-dev-storage.cjs.js\"\n    },\n    \"./package.json\": \"./package.json\"\n  },\n  repository: \"https://github.com/thirdweb-dev/js/tree/main/packages/storage\",\n  author: \"thirdweb eng <eng@thirdweb.com>\",\n  license: \"Apache-2.0\",\n  sideEffects: false,\n  scripts: {\n    format: \"prettier --write 'src/**/*'\",\n    lint: \"eslint src/\",\n    fix: \"eslint src/ --fix\",\n    \"generate-docs\": \"api-extractor run --local && api-documenter markdown -i ./temp -o ./docs\",\n    clean: \"rm -rf dist/\",\n    build: \"tsc && preconstruct build\",\n    \"test:all\": \"NODE_ENV=test SWC_NODE_PROJECT=./tsconfig.test.json mocha --timeout 30000 --parallel './test/**/*.test.ts'\",\n    test: \"pnpm test:all\",\n    \"test:single\": \"NODE_ENV=test SWC_NODE_PROJECT=./tsconfig.test.json mocha --timeout 30000\",\n    push: \"yalc push\"\n  },\n  files: [\"dist/\"],\n  preconstruct: {\n    exports: {\n      envConditions: [\"browser\"]\n    }\n  },\n  devDependencies: {\n    \"@babel/preset-env\": \"^7.22.9\",\n    \"@babel/preset-typescript\": \"^7.22.5\",\n    \"@microsoft/api-documenter\": \"^7.22.30\",\n    \"@microsoft/api-extractor\": \"^7.36.3\",\n    \"@microsoft/tsdoc\": \"^0.14.1\",\n    \"@preconstruct/cli\": \"2.7.0\",\n    \"@swc-node/register\": \"^1.6.6\",\n    \"@thirdweb-dev/tsconfig\": \"workspace:*\",\n    \"@types/chai\": \"^4.3.5\",\n    \"@types/mocha\": \"^10.0.0\",\n    \"@types/uuid\": \"^9.0.2\",\n    \"@typescript-eslint/eslint-plugin\": \"^6.2.0\",\n    \"@typescript-eslint/parser\": \"^6.2.0\",\n    chai: \"^4.3.6\",\n    eslint: \"^8.45.0\",\n    \"eslint-config-thirdweb\": \"workspace:*\",\n    esm: \"^3.2.25\",\n    mocha: \"^10.2.0\",\n    typescript: \"^5.1.6\"\n  },\n  dependencies: {\n    \"cid-tool\": \"^3.0.0\",\n    \"cross-fetch\": \"^3.1.8\",\n    \"form-data\": \"^4.0.0\",\n    uuid: \"^9.0.0\"\n  }\n};\n\n/**\n * Default downloader used - handles downloading from all schemes specified in the gateway URLs configuration.\n *\n * @example\n * ```jsx\n * // Can instantiate the downloader with the default gateway URLs\n * const downloader = new StorageDownloader();\n *\n * // client id if used in client-side applications\n * const clientId = \"your-client-id\";\n * const storage = new ThirdwebStorage({ clientId, downloader });\n *\n * // secret key if used in server-side applications\n * const secretKey = \"your-secret-key\";\n * const storage = new ThirdwebStorage({ secretKey, downloader });\n * ```\n *\n * @public\n */\nclass StorageDownloader {\n  constructor(options) {\n    _defineProperty(this, \"DEFAULT_TIMEOUT_IN_SECONDS\", 60);\n    _defineProperty(this, \"DEFAULT_MAX_RETRIES\", 3);\n    this.secretKey = options.secretKey;\n    this.clientId = options.clientId;\n    this.defaultTimeout = options.timeoutInSeconds || this.DEFAULT_TIMEOUT_IN_SECONDS;\n  }\n  async download(uri, gatewayUrls, options) {\n    let attempts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    const maxRetries = (options === null || options === void 0 ? void 0 : options.maxRetries) || this.DEFAULT_MAX_RETRIES;\n    if (attempts > maxRetries) {\n      console.error(\"[FAILED_TO_DOWNLOAD_ERROR] Failed to download from URI - too many attempts failed.\");\n      // return a 404 response to avoid retrying\n      return new Response(JSON.stringify({\n        error: \"Not Found\"\n      }), {\n        status: 404,\n        headers: {\n          \"Content-Type\": \"application/json\"\n        }\n      });\n    }\n\n    // Replace recognized scheme with the highest priority gateway URL that hasn't already been attempted\n    let resolvedUri = replaceSchemeWithGatewayUrl(uri, gatewayUrls, attempts, this.clientId);\n    // If every gateway URL we know about for the designated scheme has been tried (via recursion) and failed, throw an error\n    if (!resolvedUri) {\n      console.error(\"[FAILED_TO_DOWNLOAD_ERROR] Unable to download from URI - all gateway URLs failed to respond.\");\n      return new Response(JSON.stringify({\n        error: \"Not Found\"\n      }), {\n        status: 404,\n        headers: {\n          \"Content-Type\": \"application/json\"\n        }\n      });\n    } else if (attempts > 0) {\n      console.warn(\"Retrying download with backup gateway URL: \".concat(resolvedUri));\n    }\n    let headers = {};\n    if (isTwGatewayUrl(resolvedUri)) {\n      const bundleId = typeof globalThis !== \"undefined\" && \"APP_BUNDLE_ID\" in globalThis ? globalThis.APP_BUNDLE_ID : undefined;\n      if (this.secretKey) {\n        headers = {\n          \"x-secret-key\": this.secretKey\n        };\n      } else if (this.clientId) {\n        if (!resolvedUri.includes(\"bundleId\")) {\n          resolvedUri = resolvedUri + (bundleId ? \"?bundleId=\".concat(bundleId) : \"\");\n        }\n        headers[\"x-client-Id\"] = this.clientId;\n      }\n      // if we have a authorization token on global context then add that to the headers\n      if (typeof globalThis !== \"undefined\" && \"TW_AUTH_TOKEN\" in globalThis && typeof globalThis.TW_AUTH_TOKEN === \"string\") {\n        headers = {\n          ...headers,\n          authorization: \"Bearer \".concat(globalThis.TW_AUTH_TOKEN)\n        };\n      }\n      if (typeof globalThis !== \"undefined\" && \"TW_CLI_AUTH_TOKEN\" in globalThis && typeof globalThis.TW_CLI_AUTH_TOKEN === \"string\") {\n        headers = {\n          ...headers,\n          authorization: \"Bearer \".concat(globalThis.TW_CLI_AUTH_TOKEN)\n        };\n        headers[\"x-authorize-wallet\"] = \"true\";\n      }\n      headers[\"x-sdk-version\"] = pkg.version;\n      headers[\"x-sdk-name\"] = pkg.name;\n      headers[\"x-sdk-platform\"] = bundleId ? \"react-native\" : window.bridge !== undefined ? \"webGL\" : \"browser\";\n    }\n    if (isTooManyRequests(resolvedUri)) {\n      // skip the request if we're getting too many request error from the gateway\n      return this.download(uri, gatewayUrls, options, attempts + 1);\n    }\n    const controller = new AbortController();\n    const timeoutInSeconds = (options === null || options === void 0 ? void 0 : options.timeoutInSeconds) || this.defaultTimeout;\n    const timeout = setTimeout(() => controller.abort(), timeoutInSeconds * 1000);\n    const resOrErr = await fetch(resolvedUri, {\n      headers,\n      signal: controller.signal\n    }).catch(err => err);\n    // if we get here clear the timeout\n    if (timeout) {\n      clearTimeout(timeout);\n    }\n    if (!(\"status\" in resOrErr)) {\n      // early exit if we don't have a status code\n      throw new Error(\"Request timed out after \".concat(timeoutInSeconds, \" seconds. \").concat(isTwGatewayUrl(resolvedUri) ? \"You can update the timeoutInSeconds option to increase the timeout.\" : \"You're using a public IPFS gateway, pass in a clientId or secretKey for a reliable IPFS gateway.\"));\n    }\n\n    // if the request is good we can skip everything else\n    if (resOrErr.ok) {\n      return resOrErr;\n    }\n    if (resOrErr.status === 429) {\n      // track that we got a too many requests error\n      tooManyRequestsBackOff(resolvedUri, resOrErr);\n      // Since the current gateway failed, recursively try the next one we know about\n      return this.download(uri, gatewayUrls, options, attempts + 1);\n    }\n    if (resOrErr.status === 410) {\n      // Don't retry if the content is blocklisted\n      console.error(\"Request to \".concat(resolvedUri, \" failed because this content seems to be blocklisted. Search VirusTotal for this URL to confirm: \").concat(resolvedUri, \" \"));\n      return resOrErr;\n    }\n    console.warn(\"Request to \".concat(resolvedUri, \" failed with status \").concat(resOrErr.status, \" - \").concat(resOrErr.statusText));\n\n    // if the status is 404 and we're using a thirdweb gateway url, return the response as is\n    if (resOrErr.status === 404 && isTwGatewayUrl(resolvedUri)) {\n      return resOrErr;\n    }\n\n    // these are the only errors that we want to retry, everything else we should just return the error as is\n    // 408 - Request Timeout\n    // 429 - Too Many Requests\n    // 5xx - Server Errors\n    if (resOrErr.status !== 408 && resOrErr.status !== 429 && resOrErr.status < 500) {\n      return resOrErr;\n    }\n\n    // Since the current gateway failed, recursively try the next one we know about\n    return this.download(uri, gatewayUrls, options, attempts + 1);\n  }\n}\nconst TOO_MANY_REQUESTS_TRACKER = new Map();\nfunction isTooManyRequests(gatewayUrl) {\n  return TOO_MANY_REQUESTS_TRACKER.has(gatewayUrl);\n}\nconst TIMEOUT_MAP = new Map();\nfunction tooManyRequestsBackOff(gatewayUrl, response) {\n  // if we already have a timeout for this gateway url, clear it\n  if (TIMEOUT_MAP.has(gatewayUrl)) {\n    clearTimeout(TIMEOUT_MAP.get(gatewayUrl));\n  }\n  const retryAfter = response.headers.get(\"Retry-After\");\n  let backOff = 5000;\n  if (retryAfter) {\n    const retryAfterSeconds = parseInt(retryAfter);\n    if (!isNaN(retryAfterSeconds)) {\n      backOff = retryAfterSeconds * 1000;\n    }\n  }\n\n  // track that we got a too many requests error\n  TOO_MANY_REQUESTS_TRACKER.set(gatewayUrl, true);\n  TIMEOUT_MAP.set(gatewayUrl, setTimeout(() => TOO_MANY_REQUESTS_TRACKER.delete(gatewayUrl), backOff));\n}\n\n/**\n * Default uploader used - handles uploading arbitrary data to IPFS\n *\n * @example\n * ```jsx\n * // Can instantiate the uploader with default configuration and your client ID when used in client-side applications\n * const uploader = new StorageUploader();\n * const clientId = \"your-client-id\";\n * const storage = new ThirdwebStorage({ clientId, uploader });\n *\n * // Can instantiate the uploader with default configuration and your secret key when used in server-side applications\n * const uploader = new StorageUploader();\n * const secretKey = \"your-secret-key\";\n * const storage = new ThirdwebStorage({ secretKey, uploader });\n *\n * // Or optionally, can pass configuration\n * const options = {\n *   // Upload objects with resolvable URLs\n *   uploadWithGatewayUrl: true,\n * }\n * const uploader = new StorageUploader(options);\n * const clientId = \"your-client-id\";\n * const storage = new ThirdwebStorage({ clientId, uploader });\n * ```\n *\n * @public\n */\nclass IpfsUploader {\n  constructor(options) {\n    this.uploadWithGatewayUrl = (options === null || options === void 0 ? void 0 : options.uploadWithGatewayUrl) || false;\n    this.uploadServerUrl = (options === null || options === void 0 ? void 0 : options.uploadServerUrl) || TW_UPLOAD_SERVER_URL;\n    this.clientId = options === null || options === void 0 ? void 0 : options.clientId;\n    this.secretKey = options === null || options === void 0 ? void 0 : options.secretKey;\n  }\n  async uploadBatch(data, options) {\n    if (options !== null && options !== void 0 && options.uploadWithoutDirectory && data.length > 1) {\n      throw new Error(\"[UPLOAD_WITHOUT_DIRECTORY_ERROR] Cannot upload more than one file or object without directory!\");\n    }\n    const formData = new FormData();\n    const {\n      form,\n      fileNames\n    } = this.buildFormData(formData, data, options);\n    {\n      return this.uploadBatchBrowser(form, fileNames, options);\n    }\n  }\n  buildFormData(form, files, options) {\n    const fileNameToFileMap = new Map();\n    const fileNames = [];\n    for (let i = 0; i < files.length; i++) {\n      const file = files[i];\n      let fileName = \"\";\n      let fileData = file;\n      if (isFileInstance(file)) {\n        if (options !== null && options !== void 0 && options.rewriteFileNames) {\n          let extensions = \"\";\n          if (file.name) {\n            const extensionStartIndex = file.name.lastIndexOf(\".\");\n            if (extensionStartIndex > -1) {\n              extensions = file.name.substring(extensionStartIndex);\n            }\n          }\n          fileName = \"\".concat(i + options.rewriteFileNames.fileStartNumber).concat(extensions);\n        } else {\n          fileName = \"\".concat(file.name);\n        }\n      } else if (isBufferOrStringWithName(file)) {\n        fileData = file.data;\n        if (options !== null && options !== void 0 && options.rewriteFileNames) {\n          fileName = \"\".concat(i + options.rewriteFileNames.fileStartNumber);\n        } else {\n          fileName = \"\".concat(file.name);\n        }\n      } else {\n        if (options !== null && options !== void 0 && options.rewriteFileNames) {\n          fileName = \"\".concat(i + options.rewriteFileNames.fileStartNumber);\n        } else {\n          fileName = \"\".concat(i);\n        }\n      }\n\n      // If we don't want to wrap with directory, adjust the filepath\n      const filepath = options !== null && options !== void 0 && options.uploadWithoutDirectory ? \"files\" : \"files/\".concat(fileName);\n      if (fileNameToFileMap.has(fileName)) {\n        // if the file in the map is the same as the file we are already looking at then just skip and continue\n        if (isFileBufferOrStringEqual(fileNameToFileMap.get(fileName), file)) {\n          // we add it to the filenames array so that we can return the correct number of urls,\n          fileNames.push(fileName);\n          // but then we skip because we don't need to upload it multiple times\n          continue;\n        }\n        // otherwise if file names are the same but they are not the same file then we should throw an error (trying to upload to differnt files but with the same names)\n        throw new Error(\"[DUPLICATE_FILE_NAME_ERROR] File name \".concat(fileName, \" was passed for more than one different file.\"));\n      }\n\n      // add it to the map so that we can check for duplicates\n      fileNameToFileMap.set(fileName, file);\n      // add it to the filenames array so that we can return the correct number of urls\n      fileNames.push(fileName);\n      {\n        // browser does blob things, filepath is parsed differently on browser vs node.\n        // pls pinata?\n        form.append(\"file\", new Blob([fileData]), filepath);\n      }\n    }\n    const metadata = {\n      name: \"Storage SDK\",\n      keyvalues: {\n        ...(options === null || options === void 0 ? void 0 : options.metadata)\n      }\n    };\n    form.append(\"pinataMetadata\", JSON.stringify(metadata));\n    if (options !== null && options !== void 0 && options.uploadWithoutDirectory) {\n      form.append(\"pinataOptions\", JSON.stringify({\n        wrapWithDirectory: false\n      }));\n    }\n    return {\n      form,\n      // encode the file names on the way out (which is what the upload backend expects)\n      fileNames: fileNames.map(fName => encodeURIComponent(fName))\n    };\n  }\n  async uploadBatchBrowser(form, fileNames, options) {\n    return new Promise((resolve, reject) => {\n      const xhr = new XMLHttpRequest();\n      let timer = setTimeout(() => {\n        xhr.abort();\n        reject(new Error(\"Request to upload timed out! No upload progress received in 30s\"));\n      }, 30000);\n      xhr.upload.addEventListener(\"loadstart\", () => {\n        console.log(\"[\".concat(Date.now(), \"] [IPFS] Started\"));\n      });\n      xhr.upload.addEventListener(\"progress\", event => {\n        console.log(\"[IPFS] Progress Event \".concat(event.loaded, \"/\").concat(event.total));\n        clearTimeout(timer);\n        if (event.loaded < event.total) {\n          timer = setTimeout(() => {\n            xhr.abort();\n            reject(new Error(\"Request to upload timed out! No upload progress received in 30s\"));\n          }, 30000);\n        } else {\n          console.log(\"[\".concat(Date.now(), \"] [IPFS] Uploaded files. Waiting for response.\"));\n        }\n        if (event.lengthComputable && options !== null && options !== void 0 && options.onProgress) {\n          options === null || options === void 0 || options.onProgress({\n            progress: event.loaded,\n            total: event.total\n          });\n        }\n      });\n      xhr.addEventListener(\"load\", () => {\n        console.log(\"[\".concat(Date.now(), \"] [IPFS] Load\"));\n        clearTimeout(timer);\n        if (xhr.status >= 200 && xhr.status < 300) {\n          let body;\n          try {\n            body = JSON.parse(xhr.responseText);\n          } catch (err) {\n            return reject(new Error(\"Failed to parse JSON from upload response\"));\n          }\n          const cid = body.IpfsHash;\n          if (!cid) {\n            throw new Error(\"Failed to get IPFS hash from upload response\");\n          }\n          if (options !== null && options !== void 0 && options.uploadWithoutDirectory) {\n            return resolve([\"ipfs://\".concat(cid)]);\n          } else {\n            return resolve(fileNames.map(n => \"ipfs://\".concat(cid, \"/\").concat(n)));\n          }\n        }\n        return reject(new Error(\"Upload failed with status \".concat(xhr.status, \" - \").concat(xhr.responseText)));\n      });\n      xhr.addEventListener(\"error\", () => {\n        console.log(\"[IPFS] Load\");\n        clearTimeout(timer);\n        if (xhr.readyState !== 0 && xhr.readyState !== 4 || xhr.status === 0) {\n          return reject(new Error(\"Upload failed due to a network error.\"));\n        }\n        return reject(new Error(\"Unknown upload error occured\"));\n      });\n      xhr.open(\"POST\", \"\".concat(this.uploadServerUrl, \"/ipfs/upload\"));\n      if (this.secretKey) {\n        xhr.setRequestHeader(\"x-secret-key\", this.secretKey);\n      } else if (this.clientId) {\n        xhr.setRequestHeader(\"x-client-id\", this.clientId);\n      }\n      const bundleId = typeof globalThis !== \"undefined\" && \"APP_BUNDLE_ID\" in globalThis ? globalThis.APP_BUNDLE_ID : undefined;\n      if (bundleId) {\n        xhr.setRequestHeader(\"x-bundle-id\", bundleId);\n      }\n      xhr.setRequestHeader(\"x-sdk-version\", pkg.version);\n      xhr.setRequestHeader(\"x-sdk-name\", pkg.name);\n      xhr.setRequestHeader(\"x-sdk-platform\", bundleId ? \"react-native\" : window.bridge !== undefined ? \"webGL\" : \"browser\");\n\n      // if we have a authorization token on global context then add that to the headers, this is for the dashboard.\n      if (typeof globalThis !== \"undefined\" && \"TW_AUTH_TOKEN\" in globalThis && typeof globalThis.TW_AUTH_TOKEN === \"string\") {\n        xhr.setRequestHeader(\"authorization\", \"Bearer \".concat(globalThis.TW_AUTH_TOKEN));\n      }\n\n      // CLI auth token\n      if (typeof globalThis !== \"undefined\" && \"TW_CLI_AUTH_TOKEN\" in globalThis && typeof globalThis.TW_CLI_AUTH_TOKEN === \"string\") {\n        xhr.setRequestHeader(\"authorization\", \"Bearer \".concat(globalThis.TW_CLI_AUTH_TOKEN));\n        xhr.setRequestHeader(\"x-authorize-wallet\", \"true\");\n      }\n      xhr.send(form);\n    });\n  }\n  async uploadBatchNode(form, fileNames, options) {\n    if (options !== null && options !== void 0 && options.onProgress) {\n      console.warn(\"The onProgress option is only supported in the browser\");\n    }\n    const headers = {};\n    if (this.secretKey) {\n      headers[\"x-secret-key\"] = this.secretKey;\n    } else if (this.clientId) {\n      headers[\"x-client-id\"] = this.clientId;\n    }\n\n    // if we have a bundle id on global context then add that to the headers\n    if (typeof globalThis !== \"undefined\" && \"APP_BUNDLE_ID\" in globalThis) {\n      headers[\"x-bundle-id\"] = globalThis.APP_BUNDLE_ID;\n    }\n\n    // if we have a authorization token on global context then add that to the headers, this is for the dashboard.\n    if (typeof globalThis !== \"undefined\" && \"TW_AUTH_TOKEN\" in globalThis && typeof globalThis.TW_AUTH_TOKEN === \"string\") {\n      headers[\"authorization\"] = \"Bearer \".concat(globalThis.TW_AUTH_TOKEN);\n    }\n\n    // CLI auth token\n    if (typeof globalThis !== \"undefined\" && \"TW_CLI_AUTH_TOKEN\" in globalThis && typeof globalThis.TW_CLI_AUTH_TOKEN === \"string\") {\n      headers[\"authorization\"] = \"Bearer \".concat(globalThis.TW_CLI_AUTH_TOKEN);\n      headers[\"x-authorize-wallet\"] = \"true\";\n    }\n    const res = await fetch(\"\".concat(this.uploadServerUrl, \"/ipfs/upload\"), {\n      method: \"POST\",\n      headers: {\n        ...headers,\n        ...form.getHeaders()\n      },\n      body: form.getBuffer()\n    });\n    if (!res.ok) {\n      if (res.status === 401) {\n        throw new Error(\"Unauthorized - You don't have permission to use this service.\");\n      }\n      throw new Error(\"Failed to upload files to IPFS - \".concat(res.status, \" - \").concat(res.statusText, \" - \").concat(await res.text()));\n    }\n    const body = await res.json();\n    const cid = body.IpfsHash;\n    if (!cid) {\n      throw new Error(\"Failed to upload files to IPFS - Bad CID\");\n    }\n    if (options !== null && options !== void 0 && options.uploadWithoutDirectory) {\n      return [\"ipfs://\".concat(cid)];\n    } else {\n      return fileNames.map(name => \"ipfs://\".concat(cid, \"/\").concat(name));\n    }\n  }\n}\n\n/**\n * Upload and download files from decentralized storage systems.\n *\n * @example\n * ```jsx\n * // Create a default storage class with a client ID when used in client-side applications\n * const storage = new ThirdwebStorage({ clientId: \"your-client-id\" });\n *\n * // Create a default storage class with a secret key when used in server-side applications\n * const storage = new ThirdwebStorage({ secretKey: \"your-secret-key\" });\n *\n * You can get a clientId and secretKey from https://thirdweb.com/create-api-key\n *\n * // Upload any file or JSON object\n * const uri = await storage.upload(data);\n * const result = await storage.download(uri);\n *\n * // Or configure a custom uploader, downloader, and gateway URLs\n * const gatewayUrls = {\n *   // We define a mapping of schemes to gateway URLs\n *   \"ipfs://\": [\n *     \"https://ipfs.thirdwebcdn.com/ipfs/\",\n *     \"https://cloudflare-ipfs.com/ipfs/\",\n *     \"https://ipfs.io/ipfs/\",\n *   ],\n * };\n * const downloader = new StorageDownloader();\n * const uploader = new IpfsUploader();\n * const clientId = \"your-client-id\";\n * const storage = new ThirdwebStorage({ clientId, uploader, downloader, gatewayUrls });\n * ```\n *\n * @public\n */\nclass ThirdwebStorage {\n  constructor(options) {\n    this.uploader = (options === null || options === void 0 ? void 0 : options.uploader) || new IpfsUploader({\n      clientId: options === null || options === void 0 ? void 0 : options.clientId,\n      secretKey: options === null || options === void 0 ? void 0 : options.secretKey,\n      uploadServerUrl: options === null || options === void 0 ? void 0 : options.uploadServerUrl\n    });\n    this.downloader = (options === null || options === void 0 ? void 0 : options.downloader) || new StorageDownloader({\n      secretKey: options === null || options === void 0 ? void 0 : options.secretKey,\n      clientId: options === null || options === void 0 ? void 0 : options.clientId\n    });\n    this.gatewayUrls = prepareGatewayUrls(parseGatewayUrls(options === null || options === void 0 ? void 0 : options.gatewayUrls), options === null || options === void 0 ? void 0 : options.clientId, options === null || options === void 0 ? void 0 : options.secretKey);\n    this.clientId = options === null || options === void 0 ? void 0 : options.clientId;\n  }\n\n  /**\n   * Resolve any scheme on a URL to get a retrievable URL for the data\n   *\n   * @param url - The URL to resolve the scheme of\n   * @returns The URL with its scheme resolved\n   *\n   * @example\n   * ```jsx\n   * const uri = \"ipfs://example\";\n   * const url = storage.resolveScheme(uri);\n   * console.log(url);\n   * ```\n   */\n  resolveScheme(url) {\n    return replaceSchemeWithGatewayUrl(url, this.gatewayUrls, 0, this.clientId);\n  }\n\n  /**\n   * Downloads arbitrary data from any URL scheme.\n   *\n   * @param url - The URL of the data to download\n   * @returns The response object fetched from the resolved URL\n   *\n   * @example\n   * ```jsx\n   * const uri = \"ipfs://example\";\n   * const data = await storage.download(uri);\n   * ```\n   */\n  async download(url, options) {\n    return this.downloader.download(url, this.gatewayUrls, options);\n  }\n\n  /**\n   * Downloads JSON data from any URL scheme.\n   * Resolves any URLs with schemes to retrievable gateway URLs.\n   *\n   * @param url - The URL of the JSON data to download\n   * @returns The JSON data fetched from the resolved URL\n   *\n   * @example\n   * ```jsx\n   * const uri = \"ipfs://example\";\n   * const json = await storage.downloadJSON(uri);\n   * ```\n   */\n  async downloadJSON(url, options) {\n    const res = await this.download(url, options);\n\n    // If we get a JSON object, recursively replace any schemes with gatewayUrls\n    const json = await res.json();\n    return replaceObjectSchemesWithGatewayUrls(json, this.gatewayUrls, this.clientId);\n  }\n\n  /**\n   * Upload arbitrary file or JSON data using the configured decentralized storage system.\n   * Automatically uploads any file data within JSON objects and replaces them with hashes.\n   *\n   * @param data - Arbitrary file or JSON data to upload\n   * @param options - Options to pass through to the storage uploader class\n   * @returns - The URI of the uploaded data\n   *\n   * @example\n   * ```jsx\n   * // Upload file data\n   * const file = readFileSync(\"../file.jpg\");\n   * const fileUri = await storage.upload(file);\n   *\n   * // Or upload a JSON object\n   * const json = { name: \"JSON\", image: file };\n   * const jsonUri = await storage.upload(json);\n   * ```\n   */\n  async upload(data, options) {\n    const [uri] = await this.uploadBatch([data], options);\n    return uri;\n  }\n\n  /**\n   * Batch upload arbitrary file or JSON data using the configured decentralized storage system.\n   * Automatically uploads any file data within JSON objects and replaces them with hashes.\n   *\n   * @param data - Array of arbitrary file or JSON data to upload\n   * @param options - Options to pass through to the storage uploader class\n   * @returns - The URIs of the uploaded data\n   *\n   * @example\n   * ```jsx\n   * // Upload an array of file data\n   * const files = [\n   *  readFileSync(\"../file1.jpg\"),\n   *  readFileSync(\"../file2.jpg\"),\n   * ];\n   * const fileUris = await storage.uploadBatch(files);\n   *\n   * // Upload an array of JSON objects\n   * const objects = [\n   *  { name: \"JSON 1\", image: files[0] },\n   *  { name: \"JSON 2\", image: files[1] },\n   * ];\n   * const jsonUris = await storage.uploadBatch(objects);\n   * ```\n   */\n  async uploadBatch(data, options) {\n    data = data.filter(item => item !== undefined);\n    if (!data.length) {\n      return [];\n    }\n    const isFileArray = data.map(item => isFileOrBuffer(item) || typeof item === \"string\").every(item => !!item);\n    let uris = [];\n\n    // If data is an array of files, pass it through to upload directly\n    if (isFileArray) {\n      uris = await this.uploader.uploadBatch(data, options);\n    } else {\n      // Otherwise it is an array of JSON objects, so we have to prepare it first\n      const metadata = (await this.uploadAndReplaceFilesWithHashes(data, options)).map(item => {\n        if (typeof item === \"string\") {\n          return item;\n        }\n        return JSON.stringify(item);\n      });\n      uris = await this.uploader.uploadBatch(metadata, options);\n    }\n    if (options !== null && options !== void 0 && options.uploadWithGatewayUrl || this.uploader.uploadWithGatewayUrl) {\n      return uris.map(uri => this.resolveScheme(uri));\n    } else {\n      return uris;\n    }\n  }\n  getGatewayUrls() {\n    return this.gatewayUrls;\n  }\n  async uploadAndReplaceFilesWithHashes(data, options) {\n    let cleaned = data;\n    // Replace any gateway URLs with their hashes\n    cleaned = replaceObjectGatewayUrlsWithSchemes(cleaned, this.gatewayUrls);\n\n    // Recurse through data and extract files to upload\n    const files = extractObjectFiles(cleaned);\n    if (files.length) {\n      // Upload all files that came from the object\n      const uris = await this.uploader.uploadBatch(files, options);\n\n      // Recurse through data and replace files with hashes\n      cleaned = replaceObjectFilesWithUris(cleaned, uris);\n    }\n    if (options !== null && options !== void 0 && options.uploadWithGatewayUrl || this.uploader.uploadWithGatewayUrl) {\n      // If flag is set, replace all schemes with their preferred gateway URL\n      // Ex: used for Solana, where services don't resolve schemes for you, so URLs must be usable by default\n      cleaned = replaceObjectSchemesWithGatewayUrls(cleaned, this.gatewayUrls, this.clientId);\n    }\n    return cleaned;\n  }\n}\n\n/**\n * @internal\n */\nclass MockDownloader {\n  constructor(storage) {\n    _defineProperty(this, \"gatewayUrls\", DEFAULT_GATEWAY_URLS);\n    this.storage = storage;\n  }\n  async download(url) {\n    const [cid, name] = url.includes(\"mock://\") ? url.replace(\"mock://\", \"\").split(\"/\") : url.replace(\"ipfs://\", \"\").split(\"/\");\n    const data = name ? this.storage[cid][name] : this.storage[cid];\n    return {\n      async json() {\n        return Promise.resolve(JSON.parse(data));\n      },\n      async text() {\n        return Promise.resolve(data);\n      }\n    };\n  }\n}\n\n/**\n * @internal\n */\nclass MockUploader {\n  constructor(storage) {\n    this.storage = storage;\n  }\n  async uploadBatch(data, options) {\n    var _options$rewriteFileN;\n    const cid = v4();\n    const uris = [];\n    this.storage[cid] = {};\n    let index = (options === null || options === void 0 || (_options$rewriteFileN = options.rewriteFileNames) === null || _options$rewriteFileN === void 0 ? void 0 : _options$rewriteFileN.fileStartNumber) || 0;\n    for (const file of data) {\n      let contents;\n      if (isFileInstance(file)) {\n        contents = await file.text();\n      } else if (isBufferInstance(file)) {\n        contents = file.toString();\n      } else if (typeof file === \"string\") {\n        contents = file;\n      } else {\n        contents = isBufferInstance(file.data) ? file.data.toString() : file.data;\n        const name = file.name ? file.name : \"file_\".concat(index);\n        this.storage[cid][name] = contents;\n        uris.push(\"mock://\".concat(cid, \"/\").concat(name));\n        continue;\n      }\n      this.storage[cid][index.toString()] = contents;\n      uris.push(\"mock://\".concat(cid, \"/\").concat(index));\n      index += 1;\n    }\n    return uris;\n  }\n}\nexport { DEFAULT_GATEWAY_URLS, IpfsUploader, MockDownloader, MockUploader, PINATA_IPFS_URL, StorageDownloader, TW_UPLOAD_SERVER_URL, ThirdwebStorage, convertCidToV1, extractObjectFiles, getGatewayUrlForCid, isBrowser, isBufferInstance, isBufferOrStringWithName, isFileBufferOrStringEqual, isFileInstance, isFileOrBuffer, isTwGatewayUrl, parseGatewayUrls, prepareGatewayUrls, replaceGatewayUrlWithScheme, replaceObjectFilesWithUris, replaceObjectGatewayUrlsWithSchemes, replaceObjectSchemesWithGatewayUrls, replaceSchemeWithGatewayUrl };","map":{"version":3,"names":["CIDTool","fetch","Response","FormData","v4","getProcessEnv","key","defaultValue","arguments","length","undefined","process","env","TW_HOSTNAME_SUFFIX","TW_STAGINGHOSTNAME_SUFFIX","TW_GATEWAY_URLS","concat","isTwGatewayUrl","url","hostname","URL","isProd","endsWith","PUBLIC_GATEWAY_URLS","DEFAULT_GATEWAY_URLS","TW_UPLOAD_SERVER_URL","PINATA_IPFS_URL","parseGatewayUrls","gatewayUrls","Array","isArray","getGatewayUrlForCid","gatewayUrl","cid","clientId","parts","split","hash","convertCidToV1","filePath","slice","join","includes","replace","Error","prepareGatewayUrls","secretKey","allGatewayUrls","Object","keys","cleanedGatewayUrls","map","filter","normalized","base32","e","isBrowser","isFileInstance","data","global","File","isBufferInstance","Buffer","isBufferOrStringWithName","name","isFileOrBuffer","isFileBufferOrStringEqual","input1","input2","lastModified","size","equals","parseCidAndPath","uri","regexString","regex","RegExp","match","_match$groups","_match$groups2","groups","path","queryString","substring","indexOf","query","replaceGatewayUrlWithScheme","scheme","parsed","startsWith","replaceSchemeWithGatewayUrl","index","find","s","schemeGatewayUrls","replaceObjectGatewayUrlsWithSchemes","entry","fromEntries","entries","_ref","value","replaceObjectSchemesWithGatewayUrls","_ref2","extractObjectFiles","files","push","forEach","replaceObjectFilesWithUris","uris","shift","console","warn","_ref3","pkg","version","main","module","browser","exports","repository","author","license","sideEffects","scripts","format","lint","fix","clean","build","test","preconstruct","envConditions","devDependencies","chai","eslint","esm","mocha","typescript","dependencies","uuid","StorageDownloader","constructor","options","_defineProperty","defaultTimeout","timeoutInSeconds","DEFAULT_TIMEOUT_IN_SECONDS","download","attempts","maxRetries","DEFAULT_MAX_RETRIES","error","JSON","stringify","status","headers","resolvedUri","bundleId","globalThis","APP_BUNDLE_ID","TW_AUTH_TOKEN","authorization","TW_CLI_AUTH_TOKEN","window","bridge","isTooManyRequests","controller","AbortController","timeout","setTimeout","abort","resOrErr","signal","catch","err","clearTimeout","ok","tooManyRequestsBackOff","statusText","TOO_MANY_REQUESTS_TRACKER","Map","has","TIMEOUT_MAP","response","get","retryAfter","backOff","retryAfterSeconds","parseInt","isNaN","set","delete","IpfsUploader","uploadWithGatewayUrl","uploadServerUrl","uploadBatch","uploadWithoutDirectory","formData","form","fileNames","buildFormData","uploadBatchBrowser","fileNameToFileMap","i","file","fileName","fileData","rewriteFileNames","extensions","extensionStartIndex","lastIndexOf","fileStartNumber","filepath","append","Blob","metadata","keyvalues","wrapWithDirectory","fName","encodeURIComponent","Promise","resolve","reject","xhr","XMLHttpRequest","timer","upload","addEventListener","log","Date","now","event","loaded","total","lengthComputable","onProgress","progress","body","parse","responseText","IpfsHash","n","readyState","open","setRequestHeader","send","uploadBatchNode","res","method","getHeaders","getBuffer","text","json","ThirdwebStorage","uploader","downloader","resolveScheme","downloadJSON","item","isFileArray","every","uploadAndReplaceFilesWithHashes","getGatewayUrls","cleaned","MockDownloader","storage","MockUploader","_options$rewriteFileN","contents","toString"],"sources":["C:/Misc/Documents/Career/FinTech/BlockChain/FrontEnd/buildspace-dao-starter/node_modules/@thirdweb-dev/storage/dist/thirdweb-dev-storage.browser.esm.js"],"sourcesContent":["import CIDTool from 'cid-tool';\nimport fetch, { Response } from 'cross-fetch';\nimport FormData from 'form-data';\nimport { v4 } from 'uuid';\n\nfunction getProcessEnv(key) {\n  let defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n  if (typeof process !== \"undefined\") {\n    if (process.env[key]) {\n      return process.env[key];\n    }\n  }\n  return defaultValue;\n}\n\nconst TW_HOSTNAME_SUFFIX = \".ipfscdn.io\";\nconst TW_STAGINGHOSTNAME_SUFFIX = \".thirdwebstorage-staging.com\";\nconst TW_GATEWAY_URLS = [`https://{clientId}${TW_HOSTNAME_SUFFIX}/ipfs/{cid}/{path}`];\n\n/**\n * @internal\n * @param url\n * @returns\n */\nfunction isTwGatewayUrl(url) {\n  const hostname = new URL(url).hostname;\n  const isProd = hostname.endsWith(TW_HOSTNAME_SUFFIX);\n  if (isProd) {\n    return true;\n  }\n  // fall back to also handle staging urls\n  return hostname.endsWith(TW_STAGINGHOSTNAME_SUFFIX);\n}\nconst PUBLIC_GATEWAY_URLS = [\"https://{cid}.ipfs.cf-ipfs.com/{path}\", \"https://{cid}.ipfs.dweb.link/{path}\", \"https://ipfs.io/ipfs/{cid}/{path}\", \"https://cloudflare-ipfs.com/ipfs/{cid}/{path}\", \"https://{cid}.ipfs.w3s.link/{path}\", \"https://w3s.link/ipfs/{cid}/{path}\", \"https://nftstorage.link/ipfs/{cid}/{path}\", \"https://gateway.pinata.cloud/ipfs/{cid}/{path}\"];\n\n/**\n * @internal\n */\nconst DEFAULT_GATEWAY_URLS = {\n  // Note: Gateway URLs should have trailing slashes (we clean this on user input)\n  \"ipfs://\": [...TW_GATEWAY_URLS, ...PUBLIC_GATEWAY_URLS]\n};\n\n/**\n * @internal\n */\nconst TW_UPLOAD_SERVER_URL = getProcessEnv(\"CUSTOM_UPLOAD_SERVER_URL\", \"https://storage.thirdweb.com\");\n\n/**\n * @internal\n */\nconst PINATA_IPFS_URL = `https://api.pinata.cloud/pinning/pinFileToIPFS`;\n\n/**\n * @internal\n */\nfunction parseGatewayUrls(gatewayUrls) {\n  if (Array.isArray(gatewayUrls)) {\n    return {\n      \"ipfs://\": gatewayUrls\n    };\n  }\n  return gatewayUrls || {};\n}\n\n/**\n * @internal\n */\nfunction getGatewayUrlForCid(gatewayUrl, cid, clientId) {\n  const parts = cid.split(\"/\");\n  const hash = convertCidToV1(parts[0]);\n  const filePath = parts.slice(1).join(\"/\");\n  let url = gatewayUrl;\n\n  // If the URL contains {cid} or {path} tokens, replace them with the CID and path\n  // Both tokens must be present for the URL to be valid\n  if (gatewayUrl.includes(\"{cid}\") && gatewayUrl.includes(\"{path}\")) {\n    url = url.replace(\"{cid}\", hash).replace(\"{path}\", filePath);\n  }\n  // If the URL contains only the {cid} token, replace it with the CID\n  else if (gatewayUrl.includes(\"{cid}\")) {\n    url = url.replace(\"{cid}\", hash);\n  }\n  // If those tokens don't exist, use the canonical gateway URL format\n  else {\n    url += `${hash}/${filePath}`;\n  }\n  // if the URL contains the {clientId} token, replace it with the client ID\n  if (gatewayUrl.includes(\"{clientId}\")) {\n    if (!clientId) {\n      throw new Error(\"Cannot use {clientId} in gateway URL without providing a client ID\");\n    }\n    url = url.replace(\"{clientId}\", clientId);\n  }\n  return url;\n}\n\n/**\n * @internal\n */\nfunction prepareGatewayUrls(gatewayUrls, clientId, secretKey) {\n  const allGatewayUrls = {\n    ...DEFAULT_GATEWAY_URLS,\n    ...gatewayUrls\n  };\n  for (const key of Object.keys(allGatewayUrls)) {\n    const cleanedGatewayUrls = allGatewayUrls[key].map(url => {\n      // inject clientId when present\n      if (clientId && url.includes(\"{clientId}\")) {\n        return url.replace(\"{clientId}\", clientId);\n      } else if (secretKey && url.includes(\"{clientId}\")) {\n        // should only be used on Node.js in a backend/script context\n        {\n          throw new Error(\"Cannot use secretKey in browser context\");\n        }\n      } else if (url.includes(\"{clientId}\")) {\n        // if no client id passed, filter out the url\n        return undefined;\n      } else {\n        return url;\n      }\n    }).filter(url => url !== undefined);\n    allGatewayUrls[key] = cleanedGatewayUrls;\n  }\n  return allGatewayUrls;\n}\n\n/**\n * @internal\n */\nfunction convertCidToV1(cid) {\n  let normalized;\n  try {\n    const hash = cid.split(\"/\")[0];\n    normalized = CIDTool.base32(hash);\n  } catch (e) {\n    throw new Error(`The CID ${cid} is not valid.`);\n  }\n  return normalized;\n}\n\n/**\n * @internal\n */\nfunction isBrowser() {\n  return \"object\" !== \"undefined\";\n}\n\n/**\n * @internal\n */\nfunction isFileInstance(data) {\n  return global.File && data instanceof File;\n}\n\n/**\n * @internal\n */\nfunction isBufferInstance(data) {\n  return global.Buffer && data instanceof Buffer;\n}\n\n/**\n * @internal\n */\nfunction isBufferOrStringWithName(data) {\n  return !!(data && data.name && data.data && typeof data.name === \"string\" && (typeof data.data === \"string\" || isBufferInstance(data.data)));\n}\nfunction isFileOrBuffer(data) {\n  return isFileInstance(data) || isBufferInstance(data) || isBufferOrStringWithName(data);\n}\n\n/**\n * @internal\n */\nfunction isFileBufferOrStringEqual(input1, input2) {\n  if (isFileInstance(input1) && isFileInstance(input2)) {\n    // if both are File types, compare the name, size, and last modified date (best guess that these are the same files)\n    if (input1.name === input2.name && input1.lastModified === input2.lastModified && input1.size === input2.size) {\n      return true;\n    }\n  } else if (isBufferInstance(input1) && isBufferInstance(input2)) {\n    // buffer gives us an easy way to compare the contents!\n\n    return input1.equals(input2);\n  } else if (isBufferOrStringWithName(input1) && isBufferOrStringWithName(input2)) {\n    // first check the names\n    if (input1.name === input2.name) {\n      // if the data for both is a string, compare the strings\n      if (typeof input1.data === \"string\" && typeof input2.data === \"string\") {\n        return input1.data === input2.data;\n      } else if (isBufferInstance(input1.data) && isBufferInstance(input2.data)) {\n        // otherwise we know it's buffers, so compare the buffers\n        return input1.data.equals(input2.data);\n      }\n    }\n  }\n  // otherwise if we have not found a match, return false\n  return false;\n}\n\n/**\n * @internal\n */\nfunction parseCidAndPath(gatewayUrl, uri) {\n  const regexString = gatewayUrl.replace(\"{cid}\", \"(?<hash>[^/]+)\").replace(\"{path}\", \"(?<path>[^?#]+)\");\n  const regex = new RegExp(regexString);\n  const match = uri.match(regex);\n  if (match) {\n    const hash = match.groups?.hash;\n    const path = match.groups?.path;\n    const queryString = uri.includes(\"?\") ? uri.substring(uri.indexOf(\"?\") + 1) : \"\";\n    return {\n      hash,\n      path,\n      query: queryString\n    };\n  }\n}\n\n/**\n * @internal\n */\nfunction replaceGatewayUrlWithScheme(uri, gatewayUrls) {\n  for (const scheme of Object.keys(gatewayUrls)) {\n    for (const gatewayUrl of gatewayUrls[scheme]) {\n      // If the url is a tokenized url, we need to convert it to a canonical url\n      // Otherwise, we just need to check if the url is a prefix of the uri\n      if (gatewayUrl.includes(\"{cid}\")) {\n        // Given the url is a tokenized url, we need to lift the cid and the path from the uri\n        const parsed = parseCidAndPath(gatewayUrl, uri);\n        if (parsed?.hash && parsed?.path) {\n          const queryString = parsed?.query ? `?${parsed?.query}` : \"\";\n          return `${scheme}${parsed?.hash}/${parsed?.path}${queryString}`;\n        } else {\n          // If we can't lift the cid and path from the uri, we can't replace the gateway url, return the orig string\n          return uri;\n        }\n      } else if (uri.startsWith(gatewayUrl)) {\n        return uri.replace(gatewayUrl, scheme);\n      }\n    }\n  }\n  return uri;\n}\n\n/**\n * @internal\n */\nfunction replaceSchemeWithGatewayUrl(uri, gatewayUrls) {\n  let index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  let clientId = arguments.length > 3 ? arguments[3] : undefined;\n  const scheme = Object.keys(gatewayUrls).find(s => uri.startsWith(s));\n  const schemeGatewayUrls = scheme ? gatewayUrls[scheme] : [];\n  if (!scheme && index > 0 || scheme && index >= schemeGatewayUrls.length) {\n    return undefined;\n  }\n  if (!scheme) {\n    return uri;\n  }\n  const path = uri.replace(scheme, \"\");\n  return getGatewayUrlForCid(schemeGatewayUrls[index], path, clientId);\n}\n\n/**\n * @internal\n */\nfunction replaceObjectGatewayUrlsWithSchemes(data, gatewayUrls) {\n  if (typeof data === \"string\") {\n    return replaceGatewayUrlWithScheme(data, gatewayUrls);\n  }\n  if (typeof data === \"object\") {\n    if (!data) {\n      return data;\n    }\n    if (isFileOrBuffer(data)) {\n      return data;\n    }\n    if (Array.isArray(data)) {\n      return data.map(entry => replaceObjectGatewayUrlsWithSchemes(entry, gatewayUrls));\n    }\n    return Object.fromEntries(Object.entries(data).map(_ref => {\n      let [key, value] = _ref;\n      return [key, replaceObjectGatewayUrlsWithSchemes(value, gatewayUrls)];\n    }));\n  }\n  return data;\n}\n\n/**\n * @internal\n */\nfunction replaceObjectSchemesWithGatewayUrls(data, gatewayUrls, clientId) {\n  if (typeof data === \"string\") {\n    return replaceSchemeWithGatewayUrl(data, gatewayUrls, 0, clientId);\n  }\n  if (typeof data === \"object\") {\n    if (!data) {\n      return data;\n    }\n    if (isFileOrBuffer(data)) {\n      return data;\n    }\n    if (Array.isArray(data)) {\n      return data.map(entry => replaceObjectSchemesWithGatewayUrls(entry, gatewayUrls, clientId));\n    }\n    return Object.fromEntries(Object.entries(data).map(_ref2 => {\n      let [key, value] = _ref2;\n      return [key, replaceObjectSchemesWithGatewayUrls(value, gatewayUrls, clientId)];\n    }));\n  }\n  return data;\n}\n\n/**\n * @internal\n */\nfunction extractObjectFiles(data) {\n  let files = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  // If item is a FileOrBuffer add it to our list of files\n  if (isFileOrBuffer(data)) {\n    files.push(data);\n    return files;\n  }\n  if (typeof data === \"object\") {\n    if (!data) {\n      return files;\n    }\n    if (Array.isArray(data)) {\n      data.forEach(entry => extractObjectFiles(entry, files));\n    } else {\n      Object.keys(data).map(key => extractObjectFiles(data[key], files));\n    }\n  }\n  return files;\n}\n\n/**\n * @internal\n */\nfunction replaceObjectFilesWithUris(data, uris) {\n  if (isFileOrBuffer(data)) {\n    if (uris.length) {\n      data = uris.shift();\n      return data;\n    } else {\n      console.warn(\"Not enough URIs to replace all files in object.\");\n    }\n  }\n  if (typeof data === \"object\") {\n    if (!data) {\n      return data;\n    }\n    if (Array.isArray(data)) {\n      return data.map(entry => replaceObjectFilesWithUris(entry, uris));\n    } else {\n      return Object.fromEntries(Object.entries(data).map(_ref3 => {\n        let [key, value] = _ref3;\n        return [key, replaceObjectFilesWithUris(value, uris)];\n      }));\n    }\n  }\n  return data;\n}\n\nvar pkg = {\n\tname: \"@thirdweb-dev/storage\",\n\tversion: \"1.2.11\",\n\tmain: \"dist/thirdweb-dev-storage.cjs.js\",\n\tmodule: \"dist/thirdweb-dev-storage.esm.js\",\n\tbrowser: {\n\t\t\"./dist/thirdweb-dev-storage.esm.js\": \"./dist/thirdweb-dev-storage.browser.esm.js\"\n\t},\n\texports: {\n\t\t\".\": {\n\t\t\tmodule: {\n\t\t\t\tbrowser: \"./dist/thirdweb-dev-storage.browser.esm.js\",\n\t\t\t\t\"default\": \"./dist/thirdweb-dev-storage.esm.js\"\n\t\t\t},\n\t\t\t\"default\": \"./dist/thirdweb-dev-storage.cjs.js\"\n\t\t},\n\t\t\"./package.json\": \"./package.json\"\n\t},\n\trepository: \"https://github.com/thirdweb-dev/js/tree/main/packages/storage\",\n\tauthor: \"thirdweb eng <eng@thirdweb.com>\",\n\tlicense: \"Apache-2.0\",\n\tsideEffects: false,\n\tscripts: {\n\t\tformat: \"prettier --write 'src/**/*'\",\n\t\tlint: \"eslint src/\",\n\t\tfix: \"eslint src/ --fix\",\n\t\t\"generate-docs\": \"api-extractor run --local && api-documenter markdown -i ./temp -o ./docs\",\n\t\tclean: \"rm -rf dist/\",\n\t\tbuild: \"tsc && preconstruct build\",\n\t\t\"test:all\": \"NODE_ENV=test SWC_NODE_PROJECT=./tsconfig.test.json mocha --timeout 30000 --parallel './test/**/*.test.ts'\",\n\t\ttest: \"pnpm test:all\",\n\t\t\"test:single\": \"NODE_ENV=test SWC_NODE_PROJECT=./tsconfig.test.json mocha --timeout 30000\",\n\t\tpush: \"yalc push\"\n\t},\n\tfiles: [\n\t\t\"dist/\"\n\t],\n\tpreconstruct: {\n\t\texports: {\n\t\t\tenvConditions: [\n\t\t\t\t\"browser\"\n\t\t\t]\n\t\t}\n\t},\n\tdevDependencies: {\n\t\t\"@babel/preset-env\": \"^7.22.9\",\n\t\t\"@babel/preset-typescript\": \"^7.22.5\",\n\t\t\"@microsoft/api-documenter\": \"^7.22.30\",\n\t\t\"@microsoft/api-extractor\": \"^7.36.3\",\n\t\t\"@microsoft/tsdoc\": \"^0.14.1\",\n\t\t\"@preconstruct/cli\": \"2.7.0\",\n\t\t\"@swc-node/register\": \"^1.6.6\",\n\t\t\"@thirdweb-dev/tsconfig\": \"workspace:*\",\n\t\t\"@types/chai\": \"^4.3.5\",\n\t\t\"@types/mocha\": \"^10.0.0\",\n\t\t\"@types/uuid\": \"^9.0.2\",\n\t\t\"@typescript-eslint/eslint-plugin\": \"^6.2.0\",\n\t\t\"@typescript-eslint/parser\": \"^6.2.0\",\n\t\tchai: \"^4.3.6\",\n\t\teslint: \"^8.45.0\",\n\t\t\"eslint-config-thirdweb\": \"workspace:*\",\n\t\tesm: \"^3.2.25\",\n\t\tmocha: \"^10.2.0\",\n\t\ttypescript: \"^5.1.6\"\n\t},\n\tdependencies: {\n\t\t\"cid-tool\": \"^3.0.0\",\n\t\t\"cross-fetch\": \"^3.1.8\",\n\t\t\"form-data\": \"^4.0.0\",\n\t\tuuid: \"^9.0.0\"\n\t}\n};\n\n/**\n * Default downloader used - handles downloading from all schemes specified in the gateway URLs configuration.\n *\n * @example\n * ```jsx\n * // Can instantiate the downloader with the default gateway URLs\n * const downloader = new StorageDownloader();\n *\n * // client id if used in client-side applications\n * const clientId = \"your-client-id\";\n * const storage = new ThirdwebStorage({ clientId, downloader });\n *\n * // secret key if used in server-side applications\n * const secretKey = \"your-secret-key\";\n * const storage = new ThirdwebStorage({ secretKey, downloader });\n * ```\n *\n * @public\n */\nclass StorageDownloader {\n  DEFAULT_TIMEOUT_IN_SECONDS = 60;\n  DEFAULT_MAX_RETRIES = 3;\n  constructor(options) {\n    this.secretKey = options.secretKey;\n    this.clientId = options.clientId;\n    this.defaultTimeout = options.timeoutInSeconds || this.DEFAULT_TIMEOUT_IN_SECONDS;\n  }\n  async download(uri, gatewayUrls, options) {\n    let attempts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    const maxRetries = options?.maxRetries || this.DEFAULT_MAX_RETRIES;\n    if (attempts > maxRetries) {\n      console.error(\"[FAILED_TO_DOWNLOAD_ERROR] Failed to download from URI - too many attempts failed.\");\n      // return a 404 response to avoid retrying\n      return new Response(JSON.stringify({\n        error: \"Not Found\"\n      }), {\n        status: 404,\n        headers: {\n          \"Content-Type\": \"application/json\"\n        }\n      });\n    }\n\n    // Replace recognized scheme with the highest priority gateway URL that hasn't already been attempted\n    let resolvedUri = replaceSchemeWithGatewayUrl(uri, gatewayUrls, attempts, this.clientId);\n    // If every gateway URL we know about for the designated scheme has been tried (via recursion) and failed, throw an error\n    if (!resolvedUri) {\n      console.error(\"[FAILED_TO_DOWNLOAD_ERROR] Unable to download from URI - all gateway URLs failed to respond.\");\n      return new Response(JSON.stringify({\n        error: \"Not Found\"\n      }), {\n        status: 404,\n        headers: {\n          \"Content-Type\": \"application/json\"\n        }\n      });\n    } else if (attempts > 0) {\n      console.warn(`Retrying download with backup gateway URL: ${resolvedUri}`);\n    }\n    let headers = {};\n    if (isTwGatewayUrl(resolvedUri)) {\n      const bundleId = typeof globalThis !== \"undefined\" && \"APP_BUNDLE_ID\" in globalThis ? globalThis.APP_BUNDLE_ID : undefined;\n      if (this.secretKey) {\n        headers = {\n          \"x-secret-key\": this.secretKey\n        };\n      } else if (this.clientId) {\n        if (!resolvedUri.includes(\"bundleId\")) {\n          resolvedUri = resolvedUri + (bundleId ? `?bundleId=${bundleId}` : \"\");\n        }\n        headers[\"x-client-Id\"] = this.clientId;\n      }\n      // if we have a authorization token on global context then add that to the headers\n      if (typeof globalThis !== \"undefined\" && \"TW_AUTH_TOKEN\" in globalThis && typeof globalThis.TW_AUTH_TOKEN === \"string\") {\n        headers = {\n          ...headers,\n          authorization: `Bearer ${globalThis.TW_AUTH_TOKEN}`\n        };\n      }\n      if (typeof globalThis !== \"undefined\" && \"TW_CLI_AUTH_TOKEN\" in globalThis && typeof globalThis.TW_CLI_AUTH_TOKEN === \"string\") {\n        headers = {\n          ...headers,\n          authorization: `Bearer ${globalThis.TW_CLI_AUTH_TOKEN}`\n        };\n        headers[\"x-authorize-wallet\"] = \"true\";\n      }\n      headers[\"x-sdk-version\"] = pkg.version;\n      headers[\"x-sdk-name\"] = pkg.name;\n      headers[\"x-sdk-platform\"] = bundleId ? \"react-native\" : window.bridge !== undefined ? \"webGL\" : \"browser\" ;\n    }\n    if (isTooManyRequests(resolvedUri)) {\n      // skip the request if we're getting too many request error from the gateway\n      return this.download(uri, gatewayUrls, options, attempts + 1);\n    }\n    const controller = new AbortController();\n    const timeoutInSeconds = options?.timeoutInSeconds || this.defaultTimeout;\n    const timeout = setTimeout(() => controller.abort(), timeoutInSeconds * 1000);\n    const resOrErr = await fetch(resolvedUri, {\n      headers,\n      signal: controller.signal\n    }).catch(err => err);\n    // if we get here clear the timeout\n    if (timeout) {\n      clearTimeout(timeout);\n    }\n    if (!(\"status\" in resOrErr)) {\n      // early exit if we don't have a status code\n      throw new Error(`Request timed out after ${timeoutInSeconds} seconds. ${isTwGatewayUrl(resolvedUri) ? \"You can update the timeoutInSeconds option to increase the timeout.\" : \"You're using a public IPFS gateway, pass in a clientId or secretKey for a reliable IPFS gateway.\"}`);\n    }\n\n    // if the request is good we can skip everything else\n    if (resOrErr.ok) {\n      return resOrErr;\n    }\n    if (resOrErr.status === 429) {\n      // track that we got a too many requests error\n      tooManyRequestsBackOff(resolvedUri, resOrErr);\n      // Since the current gateway failed, recursively try the next one we know about\n      return this.download(uri, gatewayUrls, options, attempts + 1);\n    }\n    if (resOrErr.status === 410) {\n      // Don't retry if the content is blocklisted\n      console.error(`Request to ${resolvedUri} failed because this content seems to be blocklisted. Search VirusTotal for this URL to confirm: ${resolvedUri} `);\n      return resOrErr;\n    }\n    console.warn(`Request to ${resolvedUri} failed with status ${resOrErr.status} - ${resOrErr.statusText}`);\n\n    // if the status is 404 and we're using a thirdweb gateway url, return the response as is\n    if (resOrErr.status === 404 && isTwGatewayUrl(resolvedUri)) {\n      return resOrErr;\n    }\n\n    // these are the only errors that we want to retry, everything else we should just return the error as is\n    // 408 - Request Timeout\n    // 429 - Too Many Requests\n    // 5xx - Server Errors\n    if (resOrErr.status !== 408 && resOrErr.status !== 429 && resOrErr.status < 500) {\n      return resOrErr;\n    }\n\n    // Since the current gateway failed, recursively try the next one we know about\n    return this.download(uri, gatewayUrls, options, attempts + 1);\n  }\n}\nconst TOO_MANY_REQUESTS_TRACKER = new Map();\nfunction isTooManyRequests(gatewayUrl) {\n  return TOO_MANY_REQUESTS_TRACKER.has(gatewayUrl);\n}\nconst TIMEOUT_MAP = new Map();\nfunction tooManyRequestsBackOff(gatewayUrl, response) {\n  // if we already have a timeout for this gateway url, clear it\n  if (TIMEOUT_MAP.has(gatewayUrl)) {\n    clearTimeout(TIMEOUT_MAP.get(gatewayUrl));\n  }\n  const retryAfter = response.headers.get(\"Retry-After\");\n  let backOff = 5000;\n  if (retryAfter) {\n    const retryAfterSeconds = parseInt(retryAfter);\n    if (!isNaN(retryAfterSeconds)) {\n      backOff = retryAfterSeconds * 1000;\n    }\n  }\n\n  // track that we got a too many requests error\n  TOO_MANY_REQUESTS_TRACKER.set(gatewayUrl, true);\n  TIMEOUT_MAP.set(gatewayUrl, setTimeout(() => TOO_MANY_REQUESTS_TRACKER.delete(gatewayUrl), backOff));\n}\n\n/**\n * Default uploader used - handles uploading arbitrary data to IPFS\n *\n * @example\n * ```jsx\n * // Can instantiate the uploader with default configuration and your client ID when used in client-side applications\n * const uploader = new StorageUploader();\n * const clientId = \"your-client-id\";\n * const storage = new ThirdwebStorage({ clientId, uploader });\n *\n * // Can instantiate the uploader with default configuration and your secret key when used in server-side applications\n * const uploader = new StorageUploader();\n * const secretKey = \"your-secret-key\";\n * const storage = new ThirdwebStorage({ secretKey, uploader });\n *\n * // Or optionally, can pass configuration\n * const options = {\n *   // Upload objects with resolvable URLs\n *   uploadWithGatewayUrl: true,\n * }\n * const uploader = new StorageUploader(options);\n * const clientId = \"your-client-id\";\n * const storage = new ThirdwebStorage({ clientId, uploader });\n * ```\n *\n * @public\n */\nclass IpfsUploader {\n  constructor(options) {\n    this.uploadWithGatewayUrl = options?.uploadWithGatewayUrl || false;\n    this.uploadServerUrl = options?.uploadServerUrl || TW_UPLOAD_SERVER_URL;\n    this.clientId = options?.clientId;\n    this.secretKey = options?.secretKey;\n  }\n  async uploadBatch(data, options) {\n    if (options?.uploadWithoutDirectory && data.length > 1) {\n      throw new Error(\"[UPLOAD_WITHOUT_DIRECTORY_ERROR] Cannot upload more than one file or object without directory!\");\n    }\n    const formData = new FormData();\n    const {\n      form,\n      fileNames\n    } = this.buildFormData(formData, data, options);\n    {\n      return this.uploadBatchBrowser(form, fileNames, options);\n    }\n  }\n  buildFormData(form, files, options) {\n    const fileNameToFileMap = new Map();\n    const fileNames = [];\n    for (let i = 0; i < files.length; i++) {\n      const file = files[i];\n      let fileName = \"\";\n      let fileData = file;\n      if (isFileInstance(file)) {\n        if (options?.rewriteFileNames) {\n          let extensions = \"\";\n          if (file.name) {\n            const extensionStartIndex = file.name.lastIndexOf(\".\");\n            if (extensionStartIndex > -1) {\n              extensions = file.name.substring(extensionStartIndex);\n            }\n          }\n          fileName = `${i + options.rewriteFileNames.fileStartNumber}${extensions}`;\n        } else {\n          fileName = `${file.name}`;\n        }\n      } else if (isBufferOrStringWithName(file)) {\n        fileData = file.data;\n        if (options?.rewriteFileNames) {\n          fileName = `${i + options.rewriteFileNames.fileStartNumber}`;\n        } else {\n          fileName = `${file.name}`;\n        }\n      } else {\n        if (options?.rewriteFileNames) {\n          fileName = `${i + options.rewriteFileNames.fileStartNumber}`;\n        } else {\n          fileName = `${i}`;\n        }\n      }\n\n      // If we don't want to wrap with directory, adjust the filepath\n      const filepath = options?.uploadWithoutDirectory ? `files` : `files/${fileName}`;\n      if (fileNameToFileMap.has(fileName)) {\n        // if the file in the map is the same as the file we are already looking at then just skip and continue\n        if (isFileBufferOrStringEqual(fileNameToFileMap.get(fileName), file)) {\n          // we add it to the filenames array so that we can return the correct number of urls,\n          fileNames.push(fileName);\n          // but then we skip because we don't need to upload it multiple times\n          continue;\n        }\n        // otherwise if file names are the same but they are not the same file then we should throw an error (trying to upload to differnt files but with the same names)\n        throw new Error(`[DUPLICATE_FILE_NAME_ERROR] File name ${fileName} was passed for more than one different file.`);\n      }\n\n      // add it to the map so that we can check for duplicates\n      fileNameToFileMap.set(fileName, file);\n      // add it to the filenames array so that we can return the correct number of urls\n      fileNames.push(fileName);\n      {\n        // browser does blob things, filepath is parsed differently on browser vs node.\n        // pls pinata?\n        form.append(\"file\", new Blob([fileData]), filepath);\n      }\n    }\n    const metadata = {\n      name: `Storage SDK`,\n      keyvalues: {\n        ...options?.metadata\n      }\n    };\n    form.append(\"pinataMetadata\", JSON.stringify(metadata));\n    if (options?.uploadWithoutDirectory) {\n      form.append(\"pinataOptions\", JSON.stringify({\n        wrapWithDirectory: false\n      }));\n    }\n    return {\n      form,\n      // encode the file names on the way out (which is what the upload backend expects)\n      fileNames: fileNames.map(fName => encodeURIComponent(fName))\n    };\n  }\n  async uploadBatchBrowser(form, fileNames, options) {\n    return new Promise((resolve, reject) => {\n      const xhr = new XMLHttpRequest();\n      let timer = setTimeout(() => {\n        xhr.abort();\n        reject(new Error(\"Request to upload timed out! No upload progress received in 30s\"));\n      }, 30000);\n      xhr.upload.addEventListener(\"loadstart\", () => {\n        console.log(`[${Date.now()}] [IPFS] Started`);\n      });\n      xhr.upload.addEventListener(\"progress\", event => {\n        console.log(`[IPFS] Progress Event ${event.loaded}/${event.total}`);\n        clearTimeout(timer);\n        if (event.loaded < event.total) {\n          timer = setTimeout(() => {\n            xhr.abort();\n            reject(new Error(\"Request to upload timed out! No upload progress received in 30s\"));\n          }, 30000);\n        } else {\n          console.log(`[${Date.now()}] [IPFS] Uploaded files. Waiting for response.`);\n        }\n        if (event.lengthComputable && options?.onProgress) {\n          options?.onProgress({\n            progress: event.loaded,\n            total: event.total\n          });\n        }\n      });\n      xhr.addEventListener(\"load\", () => {\n        console.log(`[${Date.now()}] [IPFS] Load`);\n        clearTimeout(timer);\n        if (xhr.status >= 200 && xhr.status < 300) {\n          let body;\n          try {\n            body = JSON.parse(xhr.responseText);\n          } catch (err) {\n            return reject(new Error(\"Failed to parse JSON from upload response\"));\n          }\n          const cid = body.IpfsHash;\n          if (!cid) {\n            throw new Error(\"Failed to get IPFS hash from upload response\");\n          }\n          if (options?.uploadWithoutDirectory) {\n            return resolve([`ipfs://${cid}`]);\n          } else {\n            return resolve(fileNames.map(n => `ipfs://${cid}/${n}`));\n          }\n        }\n        return reject(new Error(`Upload failed with status ${xhr.status} - ${xhr.responseText}`));\n      });\n      xhr.addEventListener(\"error\", () => {\n        console.log(\"[IPFS] Load\");\n        clearTimeout(timer);\n        if (xhr.readyState !== 0 && xhr.readyState !== 4 || xhr.status === 0) {\n          return reject(new Error(\"Upload failed due to a network error.\"));\n        }\n        return reject(new Error(\"Unknown upload error occured\"));\n      });\n      xhr.open(\"POST\", `${this.uploadServerUrl}/ipfs/upload`);\n      if (this.secretKey) {\n        xhr.setRequestHeader(\"x-secret-key\", this.secretKey);\n      } else if (this.clientId) {\n        xhr.setRequestHeader(\"x-client-id\", this.clientId);\n      }\n      const bundleId = typeof globalThis !== \"undefined\" && \"APP_BUNDLE_ID\" in globalThis ? globalThis.APP_BUNDLE_ID : undefined;\n      if (bundleId) {\n        xhr.setRequestHeader(\"x-bundle-id\", bundleId);\n      }\n      xhr.setRequestHeader(\"x-sdk-version\", pkg.version);\n      xhr.setRequestHeader(\"x-sdk-name\", pkg.name);\n      xhr.setRequestHeader(\"x-sdk-platform\", bundleId ? \"react-native\" : window.bridge !== undefined ? \"webGL\" : \"browser\" );\n\n      // if we have a authorization token on global context then add that to the headers, this is for the dashboard.\n      if (typeof globalThis !== \"undefined\" && \"TW_AUTH_TOKEN\" in globalThis && typeof globalThis.TW_AUTH_TOKEN === \"string\") {\n        xhr.setRequestHeader(\"authorization\", `Bearer ${globalThis.TW_AUTH_TOKEN}`);\n      }\n\n      // CLI auth token\n      if (typeof globalThis !== \"undefined\" && \"TW_CLI_AUTH_TOKEN\" in globalThis && typeof globalThis.TW_CLI_AUTH_TOKEN === \"string\") {\n        xhr.setRequestHeader(\"authorization\", `Bearer ${globalThis.TW_CLI_AUTH_TOKEN}`);\n        xhr.setRequestHeader(\"x-authorize-wallet\", `true`);\n      }\n      xhr.send(form);\n    });\n  }\n  async uploadBatchNode(form, fileNames, options) {\n    if (options?.onProgress) {\n      console.warn(\"The onProgress option is only supported in the browser\");\n    }\n    const headers = {};\n    if (this.secretKey) {\n      headers[\"x-secret-key\"] = this.secretKey;\n    } else if (this.clientId) {\n      headers[\"x-client-id\"] = this.clientId;\n    }\n\n    // if we have a bundle id on global context then add that to the headers\n    if (typeof globalThis !== \"undefined\" && \"APP_BUNDLE_ID\" in globalThis) {\n      headers[\"x-bundle-id\"] = globalThis.APP_BUNDLE_ID;\n    }\n\n    // if we have a authorization token on global context then add that to the headers, this is for the dashboard.\n    if (typeof globalThis !== \"undefined\" && \"TW_AUTH_TOKEN\" in globalThis && typeof globalThis.TW_AUTH_TOKEN === \"string\") {\n      headers[\"authorization\"] = `Bearer ${globalThis.TW_AUTH_TOKEN}`;\n    }\n\n    // CLI auth token\n    if (typeof globalThis !== \"undefined\" && \"TW_CLI_AUTH_TOKEN\" in globalThis && typeof globalThis.TW_CLI_AUTH_TOKEN === \"string\") {\n      headers[\"authorization\"] = `Bearer ${globalThis.TW_CLI_AUTH_TOKEN}`;\n      headers[\"x-authorize-wallet\"] = \"true\";\n    }\n    const res = await fetch(`${this.uploadServerUrl}/ipfs/upload`, {\n      method: \"POST\",\n      headers: {\n        ...headers,\n        ...form.getHeaders()\n      },\n      body: form.getBuffer()\n    });\n    if (!res.ok) {\n      if (res.status === 401) {\n        throw new Error(\"Unauthorized - You don't have permission to use this service.\");\n      }\n      throw new Error(`Failed to upload files to IPFS - ${res.status} - ${res.statusText} - ${await res.text()}`);\n    }\n    const body = await res.json();\n    const cid = body.IpfsHash;\n    if (!cid) {\n      throw new Error(\"Failed to upload files to IPFS - Bad CID\");\n    }\n    if (options?.uploadWithoutDirectory) {\n      return [`ipfs://${cid}`];\n    } else {\n      return fileNames.map(name => `ipfs://${cid}/${name}`);\n    }\n  }\n}\n\n/**\n * Upload and download files from decentralized storage systems.\n *\n * @example\n * ```jsx\n * // Create a default storage class with a client ID when used in client-side applications\n * const storage = new ThirdwebStorage({ clientId: \"your-client-id\" });\n *\n * // Create a default storage class with a secret key when used in server-side applications\n * const storage = new ThirdwebStorage({ secretKey: \"your-secret-key\" });\n *\n * You can get a clientId and secretKey from https://thirdweb.com/create-api-key\n *\n * // Upload any file or JSON object\n * const uri = await storage.upload(data);\n * const result = await storage.download(uri);\n *\n * // Or configure a custom uploader, downloader, and gateway URLs\n * const gatewayUrls = {\n *   // We define a mapping of schemes to gateway URLs\n *   \"ipfs://\": [\n *     \"https://ipfs.thirdwebcdn.com/ipfs/\",\n *     \"https://cloudflare-ipfs.com/ipfs/\",\n *     \"https://ipfs.io/ipfs/\",\n *   ],\n * };\n * const downloader = new StorageDownloader();\n * const uploader = new IpfsUploader();\n * const clientId = \"your-client-id\";\n * const storage = new ThirdwebStorage({ clientId, uploader, downloader, gatewayUrls });\n * ```\n *\n * @public\n */\nclass ThirdwebStorage {\n  constructor(options) {\n    this.uploader = options?.uploader || new IpfsUploader({\n      clientId: options?.clientId,\n      secretKey: options?.secretKey,\n      uploadServerUrl: options?.uploadServerUrl\n    });\n    this.downloader = options?.downloader || new StorageDownloader({\n      secretKey: options?.secretKey,\n      clientId: options?.clientId\n    });\n    this.gatewayUrls = prepareGatewayUrls(parseGatewayUrls(options?.gatewayUrls), options?.clientId, options?.secretKey);\n    this.clientId = options?.clientId;\n  }\n\n  /**\n   * Resolve any scheme on a URL to get a retrievable URL for the data\n   *\n   * @param url - The URL to resolve the scheme of\n   * @returns The URL with its scheme resolved\n   *\n   * @example\n   * ```jsx\n   * const uri = \"ipfs://example\";\n   * const url = storage.resolveScheme(uri);\n   * console.log(url);\n   * ```\n   */\n  resolveScheme(url) {\n    return replaceSchemeWithGatewayUrl(url, this.gatewayUrls, 0, this.clientId);\n  }\n\n  /**\n   * Downloads arbitrary data from any URL scheme.\n   *\n   * @param url - The URL of the data to download\n   * @returns The response object fetched from the resolved URL\n   *\n   * @example\n   * ```jsx\n   * const uri = \"ipfs://example\";\n   * const data = await storage.download(uri);\n   * ```\n   */\n  async download(url, options) {\n    return this.downloader.download(url, this.gatewayUrls, options);\n  }\n\n  /**\n   * Downloads JSON data from any URL scheme.\n   * Resolves any URLs with schemes to retrievable gateway URLs.\n   *\n   * @param url - The URL of the JSON data to download\n   * @returns The JSON data fetched from the resolved URL\n   *\n   * @example\n   * ```jsx\n   * const uri = \"ipfs://example\";\n   * const json = await storage.downloadJSON(uri);\n   * ```\n   */\n  async downloadJSON(url, options) {\n    const res = await this.download(url, options);\n\n    // If we get a JSON object, recursively replace any schemes with gatewayUrls\n    const json = await res.json();\n    return replaceObjectSchemesWithGatewayUrls(json, this.gatewayUrls, this.clientId);\n  }\n\n  /**\n   * Upload arbitrary file or JSON data using the configured decentralized storage system.\n   * Automatically uploads any file data within JSON objects and replaces them with hashes.\n   *\n   * @param data - Arbitrary file or JSON data to upload\n   * @param options - Options to pass through to the storage uploader class\n   * @returns - The URI of the uploaded data\n   *\n   * @example\n   * ```jsx\n   * // Upload file data\n   * const file = readFileSync(\"../file.jpg\");\n   * const fileUri = await storage.upload(file);\n   *\n   * // Or upload a JSON object\n   * const json = { name: \"JSON\", image: file };\n   * const jsonUri = await storage.upload(json);\n   * ```\n   */\n  async upload(data, options) {\n    const [uri] = await this.uploadBatch([data], options);\n    return uri;\n  }\n\n  /**\n   * Batch upload arbitrary file or JSON data using the configured decentralized storage system.\n   * Automatically uploads any file data within JSON objects and replaces them with hashes.\n   *\n   * @param data - Array of arbitrary file or JSON data to upload\n   * @param options - Options to pass through to the storage uploader class\n   * @returns - The URIs of the uploaded data\n   *\n   * @example\n   * ```jsx\n   * // Upload an array of file data\n   * const files = [\n   *  readFileSync(\"../file1.jpg\"),\n   *  readFileSync(\"../file2.jpg\"),\n   * ];\n   * const fileUris = await storage.uploadBatch(files);\n   *\n   * // Upload an array of JSON objects\n   * const objects = [\n   *  { name: \"JSON 1\", image: files[0] },\n   *  { name: \"JSON 2\", image: files[1] },\n   * ];\n   * const jsonUris = await storage.uploadBatch(objects);\n   * ```\n   */\n  async uploadBatch(data, options) {\n    data = data.filter(item => item !== undefined);\n    if (!data.length) {\n      return [];\n    }\n    const isFileArray = data.map(item => isFileOrBuffer(item) || typeof item === \"string\").every(item => !!item);\n    let uris = [];\n\n    // If data is an array of files, pass it through to upload directly\n    if (isFileArray) {\n      uris = await this.uploader.uploadBatch(data, options);\n    } else {\n      // Otherwise it is an array of JSON objects, so we have to prepare it first\n      const metadata = (await this.uploadAndReplaceFilesWithHashes(data, options)).map(item => {\n        if (typeof item === \"string\") {\n          return item;\n        }\n        return JSON.stringify(item);\n      });\n      uris = await this.uploader.uploadBatch(metadata, options);\n    }\n    if (options?.uploadWithGatewayUrl || this.uploader.uploadWithGatewayUrl) {\n      return uris.map(uri => this.resolveScheme(uri));\n    } else {\n      return uris;\n    }\n  }\n  getGatewayUrls() {\n    return this.gatewayUrls;\n  }\n  async uploadAndReplaceFilesWithHashes(data, options) {\n    let cleaned = data;\n    // Replace any gateway URLs with their hashes\n    cleaned = replaceObjectGatewayUrlsWithSchemes(cleaned, this.gatewayUrls);\n\n    // Recurse through data and extract files to upload\n    const files = extractObjectFiles(cleaned);\n    if (files.length) {\n      // Upload all files that came from the object\n      const uris = await this.uploader.uploadBatch(files, options);\n\n      // Recurse through data and replace files with hashes\n      cleaned = replaceObjectFilesWithUris(cleaned, uris);\n    }\n    if (options?.uploadWithGatewayUrl || this.uploader.uploadWithGatewayUrl) {\n      // If flag is set, replace all schemes with their preferred gateway URL\n      // Ex: used for Solana, where services don't resolve schemes for you, so URLs must be usable by default\n      cleaned = replaceObjectSchemesWithGatewayUrls(cleaned, this.gatewayUrls, this.clientId);\n    }\n    return cleaned;\n  }\n}\n\n/**\n * @internal\n */\nclass MockDownloader {\n  gatewayUrls = DEFAULT_GATEWAY_URLS;\n  constructor(storage) {\n    this.storage = storage;\n  }\n  async download(url) {\n    const [cid, name] = url.includes(\"mock://\") ? url.replace(\"mock://\", \"\").split(\"/\") : url.replace(\"ipfs://\", \"\").split(\"/\");\n    const data = name ? this.storage[cid][name] : this.storage[cid];\n    return {\n      async json() {\n        return Promise.resolve(JSON.parse(data));\n      },\n      async text() {\n        return Promise.resolve(data);\n      }\n    };\n  }\n}\n\n/**\n * @internal\n */\nclass MockUploader {\n  constructor(storage) {\n    this.storage = storage;\n  }\n  async uploadBatch(data, options) {\n    const cid = v4();\n    const uris = [];\n    this.storage[cid] = {};\n    let index = options?.rewriteFileNames?.fileStartNumber || 0;\n    for (const file of data) {\n      let contents;\n      if (isFileInstance(file)) {\n        contents = await file.text();\n      } else if (isBufferInstance(file)) {\n        contents = file.toString();\n      } else if (typeof file === \"string\") {\n        contents = file;\n      } else {\n        contents = isBufferInstance(file.data) ? file.data.toString() : file.data;\n        const name = file.name ? file.name : `file_${index}`;\n        this.storage[cid][name] = contents;\n        uris.push(`mock://${cid}/${name}`);\n        continue;\n      }\n      this.storage[cid][index.toString()] = contents;\n      uris.push(`mock://${cid}/${index}`);\n      index += 1;\n    }\n    return uris;\n  }\n}\n\nexport { DEFAULT_GATEWAY_URLS, IpfsUploader, MockDownloader, MockUploader, PINATA_IPFS_URL, StorageDownloader, TW_UPLOAD_SERVER_URL, ThirdwebStorage, convertCidToV1, extractObjectFiles, getGatewayUrlForCid, isBrowser, isBufferInstance, isBufferOrStringWithName, isFileBufferOrStringEqual, isFileInstance, isFileOrBuffer, isTwGatewayUrl, parseGatewayUrls, prepareGatewayUrls, replaceGatewayUrlWithScheme, replaceObjectFilesWithUris, replaceObjectGatewayUrlsWithSchemes, replaceObjectSchemesWithGatewayUrls, replaceSchemeWithGatewayUrl };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}