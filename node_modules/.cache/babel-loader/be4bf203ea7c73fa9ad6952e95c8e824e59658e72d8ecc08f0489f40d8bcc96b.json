{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AdapterL2 = exports.AdapterL1 = void 0;\nconst ethers_1 = require(\"ethers\");\nconst typechain_1 = require(\"../typechain\");\nconst utils_1 = require(\"./utils\");\nfunction AdapterL1(Base) {\n  return class Adapter extends Base {\n    _providerL2() {\n      throw new Error('Must be implemented by the derived class!');\n    }\n    _providerL1() {\n      throw new Error('Must be implemented by the derived class!');\n    }\n    _signerL1() {\n      throw new Error('Must be implemented by the derived class!');\n    }\n    async getMainContract() {\n      const address = await this._providerL2().getMainContractAddress();\n      return typechain_1.IZkSyncFactory.connect(address, this._signerL1());\n    }\n    async getL1BridgeContracts() {\n      const addresses = await this._providerL2().getDefaultBridgeAddresses();\n      return {\n        erc20: typechain_1.IL1BridgeFactory.connect(addresses.erc20L1, this._signerL1())\n      };\n    }\n    async getBalanceL1(token, blockTag) {\n      token !== null && token !== void 0 ? token : token = utils_1.ETH_ADDRESS;\n      if ((0, utils_1.isETH)(token)) {\n        return await this._providerL1().getBalance(await this.getAddress(), blockTag);\n      } else {\n        const erc20contract = typechain_1.IERC20MetadataFactory.connect(token, this._providerL1());\n        return await erc20contract.balanceOf(await this.getAddress());\n      }\n    }\n    async l2TokenAddress(token) {\n      if (token == utils_1.ETH_ADDRESS) {\n        return utils_1.ETH_ADDRESS;\n      } else {\n        const erc20Bridge = (await this.getL1BridgeContracts()).erc20;\n        return await erc20Bridge.l2TokenAddress(token);\n      }\n    }\n    async approveERC20(token, amount, overrides) {\n      if ((0, utils_1.isETH)(token)) {\n        throw new Error(\"ETH token can't be approved. The address of the token does not exist on L1.\");\n      }\n      let bridgeAddress = overrides === null || overrides === void 0 ? void 0 : overrides.bridgeAddress;\n      const erc20contract = typechain_1.IERC20MetadataFactory.connect(token, this._signerL1());\n      if (bridgeAddress == null) {\n        bridgeAddress = (await this._providerL2().getDefaultBridgeAddresses()).erc20L1;\n      } else {\n        delete overrides.bridgeAddress;\n      }\n      return await erc20contract.approve(bridgeAddress, amount, overrides);\n    }\n    async getBaseCost(params) {\n      var _a, _b;\n      const zksyncContract = await this.getMainContract();\n      const parameters = {\n        ...(0, utils_1.layer1TxDefaults)(),\n        ...params\n      };\n      (_a = parameters.gasPrice) !== null && _a !== void 0 ? _a : parameters.gasPrice = await this._providerL1().getGasPrice();\n      (_b = parameters.gasPerPubdataByte) !== null && _b !== void 0 ? _b : parameters.gasPerPubdataByte = utils_1.REQUIRED_L1_TO_L2_GAS_PER_PUBDATA_LIMIT;\n      return ethers_1.BigNumber.from(await zksyncContract.l2TransactionBaseCost(parameters.gasPrice, parameters.gasLimit, parameters.gasPerPubdataByte));\n    }\n    async deposit(transaction) {\n      var _a;\n      const depositTx = await this.getDepositTx(transaction);\n      if (transaction.token == utils_1.ETH_ADDRESS) {\n        return this.requestExecute(depositTx);\n      } else {\n        const bridgeContracts = await this.getL1BridgeContracts();\n        if (transaction.approveERC20) {\n          const approveTx = await this.approveERC20(transaction.token, transaction.amount, {\n            bridgeAddress: (_a = transaction.bridgeAddress) !== null && _a !== void 0 ? _a : bridgeContracts.erc20.address,\n            ...transaction.approveOverrides\n          });\n          await approveTx.wait();\n        }\n        return await this._providerL2().getPriorityOpResponse(await this._signerL1().sendTransaction(depositTx));\n      }\n    }\n    async estimateGasDeposit(transaction) {\n      const depositTx = await this.getDepositTx(transaction);\n      if (transaction.token == utils_1.ETH_ADDRESS) {\n        return await this.estimateGasRequestExecute(depositTx);\n      } else {\n        return await this._providerL1().estimateGas(depositTx);\n      }\n    }\n    async getDepositTx(transaction) {\n      var _a, _b, _c, _d, _e, _f, _g;\n      const bridgeContracts = await this.getL1BridgeContracts();\n      if (transaction.bridgeAddress) {\n        bridgeContracts.erc20.attach(transaction.bridgeAddress);\n      }\n      const {\n        ...tx\n      } = transaction;\n      (_a = tx.to) !== null && _a !== void 0 ? _a : tx.to = await this.getAddress();\n      (_b = tx.operatorTip) !== null && _b !== void 0 ? _b : tx.operatorTip = ethers_1.BigNumber.from(0);\n      (_c = tx.overrides) !== null && _c !== void 0 ? _c : tx.overrides = {};\n      (_d = tx.gasPerPubdataByte) !== null && _d !== void 0 ? _d : tx.gasPerPubdataByte = utils_1.REQUIRED_L1_TO_L2_GAS_PER_PUBDATA_LIMIT;\n      (_e = tx.l2GasLimit) !== null && _e !== void 0 ? _e : tx.l2GasLimit = await (0, utils_1.estimateDefaultBridgeDepositL2Gas)(this._providerL1(), this._providerL2(), tx.token, tx.amount, tx.to, await this.getAddress(), tx.gasPerPubdataByte);\n      const {\n        to,\n        token,\n        amount,\n        operatorTip,\n        overrides\n      } = tx;\n      await insertGasPrice(this._providerL1(), overrides);\n      const gasPriceForEstimation = overrides.maxFeePerGas || overrides.gasPrice;\n      const zksyncContract = await this.getMainContract();\n      const baseCost = await zksyncContract.l2TransactionBaseCost(await gasPriceForEstimation, tx.l2GasLimit, tx.gasPerPubdataByte);\n      if (token == utils_1.ETH_ADDRESS) {\n        (_f = overrides.value) !== null && _f !== void 0 ? _f : overrides.value = baseCost.add(operatorTip).add(amount);\n        return {\n          contractAddress: to,\n          calldata: '0x',\n          l2Value: amount,\n          // For some reason typescript can not deduce that we've already set the\n          // tx.l2GasLimit\n          l2GasLimit: tx.l2GasLimit,\n          ...tx\n        };\n      } else {\n        const args = [to, token, amount, tx.l2GasLimit, tx.gasPerPubdataByte];\n        (_g = overrides.value) !== null && _g !== void 0 ? _g : overrides.value = baseCost.add(operatorTip);\n        await (0, utils_1.checkBaseCost)(baseCost, overrides.value);\n        // TODO: compatibility layer: using the old API which uses msg.sender as the\n        // refund recipient, to make the SDK compatible with the old contracts.\n        // const contract = bridgeContracts.erc20 as ethers.Contract;\n        return await bridgeContracts.erc20.populateTransaction.deposit(...args, overrides);\n      }\n    }\n    async _getWithdrawalLog(withdrawalHash) {\n      let index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      const hash = ethers_1.ethers.utils.hexlify(withdrawalHash);\n      const receipt = await this._providerL2().getTransactionReceipt(hash);\n      const log = receipt.logs.filter(log => log.address == utils_1.L1_MESSENGER_ADDRESS && log.topics[0] == ethers_1.ethers.utils.id('L1MessageSent(address,bytes32,bytes)'))[index];\n      return {\n        log,\n        l1BatchTxId: receipt.l1BatchTxIndex\n      };\n    }\n    async _getWithdrawalL2ToL1Log(withdrawalHash) {\n      let index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      const hash = ethers_1.ethers.utils.hexlify(withdrawalHash);\n      const receipt = await this._providerL2().getTransactionReceipt(hash);\n      const messages = Array.from(receipt.l2ToL1Logs.entries()).filter(_ref => {\n        let [_, log] = _ref;\n        return log.sender == utils_1.L1_MESSENGER_ADDRESS;\n      });\n      const [l2ToL1LogIndex, l2ToL1Log] = messages[index];\n      return {\n        l2ToL1LogIndex,\n        l2ToL1Log\n      };\n    }\n    async finalizeWithdrawalParams(withdrawalHash) {\n      let index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      const {\n        log,\n        l1BatchTxId\n      } = await this._getWithdrawalLog(withdrawalHash, index);\n      const {\n        l2ToL1LogIndex\n      } = await this._getWithdrawalL2ToL1Log(withdrawalHash, index);\n      const sender = ethers_1.ethers.utils.hexDataSlice(log.topics[1], 12);\n      const proof = await this._providerL2().getLogProof(withdrawalHash, l2ToL1LogIndex);\n      const message = ethers_1.ethers.utils.defaultAbiCoder.decode(['bytes'], log.data)[0];\n      return {\n        l1BatchNumber: log.l1BatchNumber,\n        l2MessageIndex: proof.id,\n        l2TxNumberInBlock: l1BatchTxId,\n        message,\n        sender,\n        proof: proof.proof\n      };\n    }\n    async finalizeWithdrawal(withdrawalHash) {\n      let index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      let overrides = arguments.length > 2 ? arguments[2] : undefined;\n      const {\n        l1BatchNumber,\n        l2MessageIndex,\n        l2TxNumberInBlock,\n        message,\n        sender,\n        proof\n      } = await this.finalizeWithdrawalParams(withdrawalHash, index);\n      if ((0, utils_1.isETH)(sender)) {\n        const contractAddress = await this._providerL2().getMainContractAddress();\n        const zksync = typechain_1.IZkSyncFactory.connect(contractAddress, this._signerL1());\n        return await zksync.finalizeEthWithdrawal(l1BatchNumber, l2MessageIndex, l2TxNumberInBlock, message, proof, overrides !== null && overrides !== void 0 ? overrides : {});\n      }\n      const l2Bridge = typechain_1.IL2BridgeFactory.connect(sender, this._providerL2());\n      const l1Bridge = typechain_1.IL1BridgeFactory.connect(await l2Bridge.l1Bridge(), this._signerL1());\n      return await l1Bridge.finalizeWithdrawal(l1BatchNumber, l2MessageIndex, l2TxNumberInBlock, message, proof, overrides !== null && overrides !== void 0 ? overrides : {});\n    }\n    async isWithdrawalFinalized(withdrawalHash) {\n      let index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      const {\n        log\n      } = await this._getWithdrawalLog(withdrawalHash, index);\n      const {\n        l2ToL1LogIndex\n      } = await this._getWithdrawalL2ToL1Log(withdrawalHash, index);\n      const sender = ethers_1.ethers.utils.hexDataSlice(log.topics[1], 12);\n      // `getLogProof` is called not to get proof but\n      // to get the index of the corresponding L2->L1 log,\n      // which is returned as `proof.id`.\n      const proof = await this._providerL2().getLogProof(withdrawalHash, l2ToL1LogIndex);\n      if ((0, utils_1.isETH)(sender)) {\n        const contractAddress = await this._providerL2().getMainContractAddress();\n        const zksync = typechain_1.IZkSyncFactory.connect(contractAddress, this._signerL1());\n        return await zksync.isEthWithdrawalFinalized(log.l1BatchNumber, proof.id);\n      }\n      const l2Bridge = typechain_1.IL2BridgeFactory.connect(sender, this._providerL2());\n      const l1Bridge = typechain_1.IL1BridgeFactory.connect(await l2Bridge.l1Bridge(), this._providerL1());\n      return await l1Bridge.isWithdrawalFinalized(log.l1BatchNumber, proof.id);\n    }\n    async claimFailedDeposit(depositHash, overrides) {\n      const receipt = await this._providerL2().getTransactionReceipt(ethers_1.ethers.utils.hexlify(depositHash));\n      const successL2ToL1LogIndex = receipt.l2ToL1Logs.findIndex(l2ToL1log => l2ToL1log.sender == utils_1.BOOTLOADER_FORMAL_ADDRESS && l2ToL1log.key == depositHash);\n      const successL2ToL1Log = receipt.l2ToL1Logs[successL2ToL1LogIndex];\n      if (successL2ToL1Log.value != ethers_1.ethers.constants.HashZero) {\n        throw new Error('Cannot claim successful deposit');\n      }\n      const tx = await this._providerL2().getTransaction(ethers_1.ethers.utils.hexlify(depositHash));\n      // Undo the aliasing, since the Mailbox contract set it as for contract address.\n      const l1BridgeAddress = (0, utils_1.undoL1ToL2Alias)(receipt.from);\n      const l2BridgeAddress = receipt.to;\n      const l1Bridge = typechain_1.IL1BridgeFactory.connect(l1BridgeAddress, this._signerL1());\n      const l2Bridge = typechain_1.IL2BridgeFactory.connect(l2BridgeAddress, this._providerL2());\n      const calldata = l2Bridge.interface.decodeFunctionData('finalizeDeposit', tx.data);\n      const proof = await this._providerL2().getLogProof(depositHash, successL2ToL1LogIndex);\n      return await l1Bridge.claimFailedDeposit(calldata['_l1Sender'], calldata['_l1Token'], depositHash, receipt.l1BatchNumber, proof.id, receipt.l1BatchTxIndex, proof.proof, overrides !== null && overrides !== void 0 ? overrides : {});\n    }\n    async requestExecute(transaction) {\n      const requestExecuteTx = await this.getRequestExecuteTx(transaction);\n      return this._providerL2().getPriorityOpResponse(await this._signerL1().sendTransaction(requestExecuteTx));\n    }\n    async estimateGasRequestExecute(transaction) {\n      const requestExecuteTx = await this.getRequestExecuteTx(transaction);\n      return this._providerL1().estimateGas(requestExecuteTx);\n    }\n    async getRequestExecuteTx(transaction) {\n      var _a, _b, _c, _d, _e, _f, _g, _h;\n      const zksyncContract = await this.getMainContract();\n      const {\n        ...tx\n      } = transaction;\n      (_a = tx.l2Value) !== null && _a !== void 0 ? _a : tx.l2Value = ethers_1.BigNumber.from(0);\n      (_b = tx.operatorTip) !== null && _b !== void 0 ? _b : tx.operatorTip = ethers_1.BigNumber.from(0);\n      (_c = tx.factoryDeps) !== null && _c !== void 0 ? _c : tx.factoryDeps = [];\n      (_d = tx.overrides) !== null && _d !== void 0 ? _d : tx.overrides = {};\n      (_e = tx.gasPerPubdataByte) !== null && _e !== void 0 ? _e : tx.gasPerPubdataByte = utils_1.REQUIRED_L1_TO_L2_GAS_PER_PUBDATA_LIMIT;\n      (_f = tx.refundRecipient) !== null && _f !== void 0 ? _f : tx.refundRecipient = await this.getAddress();\n      (_g = tx.l2GasLimit) !== null && _g !== void 0 ? _g : tx.l2GasLimit = await this._providerL2().estimateL1ToL2Execute(transaction);\n      const {\n        contractAddress,\n        l2Value,\n        calldata,\n        l2GasLimit,\n        factoryDeps,\n        operatorTip,\n        overrides,\n        gasPerPubdataByte,\n        refundRecipient\n      } = tx;\n      await insertGasPrice(this._providerL1(), overrides);\n      const gasPriceForEstimation = overrides.maxFeePerGas || overrides.gasPrice;\n      const baseCost = await this.getBaseCost({\n        gasPrice: await gasPriceForEstimation,\n        gasPerPubdataByte,\n        gasLimit: l2GasLimit\n      });\n      (_h = overrides.value) !== null && _h !== void 0 ? _h : overrides.value = baseCost.add(operatorTip).add(l2Value);\n      await (0, utils_1.checkBaseCost)(baseCost, overrides.value);\n      return await zksyncContract.populateTransaction.requestL2Transaction(contractAddress, l2Value, calldata, l2GasLimit, utils_1.REQUIRED_L1_TO_L2_GAS_PER_PUBDATA_LIMIT, factoryDeps, refundRecipient, overrides);\n    }\n  };\n}\nexports.AdapterL1 = AdapterL1;\nfunction AdapterL2(Base) {\n  return class Adapter extends Base {\n    _providerL2() {\n      throw new Error('Must be implemented by the derived class!');\n    }\n    _signerL2() {\n      throw new Error('Must be implemented by the derived class!');\n    }\n    async getBalance(token) {\n      let blockTag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'committed';\n      return await this._providerL2().getBalance(await this.getAddress(), blockTag, token);\n    }\n    async getAllBalances() {\n      return await this._providerL2().getAllAccountBalances(await this.getAddress());\n    }\n    async getL2BridgeContracts() {\n      const addresses = await this._providerL2().getDefaultBridgeAddresses();\n      return {\n        erc20: typechain_1.IL2BridgeFactory.connect(addresses.erc20L2, this._signerL2())\n      };\n    }\n    _fillCustomData(data) {\n      var _a, _b;\n      const customData = {\n        ...data\n      };\n      (_a = customData.gasPerPubdata) !== null && _a !== void 0 ? _a : customData.gasPerPubdata = utils_1.DEFAULT_GAS_PER_PUBDATA_LIMIT;\n      (_b = customData.factoryDeps) !== null && _b !== void 0 ? _b : customData.factoryDeps = [];\n      return customData;\n    }\n    async withdraw(transaction) {\n      const withdrawTx = await this._providerL2().getWithdrawTx({\n        from: await this.getAddress(),\n        ...transaction\n      });\n      const txResponse = await this.sendTransaction(withdrawTx);\n      return this._providerL2()._wrapTransaction(txResponse);\n    }\n    async transfer(transaction) {\n      const transferTx = await this._providerL2().getTransferTx({\n        from: await this.getAddress(),\n        ...transaction\n      });\n      const txResponse = await this.sendTransaction(transferTx);\n      return this._providerL2()._wrapTransaction(txResponse);\n    }\n  };\n}\nexports.AdapterL2 = AdapterL2;\n/// @dev This method checks if the overrides contain a gasPrice (or maxFeePerGas), if not it will insert\n/// the maxFeePerGas\nasync function insertGasPrice(l1Provider, overrides) {\n  if (!overrides.gasPrice && !overrides.maxFeePerGas) {\n    const l1FeeData = await l1Provider.getFeeData();\n    // Sometimes baseFeePerGas is not available, so we use gasPrice instead.\n    const baseFee = l1FeeData.lastBaseFeePerGas || l1FeeData.gasPrice;\n    // ethers.js by default uses multiplcation by 2, but since the price for the L2 part\n    // will depend on the L1 part, doubling base fee is typically too much.\n    const maxFeePerGas = baseFee.mul(3).div(2).add(l1FeeData.maxPriorityFeePerGas);\n    overrides.maxFeePerGas = maxFeePerGas;\n    overrides.maxPriorityFeePerGas = l1FeeData.maxPriorityFeePerGas;\n  }\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","AdapterL2","AdapterL1","ethers_1","require","typechain_1","utils_1","Base","Adapter","_providerL2","Error","_providerL1","_signerL1","getMainContract","address","getMainContractAddress","IZkSyncFactory","connect","getL1BridgeContracts","addresses","getDefaultBridgeAddresses","erc20","IL1BridgeFactory","erc20L1","getBalanceL1","token","blockTag","ETH_ADDRESS","isETH","getBalance","getAddress","erc20contract","IERC20MetadataFactory","balanceOf","l2TokenAddress","erc20Bridge","approveERC20","amount","overrides","bridgeAddress","approve","getBaseCost","params","_a","_b","zksyncContract","parameters","layer1TxDefaults","gasPrice","getGasPrice","gasPerPubdataByte","REQUIRED_L1_TO_L2_GAS_PER_PUBDATA_LIMIT","BigNumber","from","l2TransactionBaseCost","gasLimit","deposit","transaction","depositTx","getDepositTx","requestExecute","bridgeContracts","approveTx","approveOverrides","wait","getPriorityOpResponse","sendTransaction","estimateGasDeposit","estimateGasRequestExecute","estimateGas","_c","_d","_e","_f","_g","attach","tx","to","operatorTip","l2GasLimit","estimateDefaultBridgeDepositL2Gas","insertGasPrice","gasPriceForEstimation","maxFeePerGas","baseCost","add","contractAddress","calldata","l2Value","args","checkBaseCost","populateTransaction","_getWithdrawalLog","withdrawalHash","index","arguments","length","undefined","hash","ethers","utils","hexlify","receipt","getTransactionReceipt","log","logs","filter","L1_MESSENGER_ADDRESS","topics","id","l1BatchTxId","l1BatchTxIndex","_getWithdrawalL2ToL1Log","messages","Array","l2ToL1Logs","entries","_ref","_","sender","l2ToL1LogIndex","l2ToL1Log","finalizeWithdrawalParams","hexDataSlice","proof","getLogProof","message","defaultAbiCoder","decode","data","l1BatchNumber","l2MessageIndex","l2TxNumberInBlock","finalizeWithdrawal","zksync","finalizeEthWithdrawal","l2Bridge","IL2BridgeFactory","l1Bridge","isWithdrawalFinalized","isEthWithdrawalFinalized","claimFailedDeposit","depositHash","successL2ToL1LogIndex","findIndex","l2ToL1log","BOOTLOADER_FORMAL_ADDRESS","key","successL2ToL1Log","constants","HashZero","getTransaction","l1BridgeAddress","undoL1ToL2Alias","l2BridgeAddress","interface","decodeFunctionData","requestExecuteTx","getRequestExecuteTx","_h","factoryDeps","refundRecipient","estimateL1ToL2Execute","requestL2Transaction","_signerL2","getAllBalances","getAllAccountBalances","getL2BridgeContracts","erc20L2","_fillCustomData","customData","gasPerPubdata","DEFAULT_GAS_PER_PUBDATA_LIMIT","withdraw","withdrawTx","getWithdrawTx","txResponse","_wrapTransaction","transfer","transferTx","getTransferTx","l1Provider","l1FeeData","getFeeData","baseFee","lastBaseFeePerGas","mul","div","maxPriorityFeePerGas"],"sources":["C:/Misc/Documents/Career/FinTech/BlockChain/FrontEnd/buildspace-dao-starter/node_modules/zksync-web3/build/src/adapters.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AdapterL2 = exports.AdapterL1 = void 0;\nconst ethers_1 = require(\"ethers\");\nconst typechain_1 = require(\"../typechain\");\nconst utils_1 = require(\"./utils\");\nfunction AdapterL1(Base) {\n    return class Adapter extends Base {\n        _providerL2() {\n            throw new Error('Must be implemented by the derived class!');\n        }\n        _providerL1() {\n            throw new Error('Must be implemented by the derived class!');\n        }\n        _signerL1() {\n            throw new Error('Must be implemented by the derived class!');\n        }\n        async getMainContract() {\n            const address = await this._providerL2().getMainContractAddress();\n            return typechain_1.IZkSyncFactory.connect(address, this._signerL1());\n        }\n        async getL1BridgeContracts() {\n            const addresses = await this._providerL2().getDefaultBridgeAddresses();\n            return {\n                erc20: typechain_1.IL1BridgeFactory.connect(addresses.erc20L1, this._signerL1())\n            };\n        }\n        async getBalanceL1(token, blockTag) {\n            token !== null && token !== void 0 ? token : (token = utils_1.ETH_ADDRESS);\n            if ((0, utils_1.isETH)(token)) {\n                return await this._providerL1().getBalance(await this.getAddress(), blockTag);\n            }\n            else {\n                const erc20contract = typechain_1.IERC20MetadataFactory.connect(token, this._providerL1());\n                return await erc20contract.balanceOf(await this.getAddress());\n            }\n        }\n        async l2TokenAddress(token) {\n            if (token == utils_1.ETH_ADDRESS) {\n                return utils_1.ETH_ADDRESS;\n            }\n            else {\n                const erc20Bridge = (await this.getL1BridgeContracts()).erc20;\n                return await erc20Bridge.l2TokenAddress(token);\n            }\n        }\n        async approveERC20(token, amount, overrides) {\n            if ((0, utils_1.isETH)(token)) {\n                throw new Error(\"ETH token can't be approved. The address of the token does not exist on L1.\");\n            }\n            let bridgeAddress = overrides === null || overrides === void 0 ? void 0 : overrides.bridgeAddress;\n            const erc20contract = typechain_1.IERC20MetadataFactory.connect(token, this._signerL1());\n            if (bridgeAddress == null) {\n                bridgeAddress = (await this._providerL2().getDefaultBridgeAddresses()).erc20L1;\n            }\n            else {\n                delete overrides.bridgeAddress;\n            }\n            return await erc20contract.approve(bridgeAddress, amount, overrides);\n        }\n        async getBaseCost(params) {\n            var _a, _b;\n            const zksyncContract = await this.getMainContract();\n            const parameters = { ...(0, utils_1.layer1TxDefaults)(), ...params };\n            (_a = parameters.gasPrice) !== null && _a !== void 0 ? _a : (parameters.gasPrice = await this._providerL1().getGasPrice());\n            (_b = parameters.gasPerPubdataByte) !== null && _b !== void 0 ? _b : (parameters.gasPerPubdataByte = utils_1.REQUIRED_L1_TO_L2_GAS_PER_PUBDATA_LIMIT);\n            return ethers_1.BigNumber.from(await zksyncContract.l2TransactionBaseCost(parameters.gasPrice, parameters.gasLimit, parameters.gasPerPubdataByte));\n        }\n        async deposit(transaction) {\n            var _a;\n            const depositTx = await this.getDepositTx(transaction);\n            if (transaction.token == utils_1.ETH_ADDRESS) {\n                return this.requestExecute(depositTx);\n            }\n            else {\n                const bridgeContracts = await this.getL1BridgeContracts();\n                if (transaction.approveERC20) {\n                    const approveTx = await this.approveERC20(transaction.token, transaction.amount, {\n                        bridgeAddress: (_a = transaction.bridgeAddress) !== null && _a !== void 0 ? _a : bridgeContracts.erc20.address,\n                        ...transaction.approveOverrides\n                    });\n                    await approveTx.wait();\n                }\n                return await this._providerL2().getPriorityOpResponse(await this._signerL1().sendTransaction(depositTx));\n            }\n        }\n        async estimateGasDeposit(transaction) {\n            const depositTx = await this.getDepositTx(transaction);\n            if (transaction.token == utils_1.ETH_ADDRESS) {\n                return await this.estimateGasRequestExecute(depositTx);\n            }\n            else {\n                return await this._providerL1().estimateGas(depositTx);\n            }\n        }\n        async getDepositTx(transaction) {\n            var _a, _b, _c, _d, _e, _f, _g;\n            const bridgeContracts = await this.getL1BridgeContracts();\n            if (transaction.bridgeAddress) {\n                bridgeContracts.erc20.attach(transaction.bridgeAddress);\n            }\n            const { ...tx } = transaction;\n            (_a = tx.to) !== null && _a !== void 0 ? _a : (tx.to = await this.getAddress());\n            (_b = tx.operatorTip) !== null && _b !== void 0 ? _b : (tx.operatorTip = ethers_1.BigNumber.from(0));\n            (_c = tx.overrides) !== null && _c !== void 0 ? _c : (tx.overrides = {});\n            (_d = tx.gasPerPubdataByte) !== null && _d !== void 0 ? _d : (tx.gasPerPubdataByte = utils_1.REQUIRED_L1_TO_L2_GAS_PER_PUBDATA_LIMIT);\n            (_e = tx.l2GasLimit) !== null && _e !== void 0 ? _e : (tx.l2GasLimit = await (0, utils_1.estimateDefaultBridgeDepositL2Gas)(this._providerL1(), this._providerL2(), tx.token, tx.amount, tx.to, await this.getAddress(), tx.gasPerPubdataByte));\n            const { to, token, amount, operatorTip, overrides } = tx;\n            await insertGasPrice(this._providerL1(), overrides);\n            const gasPriceForEstimation = overrides.maxFeePerGas || overrides.gasPrice;\n            const zksyncContract = await this.getMainContract();\n            const baseCost = await zksyncContract.l2TransactionBaseCost(await gasPriceForEstimation, tx.l2GasLimit, tx.gasPerPubdataByte);\n            if (token == utils_1.ETH_ADDRESS) {\n                (_f = overrides.value) !== null && _f !== void 0 ? _f : (overrides.value = baseCost.add(operatorTip).add(amount));\n                return {\n                    contractAddress: to,\n                    calldata: '0x',\n                    l2Value: amount,\n                    // For some reason typescript can not deduce that we've already set the\n                    // tx.l2GasLimit\n                    l2GasLimit: tx.l2GasLimit,\n                    ...tx\n                };\n            }\n            else {\n                const args = [\n                    to,\n                    token,\n                    amount,\n                    tx.l2GasLimit,\n                    tx.gasPerPubdataByte\n                ];\n                (_g = overrides.value) !== null && _g !== void 0 ? _g : (overrides.value = baseCost.add(operatorTip));\n                await (0, utils_1.checkBaseCost)(baseCost, overrides.value);\n                // TODO: compatibility layer: using the old API which uses msg.sender as the\n                // refund recipient, to make the SDK compatible with the old contracts.\n                // const contract = bridgeContracts.erc20 as ethers.Contract;\n                return await bridgeContracts.erc20.populateTransaction.deposit(...args, overrides);\n            }\n        }\n        async _getWithdrawalLog(withdrawalHash, index = 0) {\n            const hash = ethers_1.ethers.utils.hexlify(withdrawalHash);\n            const receipt = await this._providerL2().getTransactionReceipt(hash);\n            const log = receipt.logs.filter((log) => log.address == utils_1.L1_MESSENGER_ADDRESS &&\n                log.topics[0] == ethers_1.ethers.utils.id('L1MessageSent(address,bytes32,bytes)'))[index];\n            return {\n                log,\n                l1BatchTxId: receipt.l1BatchTxIndex\n            };\n        }\n        async _getWithdrawalL2ToL1Log(withdrawalHash, index = 0) {\n            const hash = ethers_1.ethers.utils.hexlify(withdrawalHash);\n            const receipt = await this._providerL2().getTransactionReceipt(hash);\n            const messages = Array.from(receipt.l2ToL1Logs.entries()).filter(([_, log]) => log.sender == utils_1.L1_MESSENGER_ADDRESS);\n            const [l2ToL1LogIndex, l2ToL1Log] = messages[index];\n            return {\n                l2ToL1LogIndex,\n                l2ToL1Log\n            };\n        }\n        async finalizeWithdrawalParams(withdrawalHash, index = 0) {\n            const { log, l1BatchTxId } = await this._getWithdrawalLog(withdrawalHash, index);\n            const { l2ToL1LogIndex } = await this._getWithdrawalL2ToL1Log(withdrawalHash, index);\n            const sender = ethers_1.ethers.utils.hexDataSlice(log.topics[1], 12);\n            const proof = await this._providerL2().getLogProof(withdrawalHash, l2ToL1LogIndex);\n            const message = ethers_1.ethers.utils.defaultAbiCoder.decode(['bytes'], log.data)[0];\n            return {\n                l1BatchNumber: log.l1BatchNumber,\n                l2MessageIndex: proof.id,\n                l2TxNumberInBlock: l1BatchTxId,\n                message,\n                sender,\n                proof: proof.proof\n            };\n        }\n        async finalizeWithdrawal(withdrawalHash, index = 0, overrides) {\n            const { l1BatchNumber, l2MessageIndex, l2TxNumberInBlock, message, sender, proof } = await this.finalizeWithdrawalParams(withdrawalHash, index);\n            if ((0, utils_1.isETH)(sender)) {\n                const contractAddress = await this._providerL2().getMainContractAddress();\n                const zksync = typechain_1.IZkSyncFactory.connect(contractAddress, this._signerL1());\n                return await zksync.finalizeEthWithdrawal(l1BatchNumber, l2MessageIndex, l2TxNumberInBlock, message, proof, overrides !== null && overrides !== void 0 ? overrides : {});\n            }\n            const l2Bridge = typechain_1.IL2BridgeFactory.connect(sender, this._providerL2());\n            const l1Bridge = typechain_1.IL1BridgeFactory.connect(await l2Bridge.l1Bridge(), this._signerL1());\n            return await l1Bridge.finalizeWithdrawal(l1BatchNumber, l2MessageIndex, l2TxNumberInBlock, message, proof, overrides !== null && overrides !== void 0 ? overrides : {});\n        }\n        async isWithdrawalFinalized(withdrawalHash, index = 0) {\n            const { log } = await this._getWithdrawalLog(withdrawalHash, index);\n            const { l2ToL1LogIndex } = await this._getWithdrawalL2ToL1Log(withdrawalHash, index);\n            const sender = ethers_1.ethers.utils.hexDataSlice(log.topics[1], 12);\n            // `getLogProof` is called not to get proof but\n            // to get the index of the corresponding L2->L1 log,\n            // which is returned as `proof.id`.\n            const proof = await this._providerL2().getLogProof(withdrawalHash, l2ToL1LogIndex);\n            if ((0, utils_1.isETH)(sender)) {\n                const contractAddress = await this._providerL2().getMainContractAddress();\n                const zksync = typechain_1.IZkSyncFactory.connect(contractAddress, this._signerL1());\n                return await zksync.isEthWithdrawalFinalized(log.l1BatchNumber, proof.id);\n            }\n            const l2Bridge = typechain_1.IL2BridgeFactory.connect(sender, this._providerL2());\n            const l1Bridge = typechain_1.IL1BridgeFactory.connect(await l2Bridge.l1Bridge(), this._providerL1());\n            return await l1Bridge.isWithdrawalFinalized(log.l1BatchNumber, proof.id);\n        }\n        async claimFailedDeposit(depositHash, overrides) {\n            const receipt = await this._providerL2().getTransactionReceipt(ethers_1.ethers.utils.hexlify(depositHash));\n            const successL2ToL1LogIndex = receipt.l2ToL1Logs.findIndex((l2ToL1log) => l2ToL1log.sender == utils_1.BOOTLOADER_FORMAL_ADDRESS && l2ToL1log.key == depositHash);\n            const successL2ToL1Log = receipt.l2ToL1Logs[successL2ToL1LogIndex];\n            if (successL2ToL1Log.value != ethers_1.ethers.constants.HashZero) {\n                throw new Error('Cannot claim successful deposit');\n            }\n            const tx = await this._providerL2().getTransaction(ethers_1.ethers.utils.hexlify(depositHash));\n            // Undo the aliasing, since the Mailbox contract set it as for contract address.\n            const l1BridgeAddress = (0, utils_1.undoL1ToL2Alias)(receipt.from);\n            const l2BridgeAddress = receipt.to;\n            const l1Bridge = typechain_1.IL1BridgeFactory.connect(l1BridgeAddress, this._signerL1());\n            const l2Bridge = typechain_1.IL2BridgeFactory.connect(l2BridgeAddress, this._providerL2());\n            const calldata = l2Bridge.interface.decodeFunctionData('finalizeDeposit', tx.data);\n            const proof = await this._providerL2().getLogProof(depositHash, successL2ToL1LogIndex);\n            return await l1Bridge.claimFailedDeposit(calldata['_l1Sender'], calldata['_l1Token'], depositHash, receipt.l1BatchNumber, proof.id, receipt.l1BatchTxIndex, proof.proof, overrides !== null && overrides !== void 0 ? overrides : {});\n        }\n        async requestExecute(transaction) {\n            const requestExecuteTx = await this.getRequestExecuteTx(transaction);\n            return this._providerL2().getPriorityOpResponse(await this._signerL1().sendTransaction(requestExecuteTx));\n        }\n        async estimateGasRequestExecute(transaction) {\n            const requestExecuteTx = await this.getRequestExecuteTx(transaction);\n            return this._providerL1().estimateGas(requestExecuteTx);\n        }\n        async getRequestExecuteTx(transaction) {\n            var _a, _b, _c, _d, _e, _f, _g, _h;\n            const zksyncContract = await this.getMainContract();\n            const { ...tx } = transaction;\n            (_a = tx.l2Value) !== null && _a !== void 0 ? _a : (tx.l2Value = ethers_1.BigNumber.from(0));\n            (_b = tx.operatorTip) !== null && _b !== void 0 ? _b : (tx.operatorTip = ethers_1.BigNumber.from(0));\n            (_c = tx.factoryDeps) !== null && _c !== void 0 ? _c : (tx.factoryDeps = []);\n            (_d = tx.overrides) !== null && _d !== void 0 ? _d : (tx.overrides = {});\n            (_e = tx.gasPerPubdataByte) !== null && _e !== void 0 ? _e : (tx.gasPerPubdataByte = utils_1.REQUIRED_L1_TO_L2_GAS_PER_PUBDATA_LIMIT);\n            (_f = tx.refundRecipient) !== null && _f !== void 0 ? _f : (tx.refundRecipient = await this.getAddress());\n            (_g = tx.l2GasLimit) !== null && _g !== void 0 ? _g : (tx.l2GasLimit = await this._providerL2().estimateL1ToL2Execute(transaction));\n            const { contractAddress, l2Value, calldata, l2GasLimit, factoryDeps, operatorTip, overrides, gasPerPubdataByte, refundRecipient } = tx;\n            await insertGasPrice(this._providerL1(), overrides);\n            const gasPriceForEstimation = overrides.maxFeePerGas || overrides.gasPrice;\n            const baseCost = await this.getBaseCost({\n                gasPrice: await gasPriceForEstimation,\n                gasPerPubdataByte,\n                gasLimit: l2GasLimit\n            });\n            (_h = overrides.value) !== null && _h !== void 0 ? _h : (overrides.value = baseCost.add(operatorTip).add(l2Value));\n            await (0, utils_1.checkBaseCost)(baseCost, overrides.value);\n            return await zksyncContract.populateTransaction.requestL2Transaction(contractAddress, l2Value, calldata, l2GasLimit, utils_1.REQUIRED_L1_TO_L2_GAS_PER_PUBDATA_LIMIT, factoryDeps, refundRecipient, overrides);\n        }\n    };\n}\nexports.AdapterL1 = AdapterL1;\nfunction AdapterL2(Base) {\n    return class Adapter extends Base {\n        _providerL2() {\n            throw new Error('Must be implemented by the derived class!');\n        }\n        _signerL2() {\n            throw new Error('Must be implemented by the derived class!');\n        }\n        async getBalance(token, blockTag = 'committed') {\n            return await this._providerL2().getBalance(await this.getAddress(), blockTag, token);\n        }\n        async getAllBalances() {\n            return await this._providerL2().getAllAccountBalances(await this.getAddress());\n        }\n        async getL2BridgeContracts() {\n            const addresses = await this._providerL2().getDefaultBridgeAddresses();\n            return {\n                erc20: typechain_1.IL2BridgeFactory.connect(addresses.erc20L2, this._signerL2())\n            };\n        }\n        _fillCustomData(data) {\n            var _a, _b;\n            const customData = { ...data };\n            (_a = customData.gasPerPubdata) !== null && _a !== void 0 ? _a : (customData.gasPerPubdata = utils_1.DEFAULT_GAS_PER_PUBDATA_LIMIT);\n            (_b = customData.factoryDeps) !== null && _b !== void 0 ? _b : (customData.factoryDeps = []);\n            return customData;\n        }\n        async withdraw(transaction) {\n            const withdrawTx = await this._providerL2().getWithdrawTx({\n                from: await this.getAddress(),\n                ...transaction\n            });\n            const txResponse = await this.sendTransaction(withdrawTx);\n            return this._providerL2()._wrapTransaction(txResponse);\n        }\n        async transfer(transaction) {\n            const transferTx = await this._providerL2().getTransferTx({\n                from: await this.getAddress(),\n                ...transaction\n            });\n            const txResponse = await this.sendTransaction(transferTx);\n            return this._providerL2()._wrapTransaction(txResponse);\n        }\n    };\n}\nexports.AdapterL2 = AdapterL2;\n/// @dev This method checks if the overrides contain a gasPrice (or maxFeePerGas), if not it will insert\n/// the maxFeePerGas\nasync function insertGasPrice(l1Provider, overrides) {\n    if (!overrides.gasPrice && !overrides.maxFeePerGas) {\n        const l1FeeData = await l1Provider.getFeeData();\n        // Sometimes baseFeePerGas is not available, so we use gasPrice instead.\n        const baseFee = l1FeeData.lastBaseFeePerGas || l1FeeData.gasPrice;\n        // ethers.js by default uses multiplcation by 2, but since the price for the L2 part\n        // will depend on the L1 part, doubling base fee is typically too much.\n        const maxFeePerGas = baseFee.mul(3).div(2).add(l1FeeData.maxPriorityFeePerGas);\n        overrides.maxFeePerGas = maxFeePerGas;\n        overrides.maxPriorityFeePerGas = l1FeeData.maxPriorityFeePerGas;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}