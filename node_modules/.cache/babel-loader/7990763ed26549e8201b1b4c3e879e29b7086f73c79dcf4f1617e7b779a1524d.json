{"ast":null,"code":"import { _ as _classPrivateMethodInitSpec, a as _classPrivateMethodGet } from './classPrivateMethodGet-ea199cc3.browser.esm.js';\nimport { _ as _classPrivateFieldInitSpec, a as _classPrivateFieldSet, b as _classPrivateFieldGet } from './classPrivateFieldSet-a5db7c83.browser.esm.js';\nimport { _ as _defineProperty } from './defineProperty-c8ecdc07.browser.esm.js';\nimport { a as AbstractClientWallet } from './base-402f7b12.browser.esm.js';\nimport { w as walletIds } from './walletIds-a64268ca.browser.esm.js';\nimport { Core } from '@walletconnect/core';\nimport { Web3Wallet } from '@walletconnect/web3wallet';\nimport { utils } from 'ethers';\nimport EventEmitter from 'eventemitter3';\nimport { T as TW_WC_PROJECT_ID, W as WC_RELAY_URL, E as EIP155_SIGNING_METHODS } from './wc-c6a6a61c.browser.esm.js';\nimport { formatJsonRpcResult } from '@walletconnect/jsonrpc-utils';\nimport { isContractDeployed, ThirdwebSDK } from '@thirdweb-dev/sdk';\n\n// connect dapp support through wcv2 protocol\n\nclass WalletConnectHandler extends EventEmitter {}\nvar _core = /*#__PURE__*/new WeakMap();\nvar _wcWallet$1 = /*#__PURE__*/new WeakMap();\nvar _session = /*#__PURE__*/new WeakMap();\nvar _wcMetadata = /*#__PURE__*/new WeakMap();\nvar _activeProposal = /*#__PURE__*/new WeakMap();\nvar _activeRequestEvent = /*#__PURE__*/new WeakMap();\nvar _setupWalletConnectEventsListeners$1 = /*#__PURE__*/new WeakSet();\nvar _getSignParamsMessage = /*#__PURE__*/new WeakSet();\nclass WalletConnectV2Handler extends WalletConnectHandler {\n  constructor(options) {\n    super();\n    /**\n     * Gets message from various signing request methods by filtering out\n     * a value that is not an address (thus is a message).\n     * If it is a hex string, it gets converted to utf8 string\n     */\n    _classPrivateMethodInitSpec(this, _getSignParamsMessage);\n    _classPrivateMethodInitSpec(this, _setupWalletConnectEventsListeners$1);\n    _classPrivateFieldInitSpec(this, _core, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _wcWallet$1, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _session, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _wcMetadata, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _activeProposal, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _activeRequestEvent, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldSet(this, _wcMetadata, options?.walletConnectWalletMetadata || {\n      name: \"Thirdweb Smart Wallet\",\n      description: \"Thirdweb Smart Wallet\",\n      url: \"https://thirdweb.com\",\n      icons: [\"https://thirdweb.com/favicon.ico\"]\n    });\n    _classPrivateFieldSet(this, _core, new Core({\n      projectId: options?.walletConenctV2ProjectId || TW_WC_PROJECT_ID,\n      relayUrl: options?.walletConnectV2RelayUrl || WC_RELAY_URL\n    }));\n  }\n  async init() {\n    _classPrivateFieldSet(this, _wcWallet$1, await Web3Wallet.init({\n      core: _classPrivateFieldGet(this, _core),\n      metadata: _classPrivateFieldGet(this, _wcMetadata)\n    }));\n    const sessions = _classPrivateFieldGet(this, _wcWallet$1).getActiveSessions();\n    const keys = Object.keys(sessions);\n    if (keys[0]) {\n      _classPrivateFieldSet(this, _session, sessions[keys[0]]);\n    }\n    _classPrivateMethodGet(this, _setupWalletConnectEventsListeners$1, _setupWalletConnectEventsListeners2$1).call(this);\n  }\n  async connectApp(wcUri) {\n    if (!_classPrivateFieldGet(this, _wcWallet$1)) {\n      throw new Error(\"Please, init the wallet before connecting an app.\");\n    }\n    await _classPrivateFieldGet(this, _wcWallet$1).core.pairing.pair({\n      uri: wcUri\n    });\n  }\n  async approveSession(wallet) {\n    if (!_classPrivateFieldGet(this, _wcWallet$1)) {\n      throw new Error(\"Please, init the wallet before making session requests.\");\n    }\n    if (!_classPrivateFieldGet(this, _activeProposal)) {\n      throw new Error(\"Please, pass a valid proposal.\");\n    }\n    const account = await wallet.getAddress();\n    const {\n      id,\n      params\n    } = _classPrivateFieldGet(this, _activeProposal);\n    const {\n      requiredNamespaces,\n      relays\n    } = params;\n    const namespaces = {};\n    Object.keys(requiredNamespaces).forEach(key => {\n      const accounts = [];\n      const namespace = requiredNamespaces[key];\n      if (namespace) {\n        namespace.chains?.map(chain => {\n          accounts.push(`${chain}:${account}`);\n        });\n        namespaces[key] = {\n          accounts,\n          methods: namespace.methods,\n          events: namespace.events\n        };\n      }\n    });\n    _classPrivateFieldSet(this, _session, await _classPrivateFieldGet(this, _wcWallet$1).approveSession({\n      id,\n      relayProtocol: relays[0]?.protocol,\n      namespaces\n    }));\n    this.emit(\"session_approved\");\n  }\n  async rejectSession() {\n    if (!_classPrivateFieldGet(this, _wcWallet$1)) {\n      throw new Error(\"Please, init the wallet before making session requests.\");\n    }\n    if (!_classPrivateFieldGet(this, _activeProposal)) {\n      throw new Error(\"Please, pass a valid proposal.\");\n    }\n    const {\n      id\n    } = _classPrivateFieldGet(this, _activeProposal);\n    await _classPrivateFieldGet(this, _wcWallet$1).rejectSession({\n      id,\n      reason: {\n        message: \"User rejected methods.\",\n        code: 5002\n      }\n    });\n  }\n  async approveEIP155Request(wallet) {\n    if (!_classPrivateFieldGet(this, _activeRequestEvent)) {\n      return;\n    }\n    const {\n      topic,\n      params,\n      id\n    } = _classPrivateFieldGet(this, _activeRequestEvent);\n    const {\n      request\n    } = params;\n    let response;\n    switch (request.method) {\n      case EIP155_SIGNING_METHODS.PERSONAL_SIGN:\n      case EIP155_SIGNING_METHODS.ETH_SIGN:\n        const message = _classPrivateMethodGet(this, _getSignParamsMessage, _getSignParamsMessage2).call(this, request.params);\n        const signedMessage = await wallet.signMessage(message || \"\"); // TODO: handle empty message\n\n        response = formatJsonRpcResult(id, signedMessage);\n        break;\n      // case EIP155_SIGNING_METHODS.ETH_SIGN_TYPED_DATA:\n      // case EIP155_SIGNING_METHODS.ETH_SIGN_TYPED_DATA_V3:\n      // case EIP155_SIGNING_METHODS.ETH_SIGN_TYPED_DATA_V4:\n      //   const {\n      //     domain,\n      //     types,\n      //     message: data,\n      //   } = getSignTypedDataParamsData(request.params);\n      //   // https://github.com/ethers-io/ethers.js/issues/687#issuecomment-714069471\n      //   delete types.EIP712Domain;\n      //   const signedData = await wallet._signTypedData(domain, types, data);\n      //   return formatJsonRpcResult(id, signedData);\n      case EIP155_SIGNING_METHODS.ETH_SEND_TRANSACTION:\n        const signer = await wallet.getSigner();\n        const sendTransaction = request.params[0];\n        const tx = await signer.sendTransaction(sendTransaction);\n        const {\n          transactionHash\n        } = await tx.wait();\n        response = formatJsonRpcResult(id, transactionHash);\n        break;\n      case EIP155_SIGNING_METHODS.ETH_SIGN_TRANSACTION:\n        const signerSign = await wallet.getSigner();\n        const signTransaction = request.params[0];\n        const signature = await signerSign.signTransaction(signTransaction);\n        response = formatJsonRpcResult(id, signature);\n      default:\n        const error = {\n          id,\n          jsonrpc: \"2.0\",\n          error: {\n            message: \"Invalid event.\",\n            code: 1002\n          }\n        };\n        return _classPrivateFieldGet(this, _wcWallet$1)?.respondSessionRequest({\n          topic,\n          response: error\n        });\n    }\n    return _classPrivateFieldGet(this, _wcWallet$1)?.respondSessionRequest({\n      topic,\n      response\n    });\n  }\n  async rejectEIP155Request() {\n    if (!_classPrivateFieldGet(this, _activeRequestEvent)) {\n      return;\n    }\n    const {\n      topic,\n      id\n    } = _classPrivateFieldGet(this, _activeRequestEvent);\n    const response = {\n      id,\n      jsonrpc: \"2.0\",\n      error: {\n        message: \"User rejected methods.\",\n        code: 5002\n      }\n    };\n    return _classPrivateFieldGet(this, _wcWallet$1)?.respondSessionRequest({\n      topic,\n      response\n    });\n  }\n  getActiveSessions() {\n    if (!_classPrivateFieldGet(this, _wcWallet$1)) {\n      throw new Error(\"Please, init the wallet before getting sessions.\");\n    }\n    const sessions = _classPrivateFieldGet(this, _wcWallet$1).getActiveSessions();\n    const sessionKeys = Object.keys(sessions);\n    if (!sessions || sessionKeys.length === 0) {\n      return [];\n    }\n    const thisSessions = [];\n    for (const sessionKey of sessionKeys) {\n      const session = sessions[sessionKey];\n      if (session) {\n        const topic = session.topic;\n        const peerMeta = session.peer.metadata;\n        thisSessions.push({\n          topic,\n          peer: {\n            metadata: peerMeta\n          }\n        });\n      }\n    }\n    return thisSessions;\n  }\n  disconnectSession() {\n    if (!_classPrivateFieldGet(this, _wcWallet$1)) {\n      throw new Error(\"Please, init the wallet before disconnecting sessions.\");\n    }\n    if (!_classPrivateFieldGet(this, _session)) {\n      return Promise.resolve();\n    }\n    const params = {\n      topic: _classPrivateFieldGet(this, _session).topic,\n      reason: {\n        message: \"User disconnected.\",\n        code: 6000\n      }\n    };\n    return _classPrivateFieldGet(this, _wcWallet$1)?.disconnectSession(params);\n  }\n}\nfunction _setupWalletConnectEventsListeners2$1() {\n  if (!_classPrivateFieldGet(this, _wcWallet$1)) {\n    throw new Error(\"Please, init the wallet before making session requests.\");\n  }\n  _classPrivateFieldGet(this, _wcWallet$1).on(\"session_proposal\", proposal => {\n    _classPrivateFieldSet(this, _activeProposal, proposal);\n    this.emit(\"session_proposal\", {\n      proposer: {\n        metadata: proposal.params.proposer.metadata\n      }\n    });\n  });\n  _classPrivateFieldGet(this, _wcWallet$1).on(\"session_delete\", session => {\n    _classPrivateFieldSet(this, _session, undefined);\n    _classPrivateFieldSet(this, _activeProposal, undefined);\n    this.emit(\"session_delete\", {\n      topic: session.topic\n    });\n  });\n  _classPrivateFieldGet(this, _wcWallet$1).on(\"session_request\", async requestEvent => {\n    if (!_classPrivateFieldGet(this, _session)) {\n      return;\n    }\n    const {\n      params: requestParams\n    } = requestEvent;\n    const {\n      request\n    } = requestParams;\n    const {\n      params\n    } = request;\n    switch (request.method) {\n      case EIP155_SIGNING_METHODS.ETH_SIGN:\n      case EIP155_SIGNING_METHODS.PERSONAL_SIGN:\n        _classPrivateFieldSet(this, _activeRequestEvent, requestEvent);\n        const message = params[0];\n        const decodedMessage = new TextDecoder().decode(utils.arrayify(message));\n        const paramsCopy = [...params];\n        paramsCopy[0] = decodedMessage;\n        this.emit(\"session_request\", {\n          topic: _classPrivateFieldGet(this, _session).topic,\n          params: paramsCopy,\n          peer: {\n            metadata: _classPrivateFieldGet(this, _session).peer.metadata\n          },\n          method: request.method\n        });\n        return;\n      case EIP155_SIGNING_METHODS.ETH_SEND_TRANSACTION:\n      case EIP155_SIGNING_METHODS.ETH_SIGN_TRANSACTION:\n        _classPrivateFieldSet(this, _activeRequestEvent, requestEvent);\n        this.emit(\"session_request\", {\n          topic: _classPrivateFieldGet(this, _session).topic,\n          params: requestEvent.params.request.params,\n          peer: {\n            metadata: _classPrivateFieldGet(this, _session).peer.metadata\n          },\n          method: request.method\n        });\n        return;\n      default:\n        throw new Error(`WCV2.Method not supported: ${request.method}`);\n    }\n  });\n}\nfunction _getSignParamsMessage2(params) {\n  const message = params.filter(p => !utils.isAddress(p))[0] || \"\"; // TODO: handle empty message\n\n  if (utils.isHexString(message)) {\n    return utils.toUtf8String(message);\n  }\n  return message;\n}\nclass NoOpWalletConnectHandler extends WalletConnectHandler {\n  init() {\n    return Promise.resolve();\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  connectApp(uri) {\n    return Promise.resolve();\n  }\n  approveSession(\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  wallet) {\n    return Promise.resolve();\n  }\n  rejectSession() {\n    return Promise.resolve();\n  }\n  approveEIP155Request(\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  wallet) {\n    return Promise.resolve();\n  }\n  rejectEIP155Request() {\n    return Promise.resolve();\n  }\n  getActiveSessions() {\n    return [];\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  disconnectSession() {\n    return Promise.resolve();\n  }\n}\nconst sdkCache = new Map();\nfunction getSDK(chain) {\n  const cached = sdkCache.get(chain);\n  if (cached) {\n    return cached;\n  }\n  const sdk = new ThirdwebSDK(chain);\n  sdkCache.set(chain, sdk);\n  return sdk;\n}\n\n/**\n * Get all the signers added to the given smart wallet (excluding owner)\n * @param chain\n * @param factoryAddress\n * @param smartWalletAddress\n * @returns\n */\nasync function getAllSigners(chain, factoryAddress, smartWalletAddress) {\n  const readOnlySDK = getSDK(chain);\n  const factoryContract = await readOnlySDK.getContract(factoryAddress);\n  const signers = await factoryContract.call(\"getSignersOfAccount\", [smartWalletAddress]);\n  return signers;\n}\n\n/**\n * Get all the smart wallets associated with a personal wallet address\n * @param chain\n * @param factoryAddress\n * @param personalWalletAddress\n * @returns\n */\nasync function getAllSmartWallets(chain, factoryAddress, personalWalletAddress) {\n  const readOnlySDK = getSDK(chain);\n  const factoryContract = await readOnlySDK.getContract(factoryAddress);\n  const ownedAccount = await getSmartWalletAddress(chain, factoryAddress, personalWalletAddress);\n  const accessibleAccounts = await factoryContract.call(\"getAccountsOfSigner\", [personalWalletAddress]);\n  return {\n    owned: ownedAccount,\n    hasSignerRole: accessibleAccounts\n  };\n}\n\n/**\n * Check if a smart wallet is deployed for a given personal wallet address\n * @param chain\n * @param factoryAddress\n * @param personalWalletAddress\n * @returns\n */\nasync function isSmartWalletDeployed(chain, factoryAddress, personalWalletAddress) {\n  const readOnlySDK = getSDK(chain);\n  const factoryContract = await readOnlySDK.getContract(factoryAddress);\n  const accountAddress = await factoryContract.call(\"getAddress\", [personalWalletAddress]);\n  const isDeployed = await isContractDeployed(accountAddress, readOnlySDK.getProvider());\n  return isDeployed;\n}\n\n/**\n * Get the associated smart wallet address for a given personal wallet address\n * @param chain\n * @param factoryAddress\n * @param personalWalletAddress\n * @returns\n */\nasync function getSmartWalletAddress(chain, factoryAddress, personalWalletAddress) {\n  const readOnlySDK = getSDK(chain);\n  const factoryContract = await readOnlySDK.getContract(factoryAddress);\n  const accountAddress = await factoryContract.call(\"getAddress\", [personalWalletAddress]);\n  return accountAddress;\n}\nvar _wcWallet = /*#__PURE__*/new WeakMap();\nvar _setupWalletConnectEventsListeners = /*#__PURE__*/new WeakSet();\nclass SmartWallet extends AbstractClientWallet {\n  get walletName() {\n    return \"Smart Wallet\";\n  }\n  constructor(options) {\n    super(SmartWallet.id, {\n      ...options\n    });\n    _classPrivateMethodInitSpec(this, _setupWalletConnectEventsListeners);\n    _defineProperty(this, \"enableConnectApp\", false);\n    _classPrivateFieldInitSpec(this, _wcWallet, {\n      writable: true,\n      value: void 0\n    });\n    this.enableConnectApp = options?.enableConnectApp || false;\n    _classPrivateFieldSet(this, _wcWallet, this.enableConnectApp ? new WalletConnectV2Handler({\n      walletConnectWalletMetadata: options?.walletConnectWalletMetadata,\n      walletConenctV2ProjectId: options?.walletConenctV2ProjectId,\n      walletConnectV2RelayUrl: options?.walletConnectV2RelayUrl\n    }) : new NoOpWalletConnectHandler());\n  }\n  async getConnector() {\n    if (!this.connector) {\n      if (this.enableConnectApp) {\n        await _classPrivateFieldGet(this, _wcWallet).init();\n        _classPrivateMethodGet(this, _setupWalletConnectEventsListeners, _setupWalletConnectEventsListeners2).call(this);\n      }\n      const {\n        SmartWalletConnector\n      } = await import('../evm/connectors/smart-wallet/dist/thirdweb-dev-wallets-evm-connectors-smart-wallet.browser.esm.js');\n      this.connector = new SmartWalletConnector(this.options);\n    }\n    return this.connector;\n  }\n  getPersonalWallet() {\n    return this.connector?.personalWallet;\n  }\n\n  /**\n   * Check whether the connected signer can execute a given transaction using the smart wallet.\n   * @param transaction the transaction to execute using the smart wallet.\n   * @returns whether the connected signer can execute the transaction using the smart wallet.\n   */\n  async hasPermissionToExecute(transaction) {\n    const connector = await this.getConnector();\n    return connector.hasPermissionToExecute(transaction);\n  }\n\n  /**\n   * Execute a single transaction\n   * @param transactions\n   * @returns the transaction receipt\n   */\n  async execute(transaction) {\n    const connector = await this.getConnector();\n    return connector.execute(transaction);\n  }\n\n  /**\n   * Execute multiple transactions in a single batch\n   * @param transactions\n   * @returns the transaction receipt\n   */\n  async executeBatch(transactions) {\n    const connector = await this.getConnector();\n    return connector.executeBatch(transactions);\n  }\n\n  /**\n   * Manually deploy the smart wallet contract. If already deployed this will throw an error.\n   * Note that this is not necessary as the smart wallet will be deployed automatically on the first transaction the user makes.\n   * @returns the transaction receipt\n   */\n  async deploy() {\n    const connector = await this.getConnector();\n    return connector.deploy();\n  }\n\n  /**\n   * Manually deploy the smart wallet contract. If already deployed this will do nothing.\n   * Note that this is not necessary as the smart wallet will be deployed automatically on the first transaction the user makes.\n   * @returns the transaction receipt\n   */\n  async deployIfNeeded() {\n    const connector = await this.getConnector();\n    return connector.deployIfNeeded();\n  }\n\n  /**\n   * Check if the smart wallet contract is deployed\n   * @returns true if the smart wallet contract is deployed\n   */\n  async isDeployed() {\n    const connector = await this.getConnector();\n    return connector.isDeployed();\n  }\n\n  /**\n   * Create and add a session key to the smart wallet.\n   * @param keyAddress the address of the session key to add.\n   * @param permissions the permissions to grant to the session key.\n   */\n  async createSessionKey(keyAddress, permissions) {\n    const connector = await this.getConnector();\n    return connector.grantPermissions(keyAddress, permissions);\n  }\n\n  /**\n   * Remove a session key from the smart wallet.\n   * @param keyAddress the address of the session key to remove.\n   */\n  async revokeSessionKey(keyAddress) {\n    const connector = await this.getConnector();\n    return connector.revokePermissions(keyAddress);\n  }\n\n  /**\n   * Add another admin to the smart wallet.\n   * @param adminAddress the address of the admin to add.\n   */\n  async addAdmin(adminAddress) {\n    const connector = await this.getConnector();\n    return connector.addAdmin(adminAddress);\n  }\n\n  /**\n   * Remove an admin from the smart wallet.\n   * @param adminAddress the address of the admin to remove.\n   */\n  async removeAdmin(adminAddress) {\n    const connector = await this.getConnector();\n    return connector.removeAdmin(adminAddress);\n  }\n\n  /**\n   * Get all the admins and session keys active on the smart wallet.\n   */\n  async getAllActiveSigners() {\n    const connector = await this.getConnector();\n    return connector.getAllActiveSigners();\n  }\n\n  /**\n   * Get the underlying account contract of the smart wallet.\n   * @returns the account contract of the smart wallet.\n   */\n  async getAccountContract() {\n    const connector = await this.getConnector();\n    return connector.getAccountContract();\n  }\n\n  /**\n   * Get the underlying account factory contract of the smart wallet.\n   * @returns the account factory contract.\n   */\n  async getFactoryContract() {\n    const connector = await this.getConnector();\n    return connector.getFactoryContract();\n  }\n  autoConnect(params) {\n    return this.connect(params);\n  }\n\n  // wcv2\n  async connectApp(uri) {\n    if (!this.enableConnectApp) {\n      throw new Error(\"enableConnectApp is set to false in this wallet config\");\n    }\n    _classPrivateFieldGet(this, _wcWallet)?.connectApp(uri);\n  }\n  async approveSession() {\n    await _classPrivateFieldGet(this, _wcWallet).approveSession(this);\n    this.emit(\"message\", {\n      type: \"session_approved\"\n    });\n  }\n  rejectSession() {\n    return _classPrivateFieldGet(this, _wcWallet).rejectSession();\n  }\n  approveRequest() {\n    return _classPrivateFieldGet(this, _wcWallet).approveEIP155Request(this);\n  }\n  rejectRequest() {\n    return _classPrivateFieldGet(this, _wcWallet).rejectEIP155Request();\n  }\n  getActiveSessions() {\n    if (!_classPrivateFieldGet(this, _wcWallet)) {\n      throw new Error(\"Please, init the wallet before making session requests.\");\n    }\n    return _classPrivateFieldGet(this, _wcWallet).getActiveSessions();\n  }\n  disconnectSession() {\n    return _classPrivateFieldGet(this, _wcWallet)?.disconnectSession();\n  }\n  isWCReceiverEnabled() {\n    return this.enableConnectApp;\n  }\n}\nfunction _setupWalletConnectEventsListeners2() {\n  if (!_classPrivateFieldGet(this, _wcWallet)) {\n    throw new Error(\"Please, init the wallet before making session requests.\");\n  }\n  _classPrivateFieldGet(this, _wcWallet).on(\"session_proposal\", proposal => {\n    this.emit(\"message\", {\n      type: \"session_proposal\",\n      data: proposal\n    });\n  });\n  _classPrivateFieldGet(this, _wcWallet).on(\"session_delete\", () => {\n    this.emit(\"message\", {\n      type: \"session_delete\"\n    });\n  });\n  _classPrivateFieldGet(this, _wcWallet).on(\"switch_chain\", request => {\n    const chainId = request.params[0].chainId;\n    this.emit(\"message\", {\n      type: \"switch_chain\",\n      data: {\n        chainId\n      }\n    });\n    _classPrivateFieldGet(this, _wcWallet).disconnectSession();\n  });\n  _classPrivateFieldGet(this, _wcWallet).on(\"session_request\", request => {\n    this.emit(\"message\", {\n      type: \"session_request\",\n      data: request\n    });\n  });\n}\n_defineProperty(SmartWallet, \"meta\", {\n  name: \"Smart Wallet\",\n  iconURL: \"ipfs://QmeAJVqn17aDNQhjEU3kcWVZCFBrfta8LzaDGkS8Egdiyk/smart-wallet.svg\"\n});\n_defineProperty(SmartWallet, \"id\", walletIds.smartWallet);\nexport { SmartWallet as S, WalletConnectV2Handler as W, WalletConnectHandler as a, getAllSmartWallets as b, getSmartWalletAddress as c, getAllSigners as g, isSmartWalletDeployed as i };","map":{"version":3,"names":["_","_classPrivateMethodInitSpec","a","_classPrivateMethodGet","_classPrivateFieldInitSpec","_classPrivateFieldSet","b","_classPrivateFieldGet","_defineProperty","AbstractClientWallet","w","walletIds","Core","Web3Wallet","utils","EventEmitter","T","TW_WC_PROJECT_ID","W","WC_RELAY_URL","E","EIP155_SIGNING_METHODS","formatJsonRpcResult","isContractDeployed","ThirdwebSDK","WalletConnectHandler","_core","WeakMap","_wcWallet$1","_session","_wcMetadata","_activeProposal","_activeRequestEvent","_setupWalletConnectEventsListeners$1","WeakSet","_getSignParamsMessage","WalletConnectV2Handler","constructor","options","writable","value","walletConnectWalletMetadata","name","description","url","icons","projectId","walletConenctV2ProjectId","relayUrl","walletConnectV2RelayUrl","init","core","metadata","sessions","getActiveSessions","keys","Object","_setupWalletConnectEventsListeners2$1","call","connectApp","wcUri","Error","pairing","pair","uri","approveSession","wallet","account","getAddress","id","params","requiredNamespaces","relays","namespaces","forEach","key","accounts","namespace","chains","map","chain","push","methods","events","relayProtocol","protocol","emit","rejectSession","reason","message","code","approveEIP155Request","topic","request","response","method","PERSONAL_SIGN","ETH_SIGN","_getSignParamsMessage2","signedMessage","signMessage","ETH_SEND_TRANSACTION","signer","getSigner","sendTransaction","tx","transactionHash","wait","ETH_SIGN_TRANSACTION","signerSign","signTransaction","signature","error","jsonrpc","respondSessionRequest","rejectEIP155Request","sessionKeys","length","thisSessions","sessionKey","session","peerMeta","peer","disconnectSession","Promise","resolve","on","proposal","proposer","undefined","requestEvent","requestParams","decodedMessage","TextDecoder","decode","arrayify","paramsCopy","filter","p","isAddress","isHexString","toUtf8String","NoOpWalletConnectHandler","sdkCache","Map","getSDK","cached","get","sdk","set","getAllSigners","factoryAddress","smartWalletAddress","readOnlySDK","factoryContract","getContract","signers","getAllSmartWallets","personalWalletAddress","ownedAccount","getSmartWalletAddress","accessibleAccounts","owned","hasSignerRole","isSmartWalletDeployed","accountAddress","isDeployed","getProvider","_wcWallet","_setupWalletConnectEventsListeners","SmartWallet","walletName","enableConnectApp","getConnector","connector","_setupWalletConnectEventsListeners2","SmartWalletConnector","getPersonalWallet","personalWallet","hasPermissionToExecute","transaction","execute","executeBatch","transactions","deploy","deployIfNeeded","createSessionKey","keyAddress","permissions","grantPermissions","revokeSessionKey","revokePermissions","addAdmin","adminAddress","removeAdmin","getAllActiveSigners","getAccountContract","getFactoryContract","autoConnect","connect","type","approveRequest","rejectRequest","isWCReceiverEnabled","data","chainId","iconURL","smartWallet","S","c","g","i"],"sources":["C:/Misc/Documents/Career/FinTech/BlockChain/FrontEnd/buildspace-dao-starter/node_modules/@thirdweb-dev/wallets/dist/smart-wallet-f5e628ca.browser.esm.js"],"sourcesContent":["import { _ as _classPrivateMethodInitSpec, a as _classPrivateMethodGet } from './classPrivateMethodGet-ea199cc3.browser.esm.js';\nimport { _ as _classPrivateFieldInitSpec, a as _classPrivateFieldSet, b as _classPrivateFieldGet } from './classPrivateFieldSet-a5db7c83.browser.esm.js';\nimport { _ as _defineProperty } from './defineProperty-c8ecdc07.browser.esm.js';\nimport { a as AbstractClientWallet } from './base-402f7b12.browser.esm.js';\nimport { w as walletIds } from './walletIds-a64268ca.browser.esm.js';\nimport { Core } from '@walletconnect/core';\nimport { Web3Wallet } from '@walletconnect/web3wallet';\nimport { utils } from 'ethers';\nimport EventEmitter from 'eventemitter3';\nimport { T as TW_WC_PROJECT_ID, W as WC_RELAY_URL, E as EIP155_SIGNING_METHODS } from './wc-c6a6a61c.browser.esm.js';\nimport { formatJsonRpcResult } from '@walletconnect/jsonrpc-utils';\nimport { isContractDeployed, ThirdwebSDK } from '@thirdweb-dev/sdk';\n\n// connect dapp support through wcv2 protocol\n\nclass WalletConnectHandler extends EventEmitter {}\n\nvar _core = /*#__PURE__*/new WeakMap();\nvar _wcWallet$1 = /*#__PURE__*/new WeakMap();\nvar _session = /*#__PURE__*/new WeakMap();\nvar _wcMetadata = /*#__PURE__*/new WeakMap();\nvar _activeProposal = /*#__PURE__*/new WeakMap();\nvar _activeRequestEvent = /*#__PURE__*/new WeakMap();\nvar _setupWalletConnectEventsListeners$1 = /*#__PURE__*/new WeakSet();\nvar _getSignParamsMessage = /*#__PURE__*/new WeakSet();\nclass WalletConnectV2Handler extends WalletConnectHandler {\n  constructor(options) {\n    super();\n    /**\n     * Gets message from various signing request methods by filtering out\n     * a value that is not an address (thus is a message).\n     * If it is a hex string, it gets converted to utf8 string\n     */\n    _classPrivateMethodInitSpec(this, _getSignParamsMessage);\n    _classPrivateMethodInitSpec(this, _setupWalletConnectEventsListeners$1);\n    _classPrivateFieldInitSpec(this, _core, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _wcWallet$1, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _session, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _wcMetadata, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _activeProposal, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _activeRequestEvent, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldSet(this, _wcMetadata, options?.walletConnectWalletMetadata || {\n      name: \"Thirdweb Smart Wallet\",\n      description: \"Thirdweb Smart Wallet\",\n      url: \"https://thirdweb.com\",\n      icons: [\"https://thirdweb.com/favicon.ico\"]\n    });\n    _classPrivateFieldSet(this, _core, new Core({\n      projectId: options?.walletConenctV2ProjectId || TW_WC_PROJECT_ID,\n      relayUrl: options?.walletConnectV2RelayUrl || WC_RELAY_URL\n    }));\n  }\n  async init() {\n    _classPrivateFieldSet(this, _wcWallet$1, await Web3Wallet.init({\n      core: _classPrivateFieldGet(this, _core),\n      metadata: _classPrivateFieldGet(this, _wcMetadata)\n    }));\n    const sessions = _classPrivateFieldGet(this, _wcWallet$1).getActiveSessions();\n    const keys = Object.keys(sessions);\n    if (keys[0]) {\n      _classPrivateFieldSet(this, _session, sessions[keys[0]]);\n    }\n    _classPrivateMethodGet(this, _setupWalletConnectEventsListeners$1, _setupWalletConnectEventsListeners2$1).call(this);\n  }\n  async connectApp(wcUri) {\n    if (!_classPrivateFieldGet(this, _wcWallet$1)) {\n      throw new Error(\"Please, init the wallet before connecting an app.\");\n    }\n    await _classPrivateFieldGet(this, _wcWallet$1).core.pairing.pair({\n      uri: wcUri\n    });\n  }\n  async approveSession(wallet) {\n    if (!_classPrivateFieldGet(this, _wcWallet$1)) {\n      throw new Error(\"Please, init the wallet before making session requests.\");\n    }\n    if (!_classPrivateFieldGet(this, _activeProposal)) {\n      throw new Error(\"Please, pass a valid proposal.\");\n    }\n    const account = await wallet.getAddress();\n    const {\n      id,\n      params\n    } = _classPrivateFieldGet(this, _activeProposal);\n    const {\n      requiredNamespaces,\n      relays\n    } = params;\n    const namespaces = {};\n    Object.keys(requiredNamespaces).forEach(key => {\n      const accounts = [];\n      const namespace = requiredNamespaces[key];\n      if (namespace) {\n        namespace.chains?.map(chain => {\n          accounts.push(`${chain}:${account}`);\n        });\n        namespaces[key] = {\n          accounts,\n          methods: namespace.methods,\n          events: namespace.events\n        };\n      }\n    });\n    _classPrivateFieldSet(this, _session, await _classPrivateFieldGet(this, _wcWallet$1).approveSession({\n      id,\n      relayProtocol: relays[0]?.protocol,\n      namespaces\n    }));\n    this.emit(\"session_approved\");\n  }\n  async rejectSession() {\n    if (!_classPrivateFieldGet(this, _wcWallet$1)) {\n      throw new Error(\"Please, init the wallet before making session requests.\");\n    }\n    if (!_classPrivateFieldGet(this, _activeProposal)) {\n      throw new Error(\"Please, pass a valid proposal.\");\n    }\n    const {\n      id\n    } = _classPrivateFieldGet(this, _activeProposal);\n    await _classPrivateFieldGet(this, _wcWallet$1).rejectSession({\n      id,\n      reason: {\n        message: \"User rejected methods.\",\n        code: 5002\n      }\n    });\n  }\n  async approveEIP155Request(wallet) {\n    if (!_classPrivateFieldGet(this, _activeRequestEvent)) {\n      return;\n    }\n    const {\n      topic,\n      params,\n      id\n    } = _classPrivateFieldGet(this, _activeRequestEvent);\n    const {\n      request\n    } = params;\n    let response;\n    switch (request.method) {\n      case EIP155_SIGNING_METHODS.PERSONAL_SIGN:\n      case EIP155_SIGNING_METHODS.ETH_SIGN:\n        const message = _classPrivateMethodGet(this, _getSignParamsMessage, _getSignParamsMessage2).call(this, request.params);\n        const signedMessage = await wallet.signMessage(message || \"\"); // TODO: handle empty message\n\n        response = formatJsonRpcResult(id, signedMessage);\n        break;\n      // case EIP155_SIGNING_METHODS.ETH_SIGN_TYPED_DATA:\n      // case EIP155_SIGNING_METHODS.ETH_SIGN_TYPED_DATA_V3:\n      // case EIP155_SIGNING_METHODS.ETH_SIGN_TYPED_DATA_V4:\n      //   const {\n      //     domain,\n      //     types,\n      //     message: data,\n      //   } = getSignTypedDataParamsData(request.params);\n      //   // https://github.com/ethers-io/ethers.js/issues/687#issuecomment-714069471\n      //   delete types.EIP712Domain;\n      //   const signedData = await wallet._signTypedData(domain, types, data);\n      //   return formatJsonRpcResult(id, signedData);\n      case EIP155_SIGNING_METHODS.ETH_SEND_TRANSACTION:\n        const signer = await wallet.getSigner();\n        const sendTransaction = request.params[0];\n        const tx = await signer.sendTransaction(sendTransaction);\n        const {\n          transactionHash\n        } = await tx.wait();\n        response = formatJsonRpcResult(id, transactionHash);\n        break;\n      case EIP155_SIGNING_METHODS.ETH_SIGN_TRANSACTION:\n        const signerSign = await wallet.getSigner();\n        const signTransaction = request.params[0];\n        const signature = await signerSign.signTransaction(signTransaction);\n        response = formatJsonRpcResult(id, signature);\n      default:\n        const error = {\n          id,\n          jsonrpc: \"2.0\",\n          error: {\n            message: \"Invalid event.\",\n            code: 1002\n          }\n        };\n        return _classPrivateFieldGet(this, _wcWallet$1)?.respondSessionRequest({\n          topic,\n          response: error\n        });\n    }\n    return _classPrivateFieldGet(this, _wcWallet$1)?.respondSessionRequest({\n      topic,\n      response\n    });\n  }\n  async rejectEIP155Request() {\n    if (!_classPrivateFieldGet(this, _activeRequestEvent)) {\n      return;\n    }\n    const {\n      topic,\n      id\n    } = _classPrivateFieldGet(this, _activeRequestEvent);\n    const response = {\n      id,\n      jsonrpc: \"2.0\",\n      error: {\n        message: \"User rejected methods.\",\n        code: 5002\n      }\n    };\n    return _classPrivateFieldGet(this, _wcWallet$1)?.respondSessionRequest({\n      topic,\n      response\n    });\n  }\n  getActiveSessions() {\n    if (!_classPrivateFieldGet(this, _wcWallet$1)) {\n      throw new Error(\"Please, init the wallet before getting sessions.\");\n    }\n    const sessions = _classPrivateFieldGet(this, _wcWallet$1).getActiveSessions();\n    const sessionKeys = Object.keys(sessions);\n    if (!sessions || sessionKeys.length === 0) {\n      return [];\n    }\n    const thisSessions = [];\n    for (const sessionKey of sessionKeys) {\n      const session = sessions[sessionKey];\n      if (session) {\n        const topic = session.topic;\n        const peerMeta = session.peer.metadata;\n        thisSessions.push({\n          topic,\n          peer: {\n            metadata: peerMeta\n          }\n        });\n      }\n    }\n    return thisSessions;\n  }\n  disconnectSession() {\n    if (!_classPrivateFieldGet(this, _wcWallet$1)) {\n      throw new Error(\"Please, init the wallet before disconnecting sessions.\");\n    }\n    if (!_classPrivateFieldGet(this, _session)) {\n      return Promise.resolve();\n    }\n    const params = {\n      topic: _classPrivateFieldGet(this, _session).topic,\n      reason: {\n        message: \"User disconnected.\",\n        code: 6000\n      }\n    };\n    return _classPrivateFieldGet(this, _wcWallet$1)?.disconnectSession(params);\n  }\n}\nfunction _setupWalletConnectEventsListeners2$1() {\n  if (!_classPrivateFieldGet(this, _wcWallet$1)) {\n    throw new Error(\"Please, init the wallet before making session requests.\");\n  }\n  _classPrivateFieldGet(this, _wcWallet$1).on(\"session_proposal\", proposal => {\n    _classPrivateFieldSet(this, _activeProposal, proposal);\n    this.emit(\"session_proposal\", {\n      proposer: {\n        metadata: proposal.params.proposer.metadata\n      }\n    });\n  });\n  _classPrivateFieldGet(this, _wcWallet$1).on(\"session_delete\", session => {\n    _classPrivateFieldSet(this, _session, undefined);\n    _classPrivateFieldSet(this, _activeProposal, undefined);\n    this.emit(\"session_delete\", {\n      topic: session.topic\n    });\n  });\n  _classPrivateFieldGet(this, _wcWallet$1).on(\"session_request\", async requestEvent => {\n    if (!_classPrivateFieldGet(this, _session)) {\n      return;\n    }\n    const {\n      params: requestParams\n    } = requestEvent;\n    const {\n      request\n    } = requestParams;\n    const {\n      params\n    } = request;\n    switch (request.method) {\n      case EIP155_SIGNING_METHODS.ETH_SIGN:\n      case EIP155_SIGNING_METHODS.PERSONAL_SIGN:\n        _classPrivateFieldSet(this, _activeRequestEvent, requestEvent);\n        const message = params[0];\n        const decodedMessage = new TextDecoder().decode(utils.arrayify(message));\n        const paramsCopy = [...params];\n        paramsCopy[0] = decodedMessage;\n        this.emit(\"session_request\", {\n          topic: _classPrivateFieldGet(this, _session).topic,\n          params: paramsCopy,\n          peer: {\n            metadata: _classPrivateFieldGet(this, _session).peer.metadata\n          },\n          method: request.method\n        });\n        return;\n      case EIP155_SIGNING_METHODS.ETH_SEND_TRANSACTION:\n      case EIP155_SIGNING_METHODS.ETH_SIGN_TRANSACTION:\n        _classPrivateFieldSet(this, _activeRequestEvent, requestEvent);\n        this.emit(\"session_request\", {\n          topic: _classPrivateFieldGet(this, _session).topic,\n          params: requestEvent.params.request.params,\n          peer: {\n            metadata: _classPrivateFieldGet(this, _session).peer.metadata\n          },\n          method: request.method\n        });\n        return;\n      default:\n        throw new Error(`WCV2.Method not supported: ${request.method}`);\n    }\n  });\n}\nfunction _getSignParamsMessage2(params) {\n  const message = params.filter(p => !utils.isAddress(p))[0] || \"\"; // TODO: handle empty message\n\n  if (utils.isHexString(message)) {\n    return utils.toUtf8String(message);\n  }\n  return message;\n}\n\nclass NoOpWalletConnectHandler extends WalletConnectHandler {\n  init() {\n    return Promise.resolve();\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  connectApp(uri) {\n    return Promise.resolve();\n  }\n  approveSession(\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  wallet) {\n    return Promise.resolve();\n  }\n  rejectSession() {\n    return Promise.resolve();\n  }\n  approveEIP155Request(\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  wallet) {\n    return Promise.resolve();\n  }\n  rejectEIP155Request() {\n    return Promise.resolve();\n  }\n  getActiveSessions() {\n    return [];\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  disconnectSession() {\n    return Promise.resolve();\n  }\n}\n\nconst sdkCache = new Map();\nfunction getSDK(chain) {\n  const cached = sdkCache.get(chain);\n  if (cached) {\n    return cached;\n  }\n  const sdk = new ThirdwebSDK(chain);\n  sdkCache.set(chain, sdk);\n  return sdk;\n}\n\n/**\n * Get all the signers added to the given smart wallet (excluding owner)\n * @param chain\n * @param factoryAddress\n * @param smartWalletAddress\n * @returns\n */\nasync function getAllSigners(chain, factoryAddress, smartWalletAddress) {\n  const readOnlySDK = getSDK(chain);\n  const factoryContract = await readOnlySDK.getContract(factoryAddress);\n  const signers = await factoryContract.call(\"getSignersOfAccount\", [smartWalletAddress]);\n  return signers;\n}\n\n/**\n * Get all the smart wallets associated with a personal wallet address\n * @param chain\n * @param factoryAddress\n * @param personalWalletAddress\n * @returns\n */\nasync function getAllSmartWallets(chain, factoryAddress, personalWalletAddress) {\n  const readOnlySDK = getSDK(chain);\n  const factoryContract = await readOnlySDK.getContract(factoryAddress);\n  const ownedAccount = await getSmartWalletAddress(chain, factoryAddress, personalWalletAddress);\n  const accessibleAccounts = await factoryContract.call(\"getAccountsOfSigner\", [personalWalletAddress]);\n  return {\n    owned: ownedAccount,\n    hasSignerRole: accessibleAccounts\n  };\n}\n\n/**\n * Check if a smart wallet is deployed for a given personal wallet address\n * @param chain\n * @param factoryAddress\n * @param personalWalletAddress\n * @returns\n */\nasync function isSmartWalletDeployed(chain, factoryAddress, personalWalletAddress) {\n  const readOnlySDK = getSDK(chain);\n  const factoryContract = await readOnlySDK.getContract(factoryAddress);\n  const accountAddress = await factoryContract.call(\"getAddress\", [personalWalletAddress]);\n  const isDeployed = await isContractDeployed(accountAddress, readOnlySDK.getProvider());\n  return isDeployed;\n}\n\n/**\n * Get the associated smart wallet address for a given personal wallet address\n * @param chain\n * @param factoryAddress\n * @param personalWalletAddress\n * @returns\n */\nasync function getSmartWalletAddress(chain, factoryAddress, personalWalletAddress) {\n  const readOnlySDK = getSDK(chain);\n  const factoryContract = await readOnlySDK.getContract(factoryAddress);\n  const accountAddress = await factoryContract.call(\"getAddress\", [personalWalletAddress]);\n  return accountAddress;\n}\n\nvar _wcWallet = /*#__PURE__*/new WeakMap();\nvar _setupWalletConnectEventsListeners = /*#__PURE__*/new WeakSet();\nclass SmartWallet extends AbstractClientWallet {\n  get walletName() {\n    return \"Smart Wallet\";\n  }\n  constructor(options) {\n    super(SmartWallet.id, {\n      ...options\n    });\n    _classPrivateMethodInitSpec(this, _setupWalletConnectEventsListeners);\n    _defineProperty(this, \"enableConnectApp\", false);\n    _classPrivateFieldInitSpec(this, _wcWallet, {\n      writable: true,\n      value: void 0\n    });\n    this.enableConnectApp = options?.enableConnectApp || false;\n    _classPrivateFieldSet(this, _wcWallet, this.enableConnectApp ? new WalletConnectV2Handler({\n      walletConnectWalletMetadata: options?.walletConnectWalletMetadata,\n      walletConenctV2ProjectId: options?.walletConenctV2ProjectId,\n      walletConnectV2RelayUrl: options?.walletConnectV2RelayUrl\n    }) : new NoOpWalletConnectHandler());\n  }\n  async getConnector() {\n    if (!this.connector) {\n      if (this.enableConnectApp) {\n        await _classPrivateFieldGet(this, _wcWallet).init();\n        _classPrivateMethodGet(this, _setupWalletConnectEventsListeners, _setupWalletConnectEventsListeners2).call(this);\n      }\n      const {\n        SmartWalletConnector\n      } = await import('../evm/connectors/smart-wallet/dist/thirdweb-dev-wallets-evm-connectors-smart-wallet.browser.esm.js');\n      this.connector = new SmartWalletConnector(this.options);\n    }\n    return this.connector;\n  }\n  getPersonalWallet() {\n    return this.connector?.personalWallet;\n  }\n\n  /**\n   * Check whether the connected signer can execute a given transaction using the smart wallet.\n   * @param transaction the transaction to execute using the smart wallet.\n   * @returns whether the connected signer can execute the transaction using the smart wallet.\n   */\n  async hasPermissionToExecute(transaction) {\n    const connector = await this.getConnector();\n    return connector.hasPermissionToExecute(transaction);\n  }\n\n  /**\n   * Execute a single transaction\n   * @param transactions\n   * @returns the transaction receipt\n   */\n  async execute(transaction) {\n    const connector = await this.getConnector();\n    return connector.execute(transaction);\n  }\n\n  /**\n   * Execute multiple transactions in a single batch\n   * @param transactions\n   * @returns the transaction receipt\n   */\n  async executeBatch(transactions) {\n    const connector = await this.getConnector();\n    return connector.executeBatch(transactions);\n  }\n\n  /**\n   * Manually deploy the smart wallet contract. If already deployed this will throw an error.\n   * Note that this is not necessary as the smart wallet will be deployed automatically on the first transaction the user makes.\n   * @returns the transaction receipt\n   */\n  async deploy() {\n    const connector = await this.getConnector();\n    return connector.deploy();\n  }\n\n  /**\n   * Manually deploy the smart wallet contract. If already deployed this will do nothing.\n   * Note that this is not necessary as the smart wallet will be deployed automatically on the first transaction the user makes.\n   * @returns the transaction receipt\n   */\n  async deployIfNeeded() {\n    const connector = await this.getConnector();\n    return connector.deployIfNeeded();\n  }\n\n  /**\n   * Check if the smart wallet contract is deployed\n   * @returns true if the smart wallet contract is deployed\n   */\n  async isDeployed() {\n    const connector = await this.getConnector();\n    return connector.isDeployed();\n  }\n\n  /**\n   * Create and add a session key to the smart wallet.\n   * @param keyAddress the address of the session key to add.\n   * @param permissions the permissions to grant to the session key.\n   */\n  async createSessionKey(keyAddress, permissions) {\n    const connector = await this.getConnector();\n    return connector.grantPermissions(keyAddress, permissions);\n  }\n\n  /**\n   * Remove a session key from the smart wallet.\n   * @param keyAddress the address of the session key to remove.\n   */\n  async revokeSessionKey(keyAddress) {\n    const connector = await this.getConnector();\n    return connector.revokePermissions(keyAddress);\n  }\n\n  /**\n   * Add another admin to the smart wallet.\n   * @param adminAddress the address of the admin to add.\n   */\n  async addAdmin(adminAddress) {\n    const connector = await this.getConnector();\n    return connector.addAdmin(adminAddress);\n  }\n\n  /**\n   * Remove an admin from the smart wallet.\n   * @param adminAddress the address of the admin to remove.\n   */\n  async removeAdmin(adminAddress) {\n    const connector = await this.getConnector();\n    return connector.removeAdmin(adminAddress);\n  }\n\n  /**\n   * Get all the admins and session keys active on the smart wallet.\n   */\n  async getAllActiveSigners() {\n    const connector = await this.getConnector();\n    return connector.getAllActiveSigners();\n  }\n\n  /**\n   * Get the underlying account contract of the smart wallet.\n   * @returns the account contract of the smart wallet.\n   */\n  async getAccountContract() {\n    const connector = await this.getConnector();\n    return connector.getAccountContract();\n  }\n\n  /**\n   * Get the underlying account factory contract of the smart wallet.\n   * @returns the account factory contract.\n   */\n  async getFactoryContract() {\n    const connector = await this.getConnector();\n    return connector.getFactoryContract();\n  }\n  autoConnect(params) {\n    return this.connect(params);\n  }\n\n  // wcv2\n  async connectApp(uri) {\n    if (!this.enableConnectApp) {\n      throw new Error(\"enableConnectApp is set to false in this wallet config\");\n    }\n    _classPrivateFieldGet(this, _wcWallet)?.connectApp(uri);\n  }\n  async approveSession() {\n    await _classPrivateFieldGet(this, _wcWallet).approveSession(this);\n    this.emit(\"message\", {\n      type: \"session_approved\"\n    });\n  }\n  rejectSession() {\n    return _classPrivateFieldGet(this, _wcWallet).rejectSession();\n  }\n  approveRequest() {\n    return _classPrivateFieldGet(this, _wcWallet).approveEIP155Request(this);\n  }\n  rejectRequest() {\n    return _classPrivateFieldGet(this, _wcWallet).rejectEIP155Request();\n  }\n  getActiveSessions() {\n    if (!_classPrivateFieldGet(this, _wcWallet)) {\n      throw new Error(\"Please, init the wallet before making session requests.\");\n    }\n    return _classPrivateFieldGet(this, _wcWallet).getActiveSessions();\n  }\n  disconnectSession() {\n    return _classPrivateFieldGet(this, _wcWallet)?.disconnectSession();\n  }\n  isWCReceiverEnabled() {\n    return this.enableConnectApp;\n  }\n}\nfunction _setupWalletConnectEventsListeners2() {\n  if (!_classPrivateFieldGet(this, _wcWallet)) {\n    throw new Error(\"Please, init the wallet before making session requests.\");\n  }\n  _classPrivateFieldGet(this, _wcWallet).on(\"session_proposal\", proposal => {\n    this.emit(\"message\", {\n      type: \"session_proposal\",\n      data: proposal\n    });\n  });\n  _classPrivateFieldGet(this, _wcWallet).on(\"session_delete\", () => {\n    this.emit(\"message\", {\n      type: \"session_delete\"\n    });\n  });\n  _classPrivateFieldGet(this, _wcWallet).on(\"switch_chain\", request => {\n    const chainId = request.params[0].chainId;\n    this.emit(\"message\", {\n      type: \"switch_chain\",\n      data: {\n        chainId\n      }\n    });\n    _classPrivateFieldGet(this, _wcWallet).disconnectSession();\n  });\n  _classPrivateFieldGet(this, _wcWallet).on(\"session_request\", request => {\n    this.emit(\"message\", {\n      type: \"session_request\",\n      data: request\n    });\n  });\n}\n_defineProperty(SmartWallet, \"meta\", {\n  name: \"Smart Wallet\",\n  iconURL: \"ipfs://QmeAJVqn17aDNQhjEU3kcWVZCFBrfta8LzaDGkS8Egdiyk/smart-wallet.svg\"\n});\n_defineProperty(SmartWallet, \"id\", walletIds.smartWallet);\n\nexport { SmartWallet as S, WalletConnectV2Handler as W, WalletConnectHandler as a, getAllSmartWallets as b, getSmartWalletAddress as c, getAllSigners as g, isSmartWalletDeployed as i };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}