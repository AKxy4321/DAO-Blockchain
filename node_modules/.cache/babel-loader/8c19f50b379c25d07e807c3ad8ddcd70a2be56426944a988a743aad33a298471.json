{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Web3Provider = exports.Provider = void 0;\nconst ethers_1 = require(\"ethers\");\nvar Formatter = ethers_1.providers.Formatter;\nconst web_1 = require(\"@ethersproject/web\");\nconst typechain_1 = require(\"../typechain\");\nconst types_1 = require(\"./types\");\nconst utils_1 = require(\"./utils\");\nconst signer_1 = require(\"./signer\");\nlet defaultFormatter = null;\nclass Provider extends ethers_1.ethers.providers.JsonRpcProvider {\n  async getTransactionReceipt(transactionHash) {\n    await this.getNetwork();\n    transactionHash = await transactionHash;\n    const params = {\n      transactionHash: this.formatter.hash(transactionHash, true)\n    };\n    return (0, web_1.poll)(async () => {\n      const result = await this.perform('getTransactionReceipt', params);\n      if (result == null) {\n        if (this._emitted['t:' + transactionHash] == null) {\n          return null;\n        }\n        return undefined;\n      }\n      if (result.blockNumber == null && result.status != null && ethers_1.BigNumber.from(result.status).isZero()) {\n        // transaction is rejected in the state-keeper\n        return {\n          ...this.formatter.receipt({\n            ...result,\n            confirmations: 1,\n            blockNumber: 0,\n            blockHash: ethers_1.ethers.constants.HashZero\n          }),\n          blockNumber: null,\n          blockHash: null,\n          l1BatchNumber: null,\n          l1BatchTxIndex: null\n        };\n      }\n      if (result.blockHash == null) {\n        // receipt is not ready\n        return undefined;\n      } else {\n        const receipt = this.formatter.receipt(result);\n        if (receipt.blockNumber == null) {\n          receipt.confirmations = 0;\n        } else if (receipt.confirmations == null) {\n          const blockNumber = await this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n          // Add the confirmations using the fast block number (pessimistic)\n          let confirmations = blockNumber - receipt.blockNumber + 1;\n          if (confirmations <= 0) {\n            confirmations = 1;\n          }\n          receipt.confirmations = confirmations;\n        }\n        return receipt;\n      }\n    }, {\n      oncePoll: this\n    });\n  }\n  async getBlock(blockHashOrBlockTag) {\n    return this._getBlock(blockHashOrBlockTag, false);\n  }\n  async getBlockWithTransactions(blockHashOrBlockTag) {\n    return this._getBlock(blockHashOrBlockTag, true);\n  }\n  static getFormatter() {\n    if (defaultFormatter == null) {\n      defaultFormatter = new Formatter();\n      const number = defaultFormatter.number.bind(defaultFormatter);\n      const boolean = defaultFormatter.boolean.bind(defaultFormatter);\n      const hash = defaultFormatter.hash.bind(defaultFormatter);\n      const address = defaultFormatter.address.bind(defaultFormatter);\n      defaultFormatter.formats.receiptLog.l1BatchNumber = Formatter.allowNull(number);\n      defaultFormatter.formats.l2Tol1Log = {\n        blockNumber: number,\n        blockHash: hash,\n        l1BatchNumber: Formatter.allowNull(number),\n        transactionIndex: number,\n        shardId: number,\n        isService: boolean,\n        sender: address,\n        key: hash,\n        value: hash,\n        transactionHash: hash,\n        logIndex: number\n      };\n      defaultFormatter.formats.receipt.l1BatchNumber = Formatter.allowNull(number);\n      defaultFormatter.formats.receipt.l1BatchTxIndex = Formatter.allowNull(number);\n      defaultFormatter.formats.receipt.l2ToL1Logs = Formatter.arrayOf(value => Formatter.check(defaultFormatter.formats.l2Tol1Log, value));\n      defaultFormatter.formats.block.l1BatchNumber = Formatter.allowNull(number);\n      defaultFormatter.formats.block.l1BatchTimestamp = Formatter.allowNull(number);\n      defaultFormatter.formats.blockWithTransactions.l1BatchNumber = Formatter.allowNull(number);\n      defaultFormatter.formats.blockWithTransactions.l1BatchTimestamp = Formatter.allowNull(number);\n      defaultFormatter.formats.transaction.l1BatchNumber = Formatter.allowNull(number);\n      defaultFormatter.formats.transaction.l1BatchTxIndex = Formatter.allowNull(number);\n      defaultFormatter.formats.filterLog.l1BatchNumber = Formatter.allowNull(number);\n    }\n    return defaultFormatter;\n  }\n  async getBalance(address, blockTag, tokenAddress) {\n    const tag = this.formatter.blockTag(blockTag);\n    if (tokenAddress == null || (0, utils_1.isETH)(tokenAddress)) {\n      // requesting ETH balance\n      return await super.getBalance(address, tag);\n    } else {\n      try {\n        let token = typechain_1.IERC20MetadataFactory.connect(tokenAddress, this);\n        return await token.balanceOf(address, {\n          blockTag: tag\n        });\n      } catch {\n        return ethers_1.BigNumber.from(0);\n      }\n    }\n  }\n  async l2TokenAddress(token) {\n    if (token == utils_1.ETH_ADDRESS) {\n      return utils_1.ETH_ADDRESS;\n    } else {\n      const erc20BridgeAddress = (await this.getDefaultBridgeAddresses()).erc20L2;\n      const erc20Bridge = typechain_1.IL2BridgeFactory.connect(erc20BridgeAddress, this);\n      return await erc20Bridge.l2TokenAddress(token);\n    }\n  }\n  async l1TokenAddress(token) {\n    if (token == utils_1.ETH_ADDRESS) {\n      return utils_1.ETH_ADDRESS;\n    } else {\n      const erc20BridgeAddress = (await this.getDefaultBridgeAddresses()).erc20L2;\n      const erc20Bridge = typechain_1.IL2BridgeFactory.connect(erc20BridgeAddress, this);\n      return await erc20Bridge.l1TokenAddress(token);\n    }\n  }\n  // This function is used when formatting requests for\n  // eth_call and eth_estimateGas. We override it here\n  // because we have extra stuff to serialize (customData).\n  // This function is for internal use only.\n  static hexlifyTransaction(transaction, allowExtra) {\n    var _a;\n    const result = ethers_1.ethers.providers.JsonRpcProvider.hexlifyTransaction(transaction, {\n      ...allowExtra,\n      customData: true,\n      from: true\n    });\n    if (transaction.customData == null) {\n      return result;\n    }\n    result.eip712Meta = {\n      gasPerPubdata: ethers_1.utils.hexValue((_a = transaction.customData.gasPerPubdata) !== null && _a !== void 0 ? _a : 0)\n    };\n    transaction.type = utils_1.EIP712_TX_TYPE;\n    if (transaction.customData.factoryDeps) {\n      // @ts-ignore\n      result.eip712Meta.factoryDeps = transaction.customData.factoryDeps.map(dep =>\n      // TODO (SMA-1605): we arraify instead of hexlifying because server expects Vec<u8>.\n      //  We should change deserialization there.\n      Array.from(ethers_1.utils.arrayify(dep)));\n    }\n    if (transaction.customData.paymasterParams) {\n      // @ts-ignore\n      result.eip712Meta.paymasterParams = {\n        paymaster: ethers_1.utils.hexlify(transaction.customData.paymasterParams.paymaster),\n        paymasterInput: Array.from(ethers_1.utils.arrayify(transaction.customData.paymasterParams.paymasterInput))\n      };\n    }\n    return result;\n  }\n  async estimateGas(transaction) {\n    await this.getNetwork();\n    const params = await ethers_1.utils.resolveProperties({\n      transaction: this._getTransactionRequest(transaction)\n    });\n    if (transaction.customData != null) {\n      // @ts-ignore\n      params.transaction.customData = transaction.customData;\n    }\n    const result = await this.perform('estimateGas', params);\n    try {\n      return ethers_1.BigNumber.from(result);\n    } catch (error) {\n      throw new Error(\"bad result from backend (estimateGas): \".concat(result));\n    }\n  }\n  async estimateGasL1(transaction) {\n    await this.getNetwork();\n    const params = await ethers_1.utils.resolveProperties({\n      transaction: this._getTransactionRequest(transaction)\n    });\n    if (transaction.customData != null) {\n      // @ts-ignore\n      params.transaction.customData = transaction.customData;\n    }\n    const result = await this.send('zks_estimateGasL1ToL2', [Provider.hexlifyTransaction(params.transaction, {\n      from: true\n    })]);\n    try {\n      return ethers_1.BigNumber.from(result);\n    } catch (error) {\n      throw new Error(\"bad result from backend (zks_estimateGasL1ToL2): \".concat(result));\n    }\n  }\n  async getGasPrice(token) {\n    const params = token ? [token] : [];\n    const price = await this.send('eth_gasPrice', params);\n    return ethers_1.BigNumber.from(price);\n  }\n  constructor(url, network) {\n    super(url, network);\n    this.pollingInterval = 500;\n    const blockTag = this.formatter.blockTag.bind(this.formatter);\n    this.formatter.blockTag = tag => {\n      if (tag == 'committed' || tag == 'finalized') {\n        return tag;\n      }\n      return blockTag(tag);\n    };\n    this.contractAddresses = {};\n    this.formatter.transaction = utils_1.parseTransaction;\n  }\n  async getMessageProof(blockNumber, sender, messageHash, logIndex) {\n    return await this.send('zks_getL2ToL1MsgProof', [ethers_1.BigNumber.from(blockNumber).toNumber(), sender, ethers_1.ethers.utils.hexlify(messageHash), logIndex]);\n  }\n  async getLogProof(txHash, index) {\n    return await this.send('zks_getL2ToL1LogProof', [ethers_1.ethers.utils.hexlify(txHash), index]);\n  }\n  async getL1BatchBlockRange(l1BatchNumber) {\n    const range = await this.send('zks_getL1BatchBlockRange', [l1BatchNumber]);\n    if (range == null) {\n      return null;\n    }\n    return [parseInt(range[0], 16), parseInt(range[1], 16)];\n  }\n  async getMainContractAddress() {\n    if (!this.contractAddresses.mainContract) {\n      this.contractAddresses.mainContract = await this.send('zks_getMainContract', []);\n    }\n    return this.contractAddresses.mainContract;\n  }\n  async getTestnetPaymasterAddress() {\n    // Unlike contract's addresses, the testnet paymaster is not cached, since it can be trivially changed\n    // on the fly by the server and should not be relied to be constant\n    return await this.send('zks_getTestnetPaymaster', []);\n  }\n  async getDefaultBridgeAddresses() {\n    if (!this.contractAddresses.erc20BridgeL1) {\n      let addresses = await this.send('zks_getBridgeContracts', []);\n      this.contractAddresses.erc20BridgeL1 = addresses.l1Erc20DefaultBridge;\n      this.contractAddresses.erc20BridgeL2 = addresses.l2Erc20DefaultBridge;\n    }\n    return {\n      erc20L1: this.contractAddresses.erc20BridgeL1,\n      erc20L2: this.contractAddresses.erc20BridgeL2\n    };\n  }\n  async getConfirmedTokens() {\n    let start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 255;\n    const tokens = await this.send('zks_getConfirmedTokens', [start, limit]);\n    return tokens.map(token => ({\n      address: token.l2Address,\n      ...token\n    }));\n  }\n  async getTokenPrice(token) {\n    return await this.send('zks_getTokenPrice', [token]);\n  }\n  async getAllAccountBalances(address) {\n    let balances = await this.send('zks_getAllAccountBalances', [address]);\n    for (let token in balances) {\n      balances[token] = ethers_1.BigNumber.from(balances[token]);\n    }\n    return balances;\n  }\n  async l1ChainId() {\n    const res = await this.send('zks_L1ChainId', []);\n    return ethers_1.BigNumber.from(res).toNumber();\n  }\n  async getL1BatchNumber() {\n    const number = await this.send('zks_L1BatchNumber', []);\n    return ethers_1.BigNumber.from(number).toNumber();\n  }\n  async getL1BatchDetails(number) {\n    return await this.send('zks_getL1BatchDetails', [number]);\n  }\n  async getBlockDetails(number) {\n    return await this.send('zks_getBlockDetails', [number]);\n  }\n  async getTransactionDetails(txHash) {\n    return await this.send('zks_getTransactionDetails', [txHash]);\n  }\n  async getWithdrawTx(transaction) {\n    var _a, _b, _c;\n    var _d;\n    const {\n      ...tx\n    } = transaction;\n    if (tx.to == null && tx.from == null) {\n      throw new Error('withdrawal target address is undefined');\n    }\n    (_a = tx.to) !== null && _a !== void 0 ? _a : tx.to = tx.from;\n    (_b = tx.overrides) !== null && _b !== void 0 ? _b : tx.overrides = {};\n    (_c = (_d = tx.overrides).from) !== null && _c !== void 0 ? _c : _d.from = tx.from;\n    if ((0, utils_1.isETH)(tx.token)) {\n      if (!tx.overrides.value) {\n        tx.overrides.value = tx.amount;\n      }\n      const passedValue = ethers_1.BigNumber.from(tx.overrides.value);\n      if (!passedValue.eq(tx.amount)) {\n        // To avoid users shooting themselves into the foot, we will always use the amount to withdraw\n        // as the value\n        throw new Error('The tx.value is not equal to the value withdrawn');\n      }\n      const ethL2Token = typechain_1.IEthTokenFactory.connect(utils_1.L2_ETH_TOKEN_ADDRESS, this);\n      return ethL2Token.populateTransaction.withdraw(tx.to, tx.overrides);\n    }\n    if (tx.bridgeAddress == null) {\n      const bridges = await this.getDefaultBridgeAddresses();\n      tx.bridgeAddress = bridges.erc20L2;\n    }\n    const bridge = typechain_1.IL2BridgeFactory.connect(tx.bridgeAddress, this);\n    return bridge.populateTransaction.withdraw(tx.to, tx.token, tx.amount, tx.overrides);\n  }\n  async estimateGasWithdraw(transaction) {\n    const withdrawTx = await this.getWithdrawTx(transaction);\n    return await this.estimateGas(withdrawTx);\n  }\n  async getTransferTx(transaction) {\n    var _a, _b;\n    var _c;\n    const {\n      ...tx\n    } = transaction;\n    (_a = tx.overrides) !== null && _a !== void 0 ? _a : tx.overrides = {};\n    (_b = (_c = tx.overrides).from) !== null && _b !== void 0 ? _b : _c.from = tx.from;\n    if (tx.token == null || tx.token == utils_1.ETH_ADDRESS) {\n      return {\n        ...(await ethers_1.ethers.utils.resolveProperties(tx.overrides)),\n        to: tx.to,\n        value: tx.amount\n      };\n    } else {\n      const token = typechain_1.IERC20MetadataFactory.connect(tx.token, this);\n      return await token.populateTransaction.transfer(tx.to, tx.amount, tx.overrides);\n    }\n  }\n  async estimateGasTransfer(transaction) {\n    const transferTx = await this.getTransferTx(transaction);\n    return await this.estimateGas(transferTx);\n  }\n  static getDefaultProvider() {\n    // TODO (SMA-1606): Add different urls for different networks.\n    return new Provider(process.env.ZKSYNC_WEB3_API_URL || 'http://localhost:3050');\n  }\n  async newFilter(filter) {\n    filter = await filter;\n    const id = await this.send('eth_newFilter', [this._prepareFilter(filter)]);\n    return ethers_1.BigNumber.from(id);\n  }\n  async newBlockFilter() {\n    const id = await this.send('eth_newBlockFilter', []);\n    return ethers_1.BigNumber.from(id);\n  }\n  async newPendingTransactionsFilter() {\n    const id = await this.send('eth_newPendingTransactionFilter', []);\n    return ethers_1.BigNumber.from(id);\n  }\n  async getFilterChanges(idx) {\n    const logs = await this.send('eth_getFilterChanges', [idx.toHexString()]);\n    return typeof logs[0] === 'string' ? logs : this._parseLogs(logs);\n  }\n  async getLogs() {\n    let filter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    filter = await filter;\n    const logs = await this.send('eth_getLogs', [this._prepareFilter(filter)]);\n    return this._parseLogs(logs);\n  }\n  _parseLogs(logs) {\n    return Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs);\n  }\n  _prepareFilter(filter) {\n    return {\n      ...filter,\n      fromBlock: filter.fromBlock == null ? null : this.formatter.blockTag(filter.fromBlock),\n      toBlock: filter.fromBlock == null ? null : this.formatter.blockTag(filter.toBlock)\n    };\n  }\n  _wrapTransaction(tx, hash) {\n    const response = super._wrapTransaction(tx, hash);\n    response.waitFinalize = async () => {\n      const receipt = await response.wait();\n      while (true) {\n        const block = await this.getBlock('finalized');\n        if (receipt.blockNumber <= block.number) {\n          return await this.getTransactionReceipt(receipt.transactionHash);\n        } else {\n          await (0, utils_1.sleep)(this.pollingInterval);\n        }\n      }\n    };\n    return response;\n  }\n  // This is inefficient. Status should probably be indicated in the transaction receipt.\n  async getTransactionStatus(txHash) {\n    const tx = await this.getTransaction(txHash);\n    if (tx == null) {\n      return types_1.TransactionStatus.NotFound;\n    }\n    if (tx.blockNumber == null) {\n      return types_1.TransactionStatus.Processing;\n    }\n    const verifiedBlock = await this.getBlock('finalized');\n    if (tx.blockNumber <= verifiedBlock.number) {\n      return types_1.TransactionStatus.Finalized;\n    }\n    return types_1.TransactionStatus.Committed;\n  }\n  async getTransaction(hash) {\n    hash = await hash;\n    const tx = await super.getTransaction(hash);\n    return tx ? this._wrapTransaction(tx, hash) : null;\n  }\n  async sendTransaction(transaction) {\n    return await super.sendTransaction(transaction);\n  }\n  async getL2TransactionFromPriorityOp(l1TxResponse) {\n    const receipt = await l1TxResponse.wait();\n    const l2Hash = (0, utils_1.getL2HashFromPriorityOp)(receipt, await this.getMainContractAddress());\n    let status = null;\n    do {\n      status = await this.getTransactionStatus(l2Hash);\n      await (0, utils_1.sleep)(this.pollingInterval);\n    } while (status == types_1.TransactionStatus.NotFound);\n    return await this.getTransaction(l2Hash);\n  }\n  async getPriorityOpResponse(l1TxResponse) {\n    const l2Response = {\n      ...l1TxResponse\n    };\n    l2Response.waitL1Commit = l2Response.wait;\n    l2Response.wait = async () => {\n      const l2Tx = await this.getL2TransactionFromPriorityOp(l1TxResponse);\n      return await l2Tx.wait();\n    };\n    l2Response.waitFinalize = async () => {\n      const l2Tx = await this.getL2TransactionFromPriorityOp(l1TxResponse);\n      return await l2Tx.waitFinalize();\n    };\n    return l2Response;\n  }\n  async getContractAccountInfo(address) {\n    const deployerContract = new ethers_1.Contract(utils_1.CONTRACT_DEPLOYER_ADDRESS, utils_1.CONTRACT_DEPLOYER, this);\n    const data = await deployerContract.getAccountInfo(address);\n    return {\n      supportedAAVersion: data.supportedAAVersion,\n      nonceOrdering: data.nonceOrdering\n    };\n  }\n  // TODO (EVM-3): support refundRecipient for fee estimation\n  async estimateL1ToL2Execute(transaction) {\n    var _a, _b;\n    (_a = transaction.gasPerPubdataByte) !== null && _a !== void 0 ? _a : transaction.gasPerPubdataByte = utils_1.REQUIRED_L1_TO_L2_GAS_PER_PUBDATA_LIMIT;\n    // If the `from` address is not provided, we use a random address, because\n    // due to storage slot aggregation, the gas estimation will depend on the address\n    // and so estimation for the zero address may be smaller than for the sender.\n    (_b = transaction.caller) !== null && _b !== void 0 ? _b : transaction.caller = ethers_1.ethers.Wallet.createRandom().address;\n    const customData = {\n      gasPerPubdataByte: transaction.gasPerPubdataByte\n    };\n    if (transaction.factoryDeps) {\n      Object.assign(customData, {\n        factoryDeps: transaction.factoryDeps\n      });\n    }\n    const fee = await this.estimateGasL1({\n      from: transaction.caller,\n      data: transaction.calldata,\n      to: transaction.contractAddress,\n      value: transaction.l2Value,\n      customData\n    });\n    return fee;\n  }\n}\nexports.Provider = Provider;\nclass Web3Provider extends Provider {\n  constructor(provider, network) {\n    if (provider == null) {\n      throw new Error('missing provider');\n    }\n    if (!provider.request) {\n      throw new Error('provider must implement eip-1193');\n    }\n    let path = provider.host || provider.path || (provider.isMetaMask ? 'metamask' : 'eip-1193:');\n    super(path, network);\n    this.provider = provider;\n  }\n  async send(method, params) {\n    params !== null && params !== void 0 ? params : params = [];\n    // Metamask complains about eth_sign (and on some versions hangs)\n    if (method == 'eth_sign' && (this.provider.isMetaMask || this.provider.isStatus)) {\n      // https://github.com/ethereum/go-ethereum/wiki/Management-APIs#personal_sign\n      method = 'personal_sign';\n      params = [params[1], params[0]];\n    }\n    return await this.provider.request({\n      method,\n      params\n    });\n  }\n  getSigner(addressOrIndex) {\n    return signer_1.Signer.from(super.getSigner(addressOrIndex));\n  }\n  async estimateGas(transaction) {\n    const gas = await super.estimateGas(transaction);\n    const metamaskMinimum = ethers_1.BigNumber.from(21000);\n    const isEIP712 = transaction.customData != null || transaction.type == utils_1.EIP712_TX_TYPE;\n    return gas.gt(metamaskMinimum) || isEIP712 ? gas : metamaskMinimum;\n  }\n}\nexports.Web3Provider = Web3Provider;","map":{"version":3,"names":["Object","defineProperty","exports","value","Web3Provider","Provider","ethers_1","require","Formatter","providers","web_1","typechain_1","types_1","utils_1","signer_1","defaultFormatter","ethers","JsonRpcProvider","getTransactionReceipt","transactionHash","getNetwork","params","formatter","hash","poll","result","perform","_emitted","undefined","blockNumber","status","BigNumber","from","isZero","receipt","confirmations","blockHash","constants","HashZero","l1BatchNumber","l1BatchTxIndex","_getInternalBlockNumber","pollingInterval","oncePoll","getBlock","blockHashOrBlockTag","_getBlock","getBlockWithTransactions","getFormatter","number","bind","boolean","address","formats","receiptLog","allowNull","l2Tol1Log","transactionIndex","shardId","isService","sender","key","logIndex","l2ToL1Logs","arrayOf","check","block","l1BatchTimestamp","blockWithTransactions","transaction","filterLog","getBalance","blockTag","tokenAddress","tag","isETH","token","IERC20MetadataFactory","connect","balanceOf","l2TokenAddress","ETH_ADDRESS","erc20BridgeAddress","getDefaultBridgeAddresses","erc20L2","erc20Bridge","IL2BridgeFactory","l1TokenAddress","hexlifyTransaction","allowExtra","_a","customData","eip712Meta","gasPerPubdata","utils","hexValue","type","EIP712_TX_TYPE","factoryDeps","map","dep","Array","arrayify","paymasterParams","paymaster","hexlify","paymasterInput","estimateGas","resolveProperties","_getTransactionRequest","error","Error","concat","estimateGasL1","send","getGasPrice","price","constructor","url","network","contractAddresses","parseTransaction","getMessageProof","messageHash","toNumber","getLogProof","txHash","index","getL1BatchBlockRange","range","parseInt","getMainContractAddress","mainContract","getTestnetPaymasterAddress","erc20BridgeL1","addresses","l1Erc20DefaultBridge","erc20BridgeL2","l2Erc20DefaultBridge","erc20L1","getConfirmedTokens","start","arguments","length","limit","tokens","l2Address","getTokenPrice","getAllAccountBalances","balances","l1ChainId","res","getL1BatchNumber","getL1BatchDetails","getBlockDetails","getTransactionDetails","getWithdrawTx","_b","_c","_d","tx","to","overrides","amount","passedValue","eq","ethL2Token","IEthTokenFactory","L2_ETH_TOKEN_ADDRESS","populateTransaction","withdraw","bridgeAddress","bridges","bridge","estimateGasWithdraw","withdrawTx","getTransferTx","transfer","estimateGasTransfer","transferTx","getDefaultProvider","process","env","ZKSYNC_WEB3_API_URL","newFilter","filter","id","_prepareFilter","newBlockFilter","newPendingTransactionsFilter","getFilterChanges","idx","logs","toHexString","_parseLogs","getLogs","fromBlock","toBlock","_wrapTransaction","response","waitFinalize","wait","sleep","getTransactionStatus","getTransaction","TransactionStatus","NotFound","Processing","verifiedBlock","Finalized","Committed","sendTransaction","getL2TransactionFromPriorityOp","l1TxResponse","l2Hash","getL2HashFromPriorityOp","getPriorityOpResponse","l2Response","waitL1Commit","l2Tx","getContractAccountInfo","deployerContract","Contract","CONTRACT_DEPLOYER_ADDRESS","CONTRACT_DEPLOYER","data","getAccountInfo","supportedAAVersion","nonceOrdering","estimateL1ToL2Execute","gasPerPubdataByte","REQUIRED_L1_TO_L2_GAS_PER_PUBDATA_LIMIT","caller","Wallet","createRandom","assign","fee","calldata","contractAddress","l2Value","provider","request","path","host","isMetaMask","method","isStatus","getSigner","addressOrIndex","Signer","gas","metamaskMinimum","isEIP712","gt"],"sources":["C:/Misc/Documents/Career/FinTech/BlockChain/FrontEnd/buildspace-dao-starter/node_modules/zksync-web3/build/src/provider.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Web3Provider = exports.Provider = void 0;\nconst ethers_1 = require(\"ethers\");\nvar Formatter = ethers_1.providers.Formatter;\nconst web_1 = require(\"@ethersproject/web\");\nconst typechain_1 = require(\"../typechain\");\nconst types_1 = require(\"./types\");\nconst utils_1 = require(\"./utils\");\nconst signer_1 = require(\"./signer\");\nlet defaultFormatter = null;\nclass Provider extends ethers_1.ethers.providers.JsonRpcProvider {\n    async getTransactionReceipt(transactionHash) {\n        await this.getNetwork();\n        transactionHash = await transactionHash;\n        const params = { transactionHash: this.formatter.hash(transactionHash, true) };\n        return (0, web_1.poll)(async () => {\n            const result = await this.perform('getTransactionReceipt', params);\n            if (result == null) {\n                if (this._emitted['t:' + transactionHash] == null) {\n                    return null;\n                }\n                return undefined;\n            }\n            if (result.blockNumber == null && result.status != null && ethers_1.BigNumber.from(result.status).isZero()) {\n                // transaction is rejected in the state-keeper\n                return {\n                    ...this.formatter.receipt({\n                        ...result,\n                        confirmations: 1,\n                        blockNumber: 0,\n                        blockHash: ethers_1.ethers.constants.HashZero\n                    }),\n                    blockNumber: null,\n                    blockHash: null,\n                    l1BatchNumber: null,\n                    l1BatchTxIndex: null\n                };\n            }\n            if (result.blockHash == null) {\n                // receipt is not ready\n                return undefined;\n            }\n            else {\n                const receipt = this.formatter.receipt(result);\n                if (receipt.blockNumber == null) {\n                    receipt.confirmations = 0;\n                }\n                else if (receipt.confirmations == null) {\n                    const blockNumber = await this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                    // Add the confirmations using the fast block number (pessimistic)\n                    let confirmations = blockNumber - receipt.blockNumber + 1;\n                    if (confirmations <= 0) {\n                        confirmations = 1;\n                    }\n                    receipt.confirmations = confirmations;\n                }\n                return receipt;\n            }\n        }, { oncePoll: this });\n    }\n    async getBlock(blockHashOrBlockTag) {\n        return this._getBlock(blockHashOrBlockTag, false);\n    }\n    async getBlockWithTransactions(blockHashOrBlockTag) {\n        return this._getBlock(blockHashOrBlockTag, true);\n    }\n    static getFormatter() {\n        if (defaultFormatter == null) {\n            defaultFormatter = new Formatter();\n            const number = defaultFormatter.number.bind(defaultFormatter);\n            const boolean = defaultFormatter.boolean.bind(defaultFormatter);\n            const hash = defaultFormatter.hash.bind(defaultFormatter);\n            const address = defaultFormatter.address.bind(defaultFormatter);\n            defaultFormatter.formats.receiptLog.l1BatchNumber = Formatter.allowNull(number);\n            defaultFormatter.formats.l2Tol1Log = {\n                blockNumber: number,\n                blockHash: hash,\n                l1BatchNumber: Formatter.allowNull(number),\n                transactionIndex: number,\n                shardId: number,\n                isService: boolean,\n                sender: address,\n                key: hash,\n                value: hash,\n                transactionHash: hash,\n                logIndex: number\n            };\n            defaultFormatter.formats.receipt.l1BatchNumber = Formatter.allowNull(number);\n            defaultFormatter.formats.receipt.l1BatchTxIndex = Formatter.allowNull(number);\n            defaultFormatter.formats.receipt.l2ToL1Logs = Formatter.arrayOf((value) => Formatter.check(defaultFormatter.formats.l2Tol1Log, value));\n            defaultFormatter.formats.block.l1BatchNumber = Formatter.allowNull(number);\n            defaultFormatter.formats.block.l1BatchTimestamp = Formatter.allowNull(number);\n            defaultFormatter.formats.blockWithTransactions.l1BatchNumber = Formatter.allowNull(number);\n            defaultFormatter.formats.blockWithTransactions.l1BatchTimestamp = Formatter.allowNull(number);\n            defaultFormatter.formats.transaction.l1BatchNumber = Formatter.allowNull(number);\n            defaultFormatter.formats.transaction.l1BatchTxIndex = Formatter.allowNull(number);\n            defaultFormatter.formats.filterLog.l1BatchNumber = Formatter.allowNull(number);\n        }\n        return defaultFormatter;\n    }\n    async getBalance(address, blockTag, tokenAddress) {\n        const tag = this.formatter.blockTag(blockTag);\n        if (tokenAddress == null || (0, utils_1.isETH)(tokenAddress)) {\n            // requesting ETH balance\n            return await super.getBalance(address, tag);\n        }\n        else {\n            try {\n                let token = typechain_1.IERC20MetadataFactory.connect(tokenAddress, this);\n                return await token.balanceOf(address, { blockTag: tag });\n            }\n            catch {\n                return ethers_1.BigNumber.from(0);\n            }\n        }\n    }\n    async l2TokenAddress(token) {\n        if (token == utils_1.ETH_ADDRESS) {\n            return utils_1.ETH_ADDRESS;\n        }\n        else {\n            const erc20BridgeAddress = (await this.getDefaultBridgeAddresses()).erc20L2;\n            const erc20Bridge = typechain_1.IL2BridgeFactory.connect(erc20BridgeAddress, this);\n            return await erc20Bridge.l2TokenAddress(token);\n        }\n    }\n    async l1TokenAddress(token) {\n        if (token == utils_1.ETH_ADDRESS) {\n            return utils_1.ETH_ADDRESS;\n        }\n        else {\n            const erc20BridgeAddress = (await this.getDefaultBridgeAddresses()).erc20L2;\n            const erc20Bridge = typechain_1.IL2BridgeFactory.connect(erc20BridgeAddress, this);\n            return await erc20Bridge.l1TokenAddress(token);\n        }\n    }\n    // This function is used when formatting requests for\n    // eth_call and eth_estimateGas. We override it here\n    // because we have extra stuff to serialize (customData).\n    // This function is for internal use only.\n    static hexlifyTransaction(transaction, allowExtra) {\n        var _a;\n        const result = ethers_1.ethers.providers.JsonRpcProvider.hexlifyTransaction(transaction, {\n            ...allowExtra,\n            customData: true,\n            from: true\n        });\n        if (transaction.customData == null) {\n            return result;\n        }\n        result.eip712Meta = {\n            gasPerPubdata: ethers_1.utils.hexValue((_a = transaction.customData.gasPerPubdata) !== null && _a !== void 0 ? _a : 0)\n        };\n        transaction.type = utils_1.EIP712_TX_TYPE;\n        if (transaction.customData.factoryDeps) {\n            // @ts-ignore\n            result.eip712Meta.factoryDeps = transaction.customData.factoryDeps.map((dep) => \n            // TODO (SMA-1605): we arraify instead of hexlifying because server expects Vec<u8>.\n            //  We should change deserialization there.\n            Array.from(ethers_1.utils.arrayify(dep)));\n        }\n        if (transaction.customData.paymasterParams) {\n            // @ts-ignore\n            result.eip712Meta.paymasterParams = {\n                paymaster: ethers_1.utils.hexlify(transaction.customData.paymasterParams.paymaster),\n                paymasterInput: Array.from(ethers_1.utils.arrayify(transaction.customData.paymasterParams.paymasterInput))\n            };\n        }\n        return result;\n    }\n    async estimateGas(transaction) {\n        await this.getNetwork();\n        const params = await ethers_1.utils.resolveProperties({\n            transaction: this._getTransactionRequest(transaction)\n        });\n        if (transaction.customData != null) {\n            // @ts-ignore\n            params.transaction.customData = transaction.customData;\n        }\n        const result = await this.perform('estimateGas', params);\n        try {\n            return ethers_1.BigNumber.from(result);\n        }\n        catch (error) {\n            throw new Error(`bad result from backend (estimateGas): ${result}`);\n        }\n    }\n    async estimateGasL1(transaction) {\n        await this.getNetwork();\n        const params = await ethers_1.utils.resolveProperties({\n            transaction: this._getTransactionRequest(transaction)\n        });\n        if (transaction.customData != null) {\n            // @ts-ignore\n            params.transaction.customData = transaction.customData;\n        }\n        const result = await this.send('zks_estimateGasL1ToL2', [\n            Provider.hexlifyTransaction(params.transaction, { from: true })\n        ]);\n        try {\n            return ethers_1.BigNumber.from(result);\n        }\n        catch (error) {\n            throw new Error(`bad result from backend (zks_estimateGasL1ToL2): ${result}`);\n        }\n    }\n    async getGasPrice(token) {\n        const params = token ? [token] : [];\n        const price = await this.send('eth_gasPrice', params);\n        return ethers_1.BigNumber.from(price);\n    }\n    constructor(url, network) {\n        super(url, network);\n        this.pollingInterval = 500;\n        const blockTag = this.formatter.blockTag.bind(this.formatter);\n        this.formatter.blockTag = (tag) => {\n            if (tag == 'committed' || tag == 'finalized') {\n                return tag;\n            }\n            return blockTag(tag);\n        };\n        this.contractAddresses = {};\n        this.formatter.transaction = utils_1.parseTransaction;\n    }\n    async getMessageProof(blockNumber, sender, messageHash, logIndex) {\n        return await this.send('zks_getL2ToL1MsgProof', [\n            ethers_1.BigNumber.from(blockNumber).toNumber(),\n            sender,\n            ethers_1.ethers.utils.hexlify(messageHash),\n            logIndex\n        ]);\n    }\n    async getLogProof(txHash, index) {\n        return await this.send('zks_getL2ToL1LogProof', [ethers_1.ethers.utils.hexlify(txHash), index]);\n    }\n    async getL1BatchBlockRange(l1BatchNumber) {\n        const range = await this.send('zks_getL1BatchBlockRange', [l1BatchNumber]);\n        if (range == null) {\n            return null;\n        }\n        return [parseInt(range[0], 16), parseInt(range[1], 16)];\n    }\n    async getMainContractAddress() {\n        if (!this.contractAddresses.mainContract) {\n            this.contractAddresses.mainContract = await this.send('zks_getMainContract', []);\n        }\n        return this.contractAddresses.mainContract;\n    }\n    async getTestnetPaymasterAddress() {\n        // Unlike contract's addresses, the testnet paymaster is not cached, since it can be trivially changed\n        // on the fly by the server and should not be relied to be constant\n        return await this.send('zks_getTestnetPaymaster', []);\n    }\n    async getDefaultBridgeAddresses() {\n        if (!this.contractAddresses.erc20BridgeL1) {\n            let addresses = await this.send('zks_getBridgeContracts', []);\n            this.contractAddresses.erc20BridgeL1 = addresses.l1Erc20DefaultBridge;\n            this.contractAddresses.erc20BridgeL2 = addresses.l2Erc20DefaultBridge;\n        }\n        return {\n            erc20L1: this.contractAddresses.erc20BridgeL1,\n            erc20L2: this.contractAddresses.erc20BridgeL2\n        };\n    }\n    async getConfirmedTokens(start = 0, limit = 255) {\n        const tokens = await this.send('zks_getConfirmedTokens', [start, limit]);\n        return tokens.map((token) => ({ address: token.l2Address, ...token }));\n    }\n    async getTokenPrice(token) {\n        return await this.send('zks_getTokenPrice', [token]);\n    }\n    async getAllAccountBalances(address) {\n        let balances = await this.send('zks_getAllAccountBalances', [address]);\n        for (let token in balances) {\n            balances[token] = ethers_1.BigNumber.from(balances[token]);\n        }\n        return balances;\n    }\n    async l1ChainId() {\n        const res = await this.send('zks_L1ChainId', []);\n        return ethers_1.BigNumber.from(res).toNumber();\n    }\n    async getL1BatchNumber() {\n        const number = await this.send('zks_L1BatchNumber', []);\n        return ethers_1.BigNumber.from(number).toNumber();\n    }\n    async getL1BatchDetails(number) {\n        return await this.send('zks_getL1BatchDetails', [number]);\n    }\n    async getBlockDetails(number) {\n        return await this.send('zks_getBlockDetails', [number]);\n    }\n    async getTransactionDetails(txHash) {\n        return await this.send('zks_getTransactionDetails', [txHash]);\n    }\n    async getWithdrawTx(transaction) {\n        var _a, _b, _c;\n        var _d;\n        const { ...tx } = transaction;\n        if (tx.to == null && tx.from == null) {\n            throw new Error('withdrawal target address is undefined');\n        }\n        (_a = tx.to) !== null && _a !== void 0 ? _a : (tx.to = tx.from);\n        (_b = tx.overrides) !== null && _b !== void 0 ? _b : (tx.overrides = {});\n        (_c = (_d = tx.overrides).from) !== null && _c !== void 0 ? _c : (_d.from = tx.from);\n        if ((0, utils_1.isETH)(tx.token)) {\n            if (!tx.overrides.value) {\n                tx.overrides.value = tx.amount;\n            }\n            const passedValue = ethers_1.BigNumber.from(tx.overrides.value);\n            if (!passedValue.eq(tx.amount)) {\n                // To avoid users shooting themselves into the foot, we will always use the amount to withdraw\n                // as the value\n                throw new Error('The tx.value is not equal to the value withdrawn');\n            }\n            const ethL2Token = typechain_1.IEthTokenFactory.connect(utils_1.L2_ETH_TOKEN_ADDRESS, this);\n            return ethL2Token.populateTransaction.withdraw(tx.to, tx.overrides);\n        }\n        if (tx.bridgeAddress == null) {\n            const bridges = await this.getDefaultBridgeAddresses();\n            tx.bridgeAddress = bridges.erc20L2;\n        }\n        const bridge = typechain_1.IL2BridgeFactory.connect(tx.bridgeAddress, this);\n        return bridge.populateTransaction.withdraw(tx.to, tx.token, tx.amount, tx.overrides);\n    }\n    async estimateGasWithdraw(transaction) {\n        const withdrawTx = await this.getWithdrawTx(transaction);\n        return await this.estimateGas(withdrawTx);\n    }\n    async getTransferTx(transaction) {\n        var _a, _b;\n        var _c;\n        const { ...tx } = transaction;\n        (_a = tx.overrides) !== null && _a !== void 0 ? _a : (tx.overrides = {});\n        (_b = (_c = tx.overrides).from) !== null && _b !== void 0 ? _b : (_c.from = tx.from);\n        if (tx.token == null || tx.token == utils_1.ETH_ADDRESS) {\n            return {\n                ...(await ethers_1.ethers.utils.resolveProperties(tx.overrides)),\n                to: tx.to,\n                value: tx.amount\n            };\n        }\n        else {\n            const token = typechain_1.IERC20MetadataFactory.connect(tx.token, this);\n            return await token.populateTransaction.transfer(tx.to, tx.amount, tx.overrides);\n        }\n    }\n    async estimateGasTransfer(transaction) {\n        const transferTx = await this.getTransferTx(transaction);\n        return await this.estimateGas(transferTx);\n    }\n    static getDefaultProvider() {\n        // TODO (SMA-1606): Add different urls for different networks.\n        return new Provider(process.env.ZKSYNC_WEB3_API_URL || 'http://localhost:3050');\n    }\n    async newFilter(filter) {\n        filter = await filter;\n        const id = await this.send('eth_newFilter', [this._prepareFilter(filter)]);\n        return ethers_1.BigNumber.from(id);\n    }\n    async newBlockFilter() {\n        const id = await this.send('eth_newBlockFilter', []);\n        return ethers_1.BigNumber.from(id);\n    }\n    async newPendingTransactionsFilter() {\n        const id = await this.send('eth_newPendingTransactionFilter', []);\n        return ethers_1.BigNumber.from(id);\n    }\n    async getFilterChanges(idx) {\n        const logs = await this.send('eth_getFilterChanges', [idx.toHexString()]);\n        return typeof logs[0] === 'string' ? logs : this._parseLogs(logs);\n    }\n    async getLogs(filter = {}) {\n        filter = await filter;\n        const logs = await this.send('eth_getLogs', [this._prepareFilter(filter)]);\n        return this._parseLogs(logs);\n    }\n    _parseLogs(logs) {\n        return Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs);\n    }\n    _prepareFilter(filter) {\n        return {\n            ...filter,\n            fromBlock: filter.fromBlock == null ? null : this.formatter.blockTag(filter.fromBlock),\n            toBlock: filter.fromBlock == null ? null : this.formatter.blockTag(filter.toBlock)\n        };\n    }\n    _wrapTransaction(tx, hash) {\n        const response = super._wrapTransaction(tx, hash);\n        response.waitFinalize = async () => {\n            const receipt = await response.wait();\n            while (true) {\n                const block = await this.getBlock('finalized');\n                if (receipt.blockNumber <= block.number) {\n                    return await this.getTransactionReceipt(receipt.transactionHash);\n                }\n                else {\n                    await (0, utils_1.sleep)(this.pollingInterval);\n                }\n            }\n        };\n        return response;\n    }\n    // This is inefficient. Status should probably be indicated in the transaction receipt.\n    async getTransactionStatus(txHash) {\n        const tx = await this.getTransaction(txHash);\n        if (tx == null) {\n            return types_1.TransactionStatus.NotFound;\n        }\n        if (tx.blockNumber == null) {\n            return types_1.TransactionStatus.Processing;\n        }\n        const verifiedBlock = await this.getBlock('finalized');\n        if (tx.blockNumber <= verifiedBlock.number) {\n            return types_1.TransactionStatus.Finalized;\n        }\n        return types_1.TransactionStatus.Committed;\n    }\n    async getTransaction(hash) {\n        hash = await hash;\n        const tx = await super.getTransaction(hash);\n        return tx ? this._wrapTransaction(tx, hash) : null;\n    }\n    async sendTransaction(transaction) {\n        return (await super.sendTransaction(transaction));\n    }\n    async getL2TransactionFromPriorityOp(l1TxResponse) {\n        const receipt = await l1TxResponse.wait();\n        const l2Hash = (0, utils_1.getL2HashFromPriorityOp)(receipt, await this.getMainContractAddress());\n        let status = null;\n        do {\n            status = await this.getTransactionStatus(l2Hash);\n            await (0, utils_1.sleep)(this.pollingInterval);\n        } while (status == types_1.TransactionStatus.NotFound);\n        return await this.getTransaction(l2Hash);\n    }\n    async getPriorityOpResponse(l1TxResponse) {\n        const l2Response = { ...l1TxResponse };\n        l2Response.waitL1Commit = l2Response.wait;\n        l2Response.wait = async () => {\n            const l2Tx = await this.getL2TransactionFromPriorityOp(l1TxResponse);\n            return await l2Tx.wait();\n        };\n        l2Response.waitFinalize = async () => {\n            const l2Tx = await this.getL2TransactionFromPriorityOp(l1TxResponse);\n            return await l2Tx.waitFinalize();\n        };\n        return l2Response;\n    }\n    async getContractAccountInfo(address) {\n        const deployerContract = new ethers_1.Contract(utils_1.CONTRACT_DEPLOYER_ADDRESS, utils_1.CONTRACT_DEPLOYER, this);\n        const data = await deployerContract.getAccountInfo(address);\n        return {\n            supportedAAVersion: data.supportedAAVersion,\n            nonceOrdering: data.nonceOrdering\n        };\n    }\n    // TODO (EVM-3): support refundRecipient for fee estimation\n    async estimateL1ToL2Execute(transaction) {\n        var _a, _b;\n        (_a = transaction.gasPerPubdataByte) !== null && _a !== void 0 ? _a : (transaction.gasPerPubdataByte = utils_1.REQUIRED_L1_TO_L2_GAS_PER_PUBDATA_LIMIT);\n        // If the `from` address is not provided, we use a random address, because\n        // due to storage slot aggregation, the gas estimation will depend on the address\n        // and so estimation for the zero address may be smaller than for the sender.\n        (_b = transaction.caller) !== null && _b !== void 0 ? _b : (transaction.caller = ethers_1.ethers.Wallet.createRandom().address);\n        const customData = {\n            gasPerPubdataByte: transaction.gasPerPubdataByte\n        };\n        if (transaction.factoryDeps) {\n            Object.assign(customData, { factoryDeps: transaction.factoryDeps });\n        }\n        const fee = await this.estimateGasL1({\n            from: transaction.caller,\n            data: transaction.calldata,\n            to: transaction.contractAddress,\n            value: transaction.l2Value,\n            customData\n        });\n        return fee;\n    }\n}\nexports.Provider = Provider;\nclass Web3Provider extends Provider {\n    constructor(provider, network) {\n        if (provider == null) {\n            throw new Error('missing provider');\n        }\n        if (!provider.request) {\n            throw new Error('provider must implement eip-1193');\n        }\n        let path = provider.host || provider.path || (provider.isMetaMask ? 'metamask' : 'eip-1193:');\n        super(path, network);\n        this.provider = provider;\n    }\n    async send(method, params) {\n        params !== null && params !== void 0 ? params : (params = []);\n        // Metamask complains about eth_sign (and on some versions hangs)\n        if (method == 'eth_sign' && (this.provider.isMetaMask || this.provider.isStatus)) {\n            // https://github.com/ethereum/go-ethereum/wiki/Management-APIs#personal_sign\n            method = 'personal_sign';\n            params = [params[1], params[0]];\n        }\n        return await this.provider.request({ method, params });\n    }\n    getSigner(addressOrIndex) {\n        return signer_1.Signer.from(super.getSigner(addressOrIndex));\n    }\n    async estimateGas(transaction) {\n        const gas = await super.estimateGas(transaction);\n        const metamaskMinimum = ethers_1.BigNumber.from(21000);\n        const isEIP712 = transaction.customData != null || transaction.type == utils_1.EIP712_TX_TYPE;\n        return gas.gt(metamaskMinimum) || isEIP712 ? gas : metamaskMinimum;\n    }\n}\nexports.Web3Provider = Web3Provider;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}