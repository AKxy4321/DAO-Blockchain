{"ast":null,"code":"import { d4 as getSignerAndProvider, cL as resolveAddress, dz as SmartContract, dA as getCompositePluginABI, e as AbiSchema, dm as getContractTypeForRemoteName, dy as ContractPublisher, dj as PREBUILT_CONTRACTS_MAP } from './contract-publisher-1ff1fe07.browser.esm.js';\nimport { ThirdwebStorage } from '@thirdweb-dev/storage';\nimport IThirdwebContractABI from '@thirdweb-dev/contracts-js/dist/abis/IThirdwebContract.json';\nimport { Contract, utils } from 'ethers';\nlet STORAGE_CACHE = new ThirdwebStorage();\nconst CONTRACT_CACHE = new Map();\nfunction getContractCacheKey(address, chainId) {\n  return \"\".concat(address, \"-\").concat(chainId);\n}\nfunction inContractCache(address, chainId) {\n  const cacheKey = getContractCacheKey(address, chainId);\n  return CONTRACT_CACHE.has(cacheKey);\n}\nfunction getCachedContract(address, chainId) {\n  if (!inContractCache(address, chainId)) {\n    throw new Error(\"Contract \".concat(address, \" was not found in cache\"));\n  }\n  const cacheKey = getContractCacheKey(address, chainId);\n  return CONTRACT_CACHE.get(cacheKey);\n}\nfunction cacheContract(contract, address, chainId) {\n  const cacheKey = getContractCacheKey(address, chainId);\n  CONTRACT_CACHE.set(cacheKey, contract);\n}\nfunction getCachedStorage(storage) {\n  return storage || STORAGE_CACHE;\n}\nasync function getContractFromAbi(params) {\n  const [signer, provider] = getSignerAndProvider(params.network, params.sdkOptions);\n  const [resolvedAddress, {\n    chainId\n  }] = await Promise.all([resolveAddress(params.address), provider.getNetwork()]);\n  if (inContractCache(resolvedAddress, chainId)) {\n    return getCachedContract(resolvedAddress, chainId);\n  }\n  const parsedAbi = typeof params.abi === \"string\" ? JSON.parse(params.abi) : params.abi;\n  const contract = new SmartContract(signer || provider, resolvedAddress, await getCompositePluginABI(resolvedAddress, AbiSchema.parse(parsedAbi), provider, params.sdkOptions, getCachedStorage(params.storage)), getCachedStorage(params.storage), params.sdkOptions, chainId);\n  cacheContract(contract, resolvedAddress, chainId);\n  return contract;\n}\nasync function resolveContractType(params) {\n  try {\n    const contract = new Contract(params.address, IThirdwebContractABI, params.provider);\n    const remoteContractType = utils.toUtf8String(await contract.contractType())\n    // eslint-disable-next-line no-control-regex\n    .replace(/\\x00/g, \"\");\n    return getContractTypeForRemoteName(remoteContractType);\n  } catch (err) {\n    return \"custom\";\n  }\n}\nasync function getContract(params) {\n  const [signer, provider] = getSignerAndProvider(params.network, params.sdkOptions);\n  const [resolvedAddress, {\n    chainId\n  }] = await Promise.all([resolveAddress(params.address), provider.getNetwork()]);\n  if (inContractCache(resolvedAddress, chainId)) {\n    return getCachedContract(resolvedAddress, chainId);\n  }\n  if (!params.contractTypeOrAbi || params.contractTypeOrAbi === \"custom\") {\n    const contractType = await resolveContractType({\n      address: resolvedAddress,\n      provider\n    });\n    if (contractType === \"custom\") {\n      const publisher = new ContractPublisher(params.network, params.sdkOptions, getCachedStorage(params.storage));\n      try {\n        const metadata = await publisher.fetchCompilerMetadataFromAddress(resolvedAddress);\n        return getContractFromAbi({\n          ...params,\n          address: resolvedAddress,\n          abi: metadata.abi\n        });\n      } catch {\n        throw new Error(\"No ABI found for this contract. Try importing it by visiting: https://thirdweb.com/\".concat(chainId, \"/\").concat(resolvedAddress));\n      }\n    } else {\n      const abi = await PREBUILT_CONTRACTS_MAP[contractType].getAbi(resolvedAddress, provider, getCachedStorage(params.storage));\n      return getContractFromAbi({\n        ...params,\n        address: resolvedAddress,\n        abi\n      });\n    }\n  } else if (typeof params.contractTypeOrAbi === \"string\" && params.contractTypeOrAbi in PREBUILT_CONTRACTS_MAP) {\n    const contract = await PREBUILT_CONTRACTS_MAP[params.contractTypeOrAbi].initialize(signer || provider, resolvedAddress, getCachedStorage(params.storage), params.sdkOptions);\n    cacheContract(contract, resolvedAddress, chainId);\n    return contract;\n  } else {\n    return getContractFromAbi({\n      ...params,\n      address: resolvedAddress,\n      abi: params.contractTypeOrAbi\n    });\n  }\n}\n\n// weakmap because if we GC the provider somewhere else we don't need to hold onto the promise anymore\nconst CHAIN_ID_CACHE = new WeakMap();\n\n/**\n * A function that returns the chainId for a given network input + sdk options combination.\n * This function will cache the promise for the chainId so that it can be reused.\n * You can call this function multiple times with the same params and it will only make one request to the provider.\n *\n * @returns the ChainId\n * @internal\n */\nasync function getChainId(params) {\n  const [, provider] = getSignerAndProvider(params.network, params.sdkOptions);\n  let chainIdPromise;\n  // if we already have a promise for the chainId, use that\n  if (CHAIN_ID_CACHE.has(provider)) {\n    chainIdPromise = CHAIN_ID_CACHE.get(provider);\n  } else {\n    chainIdPromise = provider.getNetwork()\n    // we only want the chainId\n    .then(network => network.chainId).catch(err => {\n      // in the case where the provider fails we should remove the promise from the cache so we can try again\n      CHAIN_ID_CACHE.delete(provider);\n      // also re-throw the error so downstream can handle it\n      throw err;\n    });\n    CHAIN_ID_CACHE.set(provider, chainIdPromise);\n  }\n\n  // finally await the promise (will resolve immediately if already in cache and resolved)\n  return await chainIdPromise;\n}\n\n/**\n * Get the latest block number from a given network.\n *\n * @example\n * ```javascript\n * const block = await getBlockNumber({\n *  network: \"ethereum\"\n * });\n * ```\n * @returns the latest block number\n * @public\n */\nasync function getBlockNumber(params) {\n  const [, provider] = getSignerAndProvider(params.network, params.sdkOptions);\n  return provider.getBlockNumber();\n}\nconst BLOCK_PROMISE_CACHE = new Map();\n/**\n * Get a specific block from a given network.\n *\n * @example\n * ```javascript\n * const block = await getBlock({\n *  network: \"ethereum\",\n *  block: 12345678\n * });\n * ```\n *\n * @returns the block for the given block number / block tag\n * @public\n */\nasync function getBlock(params) {\n  // first off get the chainId so we can check if we have something in cache for the blockNumber already\n  // this is 1 extra call once per possible provider\n  const chainId = await getChainId(params);\n  const blockTag = params.block;\n  const cacheKey = \"\".concat(chainId, \"_\").concat(blockTag);\n  let blockPromise;\n  if (BLOCK_PROMISE_CACHE.has(cacheKey)) {\n    blockPromise = BLOCK_PROMISE_CACHE.get(cacheKey);\n  } else {\n    const [, provider] = getSignerAndProvider(params.network, params.sdkOptions);\n    blockPromise = provider.getBlock(blockTag).catch(err => {\n      // in the case where the call fails we should remove the promise from the cache so we can try again\n      BLOCK_PROMISE_CACHE.delete(cacheKey);\n      // also re-throw the error so downstream can handle it\n      throw err;\n    });\n    BLOCK_PROMISE_CACHE.set(cacheKey, blockPromise);\n  }\n\n  // finally await the promise (will resolve immediately if already in cache and resolved)\n  return await blockPromise;\n}\nconst BLOCK_WITH_TRANSACTIONS_PROMISE_CACHE = new Map();\n/**\n * Get a specific block (with the transactions contained in it) from a given network.\n *\n * @example\n * ```javascript\n * const block = await getBlockWithTransactions({\n *  network: \"ethereum\",\n *  block: 12345678\n * });\n * ```\n *\n * @returns the block for the given block number / block tag\n * @public\n */\nasync function getBlockWithTransactions(params) {\n  // first off get the chainId so we can check if we have something in cache for the blockNumber already\n  // this is 1 extra call once per possible provider\n  const chainId = await getChainId(params);\n  const blockTag = params.block;\n  const cacheKey = \"\".concat(chainId, \"_\").concat(blockTag);\n  let blockPromise;\n  if (BLOCK_PROMISE_CACHE.has(cacheKey)) {\n    blockPromise = BLOCK_WITH_TRANSACTIONS_PROMISE_CACHE.get(cacheKey);\n  } else {\n    const [, provider] = getSignerAndProvider(params.network, params.sdkOptions);\n    blockPromise = provider.getBlockWithTransactions(blockTag).catch(err => {\n      // in the case where the call fails we should remove the promise from the cache so we can try again\n      BLOCK_WITH_TRANSACTIONS_PROMISE_CACHE.delete(cacheKey);\n      // also re-throw the error so downstream can handle it\n      throw err;\n    });\n    BLOCK_WITH_TRANSACTIONS_PROMISE_CACHE.set(cacheKey, blockPromise);\n  }\n\n  // finally await the promise (will resolve immediately if already in cache and resolved)\n  return await blockPromise;\n}\n\n/**\n * Watch for a new block number on a given network.\n *\n * @example\n * ```javascript\n * // this will log out the new block number every time a new block is finalized\n * const unsubscribe = watchBlockNumber({\n *   network: \"ethereum\",\n *   onBlockNumber: (blockNumber) => {\n *     console.log(\"new block number\", blockNumber);\n *   }\n * });\n * // later on you can call unsubscribe to stop listening for new blocks\n * unsubscribe();\n * ```\n *\n * @returns an unsubscribe function that will stop listening for new blocks when called\n * @public\n */\nfunction watchBlockNumber(params) {\n  const [, provider] = getSignerAndProvider(params.network, params.sdkOptions);\n  // start listening\n  provider.on(\"block\", params.onBlockNumber);\n  // return a function that unsubscribes the listener\n  return () => {\n    provider.off(\"block\", params.onBlockNumber);\n  };\n}\n/**\n * Watch for new blocks on a given network.\n *\n * @example\n * ```javascript\n * // this will log out the new block every time a new block is finalized\n * const unsubscribe = watchBlock({\n *   network: \"ethereum\",\n *   onBlock: (block) => {\n *     console.log(\"new block\", block);\n *   }\n * });\n * // later on you can call unsubscribe to stop listening for new blocks\n * unsubscribe();\n * ```\n *\n * @returns an unsubscribe function that will stop listening for new blocks when called\n * @public\n */\nfunction watchBlock(_ref) {\n  let {\n    onBlock,\n    ...sharedBlockParams\n  } = _ref;\n  async function onBlockNumber(blockNumber) {\n    try {\n      onBlock(await getBlock({\n        block: blockNumber,\n        ...sharedBlockParams\n      }));\n    } catch (err) {\n      // skip the block I guess?\n    }\n  }\n  // start listening and return the unsubscribe function from within watchBlockNumber\n  return watchBlockNumber({\n    ...sharedBlockParams,\n    onBlockNumber\n  });\n}\n/**\n * Watch for new blocks on a given network. (Includes parsed transactions)\n *\n * @example\n * ```javascript\n * // this will log out the new block every time a new block is finalized\n * const unsubscribe = watchBlockWithTransactions({\n *   network: \"ethereum\",\n *   onBlock: (block) => {\n *     console.log(\"new block\", block);\n *     console.log(\"new transactions\", block.transactions)\n *   }\n * });\n * // later on you can call unsubscribe to stop listening for new blocks\n * unsubscribe();\n *\n * @returns an unsubscribe function that will stop listening for new blocks when called\n * @public\n */\nfunction watchBlockWithTransactions(_ref2) {\n  let {\n    onBlock,\n    ...sharedBlockParams\n  } = _ref2;\n  async function onBlockNumber(blockNumber) {\n    try {\n      onBlock(await getBlockWithTransactions({\n        block: blockNumber,\n        ...sharedBlockParams\n      }));\n    } catch (err) {\n      // skip the block I guess?\n    }\n  }\n  // start listening and return the unsubscribe function from within watchBlockNumber\n  return watchBlockNumber({\n    ...sharedBlockParams,\n    onBlockNumber\n  });\n}\n\n/**\n * Watch for transactions to or from a given address.\n *\n * @example\n * ```javascript\n * // this will log out the new transactions every time a new block is finalized\n * const unsubscribe = watchTransactions({\n *   network: \"ethereum\",\n *   address: \"0x1234\",\n *   onTransactions: (transactions) => {\n *     console.log(\"new transactions\", transactions);\n *   }\n * });\n * // later on you can call unsubscribe to stop listening for new transactions\n * unsubscribe();\n * ```\n *\n * @returns an unsubscribe function that will stop listening for new transactions when called\n * @public\n */\nfunction watchTransactions(_ref) {\n  let {\n    address,\n    onTransactions,\n    ...sharedBlockParams\n  } = _ref;\n  // compute the toLowerCase address once so we don't have to do it on every block / transaction\n  const lcAddress = address.toLowerCase();\n  function onBlock(block) {\n    const transactions = block.transactions.filter(tx => {\n      var _tx$to;\n      // match on from first because it's guaranteed to exist\n      if (tx.from.toLowerCase() === lcAddress) {\n        // if we have a from address match on that then return true and early exit\n        return true;\n      }\n      // if we have a to address match on that and if it doesn't match then we want to return false anyways :)\n      return ((_tx$to = tx.to) === null || _tx$to === void 0 ? void 0 : _tx$to.toLowerCase()) === lcAddress;\n    });\n    // only call the callback if we have transactions to report\n    if (transactions.length > 0) {\n      onTransactions(transactions);\n    }\n  }\n  return watchBlockWithTransactions({\n    ...sharedBlockParams,\n    onBlock\n  });\n}\nexport { getContractFromAbi as a, getChainId as b, getBlock as c, getBlockNumber as d, getBlockWithTransactions as e, watchBlockNumber as f, getContract as g, watchBlockWithTransactions as h, watchTransactions as i, watchBlock as w };","map":{"version":3,"names":["d4","getSignerAndProvider","cL","resolveAddress","dz","SmartContract","dA","getCompositePluginABI","e","AbiSchema","dm","getContractTypeForRemoteName","dy","ContractPublisher","dj","PREBUILT_CONTRACTS_MAP","ThirdwebStorage","IThirdwebContractABI","Contract","utils","STORAGE_CACHE","CONTRACT_CACHE","Map","getContractCacheKey","address","chainId","concat","inContractCache","cacheKey","has","getCachedContract","Error","get","cacheContract","contract","set","getCachedStorage","storage","getContractFromAbi","params","signer","provider","network","sdkOptions","resolvedAddress","Promise","all","getNetwork","parsedAbi","abi","JSON","parse","resolveContractType","remoteContractType","toUtf8String","contractType","replace","err","getContract","contractTypeOrAbi","publisher","metadata","fetchCompilerMetadataFromAddress","getAbi","initialize","CHAIN_ID_CACHE","WeakMap","getChainId","chainIdPromise","then","catch","delete","getBlockNumber","BLOCK_PROMISE_CACHE","getBlock","blockTag","block","blockPromise","BLOCK_WITH_TRANSACTIONS_PROMISE_CACHE","getBlockWithTransactions","watchBlockNumber","on","onBlockNumber","off","watchBlock","_ref","onBlock","sharedBlockParams","blockNumber","watchBlockWithTransactions","_ref2","watchTransactions","onTransactions","lcAddress","toLowerCase","transactions","filter","tx","_tx$to","from","to","length","a","b","c","d","f","g","h","i","w"],"sources":["C:/Misc/Documents/Career/FinTech/BlockChain/FrontEnd/buildspace-dao-starter/node_modules/@thirdweb-dev/sdk/dist/watchTransactions-5ab9ecc7.browser.esm.js"],"sourcesContent":["import { d4 as getSignerAndProvider, cL as resolveAddress, dz as SmartContract, dA as getCompositePluginABI, e as AbiSchema, dm as getContractTypeForRemoteName, dy as ContractPublisher, dj as PREBUILT_CONTRACTS_MAP } from './contract-publisher-1ff1fe07.browser.esm.js';\nimport { ThirdwebStorage } from '@thirdweb-dev/storage';\nimport IThirdwebContractABI from '@thirdweb-dev/contracts-js/dist/abis/IThirdwebContract.json';\nimport { Contract, utils } from 'ethers';\n\nlet STORAGE_CACHE = new ThirdwebStorage();\nconst CONTRACT_CACHE = new Map();\nfunction getContractCacheKey(address, chainId) {\n  return `${address}-${chainId}`;\n}\nfunction inContractCache(address, chainId) {\n  const cacheKey = getContractCacheKey(address, chainId);\n  return CONTRACT_CACHE.has(cacheKey);\n}\nfunction getCachedContract(address, chainId) {\n  if (!inContractCache(address, chainId)) {\n    throw new Error(`Contract ${address} was not found in cache`);\n  }\n  const cacheKey = getContractCacheKey(address, chainId);\n  return CONTRACT_CACHE.get(cacheKey);\n}\nfunction cacheContract(contract, address, chainId) {\n  const cacheKey = getContractCacheKey(address, chainId);\n  CONTRACT_CACHE.set(cacheKey, contract);\n}\nfunction getCachedStorage(storage) {\n  return storage || STORAGE_CACHE;\n}\n\nasync function getContractFromAbi(params) {\n  const [signer, provider] = getSignerAndProvider(params.network, params.sdkOptions);\n  const [resolvedAddress, {\n    chainId\n  }] = await Promise.all([resolveAddress(params.address), provider.getNetwork()]);\n  if (inContractCache(resolvedAddress, chainId)) {\n    return getCachedContract(resolvedAddress, chainId);\n  }\n  const parsedAbi = typeof params.abi === \"string\" ? JSON.parse(params.abi) : params.abi;\n  const contract = new SmartContract(signer || provider, resolvedAddress, await getCompositePluginABI(resolvedAddress, AbiSchema.parse(parsedAbi), provider, params.sdkOptions, getCachedStorage(params.storage)), getCachedStorage(params.storage), params.sdkOptions, chainId);\n  cacheContract(contract, resolvedAddress, chainId);\n  return contract;\n}\n\nasync function resolveContractType(params) {\n  try {\n    const contract = new Contract(params.address, IThirdwebContractABI, params.provider);\n    const remoteContractType = utils.toUtf8String(await contract.contractType())\n    // eslint-disable-next-line no-control-regex\n    .replace(/\\x00/g, \"\");\n    return getContractTypeForRemoteName(remoteContractType);\n  } catch (err) {\n    return \"custom\";\n  }\n}\n\nasync function getContract(params) {\n  const [signer, provider] = getSignerAndProvider(params.network, params.sdkOptions);\n  const [resolvedAddress, {\n    chainId\n  }] = await Promise.all([resolveAddress(params.address), provider.getNetwork()]);\n  if (inContractCache(resolvedAddress, chainId)) {\n    return getCachedContract(resolvedAddress, chainId);\n  }\n  if (!params.contractTypeOrAbi || params.contractTypeOrAbi === \"custom\") {\n    const contractType = await resolveContractType({\n      address: resolvedAddress,\n      provider\n    });\n    if (contractType === \"custom\") {\n      const publisher = new ContractPublisher(params.network, params.sdkOptions, getCachedStorage(params.storage));\n      try {\n        const metadata = await publisher.fetchCompilerMetadataFromAddress(resolvedAddress);\n        return getContractFromAbi({\n          ...params,\n          address: resolvedAddress,\n          abi: metadata.abi\n        });\n      } catch {\n        throw new Error(`No ABI found for this contract. Try importing it by visiting: https://thirdweb.com/${chainId}/${resolvedAddress}`);\n      }\n    } else {\n      const abi = await PREBUILT_CONTRACTS_MAP[contractType].getAbi(resolvedAddress, provider, getCachedStorage(params.storage));\n      return getContractFromAbi({\n        ...params,\n        address: resolvedAddress,\n        abi\n      });\n    }\n  } else if (typeof params.contractTypeOrAbi === \"string\" && params.contractTypeOrAbi in PREBUILT_CONTRACTS_MAP) {\n    const contract = await PREBUILT_CONTRACTS_MAP[params.contractTypeOrAbi].initialize(signer || provider, resolvedAddress, getCachedStorage(params.storage), params.sdkOptions);\n    cacheContract(contract, resolvedAddress, chainId);\n    return contract;\n  } else {\n    return getContractFromAbi({\n      ...params,\n      address: resolvedAddress,\n      abi: params.contractTypeOrAbi\n    });\n  }\n}\n\n// weakmap because if we GC the provider somewhere else we don't need to hold onto the promise anymore\nconst CHAIN_ID_CACHE = new WeakMap();\n\n/**\n * A function that returns the chainId for a given network input + sdk options combination.\n * This function will cache the promise for the chainId so that it can be reused.\n * You can call this function multiple times with the same params and it will only make one request to the provider.\n *\n * @returns the ChainId\n * @internal\n */\nasync function getChainId(params) {\n  const [, provider] = getSignerAndProvider(params.network, params.sdkOptions);\n  let chainIdPromise;\n  // if we already have a promise for the chainId, use that\n  if (CHAIN_ID_CACHE.has(provider)) {\n    chainIdPromise = CHAIN_ID_CACHE.get(provider);\n  } else {\n    chainIdPromise = provider.getNetwork()\n    // we only want the chainId\n    .then(network => network.chainId).catch(err => {\n      // in the case where the provider fails we should remove the promise from the cache so we can try again\n      CHAIN_ID_CACHE.delete(provider);\n      // also re-throw the error so downstream can handle it\n      throw err;\n    });\n    CHAIN_ID_CACHE.set(provider, chainIdPromise);\n  }\n\n  // finally await the promise (will resolve immediately if already in cache and resolved)\n  return await chainIdPromise;\n}\n\n/**\n * Get the latest block number from a given network.\n *\n * @example\n * ```javascript\n * const block = await getBlockNumber({\n *  network: \"ethereum\"\n * });\n * ```\n * @returns the latest block number\n * @public\n */\nasync function getBlockNumber(params) {\n  const [, provider] = getSignerAndProvider(params.network, params.sdkOptions);\n  return provider.getBlockNumber();\n}\nconst BLOCK_PROMISE_CACHE = new Map();\n/**\n * Get a specific block from a given network.\n *\n * @example\n * ```javascript\n * const block = await getBlock({\n *  network: \"ethereum\",\n *  block: 12345678\n * });\n * ```\n *\n * @returns the block for the given block number / block tag\n * @public\n */\nasync function getBlock(params) {\n  // first off get the chainId so we can check if we have something in cache for the blockNumber already\n  // this is 1 extra call once per possible provider\n  const chainId = await getChainId(params);\n  const blockTag = params.block;\n  const cacheKey = `${chainId}_${blockTag}`;\n  let blockPromise;\n  if (BLOCK_PROMISE_CACHE.has(cacheKey)) {\n    blockPromise = BLOCK_PROMISE_CACHE.get(cacheKey);\n  } else {\n    const [, provider] = getSignerAndProvider(params.network, params.sdkOptions);\n    blockPromise = provider.getBlock(blockTag).catch(err => {\n      // in the case where the call fails we should remove the promise from the cache so we can try again\n      BLOCK_PROMISE_CACHE.delete(cacheKey);\n      // also re-throw the error so downstream can handle it\n      throw err;\n    });\n    BLOCK_PROMISE_CACHE.set(cacheKey, blockPromise);\n  }\n\n  // finally await the promise (will resolve immediately if already in cache and resolved)\n  return await blockPromise;\n}\nconst BLOCK_WITH_TRANSACTIONS_PROMISE_CACHE = new Map();\n/**\n * Get a specific block (with the transactions contained in it) from a given network.\n *\n * @example\n * ```javascript\n * const block = await getBlockWithTransactions({\n *  network: \"ethereum\",\n *  block: 12345678\n * });\n * ```\n *\n * @returns the block for the given block number / block tag\n * @public\n */\nasync function getBlockWithTransactions(params) {\n  // first off get the chainId so we can check if we have something in cache for the blockNumber already\n  // this is 1 extra call once per possible provider\n  const chainId = await getChainId(params);\n  const blockTag = params.block;\n  const cacheKey = `${chainId}_${blockTag}`;\n  let blockPromise;\n  if (BLOCK_PROMISE_CACHE.has(cacheKey)) {\n    blockPromise = BLOCK_WITH_TRANSACTIONS_PROMISE_CACHE.get(cacheKey);\n  } else {\n    const [, provider] = getSignerAndProvider(params.network, params.sdkOptions);\n    blockPromise = provider.getBlockWithTransactions(blockTag).catch(err => {\n      // in the case where the call fails we should remove the promise from the cache so we can try again\n      BLOCK_WITH_TRANSACTIONS_PROMISE_CACHE.delete(cacheKey);\n      // also re-throw the error so downstream can handle it\n      throw err;\n    });\n    BLOCK_WITH_TRANSACTIONS_PROMISE_CACHE.set(cacheKey, blockPromise);\n  }\n\n  // finally await the promise (will resolve immediately if already in cache and resolved)\n  return await blockPromise;\n}\n\n/**\n * Watch for a new block number on a given network.\n *\n * @example\n * ```javascript\n * // this will log out the new block number every time a new block is finalized\n * const unsubscribe = watchBlockNumber({\n *   network: \"ethereum\",\n *   onBlockNumber: (blockNumber) => {\n *     console.log(\"new block number\", blockNumber);\n *   }\n * });\n * // later on you can call unsubscribe to stop listening for new blocks\n * unsubscribe();\n * ```\n *\n * @returns an unsubscribe function that will stop listening for new blocks when called\n * @public\n */\nfunction watchBlockNumber(params) {\n  const [, provider] = getSignerAndProvider(params.network, params.sdkOptions);\n  // start listening\n  provider.on(\"block\", params.onBlockNumber);\n  // return a function that unsubscribes the listener\n  return () => {\n    provider.off(\"block\", params.onBlockNumber);\n  };\n}\n/**\n * Watch for new blocks on a given network.\n *\n * @example\n * ```javascript\n * // this will log out the new block every time a new block is finalized\n * const unsubscribe = watchBlock({\n *   network: \"ethereum\",\n *   onBlock: (block) => {\n *     console.log(\"new block\", block);\n *   }\n * });\n * // later on you can call unsubscribe to stop listening for new blocks\n * unsubscribe();\n * ```\n *\n * @returns an unsubscribe function that will stop listening for new blocks when called\n * @public\n */\nfunction watchBlock(_ref) {\n  let {\n    onBlock,\n    ...sharedBlockParams\n  } = _ref;\n  async function onBlockNumber(blockNumber) {\n    try {\n      onBlock(await getBlock({\n        block: blockNumber,\n        ...sharedBlockParams\n      }));\n    } catch (err) {\n      // skip the block I guess?\n    }\n  }\n  // start listening and return the unsubscribe function from within watchBlockNumber\n  return watchBlockNumber({\n    ...sharedBlockParams,\n    onBlockNumber\n  });\n}\n/**\n * Watch for new blocks on a given network. (Includes parsed transactions)\n *\n * @example\n * ```javascript\n * // this will log out the new block every time a new block is finalized\n * const unsubscribe = watchBlockWithTransactions({\n *   network: \"ethereum\",\n *   onBlock: (block) => {\n *     console.log(\"new block\", block);\n *     console.log(\"new transactions\", block.transactions)\n *   }\n * });\n * // later on you can call unsubscribe to stop listening for new blocks\n * unsubscribe();\n *\n * @returns an unsubscribe function that will stop listening for new blocks when called\n * @public\n */\nfunction watchBlockWithTransactions(_ref2) {\n  let {\n    onBlock,\n    ...sharedBlockParams\n  } = _ref2;\n  async function onBlockNumber(blockNumber) {\n    try {\n      onBlock(await getBlockWithTransactions({\n        block: blockNumber,\n        ...sharedBlockParams\n      }));\n    } catch (err) {\n      // skip the block I guess?\n    }\n  }\n  // start listening and return the unsubscribe function from within watchBlockNumber\n  return watchBlockNumber({\n    ...sharedBlockParams,\n    onBlockNumber\n  });\n}\n\n/**\n * Watch for transactions to or from a given address.\n *\n * @example\n * ```javascript\n * // this will log out the new transactions every time a new block is finalized\n * const unsubscribe = watchTransactions({\n *   network: \"ethereum\",\n *   address: \"0x1234\",\n *   onTransactions: (transactions) => {\n *     console.log(\"new transactions\", transactions);\n *   }\n * });\n * // later on you can call unsubscribe to stop listening for new transactions\n * unsubscribe();\n * ```\n *\n * @returns an unsubscribe function that will stop listening for new transactions when called\n * @public\n */\nfunction watchTransactions(_ref) {\n  let {\n    address,\n    onTransactions,\n    ...sharedBlockParams\n  } = _ref;\n  // compute the toLowerCase address once so we don't have to do it on every block / transaction\n  const lcAddress = address.toLowerCase();\n  function onBlock(block) {\n    const transactions = block.transactions.filter(tx => {\n      // match on from first because it's guaranteed to exist\n      if (tx.from.toLowerCase() === lcAddress) {\n        // if we have a from address match on that then return true and early exit\n        return true;\n      }\n      // if we have a to address match on that and if it doesn't match then we want to return false anyways :)\n      return tx.to?.toLowerCase() === lcAddress;\n    });\n    // only call the callback if we have transactions to report\n    if (transactions.length > 0) {\n      onTransactions(transactions);\n    }\n  }\n  return watchBlockWithTransactions({\n    ...sharedBlockParams,\n    onBlock\n  });\n}\n\nexport { getContractFromAbi as a, getChainId as b, getBlock as c, getBlockNumber as d, getBlockWithTransactions as e, watchBlockNumber as f, getContract as g, watchBlockWithTransactions as h, watchTransactions as i, watchBlock as w };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}