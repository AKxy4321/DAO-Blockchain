{"ast":null,"code":"import { _ as _classPrivateFieldInitSpec, a as _classPrivateFieldSet, b as _classPrivateFieldGet } from '../../../../dist/classPrivateFieldSet-a5db7c83.browser.esm.js';\nimport { _ as _defineProperty } from '../../../../dist/defineProperty-c8ecdc07.browser.esm.js';\nimport { ethers, utils } from 'ethers';\nimport { OAuthExtension } from '@magic-ext/oauth';\nimport { Magic } from 'magic-sdk';\nimport { W as WagmiConnector } from '../../../../dist/WagmiConnector-2f14002d.browser.esm.js';\nimport { n as normalizeChainId } from '../../../../dist/normalizeChainId-e4cc0175.browser.esm.js';\nimport '@thirdweb-dev/chains';\nimport 'eventemitter3';\nconst IS_SERVER = \"object\" === \"undefined\";\nclass MagicBaseConnector extends WagmiConnector {\n  constructor(config) {\n    super(config);\n    _defineProperty(this, \"id\", \"magic-link\");\n    _defineProperty(this, \"name\", \"Magic Link\");\n    _defineProperty(this, \"ready\", !IS_SERVER);\n    this.magicOptions = config.options;\n  }\n  async getAccount() {\n    const provider = new ethers.providers.Web3Provider(await this.getProvider()) // TODO: fix type mismatch\n    ;\n\n    const signer = provider.getSigner();\n    const account = await signer.getAddress();\n    if (account.startsWith(\"0x\")) {\n      return account;\n    }\n    return \"0x\".concat(account);\n  }\n  async getProvider() {\n    if (this.provider) {\n      return this.provider;\n    }\n    const magic = this.getMagicSDK();\n    this.provider = magic.rpcProvider;\n    return this.provider;\n  }\n  async getSigner() {\n    const provider = new ethers.providers.Web3Provider(await this.getProvider()) // TODO: fix type mismatch\n    ;\n\n    const signer = await provider.getSigner();\n    return signer;\n  }\n  async isAuthorized() {\n    const magic = this.getMagicSDK();\n    try {\n      return await magic.user.isLoggedIn();\n    } catch (e) {\n      return false;\n    }\n  }\n  onAccountsChanged(accounts) {\n    if (accounts.length === 0) {\n      this.emit(\"disconnect\");\n    } else {\n      if (accounts[0]) {\n        this.emit(\"change\", {\n          account: utils.getAddress(accounts[0])\n        });\n      }\n    }\n  }\n  onChainChanged(chainId) {\n    const id = normalizeChainId(chainId);\n    const unsupported = this.isChainUnsupported(id);\n    this.emit(\"change\", {\n      chain: {\n        id,\n        unsupported\n      }\n    });\n  }\n  onDisconnect() {\n    this.emit(\"disconnect\");\n  }\n  async disconnect() {\n    const magic = this.getMagicSDK();\n    await magic.user.logout();\n  }\n}\nvar _connectedChainId = /*#__PURE__*/new WeakMap();\nvar _type = /*#__PURE__*/new WeakMap();\nclass MagicAuthConnector extends MagicBaseConnector {\n  constructor(config) {\n    var _config$options$oauth, _config$options$oauth2;\n    super(config);\n    _classPrivateFieldInitSpec(this, _connectedChainId, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _type, {\n      writable: true,\n      value: void 0\n    });\n    this.magicSdkConfiguration = config.options.magicSdkConfiguration;\n    _classPrivateFieldSet(this, _type, config.options.type);\n    this.oauthProviders = ((_config$options$oauth = config.options.oauthOptions) === null || _config$options$oauth === void 0 ? void 0 : _config$options$oauth.providers) || [];\n    this.oauthRedirectURI = (_config$options$oauth2 = config.options.oauthOptions) === null || _config$options$oauth2 === void 0 ? void 0 : _config$options$oauth2.redirectURI;\n  }\n  async connect(options) {\n    if (!this.magicOptions.apiKey) {\n      throw new Error(\"Magic API Key is not provided.\");\n    }\n    try {\n      if (options.chainId) {\n        this.initializeMagicSDK({\n          chainId: options.chainId\n        });\n      }\n      const provider = await this.getProvider();\n      this.setupListeners();\n      this.emit(\"message\", {\n        type: \"connecting\"\n      });\n\n      // Check if there is a user logged in\n      const isAuthenticated = await this.isAuthorized();\n\n      // Check if we have a chainId, in case of error just assign 0 for legacy\n      let chainId;\n      try {\n        chainId = await this.getChainId();\n      } catch (e) {\n        chainId = 0;\n      }\n      _classPrivateFieldSet(this, _connectedChainId, chainId);\n\n      // if there is a user logged in, return the user\n      if (isAuthenticated) {\n        return {\n          provider,\n          chain: {\n            id: chainId,\n            unsupported: false\n          },\n          account: await this.getAccount()\n        };\n      }\n      const magic = this.getMagicSDK();\n      if (_classPrivateFieldGet(this, _type) === \"connect\") {\n        if (\"email\" in options || \"phoneNumber\" in options) {\n          console.warn(\"Passing email or phoneNumber is not required for Magic Connect\");\n        }\n        await magic.wallet.connectWithUI();\n      } else {\n        // LOGIN WITH MAGIC LINK WITH OAUTH PROVIDER\n        if (\"oauthProvider\" in options) {\n          await magic.oauth.loginWithRedirect({\n            provider: options.oauthProvider,\n            redirectURI: this.oauthRedirectURI || window.location.href\n          });\n          await new Promise(res => {\n            // never resolve - to keep the app in \"connecting...\" state until the redirect happens\n            setTimeout(res, 10000); // timeout if takes if redirect doesn't happen for 10 seconds (will likely never happen)\n          });\n        }\n\n        // LOGIN WITH MAGIC LINK WITH EMAIL\n        else if (\"email\" in options) {\n          await magic.auth.loginWithMagicLink({\n            email: options.email,\n            showUI: true\n          });\n        }\n\n        // LOGIN WITH MAGIC LINK WITH PHONE NUMBER\n        else if (\"phoneNumber\" in options) {\n          await magic.auth.loginWithSMS({\n            phoneNumber: options.phoneNumber\n          });\n        }\n\n        // error\n        else {\n          throw new Error(\"Invalid options: Either provide and email, phoneNumber or oauthProvider when using Magic Auth\");\n        }\n      }\n      const signer = await this.getSigner();\n      let account = await signer.getAddress();\n      if (!account.startsWith(\"0x\")) {\n        account = \"0x\".concat(account);\n      }\n      return {\n        account,\n        chain: {\n          id: chainId,\n          unsupported: false\n        },\n        provider\n      };\n\n      // throw new UserRejectedRequestError(\"User rejected request\");\n    } catch (error) {\n      console.error(error);\n      throw new Error(\"Something went wrong\");\n    }\n  }\n  async getChainId() {\n    var _this$magicSdkConfigu;\n    const networkOptions = (_this$magicSdkConfigu = this.magicSdkConfiguration) === null || _this$magicSdkConfigu === void 0 ? void 0 : _this$magicSdkConfigu.network;\n    if (typeof networkOptions === \"object\") {\n      const chainID = networkOptions.chainId;\n      if (chainID) {\n        return normalizeChainId(chainID);\n      }\n    }\n    throw new Error(\"Chain ID is not defined\");\n  }\n  initializeMagicSDK() {\n    let {\n      chainId\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const options = {\n      ...this.magicSdkConfiguration,\n      extensions: [new OAuthExtension()]\n    };\n    if (chainId) {\n      const chain = this.chains.find(c => c.chainId === chainId);\n      if (chain) {\n        options.network = {\n          rpcUrl: chain.rpc[0] || \"\",\n          // TODO handle empty RPC array\n          chainId: chain.chainId\n        };\n      }\n    }\n    this.magicSDK = new Magic(this.magicOptions.apiKey, options);\n    this.provider = this.magicSDK.rpcProvider;\n    return this.magicSDK;\n  }\n  getMagicSDK() {\n    if (!this.magicSDK) {\n      return this.initializeMagicSDK();\n    }\n    return this.magicSDK;\n  }\n  async setupListeners() {\n    const provider = await this.getProvider();\n    provider.on(\"accountsChanged\", this.onAccountsChanged);\n    provider.on(\"chainChanged\", this.onChainChanged);\n    provider.on(\"disconnect\", this.onDisconnect);\n  }\n  async switchChain(chainId) {\n    const chain = this.chains.find(c => c.chainId === chainId);\n    if (!chain) {\n      throw new Error(\"Chain not found\");\n    }\n    if (_classPrivateFieldGet(this, _connectedChainId) !== chainId) {\n      this.initializeMagicSDK({\n        chainId\n      });\n    }\n    return chain;\n  }\n}\nexport { MagicAuthConnector, MagicBaseConnector };","map":{"version":3,"names":["_","_classPrivateFieldInitSpec","a","_classPrivateFieldSet","b","_classPrivateFieldGet","_defineProperty","ethers","utils","OAuthExtension","Magic","W","WagmiConnector","n","normalizeChainId","IS_SERVER","MagicBaseConnector","constructor","config","magicOptions","options","getAccount","provider","providers","Web3Provider","getProvider","signer","getSigner","account","getAddress","startsWith","concat","magic","getMagicSDK","rpcProvider","isAuthorized","user","isLoggedIn","e","onAccountsChanged","accounts","length","emit","onChainChanged","chainId","id","unsupported","isChainUnsupported","chain","onDisconnect","disconnect","logout","_connectedChainId","WeakMap","_type","MagicAuthConnector","_config$options$oauth","_config$options$oauth2","writable","value","magicSdkConfiguration","type","oauthProviders","oauthOptions","oauthRedirectURI","redirectURI","connect","apiKey","Error","initializeMagicSDK","setupListeners","isAuthenticated","getChainId","console","warn","wallet","connectWithUI","oauth","loginWithRedirect","oauthProvider","window","location","href","Promise","res","setTimeout","auth","loginWithMagicLink","email","showUI","loginWithSMS","phoneNumber","error","_this$magicSdkConfigu","networkOptions","network","chainID","arguments","undefined","extensions","chains","find","c","rpcUrl","rpc","magicSDK","on","switchChain"],"sources":["C:/Misc/Documents/Career/FinTech/BlockChain/FrontEnd/buildspace-dao-starter/node_modules/@thirdweb-dev/react-core/node_modules/@thirdweb-dev/wallets/evm/connectors/magic/dist/thirdweb-dev-wallets-evm-connectors-magic.browser.esm.js"],"sourcesContent":["import { _ as _classPrivateFieldInitSpec, a as _classPrivateFieldSet, b as _classPrivateFieldGet } from '../../../../dist/classPrivateFieldSet-a5db7c83.browser.esm.js';\nimport { _ as _defineProperty } from '../../../../dist/defineProperty-c8ecdc07.browser.esm.js';\nimport { ethers, utils } from 'ethers';\nimport { OAuthExtension } from '@magic-ext/oauth';\nimport { Magic } from 'magic-sdk';\nimport { W as WagmiConnector } from '../../../../dist/WagmiConnector-2f14002d.browser.esm.js';\nimport { n as normalizeChainId } from '../../../../dist/normalizeChainId-e4cc0175.browser.esm.js';\nimport '@thirdweb-dev/chains';\nimport 'eventemitter3';\n\nconst IS_SERVER = \"object\" === \"undefined\";\nclass MagicBaseConnector extends WagmiConnector {\n  constructor(config) {\n    super(config);\n    _defineProperty(this, \"id\", \"magic-link\");\n    _defineProperty(this, \"name\", \"Magic Link\");\n    _defineProperty(this, \"ready\", !IS_SERVER);\n    this.magicOptions = config.options;\n  }\n  async getAccount() {\n    const provider = new ethers.providers.Web3Provider(await this.getProvider()) // TODO: fix type mismatch\n    ;\n\n    const signer = provider.getSigner();\n    const account = await signer.getAddress();\n    if (account.startsWith(\"0x\")) {\n      return account;\n    }\n    return `0x${account}`;\n  }\n  async getProvider() {\n    if (this.provider) {\n      return this.provider;\n    }\n    const magic = this.getMagicSDK();\n    this.provider = magic.rpcProvider;\n    return this.provider;\n  }\n  async getSigner() {\n    const provider = new ethers.providers.Web3Provider(await this.getProvider()) // TODO: fix type mismatch\n    ;\n\n    const signer = await provider.getSigner();\n    return signer;\n  }\n  async isAuthorized() {\n    const magic = this.getMagicSDK();\n    try {\n      return await magic.user.isLoggedIn();\n    } catch (e) {\n      return false;\n    }\n  }\n  onAccountsChanged(accounts) {\n    if (accounts.length === 0) {\n      this.emit(\"disconnect\");\n    } else {\n      if (accounts[0]) {\n        this.emit(\"change\", {\n          account: utils.getAddress(accounts[0])\n        });\n      }\n    }\n  }\n  onChainChanged(chainId) {\n    const id = normalizeChainId(chainId);\n    const unsupported = this.isChainUnsupported(id);\n    this.emit(\"change\", {\n      chain: {\n        id,\n        unsupported\n      }\n    });\n  }\n  onDisconnect() {\n    this.emit(\"disconnect\");\n  }\n  async disconnect() {\n    const magic = this.getMagicSDK();\n    await magic.user.logout();\n  }\n}\nvar _connectedChainId = /*#__PURE__*/new WeakMap();\nvar _type = /*#__PURE__*/new WeakMap();\nclass MagicAuthConnector extends MagicBaseConnector {\n  constructor(config) {\n    super(config);\n    _classPrivateFieldInitSpec(this, _connectedChainId, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _type, {\n      writable: true,\n      value: void 0\n    });\n    this.magicSdkConfiguration = config.options.magicSdkConfiguration;\n    _classPrivateFieldSet(this, _type, config.options.type);\n    this.oauthProviders = config.options.oauthOptions?.providers || [];\n    this.oauthRedirectURI = config.options.oauthOptions?.redirectURI;\n  }\n  async connect(options) {\n    if (!this.magicOptions.apiKey) {\n      throw new Error(\"Magic API Key is not provided.\");\n    }\n    try {\n      if (options.chainId) {\n        this.initializeMagicSDK({\n          chainId: options.chainId\n        });\n      }\n      const provider = await this.getProvider();\n      this.setupListeners();\n      this.emit(\"message\", {\n        type: \"connecting\"\n      });\n\n      // Check if there is a user logged in\n      const isAuthenticated = await this.isAuthorized();\n\n      // Check if we have a chainId, in case of error just assign 0 for legacy\n      let chainId;\n      try {\n        chainId = await this.getChainId();\n      } catch (e) {\n        chainId = 0;\n      }\n      _classPrivateFieldSet(this, _connectedChainId, chainId);\n\n      // if there is a user logged in, return the user\n      if (isAuthenticated) {\n        return {\n          provider,\n          chain: {\n            id: chainId,\n            unsupported: false\n          },\n          account: await this.getAccount()\n        };\n      }\n      const magic = this.getMagicSDK();\n      if (_classPrivateFieldGet(this, _type) === \"connect\") {\n        if (\"email\" in options || \"phoneNumber\" in options) {\n          console.warn(\"Passing email or phoneNumber is not required for Magic Connect\");\n        }\n        await magic.wallet.connectWithUI();\n      } else {\n        // LOGIN WITH MAGIC LINK WITH OAUTH PROVIDER\n        if (\"oauthProvider\" in options) {\n          await magic.oauth.loginWithRedirect({\n            provider: options.oauthProvider,\n            redirectURI: this.oauthRedirectURI || window.location.href\n          });\n          await new Promise(res => {\n            // never resolve - to keep the app in \"connecting...\" state until the redirect happens\n            setTimeout(res, 10000); // timeout if takes if redirect doesn't happen for 10 seconds (will likely never happen)\n          });\n        }\n\n        // LOGIN WITH MAGIC LINK WITH EMAIL\n        else if (\"email\" in options) {\n          await magic.auth.loginWithMagicLink({\n            email: options.email,\n            showUI: true\n          });\n        }\n\n        // LOGIN WITH MAGIC LINK WITH PHONE NUMBER\n        else if (\"phoneNumber\" in options) {\n          await magic.auth.loginWithSMS({\n            phoneNumber: options.phoneNumber\n          });\n        }\n\n        // error\n        else {\n          throw new Error(\"Invalid options: Either provide and email, phoneNumber or oauthProvider when using Magic Auth\");\n        }\n      }\n      const signer = await this.getSigner();\n      let account = await signer.getAddress();\n      if (!account.startsWith(\"0x\")) {\n        account = `0x${account}`;\n      }\n      return {\n        account,\n        chain: {\n          id: chainId,\n          unsupported: false\n        },\n        provider\n      };\n\n      // throw new UserRejectedRequestError(\"User rejected request\");\n    } catch (error) {\n      console.error(error);\n      throw new Error(\"Something went wrong\");\n    }\n  }\n  async getChainId() {\n    const networkOptions = this.magicSdkConfiguration?.network;\n    if (typeof networkOptions === \"object\") {\n      const chainID = networkOptions.chainId;\n      if (chainID) {\n        return normalizeChainId(chainID);\n      }\n    }\n    throw new Error(\"Chain ID is not defined\");\n  }\n  initializeMagicSDK() {\n    let {\n      chainId\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const options = {\n      ...this.magicSdkConfiguration,\n      extensions: [new OAuthExtension()]\n    };\n    if (chainId) {\n      const chain = this.chains.find(c => c.chainId === chainId);\n      if (chain) {\n        options.network = {\n          rpcUrl: chain.rpc[0] || \"\",\n          // TODO handle empty RPC array\n          chainId: chain.chainId\n        };\n      }\n    }\n    this.magicSDK = new Magic(this.magicOptions.apiKey, options);\n    this.provider = this.magicSDK.rpcProvider;\n    return this.magicSDK;\n  }\n  getMagicSDK() {\n    if (!this.magicSDK) {\n      return this.initializeMagicSDK();\n    }\n    return this.magicSDK;\n  }\n  async setupListeners() {\n    const provider = await this.getProvider();\n    provider.on(\"accountsChanged\", this.onAccountsChanged);\n    provider.on(\"chainChanged\", this.onChainChanged);\n    provider.on(\"disconnect\", this.onDisconnect);\n  }\n  async switchChain(chainId) {\n    const chain = this.chains.find(c => c.chainId === chainId);\n    if (!chain) {\n      throw new Error(\"Chain not found\");\n    }\n    if (_classPrivateFieldGet(this, _connectedChainId) !== chainId) {\n      this.initializeMagicSDK({\n        chainId\n      });\n    }\n    return chain;\n  }\n}\n\nexport { MagicAuthConnector, MagicBaseConnector };\n"],"mappings":"AAAA,SAASA,CAAC,IAAIC,0BAA0B,EAAEC,CAAC,IAAIC,qBAAqB,EAAEC,CAAC,IAAIC,qBAAqB,QAAQ,+DAA+D;AACvK,SAASL,CAAC,IAAIM,eAAe,QAAQ,yDAAyD;AAC9F,SAASC,MAAM,EAAEC,KAAK,QAAQ,QAAQ;AACtC,SAASC,cAAc,QAAQ,kBAAkB;AACjD,SAASC,KAAK,QAAQ,WAAW;AACjC,SAASC,CAAC,IAAIC,cAAc,QAAQ,yDAAyD;AAC7F,SAASC,CAAC,IAAIC,gBAAgB,QAAQ,2DAA2D;AACjG,OAAO,sBAAsB;AAC7B,OAAO,eAAe;AAEtB,MAAMC,SAAS,GAAG,QAAQ,KAAK,WAAW;AAC1C,MAAMC,kBAAkB,SAASJ,cAAc,CAAC;EAC9CK,WAAWA,CAACC,MAAM,EAAE;IAClB,KAAK,CAACA,MAAM,CAAC;IACbZ,eAAe,CAAC,IAAI,EAAE,IAAI,EAAE,YAAY,CAAC;IACzCA,eAAe,CAAC,IAAI,EAAE,MAAM,EAAE,YAAY,CAAC;IAC3CA,eAAe,CAAC,IAAI,EAAE,OAAO,EAAE,CAACS,SAAS,CAAC;IAC1C,IAAI,CAACI,YAAY,GAAGD,MAAM,CAACE,OAAO;EACpC;EACA,MAAMC,UAAUA,CAAA,EAAG;IACjB,MAAMC,QAAQ,GAAG,IAAIf,MAAM,CAACgB,SAAS,CAACC,YAAY,CAAC,MAAM,IAAI,CAACC,WAAW,CAAC,CAAC,CAAC,CAAC;IAAA;;IAG7E,MAAMC,MAAM,GAAGJ,QAAQ,CAACK,SAAS,CAAC,CAAC;IACnC,MAAMC,OAAO,GAAG,MAAMF,MAAM,CAACG,UAAU,CAAC,CAAC;IACzC,IAAID,OAAO,CAACE,UAAU,CAAC,IAAI,CAAC,EAAE;MAC5B,OAAOF,OAAO;IAChB;IACA,YAAAG,MAAA,CAAYH,OAAO;EACrB;EACA,MAAMH,WAAWA,CAAA,EAAG;IAClB,IAAI,IAAI,CAACH,QAAQ,EAAE;MACjB,OAAO,IAAI,CAACA,QAAQ;IACtB;IACA,MAAMU,KAAK,GAAG,IAAI,CAACC,WAAW,CAAC,CAAC;IAChC,IAAI,CAACX,QAAQ,GAAGU,KAAK,CAACE,WAAW;IACjC,OAAO,IAAI,CAACZ,QAAQ;EACtB;EACA,MAAMK,SAASA,CAAA,EAAG;IAChB,MAAML,QAAQ,GAAG,IAAIf,MAAM,CAACgB,SAAS,CAACC,YAAY,CAAC,MAAM,IAAI,CAACC,WAAW,CAAC,CAAC,CAAC,CAAC;IAAA;;IAG7E,MAAMC,MAAM,GAAG,MAAMJ,QAAQ,CAACK,SAAS,CAAC,CAAC;IACzC,OAAOD,MAAM;EACf;EACA,MAAMS,YAAYA,CAAA,EAAG;IACnB,MAAMH,KAAK,GAAG,IAAI,CAACC,WAAW,CAAC,CAAC;IAChC,IAAI;MACF,OAAO,MAAMD,KAAK,CAACI,IAAI,CAACC,UAAU,CAAC,CAAC;IACtC,CAAC,CAAC,OAAOC,CAAC,EAAE;MACV,OAAO,KAAK;IACd;EACF;EACAC,iBAAiBA,CAACC,QAAQ,EAAE;IAC1B,IAAIA,QAAQ,CAACC,MAAM,KAAK,CAAC,EAAE;MACzB,IAAI,CAACC,IAAI,CAAC,YAAY,CAAC;IACzB,CAAC,MAAM;MACL,IAAIF,QAAQ,CAAC,CAAC,CAAC,EAAE;QACf,IAAI,CAACE,IAAI,CAAC,QAAQ,EAAE;UAClBd,OAAO,EAAEpB,KAAK,CAACqB,UAAU,CAACW,QAAQ,CAAC,CAAC,CAAC;QACvC,CAAC,CAAC;MACJ;IACF;EACF;EACAG,cAAcA,CAACC,OAAO,EAAE;IACtB,MAAMC,EAAE,GAAG/B,gBAAgB,CAAC8B,OAAO,CAAC;IACpC,MAAME,WAAW,GAAG,IAAI,CAACC,kBAAkB,CAACF,EAAE,CAAC;IAC/C,IAAI,CAACH,IAAI,CAAC,QAAQ,EAAE;MAClBM,KAAK,EAAE;QACLH,EAAE;QACFC;MACF;IACF,CAAC,CAAC;EACJ;EACAG,YAAYA,CAAA,EAAG;IACb,IAAI,CAACP,IAAI,CAAC,YAAY,CAAC;EACzB;EACA,MAAMQ,UAAUA,CAAA,EAAG;IACjB,MAAMlB,KAAK,GAAG,IAAI,CAACC,WAAW,CAAC,CAAC;IAChC,MAAMD,KAAK,CAACI,IAAI,CAACe,MAAM,CAAC,CAAC;EAC3B;AACF;AACA,IAAIC,iBAAiB,GAAG,aAAa,IAAIC,OAAO,CAAC,CAAC;AAClD,IAAIC,KAAK,GAAG,aAAa,IAAID,OAAO,CAAC,CAAC;AACtC,MAAME,kBAAkB,SAASvC,kBAAkB,CAAC;EAClDC,WAAWA,CAACC,MAAM,EAAE;IAAA,IAAAsC,qBAAA,EAAAC,sBAAA;IAClB,KAAK,CAACvC,MAAM,CAAC;IACbjB,0BAA0B,CAAC,IAAI,EAAEmD,iBAAiB,EAAE;MAClDM,QAAQ,EAAE,IAAI;MACdC,KAAK,EAAE,KAAK;IACd,CAAC,CAAC;IACF1D,0BAA0B,CAAC,IAAI,EAAEqD,KAAK,EAAE;MACtCI,QAAQ,EAAE,IAAI;MACdC,KAAK,EAAE,KAAK;IACd,CAAC,CAAC;IACF,IAAI,CAACC,qBAAqB,GAAG1C,MAAM,CAACE,OAAO,CAACwC,qBAAqB;IACjEzD,qBAAqB,CAAC,IAAI,EAAEmD,KAAK,EAAEpC,MAAM,CAACE,OAAO,CAACyC,IAAI,CAAC;IACvD,IAAI,CAACC,cAAc,GAAG,EAAAN,qBAAA,GAAAtC,MAAM,CAACE,OAAO,CAAC2C,YAAY,cAAAP,qBAAA,uBAA3BA,qBAAA,CAA6BjC,SAAS,KAAI,EAAE;IAClE,IAAI,CAACyC,gBAAgB,IAAAP,sBAAA,GAAGvC,MAAM,CAACE,OAAO,CAAC2C,YAAY,cAAAN,sBAAA,uBAA3BA,sBAAA,CAA6BQ,WAAW;EAClE;EACA,MAAMC,OAAOA,CAAC9C,OAAO,EAAE;IACrB,IAAI,CAAC,IAAI,CAACD,YAAY,CAACgD,MAAM,EAAE;MAC7B,MAAM,IAAIC,KAAK,CAAC,gCAAgC,CAAC;IACnD;IACA,IAAI;MACF,IAAIhD,OAAO,CAACwB,OAAO,EAAE;QACnB,IAAI,CAACyB,kBAAkB,CAAC;UACtBzB,OAAO,EAAExB,OAAO,CAACwB;QACnB,CAAC,CAAC;MACJ;MACA,MAAMtB,QAAQ,GAAG,MAAM,IAAI,CAACG,WAAW,CAAC,CAAC;MACzC,IAAI,CAAC6C,cAAc,CAAC,CAAC;MACrB,IAAI,CAAC5B,IAAI,CAAC,SAAS,EAAE;QACnBmB,IAAI,EAAE;MACR,CAAC,CAAC;;MAEF;MACA,MAAMU,eAAe,GAAG,MAAM,IAAI,CAACpC,YAAY,CAAC,CAAC;;MAEjD;MACA,IAAIS,OAAO;MACX,IAAI;QACFA,OAAO,GAAG,MAAM,IAAI,CAAC4B,UAAU,CAAC,CAAC;MACnC,CAAC,CAAC,OAAOlC,CAAC,EAAE;QACVM,OAAO,GAAG,CAAC;MACb;MACAzC,qBAAqB,CAAC,IAAI,EAAEiD,iBAAiB,EAAER,OAAO,CAAC;;MAEvD;MACA,IAAI2B,eAAe,EAAE;QACnB,OAAO;UACLjD,QAAQ;UACR0B,KAAK,EAAE;YACLH,EAAE,EAAED,OAAO;YACXE,WAAW,EAAE;UACf,CAAC;UACDlB,OAAO,EAAE,MAAM,IAAI,CAACP,UAAU,CAAC;QACjC,CAAC;MACH;MACA,MAAMW,KAAK,GAAG,IAAI,CAACC,WAAW,CAAC,CAAC;MAChC,IAAI5B,qBAAqB,CAAC,IAAI,EAAEiD,KAAK,CAAC,KAAK,SAAS,EAAE;QACpD,IAAI,OAAO,IAAIlC,OAAO,IAAI,aAAa,IAAIA,OAAO,EAAE;UAClDqD,OAAO,CAACC,IAAI,CAAC,gEAAgE,CAAC;QAChF;QACA,MAAM1C,KAAK,CAAC2C,MAAM,CAACC,aAAa,CAAC,CAAC;MACpC,CAAC,MAAM;QACL;QACA,IAAI,eAAe,IAAIxD,OAAO,EAAE;UAC9B,MAAMY,KAAK,CAAC6C,KAAK,CAACC,iBAAiB,CAAC;YAClCxD,QAAQ,EAAEF,OAAO,CAAC2D,aAAa;YAC/Bd,WAAW,EAAE,IAAI,CAACD,gBAAgB,IAAIgB,MAAM,CAACC,QAAQ,CAACC;UACxD,CAAC,CAAC;UACF,MAAM,IAAIC,OAAO,CAACC,GAAG,IAAI;YACvB;YACAC,UAAU,CAACD,GAAG,EAAE,KAAK,CAAC,CAAC,CAAC;UAC1B,CAAC,CAAC;QACJ;;QAEA;QAAA,KACK,IAAI,OAAO,IAAIhE,OAAO,EAAE;UAC3B,MAAMY,KAAK,CAACsD,IAAI,CAACC,kBAAkB,CAAC;YAClCC,KAAK,EAAEpE,OAAO,CAACoE,KAAK;YACpBC,MAAM,EAAE;UACV,CAAC,CAAC;QACJ;;QAEA;QAAA,KACK,IAAI,aAAa,IAAIrE,OAAO,EAAE;UACjC,MAAMY,KAAK,CAACsD,IAAI,CAACI,YAAY,CAAC;YAC5BC,WAAW,EAAEvE,OAAO,CAACuE;UACvB,CAAC,CAAC;QACJ;;QAEA;QAAA,KACK;UACH,MAAM,IAAIvB,KAAK,CAAC,+FAA+F,CAAC;QAClH;MACF;MACA,MAAM1C,MAAM,GAAG,MAAM,IAAI,CAACC,SAAS,CAAC,CAAC;MACrC,IAAIC,OAAO,GAAG,MAAMF,MAAM,CAACG,UAAU,CAAC,CAAC;MACvC,IAAI,CAACD,OAAO,CAACE,UAAU,CAAC,IAAI,CAAC,EAAE;QAC7BF,OAAO,QAAAG,MAAA,CAAQH,OAAO,CAAE;MAC1B;MACA,OAAO;QACLA,OAAO;QACPoB,KAAK,EAAE;UACLH,EAAE,EAAED,OAAO;UACXE,WAAW,EAAE;QACf,CAAC;QACDxB;MACF,CAAC;;MAED;IACF,CAAC,CAAC,OAAOsE,KAAK,EAAE;MACdnB,OAAO,CAACmB,KAAK,CAACA,KAAK,CAAC;MACpB,MAAM,IAAIxB,KAAK,CAAC,sBAAsB,CAAC;IACzC;EACF;EACA,MAAMI,UAAUA,CAAA,EAAG;IAAA,IAAAqB,qBAAA;IACjB,MAAMC,cAAc,IAAAD,qBAAA,GAAG,IAAI,CAACjC,qBAAqB,cAAAiC,qBAAA,uBAA1BA,qBAAA,CAA4BE,OAAO;IAC1D,IAAI,OAAOD,cAAc,KAAK,QAAQ,EAAE;MACtC,MAAME,OAAO,GAAGF,cAAc,CAAClD,OAAO;MACtC,IAAIoD,OAAO,EAAE;QACX,OAAOlF,gBAAgB,CAACkF,OAAO,CAAC;MAClC;IACF;IACA,MAAM,IAAI5B,KAAK,CAAC,yBAAyB,CAAC;EAC5C;EACAC,kBAAkBA,CAAA,EAAG;IACnB,IAAI;MACFzB;IACF,CAAC,GAAGqD,SAAS,CAACxD,MAAM,GAAG,CAAC,IAAIwD,SAAS,CAAC,CAAC,CAAC,KAAKC,SAAS,GAAGD,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;IAC1E,MAAM7E,OAAO,GAAG;MACd,GAAG,IAAI,CAACwC,qBAAqB;MAC7BuC,UAAU,EAAE,CAAC,IAAI1F,cAAc,CAAC,CAAC;IACnC,CAAC;IACD,IAAImC,OAAO,EAAE;MACX,MAAMI,KAAK,GAAG,IAAI,CAACoD,MAAM,CAACC,IAAI,CAACC,CAAC,IAAIA,CAAC,CAAC1D,OAAO,KAAKA,OAAO,CAAC;MAC1D,IAAII,KAAK,EAAE;QACT5B,OAAO,CAAC2E,OAAO,GAAG;UAChBQ,MAAM,EAAEvD,KAAK,CAACwD,GAAG,CAAC,CAAC,CAAC,IAAI,EAAE;UAC1B;UACA5D,OAAO,EAAEI,KAAK,CAACJ;QACjB,CAAC;MACH;IACF;IACA,IAAI,CAAC6D,QAAQ,GAAG,IAAI/F,KAAK,CAAC,IAAI,CAACS,YAAY,CAACgD,MAAM,EAAE/C,OAAO,CAAC;IAC5D,IAAI,CAACE,QAAQ,GAAG,IAAI,CAACmF,QAAQ,CAACvE,WAAW;IACzC,OAAO,IAAI,CAACuE,QAAQ;EACtB;EACAxE,WAAWA,CAAA,EAAG;IACZ,IAAI,CAAC,IAAI,CAACwE,QAAQ,EAAE;MAClB,OAAO,IAAI,CAACpC,kBAAkB,CAAC,CAAC;IAClC;IACA,OAAO,IAAI,CAACoC,QAAQ;EACtB;EACA,MAAMnC,cAAcA,CAAA,EAAG;IACrB,MAAMhD,QAAQ,GAAG,MAAM,IAAI,CAACG,WAAW,CAAC,CAAC;IACzCH,QAAQ,CAACoF,EAAE,CAAC,iBAAiB,EAAE,IAAI,CAACnE,iBAAiB,CAAC;IACtDjB,QAAQ,CAACoF,EAAE,CAAC,cAAc,EAAE,IAAI,CAAC/D,cAAc,CAAC;IAChDrB,QAAQ,CAACoF,EAAE,CAAC,YAAY,EAAE,IAAI,CAACzD,YAAY,CAAC;EAC9C;EACA,MAAM0D,WAAWA,CAAC/D,OAAO,EAAE;IACzB,MAAMI,KAAK,GAAG,IAAI,CAACoD,MAAM,CAACC,IAAI,CAACC,CAAC,IAAIA,CAAC,CAAC1D,OAAO,KAAKA,OAAO,CAAC;IAC1D,IAAI,CAACI,KAAK,EAAE;MACV,MAAM,IAAIoB,KAAK,CAAC,iBAAiB,CAAC;IACpC;IACA,IAAI/D,qBAAqB,CAAC,IAAI,EAAE+C,iBAAiB,CAAC,KAAKR,OAAO,EAAE;MAC9D,IAAI,CAACyB,kBAAkB,CAAC;QACtBzB;MACF,CAAC,CAAC;IACJ;IACA,OAAOI,KAAK;EACd;AACF;AAEA,SAASO,kBAAkB,EAAEvC,kBAAkB"},"metadata":{},"sourceType":"module","externalDependencies":[]}