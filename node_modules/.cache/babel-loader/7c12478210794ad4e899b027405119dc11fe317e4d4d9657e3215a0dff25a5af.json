{"ast":null,"code":"import { Q as QuantitySchema, A as AmountSchema, B as BytesLikeSchema, N as NFTInputOrUriSchema, a as BasisPointsSchema, F as FileOrBufferOrStringSchema, P as PercentSchema, C as CommonNFTOutput, b as CommonNFTInput, D as DEFAULT_QUERY_ALL_COUNT, c as BasicNFTInput, M as MAX_BPS } from './QueryParams-39bcad7a.browser.esm.js';\nimport { z } from 'zod';\nimport { BigNumber, providers, utils, constants, Contract, ContractFactory } from 'ethers';\nimport invariant from 'tiny-invariant';\nimport { v4 } from 'uuid';\nimport { isBrowser as isBrowser$1, isFileOrBuffer, replaceGatewayUrlWithScheme } from '@thirdweb-dev/storage';\nimport ERC165Abi from '@thirdweb-dev/contracts-js/dist/abis/IERC165.json';\nimport IERC721MetadataAbi from '@thirdweb-dev/contracts-js/dist/abis/IERC721Metadata.json';\nimport Erc1155MetadataAbi from '@thirdweb-dev/contracts-js/dist/abis/IERC1155Metadata.json';\nimport ERC20Abi from '@thirdweb-dev/contracts-js/dist/abis/IERC20.json';\nimport IERC20MetadataAbi from '@thirdweb-dev/contracts-js/dist/abis/IERC20Metadata.json';\nimport deepEqual from 'fast-deep-equal';\nimport { MerkleTree } from 'merkletreejs';\nimport IThirdwebContractABI from '@thirdweb-dev/contracts-js/dist/abis/IThirdwebContract.json';\nimport DeprecatedAbi from '@thirdweb-dev/contracts-js/dist/abis/IDelayedRevealDeprecated.json';\nimport Erc1155Abi from '@thirdweb-dev/contracts-js/dist/abis/IERC1155.json';\nimport Erc721Abi from '@thirdweb-dev/contracts-js/dist/abis/IERC721.json';\nimport ContractPublisherAbi from '@thirdweb-dev/contracts-js/dist/abis/ContractPublisher.json';\nimport { defaultChains, getValidChainRPCs, Polygon, Mumbai } from '@thirdweb-dev/chains';\nimport bs58 from 'bs58';\nimport TWRegistryABI from '@thirdweb-dev/contracts-js/dist/abis/TWMultichainRegistryLogic.json';\nimport IBurnableERC20Abi from '@thirdweb-dev/contracts-js/dist/abis/IBurnableERC20.json';\nimport IDrop from '@thirdweb-dev/contracts-js/dist/abis/IDrop.json';\nimport DropERC20_V2Abi from '@thirdweb-dev/contracts-js/dist/abis/IDropERC20_V2.json';\nimport IDropSinglePhase from '@thirdweb-dev/contracts-js/dist/abis/IDropSinglePhase.json';\nimport IDropSinglePhaseV1 from '@thirdweb-dev/contracts-js/dist/abis/IDropSinglePhase_V1.json';\nimport IERC20PermitAbi from '@thirdweb-dev/contracts-js/dist/abis/IERC20Permit.json';\nimport IMintableERC20Abi from '@thirdweb-dev/contracts-js/dist/abis/IMintableERC20.json';\nimport MulticallAbi from '@thirdweb-dev/contracts-js/dist/abis/IMulticall.json';\nimport ISignatureMintERC20Abi from '@thirdweb-dev/contracts-js/dist/abis/ISignatureMintERC20.json';\nimport IBurnableERC721Abi from '@thirdweb-dev/contracts-js/dist/abis/IBurnableERC721.json';\nimport IClaimableERC721 from '@thirdweb-dev/contracts-js/dist/abis/IClaimableERC721.json';\nimport DelayedRevealAbi from '@thirdweb-dev/contracts-js/dist/abis/IDelayedReveal.json';\nimport DropERC721_V3Abi from '@thirdweb-dev/contracts-js/dist/abis/IDropERC721_V3.json';\nimport Erc721EnumerableAbi from '@thirdweb-dev/contracts-js/dist/abis/IERC721Enumerable.json';\nimport Erc721AQueryableAbi from '@thirdweb-dev/contracts-js/dist/abis/IERC721AQueryableUpgradeable.json';\nimport Erc721SupplyAbi from '@thirdweb-dev/contracts-js/dist/abis/IERC721Supply.json';\nimport ILazyMintAbi from '@thirdweb-dev/contracts-js/dist/abis/ILazyMint.json';\nimport IMintableERC721Abi from '@thirdweb-dev/contracts-js/dist/abis/IMintableERC721.json';\nimport SignatureMintERC721Abi from '@thirdweb-dev/contracts-js/dist/abis/ISignatureMintERC721.json';\nimport SignatureMintERC721_V1Abi from '@thirdweb-dev/contracts-js/dist/abis/ISignatureMintERC721_V1.json';\nimport TieredDropAbi from '@thirdweb-dev/contracts-js/dist/abis/LazyMintWithTier.json';\nimport SharedMetadataAbi from '@thirdweb-dev/contracts-js/dist/abis/SharedMetadata.json';\nimport zora_IDropERC721 from '@thirdweb-dev/contracts-js/dist/abis/zora_IERC721Drop.json';\nimport ILoyaltyCardAbi from '@thirdweb-dev/contracts-js/dist/abis/ILoyaltyCard.json';\nimport INFTMetadataAbi from '@thirdweb-dev/contracts-js/dist/abis/INFTMetadata.json';\nimport IBurnableERC1155Abi from '@thirdweb-dev/contracts-js/dist/abis/IBurnableERC1155.json';\nimport IClaimableERC1155 from '@thirdweb-dev/contracts-js/dist/abis/IClaimableERC1155.json';\nimport IDropMultiPhase1155 from '@thirdweb-dev/contracts-js/dist/abis/IDrop1155.json';\nimport DropERC1155_V2Abi from '@thirdweb-dev/contracts-js/dist/abis/IDropERC1155_V2.json';\nimport IDropSinglePhase1155 from '@thirdweb-dev/contracts-js/dist/abis/IDropSinglePhase1155.json';\nimport IDropSinglePhase1155_V1 from '@thirdweb-dev/contracts-js/dist/abis/IDropSinglePhase1155_V1.json';\nimport Erc1155SupplyAbi from '@thirdweb-dev/contracts-js/dist/abis/IERC1155Supply.json';\nimport Erc1155EnumerableAbi from '@thirdweb-dev/contracts-js/dist/abis/IERC1155Enumerable.json';\nimport IMintableERC1155Abi from '@thirdweb-dev/contracts-js/dist/abis/IMintableERC1155.json';\nimport ISignatureMintERC1155Abi from '@thirdweb-dev/contracts-js/dist/abis/ISignatureMintERC1155.json';\nimport IERC2771ContextAbi from '@thirdweb-dev/contracts-js/dist/abis/IERC2771Context.json';\nimport IAppURI from '@thirdweb-dev/contracts-js/dist/abis/IAppURI.json';\nimport IContractMetadataAbi from '@thirdweb-dev/contracts-js/dist/abis/IContractMetadata.json';\nimport IDirectListingsAbi from '@thirdweb-dev/contracts-js/dist/abis/IDirectListings.json';\nimport IEnglishAuctionsAbi from '@thirdweb-dev/contracts-js/dist/abis/IEnglishAuctions.json';\nimport IOffersAbi from '@thirdweb-dev/contracts-js/dist/abis/IOffers.json';\nimport IPackVRFAbi from '@thirdweb-dev/contracts-js/dist/abis/IPackVRFDirect.json';\nimport IPermissionsAbi from '@thirdweb-dev/contracts-js/dist/abis/IPermissions.json';\nimport IPermissionsEnumerableAbi from '@thirdweb-dev/contracts-js/dist/abis/IPermissionsEnumerable.json';\nimport IThirdwebPlatformFeeAbi from '@thirdweb-dev/contracts-js/dist/abis/IPlatformFee.json';\nimport IThirdwebPrimarySaleAbi from '@thirdweb-dev/contracts-js/dist/abis/IPrimarySale.json';\nimport IThirdwebRoyaltyAbi from '@thirdweb-dev/contracts-js/dist/abis/IRoyalty.json';\nimport IOwnableAbi from '@thirdweb-dev/contracts-js/dist/abis/Ownable.json';\nimport IAirdropERC20 from '@thirdweb-dev/contracts-js/dist/abis/IAirdropERC20.json';\nimport IAirdropERC721 from '@thirdweb-dev/contracts-js/dist/abis/IAirdropERC721.json';\nimport IAirdropERC1155 from '@thirdweb-dev/contracts-js/dist/abis/IAirdropERC1155.json';\nimport IAccountFactoryCore from '@thirdweb-dev/contracts-js/dist/abis/IAccountFactoryCore.json';\nimport IAccountPermissions from '@thirdweb-dev/contracts-js/dist/abis/IAccountPermissions.json';\nimport IAccount from '@thirdweb-dev/contracts-js/dist/abis/IAccount.json';\nimport { Interface } from 'ethers/lib/utils';\nimport ForwarderABI from '@thirdweb-dev/contracts-js/dist/abis/Forwarder.json';\nimport fetch from 'cross-fetch';\nimport EventEmitter from 'eventemitter3';\nconst MAX_LENGTH = 256;\nconst NUMERIC_IDENTIFIER = \"0|[1-9]\\\\d*\";\nconst MAIN_VERSION_IDENTIFIER = `(${NUMERIC_IDENTIFIER})\\\\.(${NUMERIC_IDENTIFIER})\\\\.(${NUMERIC_IDENTIFIER})`;\nconst REGEX_MAIN_VERSION = new RegExp(MAIN_VERSION_IDENTIFIER);\n\n/**\n * @internal\n */\n\n/**\n * @internal\n * @param version\n */\nfunction toSemver(version) {\n  if (version.length > MAX_LENGTH) {\n    throw new Error(`version is longer than ${MAX_LENGTH} characters`);\n  }\n  const matches = version.trim().match(REGEX_MAIN_VERSION);\n  if (!matches || matches?.length !== 4) {\n    throw new Error(`${version} is not a valid semantic version. Should be in the format of major.minor.patch. Ex: 0.4.1`);\n  }\n  const major = Number(matches[1]);\n  const minor = Number(matches[2]);\n  const patch = Number(matches[3]);\n  const versionString = [major, minor, patch].join(\".\");\n  return {\n    major,\n    minor,\n    patch,\n    versionString\n  };\n}\n\n/**\n * @internal\n * @param current\n * @param next\n */\nfunction isIncrementalVersion(current, next) {\n  const currentSemver = toSemver(current);\n  const nextSemver = toSemver(next);\n  if (nextSemver.major > currentSemver.major) {\n    return true;\n  }\n  const eqMajor = nextSemver.major === currentSemver.major;\n  if (eqMajor && nextSemver.minor > currentSemver.minor) {\n    return true;\n  }\n  const eqMinor = nextSemver.minor === currentSemver.minor;\n  return eqMajor && eqMinor && nextSemver.patch > currentSemver.patch;\n}\nfunction isDowngradeVersion(current, next) {\n  const currentSemver = toSemver(current);\n  const nextSemver = toSemver(next);\n  if (nextSemver.major < currentSemver.major) {\n    return true;\n  }\n  const eqMajor = nextSemver.major === currentSemver.major;\n  if (eqMajor && nextSemver.minor < currentSemver.minor) {\n    return true;\n  }\n  const eqMinor = nextSemver.minor === currentSemver.minor;\n  return eqMajor && eqMinor && nextSemver.patch < currentSemver.patch;\n}\nconst BigNumberSchema = /* @__PURE__ */(() => z.union([z.string(), z.number(), z.bigint(), z.custom(data => {\n  return BigNumber.isBigNumber(data);\n})]).transform(arg => BigNumber.from(arg)))();\nconst BigNumberishSchema = /* @__PURE__ */BigNumberSchema.transform(arg => arg.toString());\nconst BigNumberTransformSchema = /* @__PURE__ */(() => z.union([z.bigint(), z.custom(data => {\n  return BigNumber.isBigNumber(data);\n})]).transform(arg => {\n  return BigNumber.from(arg).toString();\n}))();\n\n/**\n * util function to check for signer, ripped out of ethers Signer.isProvider\n *\n * @param value possible signer\n * @returns boolean if value is a signer\n * @internal\n */\nfunction isSigner(value) {\n  return !!(value && value._isSigner);\n}\n\n/**\n * util function to check for provider, ripped out of ethers providers.Provider.isProvider\n *\n * @param value possible provider\n * @returns boolean if value is a provider\n * @internal\n */\nfunction isProvider(value) {\n  return !!(value && value._isProvider);\n}\nconst DEFAULT_BATCH_TIME_LIMIT_MS = 50;\nconst DEFAULT_BATCH_SIZE_LIMIT = 250;\nconst DEFAULT_BATCH_OPTIONS = {\n  timeLimitMs: DEFAULT_BATCH_TIME_LIMIT_MS,\n  sizeLimit: DEFAULT_BATCH_SIZE_LIMIT\n};\n// mostly copied from ethers.js directly but make it a StaticJsonRpcProvider\nclass StaticJsonRpcBatchProvider extends providers.StaticJsonRpcProvider {\n  constructor(url, network) {\n    let batchOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_BATCH_OPTIONS;\n    super(url, network);\n    this._timeLimitMs = batchOptions.timeLimitMs || DEFAULT_BATCH_SIZE_LIMIT;\n    this._sizeLimit = batchOptions.sizeLimit || DEFAULT_BATCH_TIME_LIMIT_MS;\n    this._pendingBatchAggregator = null;\n    this._pendingBatch = null;\n  }\n  sendCurrentBatch(request) {\n    // if we still have a timeout clear that first\n    if (this._pendingBatchAggregator) {\n      clearTimeout(this._pendingBatchAggregator);\n    }\n    // Get the current batch and clear it, so new requests\n    // go into the next batch\n    const batch = this._pendingBatch || [];\n    this._pendingBatch = null;\n    this._pendingBatchAggregator = null;\n\n    // Get the request as an array of requests\n    const request_ = batch.map(inflight => inflight.request);\n    this.emit(\"debug\", {\n      action: \"requestBatch\",\n      request: utils.deepCopy(request),\n      provider: this\n    });\n    return utils.fetchJson(this.connection, JSON.stringify(request_)).then(result => {\n      this.emit(\"debug\", {\n        action: \"response\",\n        request: request_,\n        response: result,\n        provider: this\n      });\n\n      // For each result, feed it to the correct Promise, depending\n      // on whether it was a success or error\n      batch.forEach((inflightRequest_, index) => {\n        const payload = result[index];\n\n        // there may *not* be a payload for a given request (typically RPC error level)\n        if (payload) {\n          // if there is a payload, check for an error\n          if (payload.error) {\n            const error = new Error(payload.error.message);\n            error.code = payload.error.code;\n            error.data = payload.error.data;\n            inflightRequest_.reject(error);\n          } else {\n            // if there's no error resolve the request\n            inflightRequest_.resolve(payload.result);\n          }\n        } else {\n          // if there is no payload, reject the request\n          inflightRequest_.reject(new Error(\"No response for request\"));\n        }\n      });\n    }, error => {\n      this.emit(\"debug\", {\n        action: \"response\",\n        error: error,\n        request: request_,\n        provider: this\n      });\n\n      // If there was an error, reject all the requests\n      batch.forEach(inflightRequest_ => {\n        inflightRequest_.reject(error);\n      });\n    });\n  }\n  send(method, params) {\n    const request = {\n      method: method,\n      params: params,\n      id: this._nextId++,\n      jsonrpc: \"2.0\"\n    };\n    if (this._pendingBatch === null) {\n      this._pendingBatch = [];\n    }\n    const inflightRequest = {\n      request,\n      resolve: null,\n      reject: null\n    };\n    const promise = new Promise((resolve, reject) => {\n      inflightRequest.resolve = resolve;\n      inflightRequest.reject = reject;\n    });\n    this._pendingBatch.push(inflightRequest);\n\n    // if we would go *over* the size limit of the batch with this request, send the batch now\n    if (this._pendingBatch.length === this._sizeLimit) {\n      this.sendCurrentBatch(request);\n    }\n    if (!this._pendingBatchAggregator) {\n      // Schedule batch for next event loop + short duration\n      this._pendingBatchAggregator = setTimeout(() => {\n        this.sendCurrentBatch(request);\n      }, this._timeLimitMs);\n    }\n    return promise;\n  }\n}\nconst ChainInfoInputSchema = /* @__PURE__ */(() => z.object({\n  rpc: z.array(z.string().url()),\n  chainId: z.number(),\n  nativeCurrency: z.object({\n    name: z.string(),\n    symbol: z.string(),\n    decimals: z.number()\n  }),\n  slug: z.string()\n}))();\n\n/**\n * @public\n */\nconst SDKOptionsSchema = /* @__PURE__ */(() => z.object({\n  // @ts-expect-error - zod doesn't know anything about readonly\n  supportedChains: z.array(ChainInfoInputSchema).default(defaultChains),\n  clientId: z.string().optional(),\n  secretKey: z.string().optional(),\n  readonlySettings: z.object({\n    rpcUrl: z.string().url(),\n    chainId: z.number().optional()\n  }).optional(),\n  gasSettings: z.object({\n    maxPriceInGwei: z.number().min(1, \"gas price cannot be less than 1\").default(300),\n    speed: z.enum([\"standard\", \"fast\", \"fastest\"]).default(\"fastest\")\n  }).default({\n    maxPriceInGwei: 300,\n    speed: \"fastest\"\n  }),\n  gasless: z.union([z.object({\n    openzeppelin: z.object({\n      relayerUrl: z.string().url(),\n      relayerForwarderAddress: z.string().optional(),\n      useEOAForwarder: z.boolean().default(false),\n      domainName: z.string().default(\"GSNv2 Forwarder\"),\n      domainVersion: z.string().default(\"0.0.1\")\n    }),\n    experimentalChainlessSupport: z.boolean().default(false)\n  }), z.object({\n    biconomy: z.object({\n      apiId: z.string(),\n      apiKey: z.string(),\n      deadlineSeconds: z.number().min(1, \"deadlineSeconds cannot be les than 1\").default(3600)\n    })\n  })]).optional(),\n  gatewayUrls: z.array(z.string()).optional()\n}).default({\n  gasSettings: {\n    maxPriceInGwei: 300,\n    speed: \"fastest\"\n  }\n}))();\n\n/**\n * @public\n * All these configuration options are optional with sane defaults:\n * @example\n * ```javascript\n * {\n *   readonlySettings: {\n *     rpcUrl, // force read calls to go through your own RPC url\n *     chainId, // reduce RPC calls by sepcifying your chain ID\n *   },\n *   gasSettings: {\n *     maxPriceInGwei, // Maximum gas price for transactions (default 300 gwei)\n *     speed, // the tx speed setting: 'standard'|'fast|'fastest' (default: 'fastest')\n *   },\n *   gasless: {\n *     // By specifying a gasless configuration - all transactions will get forwarded to enable gasless transactions\n *     openzeppelin: {\n *       relayerUrl, // your OZ Defender relayer URL\n *       relayerForwarderAddress, // the OZ defender relayer address (defaults to the standard one)\n *     },\n *     biconomy: {\n *       apiId, // your Biconomy API Id\n *       apiKey, // your Biconomy API Key\n *       deadlineSeconds, // your Biconomy timeout preference\n *     },\n *   },\n * }\n * ```\n */\n\n/**\n * @internal\n */\n\n/**\n * @public\n */\n\nvar pkg = {\n  name: \"@thirdweb-dev/sdk\",\n  version: \"3.10.67\",\n  description: \"The main thirdweb SDK.\",\n  repository: \"https://github.com/thirdweb-dev/js/tree/main/packages/sdk\",\n  license: \"Apache-2.0\",\n  main: \"dist/thirdweb-dev-sdk.cjs.js\",\n  module: \"dist/thirdweb-dev-sdk.esm.js\",\n  browser: {\n    \"./dist/thirdweb-dev-sdk.esm.js\": \"./dist/thirdweb-dev-sdk.browser.esm.js\"\n  },\n  exports: {\n    \".\": {\n      module: {\n        browser: \"./dist/thirdweb-dev-sdk.browser.esm.js\",\n        \"default\": \"./dist/thirdweb-dev-sdk.esm.js\"\n      },\n      \"default\": \"./dist/thirdweb-dev-sdk.cjs.js\"\n    },\n    \"./evm\": {\n      module: {\n        browser: \"./evm/dist/thirdweb-dev-sdk-evm.browser.esm.js\",\n        \"default\": \"./evm/dist/thirdweb-dev-sdk-evm.esm.js\"\n      },\n      \"default\": \"./evm/dist/thirdweb-dev-sdk-evm.cjs.js\"\n    },\n    \"./solana\": {\n      module: {\n        browser: \"./solana/dist/thirdweb-dev-sdk-solana.browser.esm.js\",\n        \"default\": \"./solana/dist/thirdweb-dev-sdk-solana.esm.js\"\n      },\n      \"default\": \"./solana/dist/thirdweb-dev-sdk-solana.cjs.js\"\n    },\n    \"./evm/zksync\": {\n      module: {\n        browser: \"./evm/zksync/dist/thirdweb-dev-sdk-evm-zksync.browser.esm.js\",\n        \"default\": \"./evm/zksync/dist/thirdweb-dev-sdk-evm-zksync.esm.js\"\n      },\n      \"default\": \"./evm/zksync/dist/thirdweb-dev-sdk-evm-zksync.cjs.js\"\n    },\n    \"./evm/functions\": {\n      module: {\n        browser: \"./evm/functions/dist/thirdweb-dev-sdk-evm-functions.browser.esm.js\",\n        \"default\": \"./evm/functions/dist/thirdweb-dev-sdk-evm-functions.esm.js\"\n      },\n      \"default\": \"./evm/functions/dist/thirdweb-dev-sdk-evm-functions.cjs.js\"\n    },\n    \"./solana/server\": {\n      module: {\n        browser: \"./solana/server/dist/thirdweb-dev-sdk-solana-server.browser.esm.js\",\n        \"default\": \"./solana/server/dist/thirdweb-dev-sdk-solana-server.esm.js\"\n      },\n      \"default\": \"./solana/server/dist/thirdweb-dev-sdk-solana-server.cjs.js\"\n    },\n    \"./package.json\": \"./package.json\"\n  },\n  files: [\"dist/\", \"evm/\", \"solana/\", \"server/\"],\n  preconstruct: {\n    entrypoints: [\"index.ts\", \"evm/index.ts\", \"evm/functions/index.ts\", \"evm/zksync/index.ts\", \"solana/index.ts\", \"solana/server/index.ts\"],\n    exports: {\n      envConditions: [\"browser\"]\n    }\n  },\n  sideEffects: false,\n  scripts: {\n    format: \"prettier --write 'src/**/*'\",\n    lint: \"eslint src/\",\n    fix: \"eslint src/ --fix\",\n    clean: \"rm -rf dist/\",\n    \"generate-docs\": \"pnpm generate-docs:evm && pnpm generate-docs:solana && pnpm generate-snippets\",\n    \"generate-docs:evm\": \"api-extractor run --local --config ./config/api-extractor-evm.json && api-documenter markdown -i ./temp -o ./docs/evm && rm -rf ./temp-evm && mv ./temp ./temp-evm\",\n    \"generate-docs:solana\": \"api-extractor run --local --config ./config/api-extractor-solana.json && api-documenter markdown -i ./temp -o ./docs/solana && rm -rf ./temp-solana && mv ./temp ./temp-solana\",\n    \"generate-snippets\": \"node ./scripts/generate-snippets.mjs && node ./scripts/generate-feature-snippets-evm.mjs\",\n    build: \"tsc && preconstruct build\",\n    \"test:evm:all\": \"SWC_NODE_PROJECT=./tsconfig.test.json nyc --reporter lcovonly --report-dir ./coverage/evm mocha --config './test/evm/.mocharc.json' --timeout 90000 --parallel './test/evm/**/*.test.ts'\",\n    \"test:evm\": \"make test-evm\",\n    \"test:evm:single\": \"SWC_NODE_PROJECT=./tsconfig.test.json mocha --config './test/evm/.mocharc.json' --timeout 90000\",\n    \"node:solana:start\": \"DEBUG='amman:(info|error|debug)' amman start --forceClone\",\n    \"node:solana:stop\": \"amman stop\",\n    \"test:solana:all\": \"SWC_NODE_PROJECT=./tsconfig.test.json nyc --reporter lcovonly --report-dir ./coverage/solana  mocha --config './test/solana/.mocharc.json' --timeout 30000 --parallel './test/solana/**/*.test.ts'\",\n    \"test:solana\": \"make test-sol\",\n    \"test:solana:single\": \"SWC_NODE_PROJECT=./tsconfig.test.json mocha --config './test/solana/.mocharc.json' --timeout 30000\",\n    push: \"yalc push\"\n  },\n  devDependencies: {\n    \"@aws-sdk/client-secrets-manager\": \"^3.378.0\",\n    \"@ethersproject/abstract-provider\": \"^5.7.0\",\n    \"@metaplex-foundation/amman\": \"^0.12.1\",\n    \"@metaplex-foundation/amman-client\": \"^0.2.4\",\n    \"@metaplex-foundation/js\": \"^0.19.2\",\n    \"@metaplex-foundation/mpl-token-metadata\": \"^2.12.0\",\n    \"@microsoft/api-documenter\": \"^7.22.30\",\n    \"@microsoft/api-extractor\": \"^7.36.3\",\n    \"@microsoft/tsdoc\": \"^0.14.1\",\n    \"@nomiclabs/hardhat-ethers\": \"^2.2.3\",\n    \"@preconstruct/cli\": \"2.7.0\",\n    \"@project-serum/anchor\": \"^0.25.0\",\n    \"@solana/spl-token\": \"^0.3.5\",\n    \"@solana/web3.js\": \"^1.62.0\",\n    \"@swc-node/register\": \"^1.6.6\",\n    \"@swc/core\": \"^1.3.71\",\n    \"@thirdweb-dev/tsconfig\": \"workspace:*\",\n    \"@types/bn.js\": \"^5.1.1\",\n    \"@types/chai\": \"^4.3.5\",\n    \"@types/deep-equal-in-any-order\": \"^1.0.1\",\n    \"@types/mocha\": \"^10.0.0\",\n    \"@types/node\": \"^18.17.1\",\n    \"@types/uuid\": \"^9.0.2\",\n    \"@typescript-eslint/eslint-plugin\": \"^6.2.0\",\n    \"@typescript-eslint/parser\": \"^6.2.0\",\n    chai: \"^4.3.6\",\n    \"deep-equal-in-any-order\": \"^1.1.18\",\n    \"dotenv-mono\": \"^1.3.10\",\n    eslint: \"^8.45.0\",\n    \"eslint-config-prettier\": \"^8.9.0\",\n    \"eslint-config-thirdweb\": \"workspace:*\",\n    \"eslint-plugin-better-tree-shaking\": \"0.0.3\",\n    \"eslint-plugin-import\": \"^2.26.0\",\n    \"eslint-plugin-inclusive-language\": \"^2.2.0\",\n    \"eslint-plugin-prettier\": \"^5.0.0\",\n    \"eslint-plugin-tsdoc\": \"^0.2.16\",\n    ethers: \"^5.7.2\",\n    \"ethers-aws-kms-signer\": \"^1.3.2\",\n    hardhat: \"^2.17.0\",\n    mocha: \"^10.2.0\",\n    nyc: \"^15.1.0\",\n    prettier: \"^3.0.0\",\n    typescript: \"^5.1.6\",\n    \"zksync-web3\": \"^0.14.3\"\n  },\n  peerDependencies: {\n    \"@aws-sdk/client-secrets-manager\": \"^3.215.0\",\n    \"@metaplex-foundation/js\": \"^0.17.6\",\n    \"@metaplex-foundation/mpl-token-metadata\": \"^2.3.3\",\n    \"@project-serum/anchor\": \"^0.25.0\",\n    \"@solana/spl-token\": \"^0.3.5\",\n    \"@solana/web3.js\": \"^1.62.0\",\n    ethers: \"^5\",\n    \"ethers-aws-kms-signer\": \"^1.3.2\",\n    \"zksync-web3\": \"^0.14.3\"\n  },\n  peerDependenciesMeta: {\n    \"@aws-sdk/client-secrets-manager\": {\n      optional: true\n    },\n    \"ethers-aws-kms-signer\": {\n      optional: true\n    },\n    \"@solana/spl-token\": {\n      optional: true\n    },\n    \"@solana/web3.js\": {\n      optional: true\n    },\n    \"@project-serum/anchor\": {\n      optional: true\n    },\n    \"@metaplex-foundation/mpl-token-metadata\": {\n      optional: true\n    },\n    \"@metaplex-foundation/js\": {\n      optional: true\n    },\n    \"zksync-web3\": {\n      optional: true\n    }\n  },\n  dependencies: {\n    \"@thirdweb-dev/chains\": \"workspace:*\",\n    \"@thirdweb-dev/contracts-js\": \"workspace:*\",\n    \"@thirdweb-dev/generated-abis\": \"workspace:*\",\n    \"@thirdweb-dev/storage\": \"workspace:*\",\n    abitype: \"^0.2.5\",\n    \"bn.js\": \"^5.2.1\",\n    bs58: \"^5.0.0\",\n    buffer: \"^6.0.3\",\n    \"cross-fetch\": \"^3.1.8\",\n    eventemitter3: \"^5.0.1\",\n    \"fast-deep-equal\": \"^3.1.3\",\n    merkletreejs: \"^0.2.24\",\n    \"tiny-invariant\": \"^1.2.0\",\n    tweetnacl: \"^1.0.3\",\n    uuid: \"^9.0.0\",\n    yaml: \"^2.3.1\",\n    zod: \"^3.20.2\"\n  },\n  bugs: {\n    url: \"https://github.com/thirdweb-dev/js/issues\"\n  },\n  author: \"thirdweb eng <eng@thirdweb.com>\"\n};\n\n/**\n * @internal\n */\nfunction buildDefaultMap(options) {\n  return options.supportedChains.reduce((previousValue, currentValue) => {\n    previousValue[currentValue.chainId] = currentValue;\n    return previousValue;\n  }, {});\n}\n\n/**\n * Get an ethers provider for the specified network\n *\n * @internal\n */\nfunction getChainProvider(network, sdkOptions) {\n  // If we have an RPC URL, use that for the provider\n  if (typeof network === \"string\" && isRpcUrl(network)) {\n    return getProviderFromRpcUrl(network, sdkOptions);\n  }\n\n  // Add the chain to the supportedChains\n  const options = SDKOptionsSchema.parse(sdkOptions);\n  if (isChainConfig(network)) {\n    options.supportedChains = [\n    // @ts-expect-error - we know this is a chain and it will work to build the map\n    network, ...options.supportedChains.filter(c => c.chainId !== network.chainId)];\n  }\n\n  // Build a map of chainId -> ChainInfo based on the supportedChains\n  const rpcMap = buildDefaultMap(options);\n  let rpcUrl = \"\";\n  let chainId;\n  try {\n    // Resolve the chain id from the network, which could be a chain, chain name, or chain id\n    chainId = getChainIdFromNetwork(network, options);\n    // Attempt to get the RPC url from the map based on the chainId\n    rpcUrl = getValidChainRPCs(rpcMap[chainId], options.clientId)[0];\n  } catch (e) {\n    // no-op\n  }\n\n  // if we still don't have an url fall back to just using the chainId or slug in the rpc and try that\n  if (!rpcUrl) {\n    rpcUrl = `https://${chainId || network}.rpc.thirdweb.com/${options.clientId || \"\"}`;\n  }\n  if (!rpcUrl) {\n    throw new Error(`No rpc url found for chain ${network}. Please provide a valid rpc url via the 'supportedChains' property of the sdk options.`);\n  }\n  return getProviderFromRpcUrl(rpcUrl, sdkOptions, chainId);\n}\nfunction getChainIdFromNetwork(network, options) {\n  if (isChainConfig(network)) {\n    // If it's a chain just return the chain id\n    return network.chainId;\n  } else if (typeof network === \"number\") {\n    // If it's a number (chainId) return it directly\n    return network;\n  } else {\n    // If it's a string (chain name) return the chain id from the map\n    const chainNameToId = options.supportedChains.reduce((acc, curr) => {\n      acc[curr.slug] = curr.chainId;\n      return acc;\n    }, {});\n    if (network in chainNameToId) {\n      return chainNameToId[network];\n    }\n  }\n  throw new Error(`Cannot resolve chainId from: ${network} - please pass the chainId instead and specify it in the 'supportedChains' property of the SDK options.`);\n}\nasync function getChainIdOrName(network) {\n  if (isChainConfig(network)) {\n    // If it's a chain just return the chain id\n    return network.chainId;\n  } else if (typeof network === \"number\") {\n    // If it's a number (chainId) return it directly\n    return network;\n  } else if (typeof network === \"number\") {\n    // If it's a string (chain name) return the chain id from the map\n    return network;\n  } else if (isProvider(network)) {\n    return network.getNetwork().then(n => n.chainId);\n  } else if (isSigner(network)) {\n    if (!network.provider) {\n      throw new Error(\"Signer does not have a provider\");\n    }\n    return network.provider.getNetwork().then(n => n.chainId);\n  }\n  throw new Error(`Cannot resolve chainId from: ${network}.`);\n}\n\n/**\n * Check whether a NetworkInput value is a Chain config (naively, without parsing)\n */\nfunction isChainConfig(network) {\n  return typeof network !== \"string\" && typeof network !== \"number\" && !isSigner(network) && !isProvider(network);\n}\n\n/**\n * Returns whether the specified url is a valid RPC url, as implemented by ethers.getDefaultProvier():\n * - https://github.com/ethers-io/ethers.js/blob/ec1b9583039a14a0e0fa15d0a2a6082a2f41cf5b/packages/providers/src.ts/index.ts#L55\n *\n * @param url - The url to check\n *\n * @internal\n */\nfunction isRpcUrl(url) {\n  const match = url.match(/^(ws|http)s?:/i);\n  if (match) {\n    switch (match[1].toLowerCase()) {\n      case \"http\":\n      case \"https\":\n      case \"ws\":\n      case \"wss\":\n        return true;\n    }\n  }\n  return false;\n}\nconst RPC_PROVIDER_MAP = new Map();\n\n/**\n * Get an ethers provider based on the specified RPC URL\n *\n * @param rpcUrl - The RPC URL\n * @param chainId - The optional chain ID\n * @returns The provider for the specified RPC URL\n *\n * @internal\n */\nfunction getProviderFromRpcUrl(rpcUrl, sdkOptions, chainId) {\n  try {\n    const headers = {};\n    // will be used to make sure we don't cache providers with different auth strategies\n    let authStrategy = \"none\";\n    if (isTwUrl(rpcUrl)) {\n      // if we have a secret key passed in the SDK options we want to always use that\n      if (sdkOptions?.secretKey) {\n        // compute the clientId from the secret key\n        // should only be used on Node.js in a backend/script context\n        if (\"object\" !== \"undefined\") {\n          throw new Error(\"Cannot use secretKey in browser context\");\n        }\n        // this is on purpose because we're using the crypto module only in node\n        // try to trick webpack :)\n        const pto = \"pto\";\n        // eslint-disable-next-line @typescript-eslint/no-var-requires\n        const crypto = require(\"cry\" + pto);\n        const hashedSecretKey = crypto.createHash(\"sha256\").update(sdkOptions.secretKey).digest(\"hex\");\n        const derivedClientId = hashedSecretKey.slice(0, 32);\n        const utilizedRpcUrl = new URL(rpcUrl);\n        // always set the clientId on the path to the derived client id\n        utilizedRpcUrl.pathname = derivedClientId;\n        // set the headers\n        headers[\"x-client-id\"] = derivedClientId;\n        headers[\"x-secret-key\"] = sdkOptions.secretKey;\n        // set the final rpc url\n        rpcUrl = utilizedRpcUrl.toString();\n        authStrategy = \"secretKey\";\n      }\n      // if we do NOT have a secret key but we have a client id we want to use that\n      else if (sdkOptions?.clientId) {\n        const utilizedRpcUrl = new URL(rpcUrl);\n        // always set the clientId on the path to the client id\n        utilizedRpcUrl.pathname = sdkOptions.clientId;\n        // set the headers\n        headers[\"x-client-id\"] = sdkOptions.clientId;\n        // set the final rpc url\n        rpcUrl = utilizedRpcUrl.toString();\n        authStrategy = \"clientId\";\n      }\n\n      // if we *also* have a tw auth token on global context add it to the headers (in addition to anything else)\n      if (typeof globalThis !== \"undefined\" && \"TW_AUTH_TOKEN\" in globalThis && typeof globalThis.TW_AUTH_TOKEN === \"string\") {\n        headers[\"authorization\"] = `Bearer ${globalThis.TW_AUTH_TOKEN}`;\n        authStrategy = \"twAuthToken\";\n      }\n      if (typeof globalThis !== \"undefined\" && \"TW_CLI_AUTH_TOKEN\" in globalThis && typeof globalThis.TW_CLI_AUTH_TOKEN === \"string\") {\n        headers[\"x-authorize-wallet\"] = \"true\";\n      }\n      const bundleId = typeof globalThis !== \"undefined\" && \"APP_BUNDLE_ID\" in globalThis ? globalThis.APP_BUNDLE_ID : undefined;\n      if (!rpcUrl.includes(\"bundleId\")) {\n        rpcUrl = rpcUrl + (bundleId ? `?bundleId=${bundleId}` : \"\");\n      }\n      headers[\"x-sdk-version\"] = pkg.version;\n      headers[\"x-sdk-name\"] = pkg.name;\n      headers[\"x-sdk-platform\"] = bundleId ? \"react-native\" : isBrowser$1() ? window.bridge !== undefined ? \"webGL\" : \"browser\" : \"node\";\n    }\n    const match = rpcUrl.match(/^(ws|http)s?:/i);\n    // Try the JSON batch provider if available\n    if (match) {\n      switch (match[1].toLowerCase()) {\n        case \"http\":\n        case \"https\":\n          // Create a unique cache key for these params\n          const seralizedOpts = `${rpcUrl}-${chainId || -1}-${authStrategy}`;\n\n          // Check if we have a provider in our cache already\n          const existingProvider = RPC_PROVIDER_MAP.get(seralizedOpts);\n          if (existingProvider) {\n            return existingProvider;\n          }\n\n          // Otherwise, create a new provider on the specific network\n          const newProvider = chainId ?\n          // If we know the chainId we should use the StaticJsonRpcBatchProvider\n          new StaticJsonRpcBatchProvider({\n            url: rpcUrl,\n            headers\n          }, chainId) :\n          // Otherwise fall back to the built in json rpc batch provider\n          new providers.JsonRpcBatchProvider({\n            url: rpcUrl,\n            headers\n          });\n\n          // Save the provider in our cache\n          RPC_PROVIDER_MAP.set(seralizedOpts, newProvider);\n          return newProvider;\n        case \"ws\":\n        case \"wss\":\n          // Use the WebSocketProvider for ws:// URLs\n          // TODO: handle auth for WS at some point\n          return new providers.WebSocketProvider(rpcUrl, chainId);\n      }\n    }\n  } catch (e) {\n    // no-op\n  }\n\n  // Always fallback to the default provider if no other option worked\n  return providers.getDefaultProvider(rpcUrl);\n}\n\n// TODO move to utils package\nfunction isTwUrl(url) {\n  return new URL(url).hostname.endsWith(\".thirdweb.com\");\n}\n\n/**\n * @internal\n */\nfunction getSignerAndProvider(network, options) {\n  let signer;\n  let provider;\n  if (isSigner(network)) {\n    // Here, we have an ethers.Signer\n    signer = network;\n    if (network.provider) {\n      provider = network.provider;\n    }\n  } else if (isProvider(network)) {\n    // Here, we have an ethers.providers.Provider\n    provider = network;\n  } else {\n    // Here, we must have a ChainOrRpcUrl, which is a chain name, chain id, rpc url, or chain config\n    // All of which, getChainProvider can handle for us\n    provider = getChainProvider(network, options);\n  }\n  if (options?.readonlySettings) {\n    // If readonly settings are specified, then overwrite the provider\n    provider = getProviderFromRpcUrl(options.readonlySettings.rpcUrl, options, options.readonlySettings.chainId);\n  }\n\n  // At this point, if we don't have a provider, don't default to a random chain\n  // Instead, just throw an error\n  if (!provider) {\n    if (signer) {\n      throw new Error(\"No provider passed to the SDK! Please make sure that your signer is connected to a provider!\");\n    }\n    throw new Error(\"No provider found! Make sure to specify which network to connect to, or pass a signer or provider to the SDK!\");\n  }\n  return [signer, provider];\n}\n\n// TODO: Respect SDK RPC configuration and don't pull straight from ethers\nlet provider;\nconst ENS_CACHE = new Map();\nasync function resolveEns(ens) {\n  let depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  if (!provider) {\n    // if we don't already have a provider then get one\n    provider = getSignerAndProvider(\"ethereum\")[1];\n  }\n  let ensPromise;\n  if (ENS_CACHE.has(ens)) {\n    ensPromise = ENS_CACHE.get(ens);\n  } else {\n    ensPromise = provider.resolveName(ens).then(address => {\n      // If they don't have an ENS, only cache for 30s\n      if (!address) {\n        return {\n          address: null,\n          expirationTime: new Date(Date.now() + 1000 * 30)\n        };\n      }\n\n      // Cache ENS for 1 hour\n      return {\n        address,\n        expirationTime: new Date(Date.now() + 1000 * 60 * 5)\n      };\n    });\n  }\n  const resolvedPromise = await ensPromise;\n  if (resolvedPromise.expirationTime < new Date()) {\n    // delete the cache if it's expired\n    ENS_CACHE.delete(ens);\n    // then call ourselves again to refresh the cache, but don't block on the result\n    if (depth === 0) {\n      resolveEns(ens, depth + 1);\n    }\n  }\n  return resolvedPromise.address;\n}\n\n// Only pass through to provider call if value ends with .eth or .cb.id\nconst EnsSchema = /* @__PURE__ */(() => z.custom(ens => typeof ens === \"string\" && (ens.endsWith(\".eth\") || ens.endsWith(\".cb.id\"))).transform(async ens => resolveEns(ens)).refine(address => !!address && utils.isAddress(address), {\n  message: \"Provided value was not a valid ENS name\"\n}))();\nconst AddressSchema = /* @__PURE__ */z.custom(address => typeof address === \"string\" && utils.isAddress(address), out => {\n  return {\n    message: `${out} is not a valid address`\n  };\n});\n\n// Important for address check to come before ENS so network request is only made when necessary\nconst AddressOrEnsSchema = /* @__PURE__ */z.union([AddressSchema, EnsSchema], {\n  invalid_type_error: \"Provided value was not a valid address or ENS name\"\n});\n\n// Use this everywhere even though it's just string so we can optionally switch it out\n// more easily if we want to later\n\n/**\n * @public\n */\nlet ChainId = /*#__PURE__*/function (ChainId) {\n  ChainId[ChainId[\"Mainnet\"] = 1] = \"Mainnet\";\n  ChainId[ChainId[\"Goerli\"] = 5] = \"Goerli\";\n  ChainId[ChainId[\"Polygon\"] = 137] = \"Polygon\";\n  ChainId[ChainId[\"Mumbai\"] = 80001] = \"Mumbai\";\n  ChainId[ChainId[\"Localhost\"] = 1337] = \"Localhost\";\n  ChainId[ChainId[\"Hardhat\"] = 31337] = \"Hardhat\";\n  ChainId[ChainId[\"Fantom\"] = 250] = \"Fantom\";\n  ChainId[ChainId[\"FantomTestnet\"] = 4002] = \"FantomTestnet\";\n  ChainId[ChainId[\"Avalanche\"] = 43114] = \"Avalanche\";\n  ChainId[ChainId[\"AvalancheFujiTestnet\"] = 43113] = \"AvalancheFujiTestnet\";\n  ChainId[ChainId[\"Optimism\"] = 10] = \"Optimism\";\n  ChainId[ChainId[\"OptimismGoerli\"] = 420] = \"OptimismGoerli\";\n  ChainId[ChainId[\"Arbitrum\"] = 42161] = \"Arbitrum\";\n  ChainId[ChainId[\"ArbitrumGoerli\"] = 421613] = \"ArbitrumGoerli\";\n  ChainId[ChainId[\"BinanceSmartChainMainnet\"] = 56] = \"BinanceSmartChainMainnet\";\n  ChainId[ChainId[\"BinanceSmartChainTestnet\"] = 97] = \"BinanceSmartChainTestnet\";\n  return ChainId;\n}({});\n\n// @ts-expect-error - readonly vs not\nlet supportedChains = defaultChains;\n\n/**\n * @internal\n */\nfunction setSupportedChains(chains) {\n  if (chains && chains.length > 0) {\n    supportedChains = chains;\n  } else {\n    // @ts-expect-error - readonly vs not\n    supportedChains = defaultChains;\n  }\n}\n\n/**\n * @internal\n */\nfunction getSupportedChains() {\n  return supportedChains;\n}\n\n/**\n * @public\n */\nconst NATIVE_TOKEN_ADDRESS = \"0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee\";\n\n/**\n * @public\n */\nconst NATIVE_TOKENS = {\n  [ChainId.Mainnet]: {\n    name: \"Ether\",\n    symbol: \"ETH\",\n    decimals: 18,\n    wrapped: {\n      address: \"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\",\n      name: \"Wrapped Ether\",\n      symbol: \"WETH\"\n    }\n  },\n  [ChainId.Goerli]: {\n    name: \"Görli Ether\",\n    symbol: \"GOR\",\n    decimals: 18,\n    wrapped: {\n      address: \"0xb4fbf271143f4fbf7b91a5ded31805e42b2208d6\",\n      name: \"Wrapped Ether\",\n      symbol: \"WETH\"\n    }\n  },\n  11155111: {\n    name: \"Sepolia Ether\",\n    symbol: \"SEP\",\n    decimals: 18,\n    wrapped: {\n      address: \"0x7b79995e5f793A07Bc00c21412e50Ecae098E7f9\",\n      name: \"Wrapped Ether\",\n      symbol: \"WETH\"\n    }\n  },\n  [ChainId.Polygon]: {\n    name: \"Matic\",\n    symbol: \"MATIC\",\n    decimals: 18,\n    wrapped: {\n      address: \"0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270\",\n      name: \"Wrapped Matic\",\n      symbol: \"WMATIC\"\n    }\n  },\n  [ChainId.Mumbai]: {\n    name: \"Matic\",\n    symbol: \"MATIC\",\n    decimals: 18,\n    wrapped: {\n      address: \"0x9c3C9283D3e44854697Cd22D3Faa240Cfb032889\",\n      name: \"Wrapped Matic\",\n      symbol: \"WMATIC\"\n    }\n  },\n  [ChainId.Avalanche]: {\n    name: \"Avalanche\",\n    symbol: \"AVAX\",\n    decimals: 18,\n    wrapped: {\n      address: \"0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7\",\n      name: \"Wrapped AVAX\",\n      symbol: \"WAVAX\"\n    }\n  },\n  [ChainId.AvalancheFujiTestnet]: {\n    name: \"Avalanche\",\n    symbol: \"AVAX\",\n    decimals: 18,\n    wrapped: {\n      address: \"0xd00ae08403B9bbb9124bB305C09058E32C39A48c\",\n      name: \"Wrapped AVAX\",\n      symbol: \"WAVAX\"\n    }\n  },\n  [ChainId.Fantom]: {\n    name: \"Fantom\",\n    symbol: \"FTM\",\n    decimals: 18,\n    wrapped: {\n      address: \"0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83\",\n      name: \"Wrapped Fantom\",\n      symbol: \"WFTM\"\n    }\n  },\n  [ChainId.FantomTestnet]: {\n    name: \"Fantom\",\n    symbol: \"FTM\",\n    decimals: 18,\n    wrapped: {\n      address: \"0xf1277d1Ed8AD466beddF92ef448A132661956621\",\n      name: \"Wrapped Fantom\",\n      symbol: \"WFTM\"\n    }\n  },\n  [ChainId.Arbitrum]: {\n    name: \"Ether\",\n    symbol: \"ETH\",\n    decimals: 18,\n    wrapped: {\n      address: \"0x82af49447d8a07e3bd95bd0d56f35241523fbab1\",\n      name: \"Wrapped Ether\",\n      symbol: \"WETH\"\n    }\n  },\n  [ChainId.ArbitrumGoerli]: {\n    name: \"Arbitrum Goerli Ether\",\n    symbol: \"AGOR\",\n    decimals: 18,\n    wrapped: {\n      address: \"0xe39Ab88f8A4777030A534146A9Ca3B52bd5D43A3\",\n      name: \"Wrapped Ether\",\n      symbol: \"WETH\"\n    }\n  },\n  [ChainId.Optimism]: {\n    name: \"Ether\",\n    symbol: \"ETH\",\n    decimals: 18,\n    wrapped: {\n      address: \"0x4200000000000000000000000000000000000006\",\n      name: \"Wrapped Ether\",\n      symbol: \"WETH\"\n    }\n  },\n  [ChainId.OptimismGoerli]: {\n    name: \"Goerli Ether\",\n    symbol: \"ETH\",\n    decimals: 18,\n    wrapped: {\n      address: \"0x4200000000000000000000000000000000000006\",\n      name: \"Wrapped Ether\",\n      symbol: \"WETH\"\n    }\n  },\n  [ChainId.BinanceSmartChainMainnet]: {\n    name: \"Binance Chain Native Token\",\n    symbol: \"BNB\",\n    decimals: 18,\n    wrapped: {\n      address: \"0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c\",\n      name: \"Wrapped Binance Chain Token\",\n      symbol: \"WBNB\"\n    }\n  },\n  [ChainId.BinanceSmartChainTestnet]: {\n    name: \"Binance Chain Native Token\",\n    symbol: \"TBNB\",\n    decimals: 18,\n    wrapped: {\n      address: \"0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd\",\n      name: \"Wrapped Binance Chain Testnet Token\",\n      symbol: \"WBNB\"\n    }\n  },\n  [ChainId.Hardhat]: {\n    name: \"Ether\",\n    symbol: \"ETH\",\n    decimals: 18,\n    wrapped: {\n      address: \"0x5FbDB2315678afecb367f032d93F642f64180aa3\",\n      name: \"Wrapped Ether\",\n      symbol: \"WETH\"\n    }\n  },\n  [ChainId.Localhost]: {\n    name: \"Ether\",\n    symbol: \"ETH\",\n    decimals: 18,\n    wrapped: {\n      address: \"0x5FbDB2315678afecb367f032d93F642f64180aa3\",\n      name: \"Wrapped Ether\",\n      symbol: \"WETH\"\n    }\n  },\n  84531: {\n    name: \"Base Goerli Testnet\",\n    symbol: \"ETH\",\n    decimals: 18,\n    wrapped: {\n      address: \"0x4200000000000000000000000000000000000006\",\n      name: \"Wrapped Ether\",\n      symbol: \"WETH\"\n    }\n  },\n  // eslint-disable-next-line no-useless-computed-key\n  [280]: {\n    name: \"zkSync Era Testnet\",\n    symbol: \"ETH\",\n    decimals: 18,\n    wrapped: {\n      address: \"0x5AEa5775959fBC2557Cc8789bC1bf90A239D9a91\",\n      name: \"Wrapped Ether\",\n      symbol: \"WETH\"\n    }\n  }\n};\n\n/**\n * Returns the native token for a given chain\n * @param chainId - the chain id\n * @public\n */\nfunction getNativeTokenByChainId(chainId) {\n  const chain = getSupportedChains().find(c => c.chainId === chainId);\n  if (chain && chain.nativeCurrency) {\n    return {\n      name: chain.nativeCurrency.name,\n      symbol: chain.nativeCurrency.symbol,\n      decimals: 18,\n      wrapped: {\n        address: constants.AddressZero,\n        name: `Wrapped ${chain.nativeCurrency.name}`,\n        symbol: `W${chain.nativeCurrency.symbol}`\n      }\n    };\n  }\n  return NATIVE_TOKENS[chainId] || {\n    name: \"Ether\",\n    symbol: \"ETH\",\n    decimals: 18,\n    wrapped: {\n      address: constants.AddressZero,\n      name: \"Wrapped Ether\",\n      symbol: \"WETH\"\n    }\n  };\n}\nconst LINK_TOKEN_ADDRESS = {\n  [ChainId.Mainnet]: \"0x514910771AF9Ca656af840dff83E8264EcF986CA\",\n  [ChainId.Goerli]: \"0x326C977E6efc84E512bB9C30f76E30c160eD06FB\",\n  [ChainId.BinanceSmartChainMainnet]: \"0x404460C6A5EdE2D891e8297795264fDe62ADBB75\",\n  [ChainId.Polygon]: \"0xb0897686c545045aFc77CF20eC7A532E3120E0F1\",\n  [ChainId.Mumbai]: \"0x326C977E6efc84E512bB9C30f76E30c160eD06FB\",\n  [ChainId.Avalanche]: \"0x5947BB275c521040051D82396192181b413227A3\",\n  [ChainId.AvalancheFujiTestnet]: \"0x0b9d5D9136855f6FEc3c0993feE6E9CE8a297846\",\n  [ChainId.Fantom]: \"0x6F43FF82CCA38001B6699a8AC47A2d0E66939407\",\n  [ChainId.FantomTestnet]: \"0xfaFedb041c0DD4fA2Dc0d87a6B0979Ee6FA7af5F\"\n};\nconst RawDateSchema = /* @__PURE__ */(() => z.union([z.date().transform(i => {\n  return BigNumber.from(Math.floor(i.getTime() / 1000));\n}), z.number().transform(i => {\n  return BigNumber.from(i);\n})]))();\n\n/**\n * Default to now\n */\nconst StartDateSchema = /* @__PURE__ */(() => RawDateSchema.default(new Date(0)))();\n\n/**\n * Default to 10 years from now\n */\nconst EndDateSchema = /* @__PURE__ */(() => RawDateSchema.default(new Date(Date.now() + 1000 * 60 * 60 * 24 * 365 * 10)))();\n\n/**\n * @internal\n */\nconst CurrencySchema = /* @__PURE__ */(() => z.object({\n  name: z.string(),\n  symbol: z.string(),\n  decimals: z.number()\n}))();\n\n/**\n * @internal\n */\nconst CurrencyValueSchema = /* @__PURE__ */(() => CurrencySchema.extend({\n  value: BigNumberSchema,\n  displayValue: z.string()\n}))();\n\n/**\n * @internal\n */\nconst MerkleSchema = /* @__PURE__ */(() => z.object({\n  merkle: z.record(z.string()).default({})\n}))();\nconst SnapshotEntryInput = /* @__PURE__ */(() => z.object({\n  address: AddressOrEnsSchema,\n  maxClaimable: QuantitySchema.default(0),\n  // defaults to 0\n  price: QuantitySchema.optional(),\n  // defaults to unlimited, but can be undefined in old snapshots\n  currencyAddress: AddressOrEnsSchema.default(constants.AddressZero).optional() // defaults to AddressZero, but can be undefined for old snapshots\n}))();\n\n/**\n * @internal\n */\nconst SnapshotInputSchema = /* @__PURE__ */(() => z.union([z.array(z.string()).transform(async strings => await Promise.all(strings.map(address => SnapshotEntryInput.parseAsync({\n  address\n})))), z.array(SnapshotEntryInput)]))();\nconst SnapshotEntryWithProofSchema = /* @__PURE__ */(() => SnapshotEntryInput.extend({\n  proof: z.array(z.string())\n}))();\n\n/**\n * @internal\n */\nconst SnapshotSchema = /* @__PURE__ */(() => z.object({\n  /**\n   * The merkle root\n   */\n  merkleRoot: z.string(),\n  claims: z.array(SnapshotEntryWithProofSchema)\n}))();\n\n/**\n * @internal\n */\n\n/**\n * @internal\n */\nconst SnapshotInfoSchema = /* @__PURE__ */(() => z.object({\n  merkleRoot: z.string(),\n  snapshotUri: z.string()\n}))();\n\n/**\n * @internal\n */\nconst ClaimConditionMetadataSchema = /* @__PURE__ */(() => z.object({\n  name: z.string().optional()\n}).catchall(z.unknown()))();\n\n/**\n * @internal\n */\nconst ClaimConditionInputSchema = /* @__PURE__ */(() => z.object({\n  startTime: StartDateSchema,\n  currencyAddress: z.string().default(NATIVE_TOKEN_ADDRESS),\n  price: AmountSchema.default(0),\n  maxClaimableSupply: QuantitySchema,\n  maxClaimablePerWallet: QuantitySchema,\n  waitInSeconds: BigNumberishSchema.default(0),\n  merkleRootHash: BytesLikeSchema.default(utils.hexZeroPad([0], 32)),\n  snapshot: z.optional(SnapshotInputSchema).nullable(),\n  metadata: ClaimConditionMetadataSchema.optional()\n}))();\n\n/**\n * @internal\n */\nconst ClaimConditionInputArray = /* @__PURE__ */z.array(ClaimConditionInputSchema);\n\n/**\n * @internal\n */\nconst PartialClaimConditionInputSchema = /* @__PURE__ */ClaimConditionInputSchema.partial();\n\n/**\n * @internal\n */\nconst ClaimConditionOutputSchema = /* @__PURE__ */(() => ClaimConditionInputSchema.extend({\n  availableSupply: QuantitySchema,\n  currentMintSupply: QuantitySchema,\n  currencyMetadata: CurrencyValueSchema.default({\n    value: BigNumber.from(\"0\"),\n    displayValue: \"0\",\n    symbol: \"\",\n    decimals: 18,\n    name: \"\"\n  }),\n  price: BigNumberSchema,\n  waitInSeconds: BigNumberSchema,\n  startTime: BigNumberSchema.transform(n => new Date(n.toNumber() * 1000)),\n  snapshot: SnapshotInputSchema.optional().nullable()\n}))();\nfunction resolveOrGenerateId(requestUId) {\n  if (requestUId === undefined) {\n    const buffer = Buffer.alloc(16);\n    v4({}, buffer);\n    return utils.hexlify(utils.toUtf8Bytes(buffer.toString(\"hex\")));\n  } else {\n    return utils.hexlify(requestUId);\n  }\n}\n\n/**\n * @internal\n */\nconst BaseSignaturePayloadInput = /* @__PURE__ */(() => z.object({\n  to: AddressOrEnsSchema.refine(address => address.toLowerCase() !== constants.AddressZero, {\n    message: \"Cannot create payload to mint to zero address\"\n  }),\n  price: AmountSchema.default(0),\n  currencyAddress: AddressSchema.default(NATIVE_TOKEN_ADDRESS),\n  mintStartTime: StartDateSchema,\n  mintEndTime: EndDateSchema,\n  uid: z.string().optional().transform(arg => resolveOrGenerateId(arg)),\n  primarySaleRecipient: AddressOrEnsSchema.default(constants.AddressZero)\n}))();\n\n/**\n * @internal\n */\nconst Signature20PayloadInput = /* @__PURE__ */BaseSignaturePayloadInput.extend({\n  quantity: AmountSchema\n});\n\n/**\n * @internal\n */\nconst Signature20PayloadOutput = /* @__PURE__ */Signature20PayloadInput.extend({\n  mintStartTime: BigNumberSchema,\n  mintEndTime: BigNumberSchema\n});\n\n/**\n * @internal\n */\nconst Signature721PayloadInput = /* @__PURE__ */(() => BaseSignaturePayloadInput.extend({\n  metadata: NFTInputOrUriSchema,\n  royaltyRecipient: z.string().default(constants.AddressZero),\n  royaltyBps: BasisPointsSchema.default(0)\n}))();\n\n/**\n * @internal\n */\nconst Signature721PayloadOutput = /* @__PURE__ */(() => Signature721PayloadInput.extend({\n  metadata: NFTInputOrUriSchema.default(\"\"),\n  uri: z.string(),\n  royaltyBps: BigNumberSchema,\n  mintStartTime: BigNumberSchema,\n  mintEndTime: BigNumberSchema\n}))();\n\n/**\n * @internal\n */\nconst Signature1155PayloadInput = /* @__PURE__ */(() => Signature721PayloadInput.extend({\n  metadata: NFTInputOrUriSchema.default(\"\"),\n  quantity: BigNumberishSchema\n}))();\n\n/**\n * @internal\n */\nconst Signature1155PayloadInputWithTokenId = /* @__PURE__ */Signature1155PayloadInput.extend({\n  tokenId: BigNumberishSchema\n});\n\n/**\n * @internal\n */\nconst Signature1155PayloadOutput = /* @__PURE__ */Signature721PayloadOutput.extend({\n  tokenId: BigNumberSchema,\n  quantity: BigNumberSchema\n});\n\n/**\n * @internal\n */\nconst Signature721WithQuantityInput = /* @__PURE__ */(() => Signature721PayloadInput.extend({\n  metadata: NFTInputOrUriSchema.default(\"\"),\n  quantity: BigNumberSchema.default(1)\n}))();\n\n/**\n * @internal\n */\nconst Signature721WithQuantityOutput = /* @__PURE__ */(() => Signature721PayloadOutput.extend({\n  quantity: BigNumberSchema.default(1)\n}))();\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\nconst MintRequest20 = [{\n  name: \"to\",\n  type: \"address\"\n}, {\n  name: \"primarySaleRecipient\",\n  type: \"address\"\n}, {\n  name: \"quantity\",\n  type: \"uint256\"\n}, {\n  name: \"price\",\n  type: \"uint256\"\n}, {\n  name: \"currency\",\n  type: \"address\"\n}, {\n  name: \"validityStartTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"validityEndTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"uid\",\n  type: \"bytes32\"\n}];\nconst MintRequest721 = [{\n  name: \"to\",\n  type: \"address\"\n}, {\n  name: \"royaltyRecipient\",\n  type: \"address\"\n}, {\n  name: \"royaltyBps\",\n  type: \"uint256\"\n}, {\n  name: \"primarySaleRecipient\",\n  type: \"address\"\n}, {\n  name: \"uri\",\n  type: \"string\"\n}, {\n  name: \"price\",\n  type: \"uint256\"\n}, {\n  name: \"currency\",\n  type: \"address\"\n}, {\n  name: \"validityStartTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"validityEndTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"uid\",\n  type: \"bytes32\"\n}];\nconst MintRequest1155 = [{\n  name: \"to\",\n  type: \"address\"\n}, {\n  name: \"royaltyRecipient\",\n  type: \"address\"\n}, {\n  name: \"royaltyBps\",\n  type: \"uint256\"\n}, {\n  name: \"primarySaleRecipient\",\n  type: \"address\"\n}, {\n  name: \"tokenId\",\n  type: \"uint256\"\n}, {\n  name: \"uri\",\n  type: \"string\"\n}, {\n  name: \"quantity\",\n  type: \"uint256\"\n}, {\n  name: \"pricePerToken\",\n  type: \"uint256\"\n}, {\n  name: \"currency\",\n  type: \"address\"\n}, {\n  name: \"validityStartTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"validityEndTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"uid\",\n  type: \"bytes32\"\n}];\nconst MintRequest721withQuantity = [{\n  name: \"to\",\n  type: \"address\"\n}, {\n  name: \"royaltyRecipient\",\n  type: \"address\"\n}, {\n  name: \"royaltyBps\",\n  type: \"uint256\"\n}, {\n  name: \"primarySaleRecipient\",\n  type: \"address\"\n}, {\n  name: \"uri\",\n  type: \"string\"\n}, {\n  name: \"quantity\",\n  type: \"uint256\"\n}, {\n  name: \"pricePerToken\",\n  type: \"uint256\"\n}, {\n  name: \"currency\",\n  type: \"address\"\n}, {\n  name: \"validityStartTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"validityEndTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"uid\",\n  type: \"bytes32\"\n}];\nconst GenericRequest = [{\n  name: \"validityStartTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"validityEndTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"uid\",\n  type: \"bytes32\"\n}, {\n  name: \"data\",\n  type: \"bytes\"\n}];\n\n/**\n * @internal\n */\nconst CommonContractSchema = /* @__PURE__ */(() => z.object({\n  name: z.string(),\n  description: z.string().optional(),\n  image: FileOrBufferOrStringSchema.optional(),\n  external_link: z.string().optional(),\n  app_uri: z.string().optional(),\n  social_urls: z.record(z.string()).optional()\n}).catchall(z.unknown()))();\n/**\n * @internal\n */\nconst CommonContractOutputSchema = /* @__PURE__ */(() => CommonContractSchema.extend({\n  image: z.string().optional()\n}).catchall(z.unknown()))();\n\n/**\n * @internal\n */\nconst CommonRoyaltySchema = /* @__PURE__ */(() => z.object({\n  /**\n   * The amount of royalty collected on all royalties represented as basis points.\n   * The default is 0 (no royalties).\n   *\n   * 1 basis point = 0.01%\n   *\n   * For example: if this value is 100, then the royalty is 1% of the total sales.\n   *\n   *  @internalremarks used by OpenSea \"seller_fee_basis_points\"\n   */\n  seller_fee_basis_points: BasisPointsSchema.default(0),\n  /**\n   * The address of the royalty recipient. All royalties will be sent\n   * to this address.\n   * @internalremarks used by OpenSea \"fee_recipient\"\n   */\n  fee_recipient: AddressOrEnsSchema.default(constants.AddressZero)\n}))();\n\n/**\n * @internal\n */\nconst CommonPrimarySaleSchema = /* @__PURE__ */z.object({\n  /**\n   * primary sale recipient address\n   */\n  primary_sale_recipient: AddressOrEnsSchema\n});\n\n/**\n * @internal\n */\nconst CommonPlatformFeeSchema = /* @__PURE__ */(() => z.object({\n  /**\n   * platform fee basis points\n   */\n  platform_fee_basis_points: BasisPointsSchema.default(0),\n  /**\n   * platform fee recipient address\n   */\n  platform_fee_recipient: AddressOrEnsSchema.default(constants.AddressZero)\n}))();\n\n/**\n * @internal\n */\nconst CommonTrustedForwarderSchema = /* @__PURE__ */(() => z.object({\n  trusted_forwarders: z.array(AddressOrEnsSchema).default([])\n}))();\n\n/**\n * @internal\n */\nconst CommonSymbolSchema = /* @__PURE__ */(() => z.object({\n  symbol: z.string().default(\"\")\n}))();\n\n/**\n * @internal\n */\nconst BYOCContractMetadataSchema = /* @__PURE__ */(() => CommonContractSchema.catchall(z.union([BigNumberTransformSchema, z.unknown()])))();\n\n/**\n * @internal\n */\n\n/**\n * @internal\n */\nconst CustomContractInput = /* @__PURE__ */(() => BYOCContractMetadataSchema.merge(CommonRoyaltySchema.merge(MerkleSchema).merge(CommonSymbolSchema).partial()).catchall(z.any()))();\n\n/**\n * @internal\n */\nconst CustomContractOutput = /* @__PURE__ */(() => CommonContractOutputSchema.merge(CommonRoyaltySchema.merge(MerkleSchema).merge(CommonSymbolSchema).partial()).catchall(z.any()))();\n\n/**\n * @internal\n */\nconst CustomContractDeploy = /* @__PURE__ */(() => CustomContractInput.merge(CommonPlatformFeeSchema.merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema).partial()))();\n\n/**\n * @internal\n */\nconst CustomContractSchema = {\n  deploy: CustomContractDeploy,\n  output: CustomContractOutput,\n  input: CustomContractInput\n};\n\n/**\n * @internal\n */\nconst AbiTypeBaseSchema = /* @__PURE__ */(() => z.object({\n  type: z.string(),\n  name: z.string().default(\"\")\n}).catchall(z.any()))();\n\n/**\n * @internal\n */\nconst AbiTypeSchema = /* @__PURE__ */(() => AbiTypeBaseSchema.extend({\n  stateMutability: z.string().optional(),\n  components: z.array(AbiTypeBaseSchema).optional()\n}).catchall(z.any()))();\n\n/**\n * @internal\n */\nconst AbiObjectSchema = /* @__PURE__ */(() => z.object({\n  type: z.string(),\n  name: z.string().default(\"\"),\n  inputs: z.array(AbiTypeSchema).default([]),\n  outputs: z.array(AbiTypeSchema).default([])\n}).catchall(z.any()))();\n\n/**\n * @internal\n */\nconst AbiSchema = /* @__PURE__ */z.array(AbiObjectSchema);\n// if we want to statically type this for external usage it has to *awlways* be the output type\n\n// input type is only used internally\n/**\n * @internal\n */\n/**\n * @internal\n */\nconst PreDeployMetadata = /* @__PURE__ */(() => z.object({\n  name: z.string(),\n  metadataUri: z.string(),\n  bytecodeUri: z.string(),\n  analytics: z.any().optional()\n}).catchall(z.any()))();\n\n/**\n * @internal\n */\nconst ChainIdToAddressSchema = /* @__PURE__ */(() => z.record(z.string(), z.string()))();\n\n/**\n * @internal\n */\nconst CustomFactoryInput = /* @__PURE__ */(() => z.object({\n  factoryFunction: z.string(),\n  params: z.array(z.object({\n    name: z.string(),\n    type: z.string()\n  })).default([]),\n  customFactoryAddresses: ChainIdToAddressSchema\n}))();\n\n/**\n * @internal\n */\nconst FactoryDeploymentSchema = /* @__PURE__ */(() => z.object({\n  implementationAddresses: ChainIdToAddressSchema,\n  implementationInitializerFunction: z.string().default(\"initialize\"),\n  customFactoryInput: CustomFactoryInput.optional(),\n  factoryAddresses: ChainIdToAddressSchema.optional()\n}))();\n\n/**\n * @internal\n */\nconst DeployTypeInput = /* @__PURE__ */(() => z.union([z.literal(\"standard\"), z.literal(\"autoFactory\"), z.literal(\"customFactory\")]))();\n\n/**\n * @internal\n */\nconst RouterTypeInput = /* @__PURE__ */(() => z.union([z.literal(\"none\"), z.literal(\"plugin\"), z.literal(\"dynamic\")]))();\n\n/**\n * @internal\n */\nconst DeploymentNetworkInput = /* @__PURE__ */(() => z.object({\n  allNetworks: z.boolean().optional(),\n  networksEnabled: z.array(z.number()).default([])\n}))();\n\n/**\n * @internal\n */\nconst ExtraPublishMetadataSchemaInput = /* @__PURE__ */(() => z.object({\n  version: z.string().refine(v => {\n    try {\n      toSemver(v);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }, out => {\n    return {\n      message: `'${out}' is not a valid semantic version. Should be in the format of major.minor.patch. Ex: 0.4.1`\n    };\n  }),\n  displayName: z.string().optional(),\n  description: z.string().optional(),\n  readme: z.string().optional(),\n  license: z.string().optional(),\n  changelog: z.string().optional(),\n  tags: z.array(z.string()).optional(),\n  audit: FileOrBufferOrStringSchema.nullable().optional(),\n  logo: FileOrBufferOrStringSchema.nullable().optional(),\n  isDeployableViaFactory: z.boolean().optional(),\n  isDeployableViaProxy: z.boolean().optional(),\n  factoryDeploymentData: FactoryDeploymentSchema.optional(),\n  deployType: DeployTypeInput.optional(),\n  routerType: RouterTypeInput.optional(),\n  defaultExtensions: z.array(z.object({\n    extensionName: z.string(),\n    extensionVersion: z.string().default(\"latest\"),\n    publisherAddress: AddressOrEnsSchema\n  })).optional(),\n  networksForDeployment: DeploymentNetworkInput.optional(),\n  constructorParams: z.record(z.string(), z.object({\n    displayName: z.string().optional(),\n    description: z.string().optional(),\n    defaultValue: z.string().optional(),\n    hidden: z.boolean().optional()\n  }).catchall(z.any())).optional(),\n  compositeAbi: AbiSchema.optional()\n}).catchall(z.any()))();\n\n/**\n * @internal\n */\nconst ExtraPublishMetadataSchemaOutput = /* @__PURE__ */(() => ExtraPublishMetadataSchemaInput.extend({\n  audit: z.string().nullable().optional(),\n  logo: z.string().nullable().optional()\n}))();\n/**\n * @internal\n */\nconst FullPublishMetadataSchemaInput = /* @__PURE__ */(() => PreDeployMetadata.merge(ExtraPublishMetadataSchemaInput).extend({\n  publisher: AddressOrEnsSchema.optional()\n}))();\n\n/**\n * @internal\n */\nconst FullPublishMetadataSchemaOutput = /* @__PURE__ */(() => PreDeployMetadata.merge(ExtraPublishMetadataSchemaOutput).extend({\n  publisher: AddressOrEnsSchema.optional()\n}))();\n/**\n * @internal\n */\nconst ProfileSchemaInput = /* @__PURE__ */(() => z.object({\n  name: z.string().optional(),\n  bio: z.string().optional(),\n  avatar: FileOrBufferOrStringSchema.nullable().optional(),\n  website: z.string().optional(),\n  twitter: z.string().optional(),\n  telegram: z.string().optional(),\n  facebook: z.string().optional(),\n  github: z.string().optional(),\n  medium: z.string().optional(),\n  linkedin: z.string().optional(),\n  reddit: z.string().optional(),\n  discord: z.string().optional()\n}))();\nconst ProfileSchemaOutput = /* @__PURE__ */(() => ProfileSchemaInput.extend({\n  avatar: z.string().nullable().optional()\n}))();\n/**\n * @internal\n */\nconst PublishedContractSchema = /* @__PURE__ */(() => z.object({\n  id: z.string(),\n  timestamp: BigNumberishSchema,\n  metadataUri: z.string()\n}))();\n\n/**\n * @internal\n * Follows https://docs.soliditylang.org/en/v0.8.15/natspec-format.html\n */\nconst ContractInfoSchema = /* @__PURE__ */(() => z.object({\n  title: z.string().optional(),\n  author: z.string().optional(),\n  details: z.string().optional(),\n  notice: z.string().optional()\n}))();\n\n/**\n * @internal\n */\nconst CompilerMetadataFetchedSchema = /* @__PURE__ */(() => z.object({\n  name: z.string(),\n  abi: AbiSchema,\n  metadata: z.record(z.string(), z.any()),\n  info: ContractInfoSchema,\n  licenses: z.array(z.string().optional()).default([]).transform(v => {\n    return v.filter(license => license !== undefined);\n  }),\n  isPartialAbi: z.boolean().optional()\n}))();\n\n/**\n * @internal\n */\nconst PreDeployMetadataFetchedSchema = /* @__PURE__ */(() => PreDeployMetadata.merge(CompilerMetadataFetchedSchema).extend({\n  bytecode: z.string()\n}))();\nconst CallOverrideSchema = /* @__PURE__ */(() => z.object({\n  gasLimit: BigNumberishSchema.optional(),\n  gasPrice: BigNumberishSchema.optional(),\n  maxFeePerGas: BigNumberishSchema.optional(),\n  maxPriorityFeePerGas: BigNumberishSchema.optional(),\n  nonce: BigNumberishSchema.optional(),\n  value: BigNumberishSchema.optional(),\n  blockTag: z.union([z.string(), z.number()]).optional(),\n  from: AddressOrEnsSchema.optional(),\n  type: z.number().optional()\n}).strict())();\n\n/**\n * Encodes and decodes Contract functions\n * @public\n */\nclass ContractEncoder {\n  constructor(contractWrapper) {\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * Encodes the given contract function with argument\n   * @returns the encoded data\n   */\n  encode(fn, args) {\n    return this.contractWrapper.readContract.interface.encodeFunctionData(fn, args);\n  }\n\n  /**\n   * Decode encoded call data for a given function\n   * @param fn - the function to decode\n   * @param encodedArgs - the encoded arguments\n   */\n  decode(fn, encodedArgs) {\n    return this.contractWrapper.readContract.interface.decodeFunctionData(fn, encodedArgs);\n  }\n}\n\n/**\n * Error that may get thrown if IPFS returns nothing for a given uri.\n * @internal\n */\nclass NotFoundError extends Error {\n  /** @internal */\n  constructor(identifier) {\n    super(identifier ? `Object with id ${identifier} NOT FOUND` : \"NOT_FOUND\");\n  }\n}\n\n/**\n * Error that may get thrown if an invalid address was passed\n * @internal\n */\nclass InvalidAddressError extends Error {\n  /** @internal */\n  constructor(address) {\n    super(address ? `'${address}' is an invalid address` : \"Invalid address passed\");\n  }\n}\n\n/**\n * @internal\n */\nclass MissingRoleError extends Error {\n  /** @internal */\n  /** @internal */\n  constructor(address, role) {\n    super(`MISSING ROLE: ${address} does not have the '${role}' role`);\n  }\n}\n\n/**\n * @internal\n */\nclass AssetNotFoundError extends Error {\n  /** @internal */\n  /** @internal */\n  constructor() {\n    let message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"The asset you're trying to use could not be found.\";\n    super(`message: ${message}`);\n  }\n}\n\n/**\n * @internal\n */\nclass UploadError extends Error {\n  /** @internal */\n  constructor(message) {\n    super(`UPLOAD_FAILED: ${message}`);\n  }\n}\n\n/**\n * @internal\n */\nclass FileNameMissingError extends Error {\n  /** @internal */\n  constructor() {\n    super(\"File name is required when object is not a `File` type object.\");\n  }\n}\n\n/**\n * @internal\n */\nclass DuplicateFileNameError extends Error {\n  /** @internal */\n  constructor(fileName) {\n    super(`DUPLICATE_FILE_NAME_ERROR: File name ${fileName} was passed for more than one file.`);\n  }\n}\n\n/**\n * @internal\n */\nclass NotEnoughTokensError extends Error {\n  /** @internal */\n  constructor(contractAddress, quantity, available) {\n    super(`BALANCE ERROR: you do not have enough balance on contract ${contractAddress} to use ${quantity} tokens. You have ${available} tokens available.`);\n  }\n}\n\n/**\n * @internal\n */\nclass MissingOwnerRoleError extends Error {\n  /** @internal */\n  constructor() {\n    super(`LIST ERROR: you should be the owner of the token to list it.`);\n  }\n}\n\n/**\n * @internal\n */\nclass QuantityAboveLimitError extends Error {\n  /** @internal */\n  constructor(quantity) {\n    super(`BUY ERROR: You cannot buy more than ${quantity} tokens`);\n  }\n}\n\n/**\n * Thrown when data fails to fetch from storage.\n * @internal\n */\nclass FetchError extends Error {\n  /** @internal */\n  constructor(message, innerError) {\n    super(`FETCH_FAILED: ${message}`);\n    this.innerError = innerError;\n  }\n}\n\n/**\n * Thrown when attempting to create a snapshot with duplicate leafs\n * @internal\n */\nclass DuplicateLeafsError extends Error {\n  constructor(message) {\n    super(`DUPLICATE_LEAFS${message ? ` : ${message}` : \"\"}`);\n  }\n}\n\n/**\n * Thrown when attempting to update/cancel an auction that already started\n * @internal\n */\nclass AuctionAlreadyStartedError extends Error {\n  constructor(id) {\n    super(`Auction already started with existing bid${id ? `, id: ${id}` : \"\"}`);\n  }\n}\n\n/**\n * @internal\n */\nclass FunctionDeprecatedError extends Error {\n  /** @internal */\n  constructor(message) {\n    super(`FUNCTION DEPRECATED. ${message ? `Use ${message} instead` : \"\"}`);\n  }\n}\n\n/**\n * Thrown when trying to retrieve a listing from a marketplace that doesn't exist\n * @internal\n */\nclass ListingNotFoundError extends Error {\n  constructor(marketplaceContractAddress, listingId) {\n    super(`Could not find listing.${marketplaceContractAddress ? ` marketplace address: ${marketplaceContractAddress}` : \"\"}${listingId ? ` listing id: ${listingId}` : \"\"}`);\n  }\n}\n\n/**\n * Thrown when trying to retrieve a listing of the wrong type\n * @internal\n */\nclass WrongListingTypeError extends Error {\n  constructor(marketplaceContractAddress, listingId, actualType, expectedType) {\n    super(`Incorrect listing type. Are you sure you're using the right method?.${marketplaceContractAddress ? ` marketplace address: ${marketplaceContractAddress}` : \"\"}${listingId ? ` listing id: ${listingId}` : \"\"}${expectedType ? ` expected type: ${expectedType}` : \"\"}${actualType ? ` actual type: ${actualType}` : \"\"}`);\n  }\n}\n\n/**\n * Thrown when attempting to transfer an asset that has restricted transferability\n * @internal\n */\nclass RestrictedTransferError extends Error {\n  constructor(assetAddress) {\n    super(`Failed to transfer asset, transfer is restricted.${assetAddress ? ` Address : ${assetAddress}` : \"\"}`);\n  }\n}\n\n/**\n * Thrown when attempting to execute an admin-role function.\n * @internal\n */\nclass AdminRoleMissingError extends Error {\n  constructor(address, contractAddress) {\n    let message = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"Failed to execute transaction\";\n    super(`${message}, admin role is missing${address ? ` on address: ${address}` : \"\"}${contractAddress ? ` on contract: ${contractAddress}` : \"\"}`);\n  }\n}\n\n/**\n * Thrown when attempting to close an auction that has not ended\n * @internal\n */\nclass AuctionHasNotEndedError extends Error {\n  constructor(id, endTime) {\n    super(`Auction has not ended yet${id ? `, id: ${id}` : \"\"}${endTime ? `, end time: ${endTime.toString()}` : \"\"}`);\n  }\n}\n\n/**\n * Thrown when attempting to call a contract function that is not implemented\n * @internal\n */\nclass ExtensionNotImplementedError extends Error {\n  constructor(feature) {\n    super(`This functionality is not available because the contract does not implement the '${feature.name}' Extension. Learn how to unlock this functionality at https://portal.thirdweb.com/extensions `);\n  }\n}\n\n/**\n * @internal\n */\n\n/**\n * @public\n */\nclass TransactionError extends Error {\n  #reason;\n  #info;\n  #raw;\n  constructor(info, raw) {\n    let errorMessage = `\\n\\n\\n╔═══════════════════╗\\n║ TRANSACTION ERROR ║\\n╚═══════════════════╝\\n\\n`;\n    errorMessage += `Reason: ${info.reason}`;\n    errorMessage += `\\n\\n\\n╔═════════════════════════╗\\n║ TRANSACTION INFORMATION ║\\n╚═════════════════════════╝\\n`;\n    errorMessage += withSpaces(\"from\", info.from);\n    if (info.to) {\n      errorMessage += withSpaces(\"to\", info.contractName ? `${info.to} (${info.contractName})` : info.to);\n    }\n    errorMessage += withSpaces(`chain`, `${info.network.name} (${info.network.chainId})`);\n    if (info.rpcUrl) {\n      try {\n        const url = new URL(info.rpcUrl);\n        errorMessage += withSpaces(`rpc`, url.hostname);\n      } catch (e2) {\n        // ignore if can't parse URL\n      }\n    }\n    if (info.hash) {\n      errorMessage += withSpaces(`tx hash`, info.hash);\n    }\n    if (info.value && info.value.gt(0)) {\n      errorMessage += withSpaces(\"value\", `${utils.formatEther(info.value)} ${NATIVE_TOKENS[info.network.chainId]?.symbol || \"\"}`);\n    }\n    errorMessage += withSpaces(`data`, `${info.data}`);\n    if (info.method) {\n      errorMessage += withSpaces(\"method\", info.method);\n    }\n    if (info.sources) {\n      const revertFile = info.sources.find(file => file.source.includes(info.reason));\n      if (revertFile) {\n        const lines = revertFile.source.split(\"\\n\").map((line, index) => `${index + 1}  ${line}`);\n        const revertLine = lines.findIndex(line => line.includes(info.reason));\n        lines[revertLine] += \"   <-- REVERT\";\n        const errorLines = lines.slice(revertLine - 8, revertLine + 4);\n        errorMessage += `\\n\\n\\n╔══════════════════════╗\\n║ SOLIDITY STACK TRACE ║\\n╚══════════════════════╝\\n\\n`;\n        errorMessage += `File: ${revertFile.filename.replace(\"node_modules/\", \"\")}\\n\\n`;\n        errorMessage += errorLines.join(\"\\n\");\n      }\n    }\n    errorMessage += `\\n\\n\\n╔═════════════════════╗\\n║ DEBUGGING RESOURCES ║\\n╚═════════════════════╝\\n\\n`;\n    errorMessage += `Need helping debugging? Join our Discord: https://discord.gg/thirdweb`;\n    errorMessage += `\\n\\n`;\n    super(errorMessage);\n    this.#reason = info.reason;\n    this.#info = info;\n    this.#raw = raw;\n  }\n\n  // Keep reason here for backwards compatibility\n  get reason() {\n    return this.#reason;\n  }\n  get raw() {\n    return this.#raw;\n  }\n  get info() {\n    return this.#info;\n  }\n}\n\n/**\n * @internal\n */\nfunction parseRevertReason(error) {\n  if (error.reason && !error.reason.includes(\"cannot estimate gas\")) {\n    return error.reason;\n  }\n  if (error.error) {\n    return error.error;\n  }\n\n  // I think this code path should never be hit, but just in case\n\n  let errorString = error;\n  if (typeof error === \"object\") {\n    // MetaMask errors come as objects so parse them first\n    errorString = JSON.stringify(error);\n  } else if (typeof error !== \"string\") {\n    errorString = error.toString();\n  }\n  return parseMessageParts(/.*?\"message\":\"([^\"\\\\]*).*?/, errorString) || parseMessageParts(/.*?\"reason\":\"([^\"\\\\]*).*?/, errorString) || error.message || \"\";\n}\nfunction withSpaces(label, content) {\n  if (content === \"\") {\n    return content;\n  }\n  const spaces = Array(10 - label.length).fill(\" \").join(\"\");\n  if (content.includes(\"\\n\")) {\n    content = \"\\n\\n  \" + content.split(\"\\n\").join(`\\n  `);\n  } else {\n    content = `${spaces}${content}`;\n  }\n  return `\\n${label}:${content}`;\n}\nfunction parseMessageParts(regex, raw) {\n  const msgMatches = raw.match(regex) || [];\n  let extracted = \"\";\n  if (msgMatches?.length > 0) {\n    extracted += msgMatches[1];\n  }\n  return extracted;\n}\n\n/**\n * @internal\n * @param err\n * @param message\n */\nfunction includesErrorMessage(err, message) {\n  if (!err) {\n    return false;\n  }\n  return err && err.toString().includes(message) || err && err.message && err.message.toString().includes(message) || err && err.error && err.error.toString().includes(message);\n}\nconst FEATURE_TOKEN_CLAIM_CONDITIONS_V1 = {\n  name: \"ERC20ClaimConditionsV1\",\n  namespace: \"token.drop.claim\",\n  docLinks: {\n    sdk: \"sdk.erc20dclaimable\",\n    contracts: \"erc20claimconditions\"\n  },\n  abis: [ERC20Abi, IDropSinglePhaseV1],\n  features: {}\n};\nconst FEATURE_TOKEN_CLAIM_CONDITIONS_V2 = {\n  name: \"ERC20ClaimConditionsV2\",\n  namespace: \"token.drop.claim\",\n  docLinks: {\n    sdk: \"sdk.erc20dclaimable\",\n    contracts: \"erc20claimconditions\"\n  },\n  abis: [ERC20Abi, IDropSinglePhase],\n  features: {}\n};\nconst FEATURE_TOKEN_CLAIM_PHASES_V2 = {\n  name: \"ERC20ClaimPhasesV2\",\n  namespace: \"token.drop.claim\",\n  docLinks: {\n    sdk: \"sdk.erc20dclaimable\",\n    contracts: \"erc20claimphases\"\n  },\n  abis: [ERC20Abi, IDrop],\n  features: {}\n};\nconst FEATURE_TOKEN_CLAIM_PHASES_V1 = {\n  name: \"ERC20ClaimPhasesV1\",\n  namespace: \"token.drop.claim\",\n  docLinks: {\n    sdk: \"sdk.erc20dclaimable\",\n    contracts: \"erc20claimphases\"\n  },\n  abis: [DropERC20_V2Abi],\n  features: {}\n};\nconst FEATURE_TOKEN_BURNABLE = {\n  name: \"ERC20Burnable\",\n  namespace: \"token.burn\",\n  docLinks: {\n    sdk: \"sdk.erc20burnable\",\n    contracts: \"erc20burnable\"\n  },\n  abis: [ERC20Abi, IBurnableERC20Abi],\n  features: {}\n};\nconst FEATURE_TOKEN_SIGNATURE_MINTABLE = {\n  name: \"ERC20SignatureMintable\",\n  namespace: \"token.signature\",\n  docLinks: {\n    sdk: \"sdk.erc20signaturemintable\",\n    contracts: \"erc20signaturemint\"\n  },\n  abis: [ERC20Abi, ISignatureMintERC20Abi],\n  features: {}\n};\nconst FEATURE_TOKEN_BATCH_MINTABLE = {\n  name: \"ERC20BatchMintable\",\n  namespace: \"token.mint.batch\",\n  docLinks: {\n    sdk: \"sdk.erc20batchmintable\",\n    contracts: \"erc20batchmintable\"\n  },\n  abis: [ERC20Abi, IMintableERC20Abi, MulticallAbi],\n  features: {}\n};\nconst FEATURE_TOKEN_MINTABLE = {\n  name: \"ERC20Mintable\",\n  namespace: \"token.mint\",\n  docLinks: {\n    sdk: \"sdk.erc20mintable\",\n    contracts: \"erc20mintable\"\n  },\n  abis: [ERC20Abi, IMintableERC20Abi],\n  features: {\n    [FEATURE_TOKEN_BATCH_MINTABLE.name]: FEATURE_TOKEN_BATCH_MINTABLE\n  }\n};\nconst FEATURE_TOKEN_PERMIT = {\n  name: \"ERC20Permit\",\n  namespace: \"token.permit\",\n  docLinks: {\n    sdk: \"sdk.erc20permit\",\n    contracts: \"erc20permit\"\n  },\n  abis: [ERC20Abi, IERC20PermitAbi],\n  features: {}\n};\nconst FEATURE_TOKEN = {\n  name: \"ERC20\",\n  namespace: \"token\",\n  docLinks: {\n    sdk: \"sdk.erc20\",\n    contracts: \"erc20\"\n  },\n  abis: [ERC20Abi, IERC20MetadataAbi],\n  features: {\n    [FEATURE_TOKEN_BURNABLE.name]: FEATURE_TOKEN_BURNABLE,\n    [FEATURE_TOKEN_MINTABLE.name]: FEATURE_TOKEN_MINTABLE,\n    [FEATURE_TOKEN_CLAIM_CONDITIONS_V1.name]: FEATURE_TOKEN_CLAIM_CONDITIONS_V1,\n    [FEATURE_TOKEN_CLAIM_CONDITIONS_V2.name]: FEATURE_TOKEN_CLAIM_CONDITIONS_V2,\n    [FEATURE_TOKEN_CLAIM_PHASES_V1.name]: FEATURE_TOKEN_CLAIM_PHASES_V1,\n    [FEATURE_TOKEN_CLAIM_PHASES_V2.name]: FEATURE_TOKEN_CLAIM_PHASES_V2,\n    [FEATURE_TOKEN_SIGNATURE_MINTABLE.name]: FEATURE_TOKEN_SIGNATURE_MINTABLE,\n    [FEATURE_TOKEN_PERMIT.name]: FEATURE_TOKEN_PERMIT\n  }\n};\nconst FEATURE_NFT_BURNABLE = {\n  name: \"ERC721Burnable\",\n  namespace: \"nft.burn\",\n  docLinks: {\n    sdk: \"sdk.erc721burnable\",\n    contracts: \"erc721burnable\"\n  },\n  abis: [Erc721Abi, IBurnableERC721Abi],\n  features: {}\n};\nconst FEATURE_NFT_REVEALABLE = {\n  name: \"ERC721Revealable\",\n  namespace: \"nft.drop.revealer\",\n  docLinks: {\n    sdk: \"sdk.delayedreveal\",\n    contracts: \"erc721revealable\"\n  },\n  abis: [Erc721Abi, ILazyMintAbi, DelayedRevealAbi],\n  features: {}\n};\nconst FEATURE_NFT_TIERED_DROP = {\n  name: \"ERC721TieredDrop\",\n  namespace: \"nft.tieredDrop\",\n  docLinks: {\n    sdk: \"sdk.erc721tiereddrop\",\n    //TODO\n    contracts: \"\"\n  },\n  abis: [Erc721Abi, TieredDropAbi],\n  features: {}\n};\nconst FEATURE_NFT_CLAIM_CONDITIONS_V1 = {\n  name: \"ERC721ClaimConditionsV1\",\n  namespace: \"nft.drop.claim\",\n  docLinks: {\n    sdk: \"sdk.erc721claimable\",\n    contracts: \"erc721claimconditions\"\n  },\n  abis: [Erc721Abi, IDropSinglePhaseV1],\n  features: {}\n};\nconst FEATURE_NFT_CLAIM_CONDITIONS_V2 = {\n  name: \"ERC721ClaimConditionsV2\",\n  namespace: \"nft.drop.claim\",\n  docLinks: {\n    sdk: \"sdk.erc721claimable\",\n    contracts: \"erc721claimconditions\"\n  },\n  abis: [Erc721Abi, IDropSinglePhase],\n  features: {}\n};\nconst FEATURE_NFT_CLAIM_PHASES_V1 = {\n  name: \"ERC721ClaimPhasesV1\",\n  namespace: \"nft.drop.claim\",\n  docLinks: {\n    sdk: \"sdk.erc721claimable\",\n    contracts: \"erc721claimphases\"\n  },\n  abis: [DropERC721_V3Abi],\n  features: {}\n};\nconst FEATURE_NFT_CLAIM_PHASES_V2 = {\n  name: \"ERC721ClaimPhasesV2\",\n  namespace: \"nft.drop.claim\",\n  docLinks: {\n    sdk: \"sdk.erc721claimable\",\n    contracts: \"erc721claimphases\"\n  },\n  abis: [Erc721Abi, IDrop],\n  features: {}\n};\nconst FEATURE_NFT_CLAIM_CUSTOM = {\n  name: \"ERC721ClaimCustom\",\n  namespace: \"nft.drop.claim\",\n  docLinks: {\n    sdk: \"sdk.erc721claimable\",\n    contracts: \"erc721claimcustom\"\n  },\n  abis: [Erc721Abi, IClaimableERC721],\n  features: {}\n};\nconst FEATURE_NFT_CLAIM_ZORA = {\n  name: \"ERC721ClaimZora\",\n  namespace: \"nft.drop.claim\",\n  docLinks: {\n    sdk: \"sdk.erc721claimable\",\n    contracts: \"erc721claimzora\"\n  },\n  abis: [Erc721Abi, zora_IDropERC721],\n  features: {}\n};\nconst FEATURE_NFT_LAZY_MINTABLE = {\n  name: \"ERC721LazyMintable\",\n  namespace: \"nft.drop\",\n  docLinks: {\n    sdk: \"sdk.erc721lazymintable\",\n    contracts: \"lazymint\"\n  },\n  abis: [Erc721Abi, ILazyMintAbi],\n  features: {\n    [FEATURE_NFT_REVEALABLE.name]: FEATURE_NFT_REVEALABLE\n  }\n};\nconst FEATURE_NFT_BATCH_MINTABLE = {\n  name: \"ERC721BatchMintable\",\n  namespace: \"nft.mint.batch\",\n  docLinks: {\n    sdk: \"sdk.erc721batchmintable\",\n    contracts: \"erc721batchmintable\"\n  },\n  abis: [Erc721Abi, IMintableERC721Abi, MulticallAbi],\n  features: {}\n};\nconst FEATURE_NFT_MINTABLE = {\n  name: \"ERC721Mintable\",\n  namespace: \"nft.mint\",\n  docLinks: {\n    sdk: \"sdk.erc721mintable\",\n    contracts: \"erc721mintable\"\n  },\n  abis: [Erc721Abi, IMintableERC721Abi],\n  features: {\n    [FEATURE_NFT_BATCH_MINTABLE.name]: FEATURE_NFT_BATCH_MINTABLE\n  }\n};\nconst FEATURE_NFT_SIGNATURE_MINTABLE_V2 = {\n  name: \"ERC721SignatureMintV2\",\n  namespace: \"nft.signature\",\n  docLinks: {\n    sdk: \"sdk.erc721signaturemint\",\n    contracts: \"erc721signaturemint\"\n  },\n  abis: [Erc721Abi, SignatureMintERC721Abi],\n  features: {}\n};\nconst FEATURE_NFT_SIGNATURE_MINTABLE_V1 = {\n  name: \"ERC721SignatureMintV1\",\n  namespace: \"nft.signature\",\n  docLinks: {\n    sdk: \"sdk.erc721signaturemint\",\n    contracts: \"erc721signaturemint\"\n  },\n  abis: [SignatureMintERC721_V1Abi],\n  features: {}\n};\nconst FEATURE_NFT_ENUMERABLE = {\n  name: \"ERC721Enumerable\",\n  namespace: \"nft.query.owned\",\n  docLinks: {\n    sdk: \"sdk.erc721enumerable\",\n    contracts: \"erc721enumerable\"\n  },\n  abis: [Erc721Abi, Erc721EnumerableAbi],\n  features: {}\n};\nconst FEATURE_NFT_QUERYABLE = {\n  name: \"ERC721AQueryable\",\n  namespace: \"nft.query.owned\",\n  docLinks: {\n    sdk: \"\",\n    contracts: \"\"\n  },\n  abis: [Erc721AQueryableAbi],\n  features: {}\n};\nconst FEATURE_NFT_SUPPLY = {\n  name: \"ERC721Supply\",\n  namespace: \"nft.query\",\n  docLinks: {\n    sdk: \"sdk.erc721supply\",\n    contracts: \"erc721supply\"\n  },\n  abis: [Erc721Abi, Erc721SupplyAbi],\n  features: {\n    [FEATURE_NFT_ENUMERABLE.name]: FEATURE_NFT_ENUMERABLE,\n    [FEATURE_NFT_QUERYABLE.name]: FEATURE_NFT_QUERYABLE\n  }\n};\nconst FEATURE_NFT_SHARED_METADATA = {\n  name: \"ERC721SharedMetadata\",\n  namespace: \"nft.sharedmetadata\",\n  docLinks: {\n    sdk: \"sdk.sharedmetadata\",\n    contracts: \"SharedMetadata\"\n  },\n  abis: [Erc721Abi, SharedMetadataAbi],\n  features: {}\n};\nconst FEATURE_NFT_LOYALTY_CARD = {\n  name: \"ERC721LoyaltyCard\",\n  namespace: \"nft.loyaltyCard\",\n  docLinks: {\n    // TODO\n    sdk: \"\",\n    contracts: \"\"\n  },\n  abis: [ILoyaltyCardAbi],\n  features: {}\n};\nconst FEATURE_NFT_UPDATABLE_METADATA = {\n  name: \"ERC721UpdatableMetadata\",\n  namespace: \"nft.metadata\",\n  docLinks: {\n    // TODO\n    sdk: \"\",\n    contracts: \"\"\n  },\n  abis: [Erc721Abi, INFTMetadataAbi],\n  features: {}\n};\nconst FEATURE_NFT = {\n  name: \"ERC721\",\n  namespace: \"nft\",\n  docLinks: {\n    sdk: \"sdk.erc721\",\n    contracts: \"erc721\"\n  },\n  abis: [Erc721Abi, IERC721MetadataAbi],\n  features: {\n    [FEATURE_NFT_BURNABLE.name]: FEATURE_NFT_BURNABLE,\n    [FEATURE_NFT_SUPPLY.name]: FEATURE_NFT_SUPPLY,\n    [FEATURE_NFT_MINTABLE.name]: FEATURE_NFT_MINTABLE,\n    [FEATURE_NFT_LAZY_MINTABLE.name]: FEATURE_NFT_LAZY_MINTABLE,\n    [FEATURE_NFT_SIGNATURE_MINTABLE_V1.name]: FEATURE_NFT_SIGNATURE_MINTABLE_V1,\n    [FEATURE_NFT_SIGNATURE_MINTABLE_V2.name]: FEATURE_NFT_SIGNATURE_MINTABLE_V2,\n    [FEATURE_NFT_TIERED_DROP.name]: FEATURE_NFT_TIERED_DROP,\n    [FEATURE_NFT_CLAIM_CUSTOM.name]: FEATURE_NFT_CLAIM_CUSTOM,\n    [FEATURE_NFT_CLAIM_ZORA.name]: FEATURE_NFT_CLAIM_ZORA,\n    [FEATURE_NFT_CLAIM_CONDITIONS_V1.name]: FEATURE_NFT_CLAIM_CONDITIONS_V1,\n    [FEATURE_NFT_CLAIM_CONDITIONS_V2.name]: FEATURE_NFT_CLAIM_CONDITIONS_V2,\n    [FEATURE_NFT_CLAIM_PHASES_V1.name]: FEATURE_NFT_CLAIM_PHASES_V1,\n    [FEATURE_NFT_CLAIM_PHASES_V2.name]: FEATURE_NFT_CLAIM_PHASES_V2,\n    [FEATURE_NFT_SHARED_METADATA.name]: FEATURE_NFT_SHARED_METADATA,\n    [FEATURE_NFT_LOYALTY_CARD.name]: FEATURE_NFT_LOYALTY_CARD,\n    [FEATURE_NFT_UPDATABLE_METADATA.name]: FEATURE_NFT_UPDATABLE_METADATA\n  }\n};\n\n// TODO could be part of IERC1155Metadata even though its not in the spec\nconst NAME_SYMBOL_ABI = [{\n  inputs: [],\n  name: \"name\",\n  outputs: [{\n    internalType: \"string\",\n    name: \"\",\n    type: \"string\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"symbol\",\n  outputs: [{\n    internalType: \"string\",\n    name: \"\",\n    type: \"string\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}];\nconst FEATURE_EDITION_BURNABLE = {\n  name: \"ERC1155Burnable\",\n  namespace: \"edition.burn\",\n  docLinks: {\n    sdk: \"sdk.erc1155burnable\",\n    contracts: \"erc1155burnable\"\n  },\n  abis: [Erc1155Abi, IBurnableERC1155Abi],\n  features: {}\n};\nconst FEATURE_EDITION_CLAIM_CONDITIONS_V1 = {\n  name: \"ERC1155ClaimConditionsV1\",\n  namespace: \"edition.drop.claim\",\n  docLinks: {\n    sdk: \"sdk.erc1155claimable\",\n    contracts: \"erc1155dropsinglephase\"\n  },\n  abis: [Erc1155Abi, IDropSinglePhase1155_V1],\n  features: {}\n};\nconst FEATURE_EDITION_CLAIM_CONDITIONS_V2 = {\n  name: \"ERC1155ClaimConditionsV2\",\n  namespace: \"edition.drop.claim\",\n  docLinks: {\n    sdk: \"sdk.erc1155claimable\",\n    contracts: \"erc1155claimconditions\"\n  },\n  abis: [Erc1155Abi, IDropSinglePhase1155],\n  features: {}\n};\nconst FEATURE_EDITION_CLAIM_PHASES_V2 = {\n  name: \"ERC1155ClaimPhasesV2\",\n  namespace: \"edition.drop.claim\",\n  docLinks: {\n    sdk: \"sdk.erc1155claimable\",\n    contracts: \"erc1155claimphases\"\n  },\n  abis: [Erc1155Abi, IDropMultiPhase1155],\n  features: {}\n};\nconst FEATURE_EDITION_CLAIM_PHASES_V1 = {\n  name: \"ERC1155ClaimPhasesV1\",\n  namespace: \"edition.drop.claim\",\n  docLinks: {\n    sdk: \"sdk.erc1155claimable\",\n    contracts: \"erc1155claimphases\"\n  },\n  abis: [DropERC1155_V2Abi],\n  features: {}\n};\nconst FEATURE_EDITION_CLAIM_CUSTOM = {\n  name: \"ERC1155ClaimCustom\",\n  namespace: \"edition.drop.claim\",\n  docLinks: {\n    sdk: \"sdk.erc1155claimable\",\n    contracts: \"erc1155claimcustom\"\n  },\n  abis: [Erc1155Abi, IClaimableERC1155],\n  features: {}\n};\nconst FEATURE_EDITION_REVEALABLE = {\n  name: \"ERC1155Revealable\",\n  namespace: \"edition.drop.revealer\",\n  docLinks: {\n    sdk: \"sdk.drop.delayedreveal\",\n    contracts: \"erc1155revealable\"\n  },\n  abis: [Erc1155Abi, ILazyMintAbi, DelayedRevealAbi],\n  features: {}\n};\nconst FEATURE_EDITION_LAZY_MINTABLE_V2 = {\n  name: \"ERC1155LazyMintableV2\",\n  namespace: \"edition.drop\",\n  docLinks: {\n    sdk: \"sdk.erc1155droppable\",\n    contracts: \"lazymint\"\n  },\n  abis: [Erc1155Abi, ILazyMintAbi],\n  features: {\n    [FEATURE_EDITION_REVEALABLE.name]: FEATURE_EDITION_REVEALABLE\n  }\n};\nconst FEATURE_EDITION_LAZY_MINTABLE_V1 = {\n  name: \"ERC1155LazyMintableV1\",\n  namespace: \"edition.drop\",\n  docLinks: {\n    sdk: \"sdk.erc1155droppable\",\n    contracts: \"lazymint\"\n  },\n  abis: [DropERC1155_V2Abi],\n  features: {\n    [FEATURE_EDITION_CLAIM_PHASES_V1.name]: FEATURE_EDITION_CLAIM_PHASES_V1\n  }\n};\nconst FEATURE_EDITION_SIGNATURE_MINTABLE = {\n  name: \"ERC1155SignatureMintable\",\n  namespace: \"edition.signature\",\n  docLinks: {\n    sdk: \"sdk.erc1155signaturemintable\",\n    contracts: \"erc1155signaturemint\"\n  },\n  abis: [Erc1155Abi, ISignatureMintERC1155Abi],\n  features: {}\n};\nconst FEATURE_EDITION_BATCH_MINTABLE = {\n  name: \"ERC1155BatchMintable\",\n  namespace: \"edition.mint.batch\",\n  docLinks: {\n    sdk: \"sdk.erc1155batchmintable\",\n    contracts: \"erc1155batchmintable\"\n  },\n  abis: [Erc1155Abi, IMintableERC1155Abi, MulticallAbi],\n  features: {}\n};\nconst FEATURE_EDITION_MINTABLE = {\n  name: \"ERC1155Mintable\",\n  namespace: \"edition.mint\",\n  docLinks: {\n    sdk: \"sdk.erc1155mintable\",\n    contracts: \"erc1155mintable\"\n  },\n  abis: [Erc1155Abi, IMintableERC1155Abi],\n  features: {\n    [FEATURE_EDITION_BATCH_MINTABLE.name]: FEATURE_EDITION_BATCH_MINTABLE\n  }\n};\nconst FEATURE_EDITION_ENUMERABLE = {\n  name: \"ERC1155Enumerable\",\n  namespace: \"edition.query\",\n  docLinks: {\n    sdk: \"sdk.erc1155\",\n    contracts: \"erc1155enumerable\"\n  },\n  abis: [Erc1155Abi, Erc1155EnumerableAbi],\n  features: {}\n};\nconst FEATURE_EDITION_UPDATABLE_METADATA = {\n  name: \"ERC1155UpdatableMetadata\",\n  namespace: \"edition.metadata\",\n  docLinks: {\n    // TODO\n    sdk: \"\",\n    contracts: \"\"\n  },\n  abis: [Erc1155Abi, INFTMetadataAbi],\n  features: {}\n};\nconst FEATURE_EDITION_SUPPLY = {\n  name: \"ERC1155Supply\",\n  namespace: \"edition.supply\",\n  docLinks: {\n    sdk: \"\",\n    contracts: \"\"\n  },\n  abis: [Erc1155Abi, Erc1155SupplyAbi],\n  features: {}\n};\nconst FEATURE_EDITION = {\n  name: \"ERC1155\",\n  namespace: \"edition\",\n  docLinks: {\n    sdk: \"sdk.erc1155enumerable\",\n    contracts: \"erc1155\"\n  },\n  abis: [Erc1155Abi, Erc1155MetadataAbi, NAME_SYMBOL_ABI],\n  features: {\n    [FEATURE_EDITION_SUPPLY.name]: FEATURE_EDITION_SUPPLY,\n    [FEATURE_EDITION_BURNABLE.name]: FEATURE_EDITION_BURNABLE,\n    [FEATURE_EDITION_ENUMERABLE.name]: FEATURE_EDITION_ENUMERABLE,\n    [FEATURE_EDITION_MINTABLE.name]: FEATURE_EDITION_MINTABLE,\n    [FEATURE_EDITION_LAZY_MINTABLE_V1.name]: FEATURE_EDITION_LAZY_MINTABLE_V1,\n    [FEATURE_EDITION_LAZY_MINTABLE_V2.name]: FEATURE_EDITION_LAZY_MINTABLE_V2,\n    [FEATURE_EDITION_REVEALABLE.name]: FEATURE_EDITION_REVEALABLE,\n    [FEATURE_EDITION_SIGNATURE_MINTABLE.name]: FEATURE_EDITION_SIGNATURE_MINTABLE,\n    [FEATURE_EDITION_CLAIM_CUSTOM.name]: FEATURE_EDITION_CLAIM_CUSTOM,\n    [FEATURE_EDITION_CLAIM_CONDITIONS_V1.name]: FEATURE_EDITION_CLAIM_CONDITIONS_V1,\n    [FEATURE_EDITION_CLAIM_CONDITIONS_V2.name]: FEATURE_EDITION_CLAIM_CONDITIONS_V2,\n    [FEATURE_EDITION_CLAIM_PHASES_V2.name]: FEATURE_EDITION_CLAIM_PHASES_V2,\n    [FEATURE_EDITION_UPDATABLE_METADATA.name]: FEATURE_EDITION_UPDATABLE_METADATA\n  }\n};\nconst getAllPluginsAbi = [{\n  inputs: [],\n  name: \"getAllPlugins\",\n  outputs: [{\n    components: [{\n      internalType: \"bytes4\",\n      name: \"functionSelector\",\n      type: \"bytes4\"\n    }, {\n      internalType: \"string\",\n      name: \"functionSignature\",\n      type: \"string\"\n    }, {\n      internalType: \"address\",\n      name: \"pluginAddress\",\n      type: \"address\"\n    }],\n    internalType: \"struct IPluginMap.Plugin[]\",\n    name: \"registered\",\n    type: \"tuple[]\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}];\nconst getAllExtensionsAbi = [{\n  inputs: [],\n  name: \"getAllExtensions\",\n  outputs: [{\n    components: [{\n      components: [{\n        internalType: \"string\",\n        name: \"name\",\n        type: \"string\"\n      }, {\n        internalType: \"string\",\n        name: \"metadataURI\",\n        type: \"string\"\n      }, {\n        internalType: \"address\",\n        name: \"implementation\",\n        type: \"address\"\n      }],\n      internalType: \"struct IExtension.ExtensionMetadata\",\n      name: \"metadata\",\n      type: \"tuple\"\n    }, {\n      components: [{\n        internalType: \"bytes4\",\n        name: \"functionSelector\",\n        type: \"bytes4\"\n      }, {\n        internalType: \"string\",\n        name: \"functionSignature\",\n        type: \"string\"\n      }],\n      internalType: \"struct IExtension.ExtensionFunction[]\",\n      name: \"functions\",\n      type: \"tuple[]\"\n    }],\n    internalType: \"struct IExtension.Extension[]\",\n    name: \"allExtensions\",\n    type: \"tuple[]\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}];\nconst FEATURE_ROYALTY = {\n  name: \"Royalty\",\n  namespace: \"royalty\",\n  docLinks: {\n    sdk: \"sdk.contractroyalty\",\n    contracts: \"royalty\"\n  },\n  abis: [IThirdwebRoyaltyAbi],\n  features: {}\n};\nconst FEATURE_PRIMARY_SALE = {\n  name: \"PrimarySale\",\n  namespace: \"sales\",\n  docLinks: {\n    sdk: \"sdk.contractprimarysale\",\n    contracts: \"primarysale\"\n  },\n  abis: [IThirdwebPrimarySaleAbi],\n  features: {}\n};\nconst FEATURE_PLATFORM_FEE = {\n  name: \"PlatformFee\",\n  namespace: \"platformFees\",\n  docLinks: {\n    sdk: \"sdk.platformfee\",\n    contracts: \"platformfee\"\n  },\n  abis: [IThirdwebPlatformFeeAbi],\n  features: {}\n};\nconst FEATURE_PERMISSIONS_ENUMERABLE = {\n  name: \"PermissionsEnumerable\",\n  namespace: \"roles\",\n  docLinks: {\n    sdk: \"sdk.contractroles\",\n    contracts: \"permissionsenumerable\"\n  },\n  abis: [IPermissionsEnumerableAbi],\n  features: {}\n};\nconst FEATURE_PERMISSIONS = {\n  name: \"Permissions\",\n  namespace: \"roles\",\n  docLinks: {\n    sdk: \"sdk.contractroles\",\n    contracts: \"permissions\"\n  },\n  abis: [IPermissionsAbi],\n  features: {\n    [FEATURE_PERMISSIONS_ENUMERABLE.name]: FEATURE_PERMISSIONS_ENUMERABLE\n  }\n};\nconst FEATURE_METADATA = {\n  name: \"ContractMetadata\",\n  namespace: \"metadata\",\n  docLinks: {\n    sdk: \"sdk.contractmetadata\",\n    contracts: \"contractmetadata\"\n  },\n  abis: [IContractMetadataAbi],\n  features: {}\n};\nconst FEATURE_APPURI = {\n  name: \"AppURI\",\n  namespace: \"appURI\",\n  docLinks: {\n    sdk: \"sdk.appURI\",\n    //TODO\n    contracts: \"\"\n  },\n  abis: [IAppURI],\n  features: {}\n};\nconst FEATURE_OWNER = {\n  name: \"Ownable\",\n  namespace: \"owner\",\n  docLinks: {\n    sdk: \"sdk.owner\",\n    contracts: \"ownable\"\n  },\n  abis: [IOwnableAbi],\n  features: {}\n};\nconst FEATURE_GASLESS = {\n  name: \"Gasless\",\n  namespace: \"gasless\",\n  docLinks: {\n    sdk: \"sdk.gaslesstransaction\",\n    // TODO add the correct name for this once it's added to portal\n    contracts: \"IERC2771Context\"\n  },\n  abis: [IERC2771ContextAbi],\n  features: {}\n};\nconst FEATURE_PACK_VRF = {\n  name: \"PackVRF\",\n  namespace: \"pack.vrf\",\n  docLinks: {\n    sdk: \"sdk.packvrf\",\n    //TODO\n    contracts: \"IPackVRF\"\n  },\n  abis: [IPackVRFAbi],\n  features: {}\n};\nconst FEATURE_PLUGIN_ROUTER = {\n  name: \"PluginRouter\",\n  namespace: \"plugin.router\",\n  docLinks: {\n    sdk: \"sdk.pluginrouter\",\n    //TODO\n    contracts: \"PluginRouter\"\n  },\n  abis: [getAllPluginsAbi],\n  features: {}\n};\nconst FEATURE_DYNAMIC_CONTRACT = {\n  name: \"DynamicContract\",\n  namespace: \"dynamic.contract\",\n  docLinks: {\n    sdk: \"\",\n    //TODO\n    contracts: \"IExtensionsManager\"\n  },\n  abis: [getAllExtensionsAbi],\n  features: {}\n};\nconst FEATURE_DIRECT_LISTINGS = {\n  name: \"DirectListings\",\n  namespace: \"direct.listings\",\n  docLinks: {\n    // TODO\n    sdk: \"\",\n    contracts: \"IDirectListings\"\n  },\n  abis: [IDirectListingsAbi],\n  features: {}\n};\nconst FEATURE_ENGLISH_AUCTIONS = {\n  name: \"EnglishAuctions\",\n  namespace: \"english.auctions\",\n  docLinks: {\n    // TODO\n    sdk: \"\",\n    contracts: \"IEnglishAuctions\"\n  },\n  abis: [IEnglishAuctionsAbi],\n  features: {}\n};\nconst FEATURE_OFFERS = {\n  name: \"Offers\",\n  namespace: \"offers\",\n  docLinks: {\n    // TODO\n    sdk: \"\",\n    contracts: \"IOffers\"\n  },\n  abis: [IOffersAbi],\n  features: {}\n};\nconst FEATURE_ACCOUNT_FACTORY = {\n  name: \"AccountFactory\",\n  namespace: \"accountFactory\",\n  docLinks: {\n    // TODO\n    sdk: \"sdk.accountFactory\",\n    contracts: \"IAccountFactory\"\n  },\n  abis: [IAccountFactoryCore],\n  features: {}\n};\nconst FEATURE_ACCOUNT_PERMISSIONS = {\n  name: \"AccountPermissions\",\n  namespace: \"accountPermissions\",\n  docLinks: {\n    // TODO\n    sdk: \"sdk.account\",\n    contracts: \"IAccountPermissions\"\n  },\n  abis: [IAccountPermissions],\n  features: {}\n};\nconst FEATURE_ACCOUNT = {\n  name: \"Account\",\n  namespace: \"account\",\n  docLinks: {\n    // TODO\n    sdk: \"sdk.account\",\n    contracts: \"IAccount\"\n  },\n  abis: [IAccount],\n  features: {\n    [FEATURE_ACCOUNT_PERMISSIONS.name]: FEATURE_ACCOUNT_PERMISSIONS\n  }\n};\nconst FEATURE_AIRDROP_ERC20 = {\n  name: \"AirdropERC20\",\n  namespace: \"airdrop20\",\n  docLinks: {\n    // TODO\n    sdk: \"\",\n    contracts: \"IAirdropERC20\"\n  },\n  abis: [IAirdropERC20],\n  features: {}\n};\nconst FEATURE_AIRDROP_ERC721 = {\n  name: \"AirdropERC721\",\n  namespace: \"airdrop721\",\n  docLinks: {\n    // TODO\n    sdk: \"\",\n    contracts: \"IAirdropERC721\"\n  },\n  abis: [IAirdropERC721],\n  features: {}\n};\nconst FEATURE_AIRDROP_ERC1155 = {\n  name: \"AirdropERC1155\",\n  namespace: \"airdrop1155\",\n  docLinks: {\n    // TODO\n    sdk: \"\",\n    contracts: \"IAirdropERC1155\"\n  },\n  abis: [IAirdropERC1155],\n  features: {}\n};\n\n/**\n * @internal\n */\n\n/**\n * @internal\n */\n\n/**\n * @internal\n */\n\n/**\n * @internal\n */\nconst SUPPORTED_FEATURES = {\n  [FEATURE_TOKEN.name]: FEATURE_TOKEN,\n  [FEATURE_NFT.name]: FEATURE_NFT,\n  [FEATURE_EDITION.name]: FEATURE_EDITION,\n  [FEATURE_ROYALTY.name]: FEATURE_ROYALTY,\n  [FEATURE_PLATFORM_FEE.name]: FEATURE_PLATFORM_FEE,\n  [FEATURE_PRIMARY_SALE.name]: FEATURE_PRIMARY_SALE,\n  [FEATURE_PERMISSIONS.name]: FEATURE_PERMISSIONS,\n  [FEATURE_METADATA.name]: FEATURE_METADATA,\n  [FEATURE_APPURI.name]: FEATURE_APPURI,\n  [FEATURE_OWNER.name]: FEATURE_OWNER,\n  [FEATURE_GASLESS.name]: FEATURE_GASLESS,\n  [FEATURE_PACK_VRF.name]: FEATURE_PACK_VRF,\n  [FEATURE_PLUGIN_ROUTER.name]: FEATURE_PLUGIN_ROUTER,\n  [FEATURE_DYNAMIC_CONTRACT.name]: FEATURE_DYNAMIC_CONTRACT,\n  [FEATURE_DIRECT_LISTINGS.name]: FEATURE_DIRECT_LISTINGS,\n  [FEATURE_ENGLISH_AUCTIONS.name]: FEATURE_ENGLISH_AUCTIONS,\n  [FEATURE_OFFERS.name]: FEATURE_OFFERS,\n  [FEATURE_AIRDROP_ERC20.name]: FEATURE_AIRDROP_ERC20,\n  [FEATURE_AIRDROP_ERC721.name]: FEATURE_AIRDROP_ERC721,\n  [FEATURE_AIRDROP_ERC1155.name]: FEATURE_AIRDROP_ERC1155,\n  [FEATURE_ACCOUNT_FACTORY.name]: FEATURE_ACCOUNT_FACTORY,\n  [FEATURE_ACCOUNT.name]: FEATURE_ACCOUNT,\n  [FEATURE_NFT_LOYALTY_CARD.name]: FEATURE_NFT_LOYALTY_CARD,\n  [FEATURE_NFT_UPDATABLE_METADATA.name]: FEATURE_NFT_UPDATABLE_METADATA\n};\nfunction toJSType(contractType) {\n  let isReturnType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  let withName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  let jsType = contractType.type;\n  let isArray = false;\n  if (jsType.endsWith(\"[]\")) {\n    isArray = true;\n    jsType = jsType.slice(0, -2);\n  }\n  if (jsType.startsWith(\"bytes\")) {\n    jsType = \"BytesLike\";\n  }\n  if (jsType.startsWith(\"uint\") || jsType.startsWith(\"int\")) {\n    jsType = isReturnType ? \"BigNumber\" : \"BigNumberish\";\n  }\n  if (jsType.startsWith(\"bool\")) {\n    jsType = \"boolean\";\n  }\n  if (jsType === \"address\") {\n    jsType = \"string\";\n  }\n  if (jsType === \"tuple\") {\n    if (contractType.components) {\n      jsType = `{ ${contractType.components.map(a => toJSType(a, false, true)).join(\", \")} }`;\n    }\n  }\n  if (isArray) {\n    jsType += \"[]\";\n  }\n  if (withName) {\n    jsType = `${contractType.name}: ${jsType}`;\n  }\n  return jsType;\n}\n\n/**\n * @internal\n * @param name\n * @param metadata\n * @param type\n */\nfunction extractCommentFromMetadata(name, metadata, type) {\n  return metadata?.output?.userdoc?.[type]?.[Object.keys(metadata?.output?.userdoc[type] || {}).find(fn => fn.includes(name || \"unknown\")) || \"\"]?.notice || metadata?.output?.devdoc?.[type]?.[Object.keys(metadata?.output?.devdoc[type] || {}).find(fn => fn.includes(name || \"unknown\")) || \"\"]?.details;\n}\n\n/**\n * @internal\n * @param abi\n * @param metadata\n */\nfunction extractFunctionsFromAbi(abi, metadata) {\n  const functions = (abi || []).filter(el => el.type === \"function\");\n  const parsed = [];\n  for (const f of functions) {\n    const doc = extractCommentFromMetadata(f.name, metadata, \"methods\");\n    const args = f.inputs?.map(i => `${i.name || \"key\"}: ${toJSType(i)}`)?.join(\", \") || \"\";\n    const fargs = args ? `, [${args}]` : \"\";\n    const out = f.outputs?.map(o => toJSType(o, true))?.join(\", \");\n    const promise = out ? `: Promise<${out}>` : `: Promise<TransactionResult>`;\n    const signature = `contract.call(\"${f.name}\"${fargs})${promise}`;\n    parsed.push({\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore we know AbiTypeBaseSchema.name is not going to be undefined since we're doing `.default(\"\")`\n      inputs: f.inputs || [],\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore we know the AbiTypeBaseSchema.name is not going to be undefined since we're doing `.default(\"\")`\n      outputs: f.outputs || [],\n      name: f.name || \"unknown\",\n      signature,\n      stateMutability: f.stateMutability || \"\",\n      comment: doc\n    });\n  }\n  return parsed;\n}\n\n/**\n * @internal\n * @param contractAbi\n * @param featureAbis\n * @returns\n */\nfunction hasMatchingAbi(contractAbi, featureAbis) {\n  const contractFn = extractFunctionsFromAbi(contractAbi);\n  const interfaceFn = featureAbis.flatMap(i => extractFunctionsFromAbi(i));\n  // match every function and their arguments\n  const intersection = contractFn.filter(fn => {\n    const match = interfaceFn.find(iFn => iFn.name === fn.name && iFn.inputs.length === fn.inputs.length && iFn.inputs.every((i, index) => {\n      if (i.type === \"tuple\" || i.type === \"tuple[]\") {\n        // check that all properties in the tuple are the same type\n        return i.type === fn.inputs[index].type && i.components?.every((c, cIndex) => {\n          return c.type === fn.inputs[index].components?.[cIndex]?.type;\n        });\n      }\n      return i.type === fn.inputs[index].type;\n    }));\n    return match !== undefined;\n  });\n  return intersection.length === interfaceFn.length;\n}\nfunction matchesAbiFromBytecode(contractBytecode, featureAbis) {\n  const interfaces = featureAbis.map(abi => new Interface(abi));\n  const selectors = interfaces.flatMap(i => {\n    return Object.values(i.functions).map(fn => Number(i.getSighash(fn)).toString(16));\n  });\n  const uniqueSelectors = [...new Set(selectors)];\n  // checks that all unique selectors are found in the bytecode\n  return uniqueSelectors.every(selector => contractBytecode.includes(selector));\n}\n\n/**\n * Processes ALL supported features and sets whether the passed in abi supports each individual feature\n * @internal\n * @param abi\n * @param features\n * @returns the nested struct of all features and whether they're detected in the abi\n */\nfunction detectFeatures(abi) {\n  let features = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : SUPPORTED_FEATURES;\n  const results = {};\n  for (const featureKey in features) {\n    const feature = features[featureKey];\n    const enabled = matchesAbiInterface(abi, feature);\n    const childResults = detectFeatures(abi, feature.features);\n    results[featureKey] = {\n      ...feature,\n      features: childResults,\n      enabled\n    };\n  }\n  return results;\n}\nfunction detectFeaturesFromBytecode(bytecode) {\n  let features = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : SUPPORTED_FEATURES;\n  const results = {};\n  for (const featureKey in features) {\n    const feature = features[featureKey];\n    const enabled = matchesAbiFromBytecode(bytecode, feature.abis);\n    const childResults = detectFeaturesFromBytecode(bytecode, feature.features);\n    results[featureKey] = {\n      ...feature,\n      features: childResults,\n      enabled\n    };\n  }\n  return results;\n}\n\n/**\n * @internal\n * @param abi\n * @param feature\n */\nfunction matchesAbiInterface(abi, feature) {\n  // returns true if all the functions in `interfaceToMatch` are found in `contract` (removing any duplicates)\n  return hasMatchingAbi(abi, feature.abis);\n}\n\n/**\n * Checks whether the given ABI supports a given feature\n * @deprecated use isExtensionEnabled instead\n * @param abi\n * @param featureName\n */\nfunction isFeatureEnabled(abi, featureName) {\n  const features = detectFeatures(abi);\n  return _featureEnabled(features, featureName);\n}\n\n/**\n * Checks whether the given ABI supports a given extension\n * @public\n * @param abi\n * @param featureName\n */\nfunction isExtensionEnabled(abi, featureName) {\n  return isFeatureEnabled(abi, featureName);\n}\n\n/**\n * Searches the feature map for featureName and returns whether its enabled\n * @internal\n * @param features\n * @param featureName\n */\nfunction _featureEnabled(features, featureName) {\n  const keys = Object.keys(features);\n  if (!keys.includes(featureName)) {\n    let found = false;\n    for (const key of keys) {\n      const f = features[key];\n      found = _featureEnabled(f.features, featureName);\n      if (found) {\n        break;\n      }\n    }\n    return found;\n  }\n  const feature = features[featureName];\n  return feature.enabled;\n}\n\n/**\n * Type guard for contractWrappers depending on passed feature name\n * @internal\n * @param contractWrapper\n * @param featureName\n */\nfunction detectContractFeature(contractWrapper, featureName) {\n  return isExtensionEnabled(AbiSchema.parse(contractWrapper.abi), featureName);\n}\n\n/**\n * @internal\n * @param contractWrapper\n * @param functionName\n */\nfunction hasFunction(functionName, contractWrapper) {\n  return functionName in contractWrapper.readContract.functions;\n}\n\n/* eslint-disable eqeqeq */\n/* eslint-disable better-tree-shaking/no-top-level-side-effects  */\nlet decoder;\ntry {\n  decoder = new TextDecoder();\n} catch (error) {}\nlet src;\nlet srcEnd;\nlet position = 0;\nconst LEGACY_RECORD_INLINE_ID = 105;\nconst RECORD_DEFINITIONS_ID = 0xdffe;\nconst RECORD_INLINE_ID = 0xdfff; // temporary first-come first-serve tag // proposed tag: 0x7265 // 're'\nconst BUNDLED_STRINGS_ID = 0xdff9;\nconst PACKED_REFERENCE_TAG_ID = 6;\nconst STOP_CODE = {};\nlet currentDecoder = {};\nlet currentStructures;\nlet srcString;\nlet srcStringStart = 0;\nlet srcStringEnd = 0;\nlet bundledStrings;\nlet referenceMap;\nlet currentExtensions = [];\nlet currentExtensionRanges = [];\nlet packedValues;\nlet dataView;\nlet restoreMapsAsObject;\nlet defaultOptions = {\n  useRecords: false,\n  mapsAsObjects: true\n};\nlet sequentialMode = false;\nclass Decoder {\n  constructor(options) {\n    if (options) {\n      if ((options.keyMap || options._keyMap) && !options.useRecords) {\n        options.useRecords = false;\n        options.mapsAsObjects = true;\n      }\n      if (options.useRecords === false && options.mapsAsObjects === undefined) {\n        options.mapsAsObjects = true;\n      }\n      if (options.getStructures) {\n        options.getShared = options.getStructures;\n      }\n      if (options.getShared && !options.structures) {\n        (options.structures = []).uninitialized = true;\n      } // this is what we use to denote an uninitialized structures\n      if (options.keyMap) {\n        this.mapKey = new Map();\n        for (let [k, v] of Object.entries(options.keyMap)) {\n          this.mapKey.set(v, k);\n        }\n      }\n    }\n    Object.assign(this, options);\n  }\n  decodeKey(key) {\n    return this.keyMap ? this.mapKey.get(key) || key : key;\n  }\n  decode(source, end) {\n    if (src) {\n      // re-entrant execution, save the state and restore it after we do this decode\n      return saveState(() => {\n        clearSource();\n        return this ? this.decode(source, end) : Decoder.prototype.decode.call(defaultOptions, source, end);\n      });\n    }\n    srcEnd = end > -1 ? end : source.length;\n    position = 0;\n    srcStringEnd = 0;\n    srcString = null;\n    bundledStrings = null;\n    src = source;\n    // this provides cached access to the data view for a buffer if it is getting reused, which is a recommend\n    // technique for getting data from a database where it can be copied into an existing buffer instead of creating\n    // new ones\n    try {\n      dataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength));\n    } catch (error) {\n      // if it doesn't have a buffer, maybe it is the wrong type of object\n      src = null;\n      if (source instanceof Uint8Array) {\n        throw error;\n      }\n      throw new Error(\"Source must be a Uint8Array or Buffer but was a \" + (source && typeof source === \"object\" ? source.constructor.name : typeof source));\n    }\n    if (this instanceof Decoder) {\n      // eslint-disable-next-line @typescript-eslint/no-this-alias\n      currentDecoder = this;\n      packedValues = this.sharedValues && (this.pack ? new Array(this.maxPrivatePackedValues || 16).concat(this.sharedValues) : this.sharedValues);\n      if (this.structures) {\n        currentStructures = this.structures;\n        return checkedRead();\n      } else if (!currentStructures || currentStructures.length > 0) {\n        currentStructures = [];\n      }\n    } else {\n      currentDecoder = defaultOptions;\n      if (!currentStructures || currentStructures.length > 0) {\n        currentStructures = [];\n      }\n      packedValues = null;\n    }\n    return checkedRead();\n  }\n}\nfunction checkedRead() {\n  try {\n    let result = read();\n    if (bundledStrings) {\n      if (position >= bundledStrings.postBundlePosition) {\n        let error = new Error(\"Unexpected bundle position\");\n        error.incomplete = true;\n        throw error;\n      }\n      // bundled strings to skip past\n      position = bundledStrings.postBundlePosition;\n      bundledStrings = null;\n    }\n    if (position == srcEnd) {\n      // finished reading this source, cleanup references\n      currentStructures = null;\n      src = null;\n      if (referenceMap) {\n        referenceMap = null;\n      }\n    } else if (position > srcEnd) {\n      // over read\n      let error = new Error(\"Unexpected end of CBOR data\");\n      error.incomplete = true;\n      throw error;\n    } else if (!sequentialMode) {\n      throw new Error(\"Data read, but end of buffer not reached\");\n    }\n    // else more to read, but we are reading sequentially, so don't clear source yet\n    return result;\n  } catch (error) {\n    clearSource();\n    if (error instanceof RangeError || error.message.startsWith(\"Unexpected end of buffer\")) {\n      error.incomplete = true;\n    }\n    throw error;\n  }\n}\nfunction read() {\n  let token = src[position++];\n  let majorType = token >> 5;\n  token = token & 0x1f;\n  if (token > 0x17) {\n    switch (token) {\n      case 0x18:\n        token = src[position++];\n        break;\n      case 0x19:\n        if (majorType == 7) {\n          return getFloat16();\n        }\n        token = dataView.getUint16(position);\n        position += 2;\n        break;\n      case 0x1a:\n        if (majorType == 7) {\n          let value = dataView.getFloat32(position);\n          if (currentDecoder.useFloat32 > 2) {\n            // this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n            let multiplier = mult10[(src[position] & 0x7f) << 1 | src[position + 1] >> 7];\n            position += 4;\n            return (multiplier * value + (value > 0 ? 0.5 : -0.5) >> 0) / multiplier;\n          }\n          position += 4;\n          return value;\n        }\n        token = dataView.getUint32(position);\n        position += 4;\n        break;\n      case 0x1b:\n        if (majorType == 7) {\n          let value = dataView.getFloat64(position);\n          position += 8;\n          return value;\n        }\n        if (majorType > 1) {\n          if (dataView.getUint32(position) > 0) {\n            throw new Error(\"JavaScript does not support arrays, maps, or strings with length over 4294967295\");\n          }\n          token = dataView.getUint32(position + 4);\n        } else if (currentDecoder.int64AsNumber) {\n          token = dataView.getUint32(position) * 0x100000000;\n          token += dataView.getUint32(position + 4);\n        } else {\n          token = dataView.getBigUint64(position);\n        }\n        position += 8;\n        break;\n      case 0x1f:\n        // indefinite length\n        switch (majorType) {\n          case 2: // byte string\n          case 3:\n            // text string\n            throw new Error(\"Indefinite length not supported for byte or text strings\");\n          case 4:\n            // array\n            let array = [];\n            let value,\n              i = 0;\n            while ((value = read()) != STOP_CODE) {\n              array[i++] = value;\n            }\n            return majorType == 4 ? array : majorType == 3 ? array.join(\"\") : Buffer.concat(array);\n          case 5:\n            // map\n            let key;\n            if (currentDecoder.mapsAsObjects) {\n              let object = {};\n              if (currentDecoder.keyMap) {\n                while ((key = read()) != STOP_CODE) {\n                  object[safeKey(currentDecoder.decodeKey(key))] = read();\n                }\n              } else {\n                while ((key = read()) != STOP_CODE) {\n                  object[safeKey(key)] = read();\n                }\n              }\n              return object;\n            } else {\n              if (restoreMapsAsObject) {\n                currentDecoder.mapsAsObjects = true;\n                restoreMapsAsObject = false;\n              }\n              let map = new Map();\n              if (currentDecoder.keyMap) {\n                while ((key = read()) != STOP_CODE) {\n                  map.set(currentDecoder.decodeKey(key), read());\n                }\n              } else {\n                while ((key = read()) != STOP_CODE) {\n                  map.set(key, read());\n                }\n              }\n              return map;\n            }\n          case 7:\n            return STOP_CODE;\n          default:\n            throw new Error(\"Invalid major type for indefinite length \" + majorType);\n        }\n      default:\n        throw new Error(\"Unknown token \" + token);\n    }\n  }\n  switch (majorType) {\n    case 0:\n      // positive int\n      return token;\n    case 1:\n      // negative int\n      return ~token;\n    case 2:\n      // buffer\n      return readBin(token);\n    case 3:\n      // string\n      if (srcStringEnd >= position) {\n        return srcString.slice(position - srcStringStart, (position += token) - srcStringStart);\n      }\n      if (srcStringEnd == 0 && srcEnd < 140 && token < 32) {\n        // for small blocks, avoiding the overhead of the extract call is helpful\n        let string = token < 16 ? shortStringInJS(token) : longStringInJS(token);\n        if (string != null) {\n          return string;\n        }\n      }\n      return readFixedString(token);\n    case 4:\n      // array\n      let array = new Array(token);\n      //if (currentDecoder.keyMap) for (let i = 0; i < token; i++) array[i] = currentDecoder.decodeKey(read())\n      //else\n      for (let i = 0; i < token; i++) {\n        array[i] = read();\n      }\n      return array;\n    case 5:\n      // map\n      if (currentDecoder.mapsAsObjects) {\n        let object = {};\n        if (currentDecoder.keyMap) {\n          for (let i = 0; i < token; i++) {\n            object[safeKey(currentDecoder.decodeKey(read()))] = read();\n          }\n        } else {\n          for (let i = 0; i < token; i++) {\n            object[safeKey(read())] = read();\n          }\n        }\n        return object;\n      } else {\n        if (restoreMapsAsObject) {\n          currentDecoder.mapsAsObjects = true;\n          restoreMapsAsObject = false;\n        }\n        let map = new Map();\n        if (currentDecoder.keyMap) {\n          for (let i = 0; i < token; i++) {\n            map.set(currentDecoder.decodeKey(read()), read());\n          }\n        } else {\n          for (let i = 0; i < token; i++) {\n            map.set(read(), read());\n          }\n        }\n        return map;\n      }\n    case 6:\n      // extension\n      if (token >= BUNDLED_STRINGS_ID) {\n        let structure = currentStructures[token & 0x1fff]; // check record structures first\n        // At some point we may provide an option for dynamic tag assignment with a range like token >= 8 && (token < 16 || (token > 0x80 && token < 0xc0) || (token > 0x130 && token < 0x4000))\n        if (structure) {\n          if (!structure.read) {\n            structure.read = createStructureReader(structure);\n          }\n          return structure.read();\n        }\n        if (token < 0x10000) {\n          if (token == RECORD_INLINE_ID) {\n            // we do a special check for this so that we can keep the currentExtensions as densely stored array (v8 stores arrays densely under about 3000 elements)\n            return recordDefinition(read());\n          } else if (token == RECORD_DEFINITIONS_ID) {\n            let length = readJustLength();\n            let id = read();\n            for (let i = 2; i < length; i++) {\n              recordDefinition([id++, read()]);\n            }\n            return read();\n          } else if (token == BUNDLED_STRINGS_ID) {\n            return readBundleExt();\n          }\n          if (currentDecoder.getShared) {\n            loadShared();\n            structure = currentStructures[token & 0x1fff];\n            if (structure) {\n              if (!structure.read) {\n                structure.read = createStructureReader(structure);\n              }\n              return structure.read();\n            }\n          }\n        }\n      }\n      let extension = currentExtensions[token];\n      if (extension) {\n        if (extension.handlesRead) {\n          return extension(read);\n        } else {\n          return extension(read());\n        }\n      } else {\n        let input = read();\n        for (let i = 0; i < currentExtensionRanges.length; i++) {\n          let value = currentExtensionRanges[i](token, input);\n          if (value !== undefined) {\n            return value;\n          }\n        }\n        return new Tag(input, token);\n      }\n    case 7:\n      // fixed value\n      switch (token) {\n        case 0x14:\n          return false;\n        case 0x15:\n          return true;\n        case 0x16:\n          return null;\n        case 0x17:\n          return;\n        // undefined\n        case 0x1f:\n        default:\n          let packedValue = (packedValues || getPackedValues())[token];\n          if (packedValue !== undefined) {\n            return packedValue;\n          }\n          throw new Error(\"Unknown token \" + token);\n      }\n    default:\n      // negative int\n      if (isNaN(token)) {\n        let error = new Error(\"Unexpected end of CBOR data\");\n        error.incomplete = true;\n        throw error;\n      }\n      throw new Error(\"Unknown CBOR token \" + token);\n  }\n}\nconst validName = /^[a-zA-Z_$][a-zA-Z\\d_$]*$/;\nfunction createStructureReader(structure) {\n  function readObject() {\n    // get the array size from the header\n    let length = src[position++];\n    //let majorType = token >> 5\n    length = length & 0x1f;\n    if (length > 0x17) {\n      switch (length) {\n        case 0x18:\n          length = src[position++];\n          break;\n        case 0x19:\n          length = dataView.getUint16(position);\n          position += 2;\n          break;\n        case 0x1a:\n          length = dataView.getUint32(position);\n          position += 4;\n          break;\n        default:\n          throw new Error(\"Expected array header, but got \" + src[position - 1]);\n      }\n    }\n    // This initial function is quick to instantiate, but runs slower. After several iterations pay the cost to build the faster function\n    let compiledReader = this.compiledReader; // first look to see if we have the fast compiled function\n    while (compiledReader) {\n      // we have a fast compiled object literal reader\n      if (compiledReader.propertyCount === length) {\n        return compiledReader(read);\n      } // with the right length, so we use it\n      compiledReader = compiledReader.next; // see if there is another reader with the right length\n    }\n\n    if (this.slowReads++ >= 3) {\n      // create a fast compiled reader\n      let array = this.length == length ? this : this.slice(0, length);\n      compiledReader = currentDecoder.keyMap ? new Function(\"r\", \"return {\" + array.map(k => currentDecoder.decodeKey(k)).map(k => validName.test(k) ? safeKey(k) + \":r()\" : \"[\" + JSON.stringify(k) + \"]:r()\").join(\",\") + \"}\") : new Function(\"r\", \"return {\" + array.map(key => validName.test(key) ? safeKey(key) + \":r()\" : \"[\" + JSON.stringify(key) + \"]:r()\").join(\",\") + \"}\");\n      if (this.compiledReader) {\n        compiledReader.next = this.compiledReader;\n      } // if there is an existing one, we store multiple readers as a linked list because it is usually pretty rare to have multiple readers (of different length) for the same structure\n      compiledReader.propertyCount = length;\n      this.compiledReader = compiledReader;\n      return compiledReader(read);\n    }\n    let object = {};\n    if (currentDecoder.keyMap) {\n      for (let i = 0; i < length; i++) {\n        object[safeKey(currentDecoder.decodeKey(this[i]))] = read();\n      }\n    } else {\n      for (let i = 0; i < length; i++) {\n        object[safeKey(this[i])] = read();\n      }\n    }\n    return object;\n  }\n  structure.slowReads = 0;\n  return readObject;\n}\nfunction safeKey(key) {\n  return key === \"__proto__\" ? \"__proto_\" : key;\n}\nlet readFixedString = readStringJS;\nfunction readStringJS(length) {\n  let result;\n  if (length < 16) {\n    if (result = shortStringInJS(length)) {\n      return result;\n    }\n  }\n  if (length > 64 && decoder) {\n    return decoder.decode(src.subarray(position, position += length));\n  }\n  const end = position + length;\n  const units = [];\n  result = \"\";\n  while (position < end) {\n    const byte1 = src[position++];\n    if ((byte1 & 0x80) === 0) {\n      // 1 byte\n      units.push(byte1);\n    } else if ((byte1 & 0xe0) === 0xc0) {\n      // 2 bytes\n      const byte2 = src[position++] & 0x3f;\n      units.push((byte1 & 0x1f) << 6 | byte2);\n    } else if ((byte1 & 0xf0) === 0xe0) {\n      // 3 bytes\n      const byte2 = src[position++] & 0x3f;\n      const byte3 = src[position++] & 0x3f;\n      units.push((byte1 & 0x1f) << 12 | byte2 << 6 | byte3);\n    } else if ((byte1 & 0xf8) === 0xf0) {\n      // 4 bytes\n      const byte2 = src[position++] & 0x3f;\n      const byte3 = src[position++] & 0x3f;\n      const byte4 = src[position++] & 0x3f;\n      let unit = (byte1 & 0x07) << 0x12 | byte2 << 0x0c | byte3 << 0x06 | byte4;\n      if (unit > 0xffff) {\n        unit -= 0x10000;\n        units.push(unit >>> 10 & 0x3ff | 0xd800);\n        unit = 0xdc00 | unit & 0x3ff;\n      }\n      units.push(unit);\n    } else {\n      units.push(byte1);\n    }\n    if (units.length >= 0x1000) {\n      result += fromCharCode.apply(String, units);\n      units.length = 0;\n    }\n  }\n  if (units.length > 0) {\n    result += fromCharCode.apply(String, units);\n  }\n  return result;\n}\nlet fromCharCode = String.fromCharCode;\nfunction longStringInJS(length) {\n  let start = position;\n  let bytes = new Array(length);\n  for (let i = 0; i < length; i++) {\n    const byte = src[position++];\n    if ((byte & 0x80) > 0) {\n      position = start;\n      return;\n    }\n    bytes[i] = byte;\n  }\n  return fromCharCode.apply(String, bytes);\n}\nfunction shortStringInJS(length) {\n  if (length < 4) {\n    if (length < 2) {\n      if (length === 0) {\n        return \"\";\n      } else {\n        let a = src[position++];\n        if ((a & 0x80) > 1) {\n          position -= 1;\n          return;\n        }\n        return fromCharCode(a);\n      }\n    } else {\n      let a = src[position++];\n      let b = src[position++];\n      if ((a & 0x80) > 0 || (b & 0x80) > 0) {\n        position -= 2;\n        return;\n      }\n      if (length < 3) {\n        return fromCharCode(a, b);\n      }\n      let c = src[position++];\n      if ((c & 0x80) > 0) {\n        position -= 3;\n        return;\n      }\n      return fromCharCode(a, b, c);\n    }\n  } else {\n    let a = src[position++];\n    let b = src[position++];\n    let c = src[position++];\n    let d = src[position++];\n    if ((a & 0x80) > 0 || (b & 0x80) > 0 || (c & 0x80) > 0 || (d & 0x80) > 0) {\n      position -= 4;\n      return;\n    }\n    if (length < 6) {\n      if (length === 4) {\n        return fromCharCode(a, b, c, d);\n      } else {\n        let e = src[position++];\n        if ((e & 0x80) > 0) {\n          position -= 5;\n          return;\n        }\n        return fromCharCode(a, b, c, d, e);\n      }\n    } else if (length < 8) {\n      let e = src[position++];\n      let f = src[position++];\n      if ((e & 0x80) > 0 || (f & 0x80) > 0) {\n        position -= 6;\n        return;\n      }\n      if (length < 7) {\n        return fromCharCode(a, b, c, d, e, f);\n      }\n      let g = src[position++];\n      if ((g & 0x80) > 0) {\n        position -= 7;\n        return;\n      }\n      return fromCharCode(a, b, c, d, e, f, g);\n    } else {\n      let e = src[position++];\n      let f = src[position++];\n      let g = src[position++];\n      let h = src[position++];\n      if ((e & 0x80) > 0 || (f & 0x80) > 0 || (g & 0x80) > 0 || (h & 0x80) > 0) {\n        position -= 8;\n        return;\n      }\n      if (length < 10) {\n        if (length === 8) {\n          return fromCharCode(a, b, c, d, e, f, g, h);\n        } else {\n          let i = src[position++];\n          if ((i & 0x80) > 0) {\n            position -= 9;\n            return;\n          }\n          return fromCharCode(a, b, c, d, e, f, g, h, i);\n        }\n      } else if (length < 12) {\n        let i = src[position++];\n        let j = src[position++];\n        if ((i & 0x80) > 0 || (j & 0x80) > 0) {\n          position -= 10;\n          return;\n        }\n        if (length < 11) {\n          return fromCharCode(a, b, c, d, e, f, g, h, i, j);\n        }\n        let k = src[position++];\n        if ((k & 0x80) > 0) {\n          position -= 11;\n          return;\n        }\n        return fromCharCode(a, b, c, d, e, f, g, h, i, j, k);\n      } else {\n        let i = src[position++];\n        let j = src[position++];\n        let k = src[position++];\n        let l = src[position++];\n        if ((i & 0x80) > 0 || (j & 0x80) > 0 || (k & 0x80) > 0 || (l & 0x80) > 0) {\n          position -= 12;\n          return;\n        }\n        if (length < 14) {\n          if (length === 12) {\n            return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l);\n          } else {\n            let m = src[position++];\n            if ((m & 0x80) > 0) {\n              position -= 13;\n              return;\n            }\n            return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m);\n          }\n        } else {\n          let m = src[position++];\n          let n = src[position++];\n          if ((m & 0x80) > 0 || (n & 0x80) > 0) {\n            position -= 14;\n            return;\n          }\n          if (length < 15) {\n            return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n);\n          }\n          let o = src[position++];\n          if ((o & 0x80) > 0) {\n            position -= 15;\n            return;\n          }\n          return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o);\n        }\n      }\n    }\n  }\n}\nfunction readBin(length) {\n  return currentDecoder.copyBuffers ?\n  // specifically use the copying slice (not the node one)\n  Uint8Array.prototype.slice.call(src, position, position += length) : src.subarray(position, position += length);\n}\nlet f32Array = new Float32Array(1);\nlet u8Array = new Uint8Array(f32Array.buffer, 0, 4);\nfunction getFloat16() {\n  let byte0 = src[position++];\n  let byte1 = src[position++];\n  let exponent = (byte0 & 0x7f) >> 2;\n  if (exponent === 0x1f) {\n    // specials\n    if (byte1 || byte0 & 3) {\n      return NaN;\n    }\n    return byte0 & 0x80 ? -Infinity : Infinity;\n  }\n  if (exponent === 0) {\n    // sub-normals\n    // significand with 10 fractional bits and divided by 2^14\n    let abs = ((byte0 & 3) << 8 | byte1) / (1 << 24);\n    return byte0 & 0x80 ? -abs : abs;\n  }\n  u8Array[3] = byte0 & 0x80 |\n  // sign bit\n  (exponent >> 1) + 56; // 4 of 5 of the exponent bits, re-offset-ed\n  u8Array[2] = (byte0 & 7) << 5 |\n  // last exponent bit and first two mantissa bits\n  byte1 >> 3; // next 5 bits of mantissa\n  u8Array[1] = byte1 << 5; // last three bits of mantissa\n  u8Array[0] = 0;\n  return f32Array[0];\n}\nclass Tag {\n  constructor(value, tag) {\n    this.value = value;\n    this.tag = tag;\n  }\n}\ncurrentExtensions[0] = dateString => {\n  // string date extension\n  return new Date(dateString);\n};\ncurrentExtensions[1] = epochSec => {\n  // numeric date extension\n  return new Date(Math.round(epochSec * 1000));\n};\ncurrentExtensions[2] = buffer => {\n  // bigint extension\n  let value = BigInt(0);\n  for (let i = 0, l = buffer.byteLength; i < l; i++) {\n    value = BigInt(buffer[i]) + value << BigInt(8);\n  }\n  return value;\n};\ncurrentExtensions[3] = buffer => {\n  // negative bigint extension\n  return BigInt(-1) - currentExtensions[2](buffer);\n};\ncurrentExtensions[4] = fraction => {\n  // best to reparse to maintain accuracy\n  return Number(fraction[1] + \"e\" + fraction[0]);\n};\ncurrentExtensions[5] = fraction => {\n  // probably not sufficiently accurate\n  return fraction[1] * Math.exp(fraction[0] * Math.log(2));\n};\n\n// the registration of the record definition extension\nconst recordDefinition = definition => {\n  let id = definition[0] - 0xe000;\n  let structure = definition[1];\n  let existingStructure = currentStructures[id];\n  if (existingStructure && existingStructure.isShared) {\n    (currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id] = existingStructure;\n  }\n  currentStructures[id] = structure;\n  structure.read = createStructureReader(structure);\n  let object = {};\n  if (currentDecoder.keyMap) {\n    for (let i = 2, l = definition.length; i < l; i++) {\n      let key = currentDecoder.decodeKey(structure[i - 2]);\n      object[safeKey(key)] = definition[i];\n    }\n  } else {\n    for (let i = 2, l = definition.length; i < l; i++) {\n      let key = structure[i - 2];\n      object[safeKey(key)] = definition[i];\n    }\n  }\n  return object;\n};\ncurrentExtensions[LEGACY_RECORD_INLINE_ID] = recordDefinition;\ncurrentExtensions[14] = value => {\n  if (bundledStrings) {\n    return bundledStrings[0].slice(bundledStrings.position0, bundledStrings.position0 += value);\n  }\n  return new Tag(value, 14);\n};\ncurrentExtensions[15] = value => {\n  if (bundledStrings) {\n    return bundledStrings[1].slice(bundledStrings.position1, bundledStrings.position1 += value);\n  }\n  return new Tag(value, 15);\n};\nlet glbl = {\n  Error,\n  RegExp\n};\ncurrentExtensions[27] = data => {\n  // http://cbor.schmorp.de/generic-object\n  return (glbl[data[0]] || Error)(data[1], data[2]);\n};\nconst packedTable = _read => {\n  if (src[position++] != 0x84) {\n    throw new Error(\"Packed values structure must be followed by a 4 element array\");\n  }\n  let newPackedValues = _read(); // packed values\n  packedValues = packedValues ? newPackedValues.concat(packedValues.slice(newPackedValues.length)) : newPackedValues;\n  packedValues.prefixes = _read();\n  packedValues.suffixes = _read();\n  return _read(); // read the rump\n};\n\npackedTable.handlesRead = true;\ncurrentExtensions[51] = packedTable;\ncurrentExtensions[PACKED_REFERENCE_TAG_ID] = data => {\n  // packed reference\n  if (!packedValues) {\n    if (currentDecoder.getShared) {\n      loadShared();\n    } else {\n      return new Tag(data, PACKED_REFERENCE_TAG_ID);\n    }\n  }\n  if (typeof data === \"number\") {\n    return packedValues[16 + (data >= 0 ? 2 * data : -2 * data - 1)];\n  }\n  throw new Error(\"No support for non-integer packed references yet\");\n};\ncurrentExtensions[25] = id => {\n  return stringRefs[id];\n};\ncurrentExtensions[256] = _read => {\n  stringRefs = [];\n  try {\n    return _read();\n  } finally {\n    stringRefs = null;\n  }\n};\ncurrentExtensions[256].handlesRead = true;\ncurrentExtensions[28] = _read => {\n  // shareable http://cbor.schmorp.de/value-sharing (for structured clones)\n  if (!referenceMap) {\n    referenceMap = new Map();\n    referenceMap.id = 0;\n  }\n  let id = referenceMap.id++;\n  let token = src[position];\n  let target;\n  // TODO: handle Maps, Sets, and other types that can cycle; this is complicated, because you potentially need to read\n  // ahead past references to record structure definitions\n  if (token >> 5 == 4) {\n    target = [];\n  } else {\n    target = {};\n  }\n  let refEntry = {\n    target\n  }; // a placeholder object\n  referenceMap.set(id, refEntry);\n  let targetProperties = _read(); // read the next value as the target object to id\n  if (refEntry.used) {\n    // there is a cycle, so we have to assign properties to original target\n    return Object.assign(target, targetProperties);\n  }\n  refEntry.target = targetProperties; // the placeholder wasn't used, replace with the deserialized one\n  return targetProperties; // no cycle, can just use the returned read object\n};\n\ncurrentExtensions[28].handlesRead = true;\ncurrentExtensions[29] = id => {\n  // sharedref http://cbor.schmorp.de/value-sharing (for structured clones)\n  let refEntry = referenceMap.get(id);\n  refEntry.used = true;\n  return refEntry.target;\n};\ncurrentExtensions[258] = array => new Set(array); // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md\n(currentExtensions[259] = _read => {\n  // https://github.com/shanewholloway/js-cbor-codec/blob/master/docs/CBOR-259-spec\n  // for decoding as a standard Map\n  if (currentDecoder.mapsAsObjects) {\n    currentDecoder.mapsAsObjects = false;\n    restoreMapsAsObject = true;\n  }\n  return _read();\n}).handlesRead = true;\nfunction combine(a, b) {\n  if (typeof a === \"string\") {\n    return a + b;\n  }\n  if (a instanceof Array) {\n    return a.concat(b);\n  }\n  return Object.assign({}, a, b);\n}\nfunction getPackedValues() {\n  if (!packedValues) {\n    if (currentDecoder.getShared) {\n      loadShared();\n    } else {\n      throw new Error(\"No packed values available\");\n    }\n  }\n  return packedValues;\n}\nconst SHARED_DATA_TAG_ID = 0x53687264; // ascii 'Shrd'\ncurrentExtensionRanges.push((tag, input) => {\n  if (tag >= 225 && tag <= 255) {\n    return combine(getPackedValues().prefixes[tag - 224], input);\n  }\n  if (tag >= 28704 && tag <= 32767) {\n    return combine(getPackedValues().prefixes[tag - 28672], input);\n  }\n  if (tag >= 1879052288 && tag <= 2147483647) {\n    return combine(getPackedValues().prefixes[tag - 1879048192], input);\n  }\n  if (tag >= 216 && tag <= 223) {\n    return combine(input, getPackedValues().suffixes[tag - 216]);\n  }\n  if (tag >= 27647 && tag <= 28671) {\n    return combine(input, getPackedValues().suffixes[tag - 27639]);\n  }\n  if (tag >= 1811940352 && tag <= 1879048191) {\n    return combine(input, getPackedValues().suffixes[tag - 1811939328]);\n  }\n  if (tag == SHARED_DATA_TAG_ID) {\n    // we do a special check for this so that we can keep the currentExtensions as densely stored array (v8 stores arrays densely under about 3000 elements)\n    return {\n      packedValues: packedValues,\n      structures: currentStructures.slice(0),\n      version: input\n    };\n  }\n  if (tag == 55799) {\n    // self-descriptive CBOR tag, just return input value\n    return input;\n  }\n});\nconst isLittleEndianMachine = new Uint8Array(new Uint16Array([1]).buffer)[0] == 1;\nconst typedArrays = [Uint8Array];\nconst typedArrayTags = [64];\nfor (let i = 0; i < typedArrays.length; i++) {\n  registerTypedArray(typedArrays[i], typedArrayTags[i]);\n}\nfunction registerTypedArray(TypedArray, tag) {\n  let dvMethod = \"get\" + TypedArray.name.slice(0, -5);\n  if (typeof TypedArray !== \"function\") {\n    TypedArray = null;\n  }\n  let bytesPerElement = TypedArray.BYTES_PER_ELEMENT;\n  for (let littleEndian = 0; littleEndian < 2; littleEndian++) {\n    if (!littleEndian && bytesPerElement == 1) {\n      continue;\n    }\n    let sizeShift = bytesPerElement == 2 ? 1 : bytesPerElement == 4 ? 2 : 3;\n    currentExtensions[littleEndian ? tag : tag - 4] = bytesPerElement == 1 || littleEndian == isLittleEndianMachine ? buffer => {\n      if (!TypedArray) {\n        throw new Error(\"Could not find typed array for code \" + tag);\n      }\n      // we have to always slice/copy here to get a new ArrayBuffer that is word/byte aligned\n      return new TypedArray(Uint8Array.prototype.slice.call(buffer, 0).buffer);\n    } : buffer => {\n      if (!TypedArray) {\n        throw new Error(\"Could not find typed array for code \" + tag);\n      }\n      let dv = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n      let elements = buffer.length >> sizeShift;\n      let ta = new TypedArray(elements);\n      let method = dv[dvMethod];\n      for (let i = 0; i < elements; i++) {\n        ta[i] = method.call(dv, i << sizeShift, littleEndian);\n      }\n      return ta;\n    };\n  }\n}\nfunction readBundleExt() {\n  let length = readJustLength();\n  let bundlePosition = position + read();\n  for (let i = 2; i < length; i++) {\n    // skip past bundles that were already read\n    let bundleLength = readJustLength(); // this will increment position, so must add to position afterwards\n    position += bundleLength;\n  }\n  let dataPosition = position;\n  position = bundlePosition;\n  bundledStrings = [readStringJS(readJustLength()), readStringJS(readJustLength())];\n  bundledStrings.position0 = 0;\n  bundledStrings.position1 = 0;\n  bundledStrings.postBundlePosition = position;\n  position = dataPosition;\n  return read();\n}\nfunction readJustLength() {\n  let token = src[position++] & 0x1f;\n  if (token > 0x17) {\n    switch (token) {\n      case 0x18:\n        token = src[position++];\n        break;\n      case 0x19:\n        token = dataView.getUint16(position);\n        position += 2;\n        break;\n      case 0x1a:\n        token = dataView.getUint32(position);\n        position += 4;\n        break;\n    }\n  }\n  return token;\n}\nfunction loadShared() {\n  if (currentDecoder.getShared) {\n    let sharedData = saveState(() => {\n      // save the state in case getShared modifies our buffer\n      src = null;\n      return currentDecoder.getShared();\n    }) || {};\n    let updatedStructures = sharedData.structures || [];\n    currentDecoder.sharedVersion = sharedData.version;\n    packedValues = currentDecoder.sharedValues = sharedData.packedValues;\n    if (currentStructures === true) {\n      currentDecoder.structures = currentStructures = updatedStructures;\n    } else {\n      currentStructures.splice.apply(currentStructures, [0, updatedStructures.length].concat(updatedStructures));\n    }\n  }\n}\nfunction saveState(callback) {\n  let savedSrcEnd = srcEnd;\n  let savedPosition = position;\n  let savedSrcStringStart = srcStringStart;\n  let savedSrcStringEnd = srcStringEnd;\n  let savedSrcString = srcString;\n  let savedReferenceMap = referenceMap;\n  let savedBundledStrings = bundledStrings;\n\n  // TODO: We may need to revisit this if we do more external calls to user code (since it could be slow)\n  let savedSrc = new Uint8Array(src.slice(0, srcEnd)); // we copy the data in case it changes while external data is processed\n  let savedStructures = currentStructures;\n  let savedDecoder = currentDecoder;\n  let savedSequentialMode = sequentialMode;\n  let value = callback();\n  srcEnd = savedSrcEnd;\n  position = savedPosition;\n  srcStringStart = savedSrcStringStart;\n  srcStringEnd = savedSrcStringEnd;\n  srcString = savedSrcString;\n  referenceMap = savedReferenceMap;\n  bundledStrings = savedBundledStrings;\n  src = savedSrc;\n  sequentialMode = savedSequentialMode;\n  currentStructures = savedStructures;\n  currentDecoder = savedDecoder;\n  dataView = new DataView(src.buffer, src.byteOffset, src.byteLength);\n  return value;\n}\nfunction clearSource() {\n  src = null;\n  referenceMap = null;\n  currentStructures = null;\n}\nconst mult10 = new Array(147); // this is a table matching binary exponents to the multiplier to determine significant digit rounding\nfor (let i = 0; i < 256; i++) {\n  mult10[i] = Number(\"1e\" + Math.floor(45.15 - i * 0.30103));\n}\nconst defaultDecoder = new Decoder({\n  useRecords: false\n});\nconst decode = defaultDecoder.decode;\n\n/**\n * @internal\n * @param hex\n */\nfunction hexToBytes(hex) {\n  hex = hex.toString(16);\n  if (!hex.startsWith(\"0x\")) {\n    hex = `0x${hex}`;\n  }\n  if (!isHexStrict(hex)) {\n    throw new Error(`Given value \"${hex}\" is not a valid hex string.`);\n  }\n  hex = hex.replace(/^0x/i, \"\");\n  const bytes = [];\n  for (let c = 0; c < hex.length; c += 2) {\n    bytes.push(parseInt(hex.slice(c, c + 2), 16));\n  }\n  return bytes;\n}\n\n/**\n * @internal\n * @param hex\n */\nfunction isHexStrict(hex) {\n  return (typeof hex === \"string\" || typeof hex === \"number\") && /^(-)?0x[0-9a-f]*$/i.test(hex.toString());\n}\n\n/**\n * @internal\n * @param bytecode\n */\nfunction extractIPFSHashFromBytecode(bytecode) {\n  const numericBytecode = hexToBytes(bytecode);\n  const cborLength = numericBytecode[numericBytecode.length - 2] * 0x100 + numericBytecode[numericBytecode.length - 1];\n  const bytecodeBuffer = Uint8Array.from(numericBytecode.slice(numericBytecode.length - 2 - cborLength, -2));\n  const cborData = decode(bytecodeBuffer);\n  if (\"ipfs\" in cborData && cborData[\"ipfs\"]) {\n    try {\n      return `ipfs://${bs58.encode(cborData[\"ipfs\"])}`;\n    } catch (e) {\n      console.warn(\"feature-detection ipfs cbor failed\", e);\n    }\n  }\n  return undefined;\n}\n\n/**\n * @internal\n * @param bytecode\n */\nfunction extractMinimalProxyImplementationAddress(bytecode) {\n  // EIP-1167 clone minimal proxy - https://eips.ethereum.org/EIPS/eip-1167\n  if (bytecode.startsWith(\"0x363d3d373d3d3d363d73\")) {\n    const implementationAddress = bytecode.slice(22, 62);\n    return `0x${implementationAddress}`;\n  }\n\n  // Minimal Proxy with receive() from 0xSplits - https://github.com/0xSplits/splits-contracts/blob/c7b741926ec9746182d0d1e2c4c2046102e5d337/contracts/libraries/Clones.sol\n  if (bytecode.startsWith(\"0x36603057343d5230\")) {\n    // +40 = size of addr\n    const implementationAddress = bytecode.slice(122, 122 + 40);\n    return `0x${implementationAddress}`;\n  }\n\n  // 0age's minimal proxy - https://medium.com/coinmonks/the-more-minimal-proxy-5756ae08ee48\n  if (bytecode.startsWith(\"0x3d3d3d3d363d3d37363d73\")) {\n    // +40 = size of addr\n    const implementationAddress = bytecode.slice(24, 24 + 40);\n    return `0x${implementationAddress}`;\n  }\n\n  // vyper's minimal proxy (uniswap v1) - https://etherscan.io/address/0x09cabec1ead1c0ba254b09efb3ee13841712be14#code\n  if (bytecode.startsWith(\"0x366000600037611000600036600073\")) {\n    const implementationAddress = bytecode.slice(32, 32 + 40);\n    return `0x${implementationAddress}`;\n  }\n  return undefined;\n}\n\n/**\n * @internal\n * @param address\n * @param provider\n */\nasync function resolveContractUriFromAddress(address, provider) {\n  const {\n    bytecode\n  } = await resolveImplementation(address, provider);\n  return extractIPFSHashFromBytecode(bytecode);\n}\nasync function resolveContractUriAndBytecode(address, provider) {\n  const {\n    bytecode\n  } = await resolveImplementation(address, provider);\n  return {\n    uri: extractIPFSHashFromBytecode(bytecode),\n    bytecode\n  };\n}\n\n/**\n * Resolve the implementation address of a proxy contract and its bytecode\n * @param address the contract address\n * @param provider RPC provider\n * @returns the implementation address and its bytecode\n */\nasync function resolveImplementation(address, provider) {\n  let bytecode;\n  try {\n    bytecode = await provider.getCode(address);\n  } catch (e) {\n    throw new Error(`Failed to get bytecode for address ${address}: ${e}`);\n  }\n  if (bytecode === \"0x\") {\n    const chain = await provider.getNetwork();\n    throw new Error(`Contract at ${address} does not exist on chain '${chain.name}' (chainId: ${chain.chainId})`);\n  }\n  try {\n    // TODO support other types of proxies\n    const implementationAddress = extractMinimalProxyImplementationAddress(bytecode);\n    if (implementationAddress) {\n      return await resolveImplementation(implementationAddress, provider);\n    }\n  } catch (e) {\n    // ignore\n  }\n\n  // EIP-1967 proxy storage slots - https://eips.ethereum.org/EIPS/eip-1967\n  try {\n    const proxyStorage = await provider.getStorageAt(address, BigNumber.from(\"0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc\"));\n    const implementationAddress = `0x${proxyStorage.slice(-40)}`;\n    if (utils.isAddress(implementationAddress) && implementationAddress !== constants.AddressZero) {\n      return await resolveImplementation(implementationAddress, provider);\n    }\n  } catch (e) {\n    // ignore\n  }\n  if (!bytecode) {\n    throw new Error(`Error fetching bytecode for ${address}`);\n  }\n  return {\n    address,\n    bytecode\n  };\n}\nconst CONTRACT_METADATA_TIMEOUT_SEC = 2;\n\n/**\n * @internal\n * @param compilerMetadataUri\n * @param storage\n */\nasync function fetchContractMetadata(compilerMetadataUri, storage) {\n  // short timeout to avoid hanging on unpinned contract metadata CIDs\n  const metadata = await storage.downloadJSON(compilerMetadataUri, {\n    timeoutInSeconds: CONTRACT_METADATA_TIMEOUT_SEC\n  });\n  if (!metadata || !metadata.output) {\n    throw new Error(`Could not resolve metadata for contract at ${compilerMetadataUri}`);\n  }\n  const abi = AbiSchema.parse(metadata.output.abi);\n  const compilationTarget = metadata.settings.compilationTarget;\n  const targets = Object.keys(compilationTarget);\n  const name = compilationTarget[targets[0]];\n  const info = ContractInfoSchema.parse({\n    title: metadata.output.devdoc.title,\n    author: metadata.output.devdoc.author,\n    details: metadata.output.devdoc.detail,\n    notice: metadata.output.userdoc.notice\n  });\n  const licenses = [...new Set(Object.entries(metadata.sources).map(_ref => {\n    let [, src] = _ref;\n    return src.license;\n  }))];\n  return {\n    name,\n    abi,\n    metadata,\n    info,\n    licenses\n  };\n}\nfunction getProcessEnv(key) {\n  let defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n  if (typeof process !== \"undefined\") {\n    if (process.env[key]) {\n      return process.env[key];\n    }\n  }\n  return defaultValue;\n}\nconst MultichainRegistry_address = \"0xcdAD8FA86e18538aC207872E8ff3536501431B73\"; // Polygon only\n\n/**\n * @internal\n */\nfunction getMultichainRegistryAddress() {\n  return getProcessEnv(\"multiChainRegistryAddress\", MultichainRegistry_address);\n}\n\n/**\n * @internal\n */\nconst isBrowser = () => \"object\" !== \"undefined\";\n\n/**\n * @internal\n */\nconst isNode = () => !isBrowser();\n\n/**\n * @internal\n */\nfunction unique(a, fn) {\n  if (a.length === 0 || a.length === 1) {\n    return a;\n  }\n  if (!fn) {\n    return a;\n  }\n  for (let i = 0; i < a.length; i++) {\n    for (let j = i + 1; j < a.length; j++) {\n      if (fn(a[i], a[j])) {\n        a.splice(j, 1);\n      }\n    }\n  }\n  return a;\n}\n\n/**\n * @internal\n */\nfunction joinABIs(abis) {\n  const parsedABIs = abis.map(abi => AbiSchema.parse(abi)).flat();\n  const filteredABIs = unique(parsedABIs, (a, b) => {\n    return a.name === b.name && a.type === b.type && a.inputs.length === b.inputs.length;\n  });\n  const finalABIs = filteredABIs.filter(item => item.type !== \"constructor\");\n  return AbiSchema.parse(finalABIs);\n}\nfunction extractFeatures(input, enabledExtensions) {\n  if (!input) {\n    return;\n  }\n  for (const extensionKey in input) {\n    const extension = input[extensionKey];\n    // if extension is enabled, then add it to enabledFeatures\n    if (extension.enabled) {\n      enabledExtensions.push(extension);\n    }\n    // recurse\n    extractFeatures(extension.features, enabledExtensions);\n  }\n}\n\n/**\n * Return all the detected features in the abi\n * @param abi - parsed array of abi entries\n * @returns array of all detected extensions with full information on each feature\n * @internal\n * @deprecated use getAllDetectedExtensions instead\n */\nfunction getAllDetectedFeatures(abi) {\n  const features = [];\n  extractFeatures(detectFeatures(abi), features);\n  return features;\n}\nfunction getAllDetectedExtensionsFromBytecode(bytecode) {\n  const features = [];\n  extractFeatures(detectFeaturesFromBytecode(bytecode), features);\n  return features;\n}\nfunction constructAbiFromBytecode(bytecode) {\n  let extensions = getAllDetectedExtensionsFromBytecode(bytecode);\n  // special deduping for ERC721 and ERC20\n  if (extensions.find(f => f.name === \"ERC721\")) {\n    extensions = extensions.filter(f => f.name !== \"ERC20\");\n  }\n  const abi = joinABIs(extensions.map(f => joinABIs(f.abis)));\n  return abi;\n}\n\n/**\n * Return all the detected extensions in the abi\n * @param abi - parsed array of abi entries\n * @returns array of all detected extensions with full information on each feature\n * @public\n */\nfunction getAllDetectedExtensions(abi) {\n  return getAllDetectedFeatures(abi).map(f => ({\n    ...f,\n    extensions: f.features\n  }));\n}\n\n// Internal static cache\nconst metadataCache = {};\nlet multichainRegistry = undefined;\nfunction getCacheKey(address, chainId) {\n  return `${address}-${chainId}`;\n}\nfunction putInCache(address, chainId, metadata) {\n  metadataCache[getCacheKey(address, chainId)] = metadata;\n}\nfunction getFromCache(address, chainId) {\n  return metadataCache[getCacheKey(address, chainId)];\n}\n\n/**\n * @internal\n * @param address\n * @param provider\n * @param storage\n */\nasync function fetchContractMetadataFromAddress(address, provider, storage) {\n  let sdkOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const chainId = (await provider.getNetwork()).chainId; // TODO resolve from sdk network\n  const cached = getFromCache(address, chainId);\n  if (cached) {\n    return cached;\n  }\n  let metadata;\n\n  // we can't race here, because the contract URI might resolve first with a non pinned URI\n  const [ipfsData, registryData] = await Promise.all([resolveContractUriAndBytecode(address, provider).catch(() => undefined), getMetadataUriFromMultichainRegistry(address, chainId, sdkOptions).then(uri => {\n    if (!uri) {\n      return undefined;\n    }\n    return {\n      uri,\n      bytecode: \"\"\n    };\n  }).catch(() => undefined)]);\n  const bytecode = ipfsData?.bytecode;\n  const metadataUri = registryData?.uri || ipfsData?.uri;\n  if (!metadataUri && !bytecode) {\n    throw new Error(`Could not fetch bytecode for contract at ${address} on chain ${chainId}, double check that the address and chainId are correct.`);\n  }\n  try {\n    metadata = await fetchContractMetadata(metadataUri, storage);\n  } catch (e) {\n    // Don't warn here, its common to not have IPFS metadata for a contract, fallback to bytecode\n  }\n  if (!metadata && bytecode) {\n    const abi = constructAbiFromBytecode(bytecode);\n    if (abi && abi.length > 0) {\n      console.warn(`Contract metadata could only be partially resolved, some contract functions might be unavailable. Try importing the contract by visiting: https://thirdweb.com/${chainId}/${address}`);\n      // return partial ABI\n      metadata = {\n        name: \"Unimported Contract\",\n        abi: abi,\n        metadata: {},\n        info: {},\n        licenses: [],\n        isPartialAbi: true\n      };\n      // return without caching\n      return metadata;\n    }\n  }\n  if (!metadata) {\n    throw new Error(`Could not resolve contract. Try importing it by visiting: https://thirdweb.com/${chainId}/${address}`);\n  }\n  putInCache(address, chainId, metadata);\n  return metadata;\n}\nasync function getMetadataUriFromMultichainRegistry(address, chainId, sdkOptions) {\n  if (!multichainRegistry) {\n    const polygonChain = sdkOptions?.supportedChains?.find(c => c.chainId === 137);\n    const chain = polygonChain || Polygon;\n    multichainRegistry = new Contract(getMultichainRegistryAddress(), TWRegistryABI, getChainProvider(chain, sdkOptions));\n  }\n  const importedUri = await multichainRegistry.getMetadataUri(chainId, address);\n  return importedUri;\n}\n\n/**\n * @internal\n * @param address\n * @param provider\n * @param storage\n * @returns\n */\nasync function fetchAbiFromAddress(address, provider, storage) {\n  try {\n    const metadata = await fetchContractMetadataFromAddress(address, provider, storage);\n    if (metadata && metadata.abi) {\n      return metadata.abi;\n    }\n  } catch (e) {\n    // ignore and return undefined\n    // will fallback to embedded ABIs for prebuilts\n  }\n  return undefined;\n}\nfunction buildDeployTransactionFunction(fn) {\n  async function executeFn() {\n    const tx = await fn(...arguments);\n    return tx.execute();\n  }\n  executeFn.prepare = fn;\n  return executeFn;\n}\nfunction buildTransactionFunction(fn) {\n  async function executeFn() {\n    const tx = await fn(...arguments);\n    return tx.execute();\n  }\n  executeFn.prepare = fn;\n  return executeFn;\n}\nasync function getDefaultGasOverrides(provider) {\n  // If we're running in the browser, let users configure gas price in their wallet UI\n  if (isBrowser()) {\n    return {};\n  }\n\n  // handle smart wallet provider\n  if (provider.originalProvider) {\n    provider = provider.originalProvider;\n  }\n  const feeData = await getDynamicFeeData(provider);\n  if (feeData.maxFeePerGas && feeData.maxPriorityFeePerGas) {\n    return {\n      maxFeePerGas: feeData.maxFeePerGas,\n      maxPriorityFeePerGas: feeData.maxPriorityFeePerGas\n    };\n  } else {\n    return {\n      gasPrice: await getGasPrice(provider)\n    };\n  }\n}\nasync function getDynamicFeeData(provider) {\n  let maxFeePerGas = null;\n  let maxPriorityFeePerGas = null;\n  const [{\n    chainId\n  }, block, eth_maxPriorityFeePerGas] = await Promise.all([provider.getNetwork(), provider.getBlock(\"latest\"), provider.send(\"eth_maxPriorityFeePerGas\", []).catch(() => null)]);\n  const baseBlockFee = block && block.baseFeePerGas ? block.baseFeePerGas : utils.parseUnits(\"100\", \"wei\");\n  if (chainId === Mumbai.chainId || chainId === Polygon.chainId) {\n    // for polygon, get fee data from gas station\n    maxPriorityFeePerGas = await getPolygonGasPriorityFee(chainId);\n  } else if (eth_maxPriorityFeePerGas) {\n    // prioritize fee from eth_maxPriorityFeePerGas\n    maxPriorityFeePerGas = BigNumber.from(eth_maxPriorityFeePerGas);\n  } else {\n    // if eth_maxPriorityFeePerGas is not available, use 1.5 gwei default\n    const feeData = await provider.getFeeData();\n    maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;\n    if (!maxPriorityFeePerGas) {\n      // chain does not support eip-1559, return null for both\n      return {\n        maxFeePerGas: null,\n        maxPriorityFeePerGas: null\n      };\n    }\n  }\n\n  // eip-1559 formula, with an extra 10% tip to account for gas volatility\n  maxFeePerGas = baseBlockFee.mul(2).add(getPreferredPriorityFee(maxPriorityFeePerGas));\n  return {\n    maxFeePerGas,\n    maxPriorityFeePerGas\n  };\n}\nfunction getPreferredPriorityFee(defaultPriorityFeePerGas) {\n  let percentMultiplier = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n  const extraTip = defaultPriorityFeePerGas.div(100).mul(percentMultiplier); // + 10%\n  const txGasPrice = defaultPriorityFeePerGas.add(extraTip);\n  return txGasPrice;\n}\nasync function getGasPrice(provider) {\n  const gasPrice = await provider.getGasPrice();\n  const maxGasPrice = utils.parseUnits(\"300\", \"gwei\"); // 300 gwei\n  const extraTip = gasPrice.div(100).mul(10); // + 10%\n  const txGasPrice = gasPrice.add(extraTip);\n  if (txGasPrice.gt(maxGasPrice)) {\n    return maxGasPrice;\n  }\n  return txGasPrice;\n}\n\n/**\n * @internal\n */\nfunction getGasStationUrl(chainId) {\n  switch (chainId) {\n    case ChainId.Polygon:\n      return \"https://gasstation.polygon.technology/v2\";\n    case ChainId.Mumbai:\n      return \"https://gasstation-testnet.polygon.technology/v2\";\n  }\n}\nconst MIN_POLYGON_GAS_PRICE = /* @__PURE__ */utils.parseUnits(\"31\", \"gwei\");\nconst MIN_MUMBAI_GAS_PRICE = /* @__PURE__ */utils.parseUnits(\"1\", \"gwei\");\n\n/**\n * @internal\n */\nfunction getDefaultGasFee(chainId) {\n  switch (chainId) {\n    case ChainId.Polygon:\n      return MIN_POLYGON_GAS_PRICE;\n    case ChainId.Mumbai:\n      return MIN_MUMBAI_GAS_PRICE;\n  }\n}\n\n/**\n *\n * @returns the gas price\n * @internal\n */\nasync function getPolygonGasPriorityFee(chainId) {\n  const gasStationUrl = getGasStationUrl(chainId);\n  try {\n    const data = await (await fetch(gasStationUrl)).json();\n    // take the standard speed here, SDK options will define the extra tip\n    const priorityFee = data[\"fast\"][\"maxPriorityFee\"];\n    if (priorityFee > 0) {\n      const fixedFee = parseFloat(priorityFee).toFixed(9);\n      return utils.parseUnits(fixedFee, \"gwei\");\n    }\n  } catch (e) {\n    console.error(\"failed to fetch gas\", e);\n  }\n  return getDefaultGasFee(chainId);\n}\n\n/**\n * @internal\n * @param publishedMetadata\n * @param storage\n */\n\nasync function fetchSourceFilesFromMetadata(publishedMetadata, storage) {\n  return await Promise.all(Object.entries(publishedMetadata.metadata.sources).map(async _ref => {\n    let [path, info] = _ref;\n    const urls = info.urls;\n    const ipfsLink = urls ? urls.find(url => url.includes(\"ipfs\")) : undefined;\n    if (ipfsLink) {\n      const ipfsHash = ipfsLink.split(\"ipfs/\")[1];\n      // 3 sec timeout for sources that haven't been uploaded to ipfs\n      const timeout = new Promise((_r, rej) => setTimeout(() => rej(\"timeout\"), 3000));\n      const source = await Promise.race([(await storage.download(`ipfs://${ipfsHash}`)).text(), timeout]);\n      return {\n        filename: path,\n        source\n      };\n    } else {\n      return {\n        filename: path,\n        source: info.content || \"Could not find source for this contract\"\n      };\n    }\n  }));\n}\nfunction isRouterContract(abi) {\n  const isPluginRouter = isFeatureEnabled(AbiSchema.parse(abi), \"PluginRouter\");\n  const isBaseRouter = isFeatureEnabled(AbiSchema.parse(abi), \"DynamicContract\");\n  return isBaseRouter || isPluginRouter;\n}\nconst ERROR_SUBSTRINGS = [\"eip-155\", \"eip155\", \"protected\", \"invalid chain id for signer\", \"chain id none\", \"chain_id mismatch\", \"recovered sender mismatch\", \"transaction hash mismatch\", \"chainid no support\", \"chainid (0)\", \"chainid(0)\"];\nconst ERROR_SUBSTRINGS_COMPOSITE = [[\"account\", \"not found\"], [\"wrong\", \"chainid\"]];\n\n/* eslint-disable no-useless-computed-key */\nconst CUSTOM_GAS_FOR_CHAIN = {\n  [5001]: {\n    name: \"Mantle Testnet\",\n    gasPrice: 1\n  },\n  [71402]: {\n    name: \"Godwoken Mainnet\",\n    gasPrice: 40_000 * 10 ** 9\n  },\n  [1351057110]: {\n    name: \"Chaos (SKALE Testnet)\",\n    gasPrice: 100000\n  },\n  [361]: {\n    name: \"Theta Mainnet\",\n    gasPrice: 4000 * 10 ** 9\n  },\n  [365]: {\n    name: \"Theta Testnet\",\n    gasPrice: 4000 * 10 ** 9\n  },\n  [7700]: {\n    name: \"Canto\",\n    gasPrice: 1000 * 10 ** 9\n  },\n  [7701]: {\n    name: \"Canto Testnet\",\n    gasPrice: 1000 * 10 ** 9\n  },\n  [338]: {\n    name: \"Cronos Testnet\",\n    gasPrice: 2000 * 10 ** 9\n  },\n  [199]: {\n    name: \"BitTorrent Chain\",\n    gasPrice: 300_000 * 10 ** 9\n  }\n};\n/* eslint-enable no-useless-computed-key */\n\nfunction matchError(error) {\n  const errorIndex = ERROR_SUBSTRINGS.findIndex(substring => error.includes(substring));\n  const compositeErrorIndex = ERROR_SUBSTRINGS_COMPOSITE.findIndex(arr => {\n    let foundError = true;\n    arr.forEach(substring => {\n      foundError &&= error.includes(substring);\n    });\n    return foundError;\n  });\n  return errorIndex !== -1 || compositeErrorIndex !== -1;\n}\nconst CREATE2_FACTORY_BYTECODE = \"0x604580600e600039806000f350fe7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe03601600081602082378035828234f58015156039578182fd5b8082525050506014600cf3\";\nconst SIGNATURE = {\n  v: 27,\n  r: \"0x2222222222222222222222222222222222222222222222222222222222222222\",\n  s: \"0x2222222222222222222222222222222222222222222222222222222222222222\"\n};\nconst COMMON_FACTORY = \"0x4e59b44847b379578588920cA78FbF26c0B4956C\"; // for pre-eip-155 supporting chains\n\nconst GAS_LIMIT_FOR_DEPLOYER = 5_000_000;\nconst DEPLOYER_BYTECODE = \"0x60806040526040516107f33803806107f383398101604081905261002291610359565b805160005b818110156100c157828181518110610041576100416104c9565b6020026020010151600001516001600160a01b03163b600014156100af576100ad838281518110610074576100746104c9565b602002602001015160200151848381518110610092576100926104c9565b6020026020010151604001516100c960201b6100091760201c565b505b806100b9816104df565b915050610027565b505050610557565b606061011183836040518060400160405280601e81526020017f416464726573733a206c6f772d6c6576656c2063616c6c206661696c6564000081525061011860201b60201c565b9392505050565b6060610127848460008561012f565b949350505050565b6060824710156101955760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6044820152651c8818d85b1b60d21b60648201526084015b60405180910390fd5b6001600160a01b0385163b6101ec5760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e7472616374000000604482015260640161018c565b600080866001600160a01b031685876040516102089190610508565b60006040518083038185875af1925050503d8060008114610245576040519150601f19603f3d011682016040523d82523d6000602084013e61024a565b606091505b50909250905061025b828286610266565b979650505050505050565b60608315610275575081610111565b8251156102855782518084602001fd5b8160405162461bcd60e51b815260040161018c9190610524565b634e487b7160e01b600052604160045260246000fd5b604051606081016001600160401b03811182821017156102d7576102d761029f565b60405290565b604051601f8201601f191681016001600160401b03811182821017156103055761030561029f565b604052919050565b80516001600160a01b038116811461032457600080fd5b919050565b60005b8381101561034457818101518382015260200161032c565b83811115610353576000848401525b50505050565b6000602080838503121561036c57600080fd5b82516001600160401b038082111561038357600080fd5b818501915085601f83011261039757600080fd5b8151818111156103a9576103a961029f565b8060051b6103b88582016102dd565b91825283810185019185810190898411156103d257600080fd5b86860192505b838310156104bc578251858111156103f05760008081fd5b86016060601f19828d0381018213156104095760008081fd5b6104116102b5565b61041c8b850161030d565b8152604061042b81860161030d565b828d01529284015192898411156104425760008081fd5b83850194508e603f86011261045957600093508384fd5b8b85015193508984111561046f5761046f61029f565b61047f8c84601f870116016102dd565b92508383528e818587010111156104965760008081fd5b6104a5848d8501838801610329565b8101919091528452505091860191908601906103d8565b9998505050505050505050565b634e487b7160e01b600052603260045260246000fd5b600060001982141561050157634e487b7160e01b600052601160045260246000fd5b5060010190565b6000825161051a818460208701610329565b9190910192915050565b6020815260008251806020840152610543816040850160208701610329565b601f01601f19169190910160400192915050565b61028d806105666000396000f3fe6080604052600080fd5b606061004b83836040518060400160405280601e81526020017f416464726573733a206c6f772d6c6576656c2063616c6c206661696c65640000815250610052565b9392505050565b60606100618484600085610069565b949350505050565b6060824710156100cf5760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6044820152651c8818d85b1b60d21b60648201526084015b60405180910390fd5b6001600160a01b0385163b6101265760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e747261637400000060448201526064016100c6565b600080866001600160a01b031685876040516101429190610208565b60006040518083038185875af1925050503d806000811461017f576040519150601f19603f3d011682016040523d82523d6000602084013e610184565b606091505b509150915061019482828661019f565b979650505050505050565b606083156101ae57508161004b565b8251156101be5782518084602001fd5b8160405162461bcd60e51b81526004016100c69190610224565b60005b838110156101f35781810151838201526020016101db565b83811115610202576000848401525b50505050565b6000825161021a8184602087016101d8565b9190910192915050565b60208152600082518060208401526102438160408501602087016101d8565b601f01601f1916919091016040019291505056fea26469706673582212200b524eb8ceaafe6c603273ee859fddbc2d6f1b7860c3d853dcf6f129f9d9371364736f6c634300080c0033\";\nconst DEPLOYER_ABI = [{\n  inputs: [{\n    components: [{\n      internalType: \"address\",\n      name: \"predictedAddress\",\n      type: \"address\"\n    }, {\n      internalType: \"address\",\n      name: \"to\",\n      type: \"address\"\n    }, {\n      internalType: \"bytes\",\n      name: \"data\",\n      type: \"bytes\"\n    }],\n    internalType: \"struct IDeployer.Transaction[]\",\n    name: \"transactions\",\n    type: \"tuple[]\"\n  }],\n  stateMutability: \"payable\",\n  type: \"constructor\"\n}];\n\n/**\n * Check if a contract exists at the given address\n *\n * @internal\n * @param address\n * @param provider\n */\nasync function isContractDeployed(address, provider) {\n  const code = await provider.getCode(address);\n  return code !== \"0x\" && code !== \"0x0\";\n}\n\n/**\n * Check if a chain enforces EIP-155 transactions\n * Ref: https://eips.ethereum.org/EIPS/eip-155\n *\n * @internal\n * @param provider\n */\nasync function isEIP155Enforced(provider) {\n  try {\n    // TODO: Find a better way to check this.\n\n    // Send a random transaction of legacy type (pre-eip-155).\n    // It will fail. Parse the error message to check whether eip-155 is enforced.\n    await provider.sendTransaction(\"0xf8a58085174876e800830186a08080b853604580600e600039806000f350fe7fffffffffffffffafffffffffffffffffffffffffffffffffffffffffffffffe03601600081602082378035828234f58015156039578182fd5b8082525050506014600cf31ba02222222222222222222222222222222222222222222222222222222222222222a02222222222222222222222222222222222222222222222222222222222222222\");\n  } catch (e) {\n    const errorMsg = e.toString().toLowerCase();\n    const errorJson = JSON.stringify(e).toLowerCase();\n    if (matchError(errorMsg) || matchError(errorJson)) {\n      return true;\n    }\n    return false;\n  }\n  return false;\n}\n\n/**\n * Generate a transaction to be sent with a keyless signer.\n *\n * @public\n * @param transaction: Unsigned transaction object\n * @param signature: Signature bytes\n */\nfunction getKeylessTxn(transaction, signature) {\n  // 1. Create serialized txn string\n  const digest = utils.arrayify(utils.keccak256(utils.serializeTransaction(transaction)));\n\n  // 2. Determine signer address from custom signature + txn\n  const signer = utils.recoverAddress(digest, signature);\n\n  // 3. Create the signed serialized txn string.\n  // To be sent directly to the chain using a provider.\n  const signedSerializedTx = utils.serializeTransaction(transaction, signature);\n  return {\n    signer: signer,\n    transaction: signedSerializedTx\n  };\n}\n\n/**\n *\n * @public\n * @param transaction: Unsigned transaction object\n * @param signature: Signature bytes\n */\nfunction getCreate2FactoryDeploymentInfo(chainId, gasPrice) {\n  const signature = utils.joinSignature(SIGNATURE);\n  const deploymentTransaction = getKeylessTxn({\n    gasPrice: gasPrice ? gasPrice : 100 * 10 ** 9,\n    gasLimit: 100000,\n    nonce: 0,\n    data: CREATE2_FACTORY_BYTECODE,\n    chainId: chainId\n  }, signature);\n  const create2FactoryAddress = utils.getContractAddress({\n    from: deploymentTransaction.signer,\n    nonce: 0\n  });\n  return {\n    ...deploymentTransaction,\n    deployment: create2FactoryAddress\n  };\n}\n\n/**\n * Get the CREATE2 Factory address for a network\n * Source code of the factory:\n * https://github.com/Arachnid/deterministic-deployment-proxy/blob/master/source/deterministic-deployment-proxy.yul\n *\n * @internal\n * @param provider\n */\nasync function getCreate2FactoryAddress(provider) {\n  const commonFactoryExists = await isContractDeployed(COMMON_FACTORY, provider);\n  if (commonFactoryExists) {\n    return COMMON_FACTORY;\n  }\n  const enforceEip155 = await isEIP155Enforced(provider);\n  const networkId = (await provider.getNetwork()).chainId;\n  const chainId = enforceEip155 ? networkId : 0;\n  const deploymentInfo = CUSTOM_GAS_FOR_CHAIN[networkId] ? getCreate2FactoryDeploymentInfo(chainId, CUSTOM_GAS_FOR_CHAIN[networkId].gasPrice) : getCreate2FactoryDeploymentInfo(chainId);\n  return deploymentInfo.deployment;\n}\nconst bytecode = \"0x60606040526040805190810160405280600d81526020017f57726170706564204574686572000000000000000000000000000000000000008152506000908051906020019061004f9291906100c8565b506040805190810160405280600481526020017f57455448000000000000000000000000000000000000000000000000000000008152506001908051906020019061009b9291906100c8565b506012600260006101000a81548160ff021916908360ff16021790555034156100c357600080fd5b61016d565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061010957805160ff1916838001178555610137565b82800160010185558215610137579182015b8281111561013657825182559160200191906001019061011b565b5b5090506101449190610148565b5090565b61016a91905b8082111561016657600081600090555060010161014e565b5090565b90565b610c348061017c6000396000f3006060604052600436106100af576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806306fdde03146100b9578063095ea7b31461014757806318160ddd146101a157806323b872dd146101ca5780632e1a7d4d14610243578063313ce5671461026657806370a082311461029557806395d89b41146102e2578063a9059cbb14610370578063d0e30db0146103ca578063dd62ed3e146103d4575b6100b7610440565b005b34156100c457600080fd5b6100cc6104dd565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561010c5780820151818401526020810190506100f1565b50505050905090810190601f1680156101395780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b341561015257600080fd5b610187600480803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803590602001909190505061057b565b604051808215151515815260200191505060405180910390f35b34156101ac57600080fd5b6101b461066d565b6040518082815260200191505060405180910390f35b34156101d557600080fd5b610229600480803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803590602001909190505061068c565b604051808215151515815260200191505060405180910390f35b341561024e57600080fd5b61026460048080359060200190919050506109d9565b005b341561027157600080fd5b610279610b05565b604051808260ff1660ff16815260200191505060405180910390f35b34156102a057600080fd5b6102cc600480803573ffffffffffffffffffffffffffffffffffffffff16906020019091905050610b18565b6040518082815260200191505060405180910390f35b34156102ed57600080fd5b6102f5610b30565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561033557808201518184015260208101905061031a565b50505050905090810190601f1680156103625780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b341561037b57600080fd5b6103b0600480803573ffffffffffffffffffffffffffffffffffffffff16906020019091908035906020019091905050610bce565b604051808215151515815260200191505060405180910390f35b6103d2610440565b005b34156103df57600080fd5b61042a600480803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803573ffffffffffffffffffffffffffffffffffffffff16906020019091905050610be3565b6040518082815260200191505060405180910390f35b34600360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825401925050819055503373ffffffffffffffffffffffffffffffffffffffff167fe1fffcc4923d04b559f4d29a8bfc6cda04eb5b0d3c460751c2402c5c5cc9109c346040518082815260200191505060405180910390a2565b60008054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156105735780601f1061054857610100808354040283529160200191610573565b820191906000526020600020905b81548152906001019060200180831161055657829003601f168201915b505050505081565b600081600460003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925846040518082815260200191505060405180910390a36001905092915050565b60003073ffffffffffffffffffffffffffffffffffffffff1631905090565b600081600360008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054101515156106dc57600080fd5b3373ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff16141580156107b457507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205414155b156108cf5781600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020541015151561084457600080fd5b81600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825403925050819055505b81600360008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000828254039250508190555081600360008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825401925050819055508273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040518082815260200191505060405180910390a3600190509392505050565b80600360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205410151515610a2757600080fd5b80600360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825403925050819055503373ffffffffffffffffffffffffffffffffffffffff166108fc829081150290604051600060405180830381858888f193505050501515610ab457600080fd5b3373ffffffffffffffffffffffffffffffffffffffff167f7fcf532c15f0a6db0bd6d0e038bea71d30d808c7d98cb3bf7268a95bf5081b65826040518082815260200191505060405180910390a250565b600260009054906101000a900460ff1681565b60036020528060005260406000206000915090505481565b60018054600181600116156101000203166002900480601f016020809104026020016040519081016040528092919081815260200182805460018160011615610100020316600290048015610bc65780601f10610b9b57610100808354040283529160200191610bc6565b820191906000526020600020905b815481529060010190602001808311610ba957829003601f168201915b505050505081565b6000610bdb33848461068c565b905092915050565b60046020528160005260406000206020528060005260406000206000915091505054815600a165627a7a72305820deb4c2ccab3c2fdca32ab3f46728389c2fe2c165d5fafa07661e4e004f6c344a0029\";\nconst ContractPublisher_address = \"0x664244560eBa21Bf82d7150C791bE1AbcD5B4cd7\"; // Polygon only\n\n/**\n * @internal\n */\nfunction getContractPublisherAddress() {\n  return getProcessEnv(\"contractPublisherAddress\", ContractPublisher_address);\n}\nconst DropErc721ContractInput = /* @__PURE__ */CommonContractSchema.merge(CommonRoyaltySchema).merge(MerkleSchema).merge(CommonSymbolSchema);\nconst DropErc721ContractOutput = /* @__PURE__ */CommonContractOutputSchema.merge(CommonRoyaltySchema).merge(MerkleSchema).merge(CommonSymbolSchema);\nconst DropErc721ContractDeploy = /* @__PURE__ */DropErc721ContractInput.merge(CommonPlatformFeeSchema).merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema);\nconst DropErc721ContractSchema = {\n  deploy: DropErc721ContractDeploy,\n  output: DropErc721ContractOutput,\n  input: DropErc721ContractInput\n};\nconst DropErc1155ContractInput = /* @__PURE__ */CommonContractSchema.merge(CommonRoyaltySchema).merge(MerkleSchema).merge(CommonSymbolSchema);\nconst DropErc1155ContractOutput = /* @__PURE__ */CommonContractOutputSchema.merge(CommonRoyaltySchema).merge(MerkleSchema).merge(CommonSymbolSchema);\nconst DropErc1155ContractDeploy = /* @__PURE__ */DropErc1155ContractInput.merge(CommonPlatformFeeSchema).merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema);\nconst DropErc1155ContractSchema = {\n  deploy: DropErc1155ContractDeploy,\n  output: DropErc1155ContractOutput,\n  input: DropErc1155ContractInput\n};\nconst MarketplaceContractInput = CommonContractSchema;\nconst MarketplaceContractOutput = CommonContractOutputSchema;\nconst MarketplaceContractDeploy = /* @__PURE__ */MarketplaceContractInput.merge(CommonPlatformFeeSchema).merge(CommonTrustedForwarderSchema);\nconst MarketplaceContractSchema = {\n  deploy: MarketplaceContractDeploy,\n  output: MarketplaceContractOutput,\n  input: MarketplaceContractInput\n};\nconst PackContractInput = /* @__PURE__ */CommonContractSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema);\nconst PackContractOutput = /* @__PURE__ */CommonContractOutputSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema);\nconst PackContractDeploy = /* @__PURE__ */PackContractInput.merge(CommonPlatformFeeSchema).merge(CommonTrustedForwarderSchema);\nconst PackContractSchema = {\n  deploy: PackContractDeploy,\n  output: PackContractOutput,\n  input: PackContractInput\n};\nconst SplitRecipientInputSchema = /* @__PURE__ */(() => z.object({\n  address: AddressOrEnsSchema,\n  sharesBps: BasisPointsSchema.gt(0, \"Shares must be greater than 0\")\n}))();\nconst SplitRecipientOuputSchema = /* @__PURE__ */SplitRecipientInputSchema.extend({\n  address: AddressOrEnsSchema,\n  sharesBps: BasisPointsSchema\n});\nconst SplitsContractInput = /* @__PURE__ */(() => CommonContractSchema.extend({\n  recipients: z.array(SplitRecipientInputSchema).default([]).superRefine((val, context) => {\n    const addressMap = {};\n    let totalShares = 0;\n    for (let index = 0; index < val.length; index++) {\n      const entry = val[index];\n      if (addressMap[entry.address]) {\n        context.addIssue({\n          code: z.ZodIssueCode.custom,\n          message: `Duplicate address.`,\n          path: [index, `address`]\n        });\n      }\n      addressMap[entry.address] = true;\n      totalShares += entry.sharesBps;\n      if (totalShares > 10000) {\n        context.addIssue({\n          code: z.ZodIssueCode.custom,\n          message: `Total shares cannot go over 100%.`,\n          path: [index, `sharesBps`]\n        });\n      }\n    }\n    if (totalShares !== 10000) {\n      context.addIssue({\n        code: z.ZodIssueCode.custom,\n        message: `Total shares need to add up to 100%. Total shares are currently ${totalShares / 100}%`,\n        path: []\n      });\n    }\n  })\n}))();\nconst SplitsContractOutput = /* @__PURE__ */(() => CommonContractOutputSchema.extend({\n  recipients: z.array(SplitRecipientOuputSchema)\n}))();\nconst SplitsContractDeploy = /* @__PURE__ */SplitsContractInput.merge(SplitsContractInput).merge(CommonTrustedForwarderSchema);\nconst SplitsContractSchema = {\n  deploy: SplitsContractDeploy,\n  output: SplitsContractOutput,\n  input: SplitsContractInput\n};\nconst TokenErc20ContractInput = /* @__PURE__ */CommonContractSchema.merge(CommonSymbolSchema);\nconst TokenErc20ContractOutput = /* @__PURE__ */CommonContractOutputSchema.merge(CommonSymbolSchema);\nconst TokenErc20ContractDeploy = /* @__PURE__ */TokenErc20ContractInput.merge(CommonPlatformFeeSchema).merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema);\nconst TokenErc20ContractSchema = {\n  deploy: TokenErc20ContractDeploy,\n  output: TokenErc20ContractOutput,\n  input: TokenErc20ContractInput\n};\nconst TokenErc721ContractInput = /* @__PURE__ */CommonContractSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema);\nconst TokenErc721ContractOutput = /* @__PURE__ */CommonContractOutputSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema);\nconst TokenErc721ContractDeploy = /* @__PURE__ */TokenErc721ContractInput.merge(CommonPlatformFeeSchema).merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema);\nconst TokenErc721ContractSchema = {\n  deploy: TokenErc721ContractDeploy,\n  output: TokenErc721ContractOutput,\n  input: TokenErc721ContractInput\n};\nconst TokenErc1155ContractInput = /* @__PURE__ */CommonContractSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema);\nconst TokenErc1155ContractOutput = /* @__PURE__ */CommonContractOutputSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema);\nconst TokenErc1155ContractDeploy = /* @__PURE__ */TokenErc1155ContractInput.merge(CommonPlatformFeeSchema).merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema);\nconst TokenErc1155ContractSchema = {\n  deploy: TokenErc1155ContractDeploy,\n  output: TokenErc1155ContractOutput,\n  input: TokenErc1155ContractInput\n};\nconst VoteSettingsInputSchema = /* @__PURE__ */(() => z.object({\n  voting_delay_in_blocks: z.number().min(0).default(0),\n  voting_period_in_blocks: z.number().min(1).default(1),\n  voting_token_address: AddressOrEnsSchema,\n  voting_quorum_fraction: PercentSchema.default(0),\n  proposal_token_threshold: BigNumberishSchema.default(1)\n}))();\nconst VoteSettingsOuputSchema = /* @__PURE__ */VoteSettingsInputSchema.extend({\n  proposal_token_threshold: BigNumberSchema\n});\nconst VoteContractInput = /* @__PURE__ */CommonContractSchema.merge(VoteSettingsInputSchema);\nconst VoteContractOutput = /* @__PURE__ */CommonContractOutputSchema.merge(VoteSettingsOuputSchema);\nconst VoteContractDeploy = /* @__PURE__ */VoteContractInput.merge(CommonTrustedForwarderSchema);\nconst VoteContractSchema = {\n  deploy: VoteContractDeploy,\n  output: VoteContractOutput,\n  input: VoteContractInput\n};\nasync function resolveAddress(addressOrEns) {\n  return AddressOrEnsSchema.parseAsync(addressOrEns);\n}\n\n/**\n * Fetch and parse the full metadata AFTER publishing a contract, with all the extra information (version, readme, etc)\n * @internal\n * @param publishMetadataUri\n * @param storage\n */\nasync function fetchExtendedReleaseMetadata(publishMetadataUri, storage) {\n  const meta = await (await storage.download(publishMetadataUri)).text();\n  return FullPublishMetadataSchemaOutput.parse(JSON.parse(meta));\n}\n\n/**\n * @internal\n * @param publishMetadataUri\n * @param storage\n */\nasync function fetchRawPredeployMetadata(publishMetadataUri, storage) {\n  return PreDeployMetadata.parse(JSON.parse(await (await storage.download(publishMetadataUri)).text()));\n}\n\n/**\n * Fetch the metadata coming from CLI, this is before deploying or releasing the contract.\n * @internal\n * @param publishMetadataUri\n * @param storage\n */\nasync function fetchPreDeployMetadata(publishMetadataUri, storage) {\n  const rawMeta = await fetchRawPredeployMetadata(publishMetadataUri, storage);\n  const deployBytecode = await (await storage.download(rawMeta.bytecodeUri)).text();\n  const parsedMeta = await fetchContractMetadata(rawMeta.metadataUri, storage);\n  return PreDeployMetadataFetchedSchema.parse({\n    ...rawMeta,\n    ...parsedMeta,\n    bytecode: deployBytecode\n  });\n}\nconst deployMetadataCache = {};\nasync function fetchAndCacheDeployMetadata(publishMetadataUri, storage) {\n  if (deployMetadataCache[publishMetadataUri]) {\n    return deployMetadataCache[publishMetadataUri];\n  }\n  const compilerMetadata = await fetchPreDeployMetadata(publishMetadataUri, storage);\n  let extendedMetadata;\n  try {\n    extendedMetadata = await fetchExtendedReleaseMetadata(publishMetadataUri, storage);\n  } catch (e) {\n    // not a factory deployment, ignore\n  }\n  const data = {\n    compilerMetadata,\n    extendedMetadata\n  };\n  deployMetadataCache[publishMetadataUri] = data;\n  return data;\n}\nconst AddressZero = \"0x0000000000000000000000000000000000000000\";\nconst TWRegistry_address = \"0x7c487845f98938Bb955B1D5AD069d9a30e4131fd\";\nconst TWFactory_address = \"0x5DBC7B840baa9daBcBe9D2492E45D7244B54A2A0\";\n\n/**\n * @internal\n */\nconst OZ_DEFENDER_FORWARDER_ADDRESS = \"0xc82BbE41f2cF04e3a8efA18F7032BDD7f6d98a81\";\n\n/**\n * @internal\n */\nconst CONTRACT_ADDRESSES = {\n  [ChainId.Mainnet]: {\n    openzeppelinForwarder: OZ_DEFENDER_FORWARDER_ADDRESS,\n    openzeppelinForwarderEOA: \"0x76ce2CB1Ae48Fa067f4fb8c5f803111AE0B24BEA\",\n    biconomyForwarder: \"0x84a0856b038eaAd1cC7E297cF34A7e72685A8693\",\n    twFactory: TWFactory_address,\n    twRegistry: TWRegistry_address,\n    twBYOCRegistry: AddressZero\n  },\n  [ChainId.Goerli]: {\n    openzeppelinForwarder: \"0x5001A14CA6163143316a7C614e30e6041033Ac20\",\n    openzeppelinForwarderEOA: \"0xe73c50cB9c5B378627ff625BB6e6725A4A5D65d2\",\n    biconomyForwarder: \"0xE041608922d06a4F26C0d4c27d8bCD01daf1f792\",\n    twFactory: TWFactory_address,\n    twRegistry: TWRegistry_address,\n    twBYOCRegistry: \"0xB1Bd9d7942A250BA2Dce27DD601F2ED4211A60C4\"\n  },\n  [ChainId.Polygon]: {\n    openzeppelinForwarder: OZ_DEFENDER_FORWARDER_ADDRESS,\n    openzeppelinForwarderEOA: \"0x4f247c69184ad61036EC2Bb3213b69F10FbEDe1F\",\n    biconomyForwarder: \"0x86C80a8aa58e0A4fa09A69624c31Ab2a6CAD56b8\",\n    twFactory: TWFactory_address,\n    twRegistry: TWRegistry_address,\n    twBYOCRegistry: \"0x308473Be900F4185A56587dE54bDFF5E8f7a6AE7\"\n  },\n  [ChainId.Mumbai]: {\n    openzeppelinForwarder: OZ_DEFENDER_FORWARDER_ADDRESS,\n    openzeppelinForwarderEOA: \"0xb1A2883fc4d287d9cB8Dbb96cFF60C76BEf2D250\",\n    biconomyForwarder: \"0x9399BB24DBB5C4b782C70c2969F58716Ebbd6a3b\",\n    twFactory: TWFactory_address,\n    twRegistry: TWRegistry_address,\n    twBYOCRegistry: \"0x3F17972CB27506eb4a6a3D59659e0B57a43fd16C\"\n  },\n  [ChainId.Avalanche]: {\n    openzeppelinForwarder: OZ_DEFENDER_FORWARDER_ADDRESS,\n    openzeppelinForwarderEOA: \"0xb1A2883fc4d287d9cB8Dbb96cFF60C76BEf2D250\",\n    biconomyForwarder: \"0x64CD353384109423a966dCd3Aa30D884C9b2E057\",\n    twFactory: TWFactory_address,\n    twRegistry: TWRegistry_address,\n    twBYOCRegistry: AddressZero\n  },\n  [ChainId.AvalancheFujiTestnet]: {\n    openzeppelinForwarder: OZ_DEFENDER_FORWARDER_ADDRESS,\n    openzeppelinForwarderEOA: \"0xe73c50cB9c5B378627ff625BB6e6725A4A5D65d2\",\n    biconomyForwarder: \"0x6271Ca63D30507f2Dcbf99B52787032506D75BBF\",\n    twFactory: TWFactory_address,\n    twRegistry: TWRegistry_address,\n    twBYOCRegistry: \"0x3E6eE864f850F5e5A98bc950B68E181Cf4010F23\"\n  },\n  [ChainId.Fantom]: {\n    openzeppelinForwarder: OZ_DEFENDER_FORWARDER_ADDRESS,\n    openzeppelinForwarderEOA: \"0xb1A2883fc4d287d9cB8Dbb96cFF60C76BEf2D250\",\n    biconomyForwarder: \"0x64CD353384109423a966dCd3Aa30D884C9b2E057\",\n    twFactory: \"0x97EA0Fcc552D5A8Fb5e9101316AAd0D62Ea0876B\",\n    twRegistry: TWRegistry_address,\n    twBYOCRegistry: AddressZero\n  },\n  [ChainId.FantomTestnet]: {\n    openzeppelinForwarder: OZ_DEFENDER_FORWARDER_ADDRESS,\n    openzeppelinForwarderEOA: \"0x42D3048b595B6e1c28a588d70366CcC2AA4dB47b\",\n    biconomyForwarder: \"0x69FB8Dca8067A5D38703b9e8b39cf2D51473E4b4\",\n    twFactory: TWFactory_address,\n    twRegistry: TWRegistry_address,\n    twBYOCRegistry: \"0x3E6eE864f850F5e5A98bc950B68E181Cf4010F23\"\n  },\n  [ChainId.Arbitrum]: {\n    openzeppelinForwarder: \"0x4a8AC7f22DeD2CF923A51e4A1c67490bd8868add\",\n    openzeppelinForwarderEOA: \"0x4f247c69184ad61036EC2Bb3213b69F10FbEDe1F\",\n    biconomyForwarder: \"0xfe0fa3C06d03bDC7fb49c892BbB39113B534fB57\",\n    twFactory: \"0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0\",\n    twRegistry: TWRegistry_address,\n    twBYOCRegistry: AddressZero\n  },\n  [ChainId.ArbitrumGoerli]: {\n    openzeppelinForwarder: \"0x8cbc8B5d71702032904750A66AEfE8B603eBC538\",\n    openzeppelinForwarderEOA: \"0x119704314Ef304EaAAE4b3c7C9ABd59272A28310\",\n    biconomyForwarder: AddressZero,\n    twFactory: \"0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0\",\n    twRegistry: TWRegistry_address,\n    twBYOCRegistry: AddressZero\n  },\n  [ChainId.Optimism]: {\n    openzeppelinForwarder: \"0xd85da690EF288A6976DE0E85Fb2Aad512eBAfbf7\",\n    openzeppelinForwarderEOA: \"0x7e80648EB2071E26937F9D42A513ccf4815fc702\",\n    biconomyForwarder: \"0xefba8a2a82ec1fb1273806174f5e28fbb917cf95\",\n    twFactory: \"0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0\",\n    twRegistry: TWRegistry_address,\n    twBYOCRegistry: AddressZero\n  },\n  [ChainId.OptimismGoerli]: {\n    openzeppelinForwarder: \"0x8cbc8B5d71702032904750A66AEfE8B603eBC538\",\n    openzeppelinForwarderEOA: \"0x119704314Ef304EaAAE4b3c7C9ABd59272A28310\",\n    biconomyForwarder: AddressZero,\n    twFactory: \"0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0\",\n    twRegistry: TWRegistry_address,\n    twBYOCRegistry: AddressZero\n  },\n  [ChainId.BinanceSmartChainMainnet]: {\n    openzeppelinForwarder: \"0x7C4717039B89d5859c4Fbb85EDB19A6E2ce61171\",\n    openzeppelinForwarderEOA: \"0xE8dd2Ff0212F86d3197b4AfDC6dAC6ac47eb10aC\",\n    biconomyForwarder: \"0x86C80a8aa58e0A4fa09A69624c31Ab2a6CAD56b8\",\n    twBYOCRegistry: AddressZero,\n    twFactory: \"0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0\",\n    twRegistry: TWRegistry_address\n  },\n  [ChainId.BinanceSmartChainTestnet]: {\n    openzeppelinForwarder: \"0x44bE9D54B9C8b5e57a3325E8Ec9154640e7c6955\",\n    openzeppelinForwarderEOA: \"0x7e80648EB2071E26937F9D42A513ccf4815fc702\",\n    biconomyForwarder: \"0x61456BF1715C1415730076BB79ae118E806E74d2\",\n    twBYOCRegistry: AddressZero,\n    twFactory: \"0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0\",\n    twRegistry: TWRegistry_address\n  },\n  [ChainId.Hardhat]: {\n    openzeppelinForwarder: AddressZero,\n    openzeppelinForwarderEOA: AddressZero,\n    biconomyForwarder: AddressZero,\n    twFactory: AddressZero,\n    twRegistry: AddressZero,\n    twBYOCRegistry: AddressZero\n  },\n  [ChainId.Localhost]: {\n    openzeppelinForwarder: AddressZero,\n    openzeppelinForwarderEOA: AddressZero,\n    biconomyForwarder: AddressZero,\n    twFactory: AddressZero,\n    twRegistry: AddressZero,\n    twBYOCRegistry: AddressZero\n  }\n};\n\n/**\n * @internal\n */\nfunction getContractAddressByChainId(chainId, contractName) {\n  // for testing only\n  if (chainId === ChainId.Hardhat || chainId === ChainId.Localhost) {\n    if (contractName === \"twFactory\") {\n      return getProcessEnv(\"factoryAddress\");\n    } else if (contractName === \"twRegistry\") {\n      return getProcessEnv(\"registryAddress\");\n    } else {\n      return AddressZero;\n    }\n  }\n  // real output here\n  return CONTRACT_ADDRESSES[chainId]?.[contractName];\n}\n\n/**\n * @internal\n */\n\n/**\n * @internal\n */\nconst InterfaceId_IERC721 = /* @__PURE__ */utils.arrayify(\"0x80ac58cd\");\n\n/**\n * @internal\n */\nconst InterfaceId_IERC1155 = /* @__PURE__ */utils.arrayify(\"0xd9b67a26\");\n\n/**\n * @public\n */\nlet EventType = /*#__PURE__*/function (EventType) {\n  EventType[\"Transaction\"] = \"transaction\";\n  EventType[\"Signature\"] = \"signature\";\n  return EventType;\n}({});\nconst THIRDWEB_DEPLOYER = \"0xdd99b75f095d0c4d5112aCe938e4e6ed962fb024\";\nasync function fetchPublishedContractFromPolygon(publisherAddress, contractName) {\n  let version = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"latest\";\n  let storage = arguments.length > 3 ? arguments[3] : undefined;\n  let clientId = arguments.length > 4 ? arguments[4] : undefined;\n  let secretKey = arguments.length > 5 ? arguments[5] : undefined;\n  const polygonChain = getSupportedChains().find(c => c.chainId === 137);\n  const chain = polygonChain || Polygon;\n  const publisher = await resolveAddress(publisherAddress);\n  const contract = new Contract(getContractPublisherAddress(), ContractPublisherAbi, getChainProvider(chain, {\n    clientId,\n    secretKey\n  }));\n  let publishedContract;\n  if (!version || version === \"latest\") {\n    const model = await contract.getPublishedContract(publisher, contractName);\n    publishedContract = PublishedContractSchema.parse({\n      id: model.contractId,\n      timestamp: model.publishTimestamp,\n      metadataUri: model.publishMetadataUri\n    });\n  } else {\n    const allVersions = (await contract.getPublishedContractVersions(publisher, contractName)).map(c => {\n      return PublishedContractSchema.parse({\n        id: c.contractId,\n        timestamp: c.publishTimestamp,\n        metadataUri: c.publishMetadataUri\n      });\n    });\n\n    // get the metadata for each version\n    const versionMetadata = await Promise.all(allVersions.map(async c => {\n      return {\n        name: c.id,\n        publishedTimestamp: c.timestamp,\n        publishedMetadata: await fetchAndCacheDeployMetadata(c.metadataUri, storage)\n      };\n    }));\n    // find the version that matches the version string\n    const versionMatch = versionMetadata.find(metadata => metadata.publishedMetadata.extendedMetadata?.version === version);\n    invariant(versionMatch, \"Contract version not found\");\n    // match the version back to the contract based on the published timestamp\n    publishedContract = allVersions.find(c => c.timestamp === versionMatch.publishedTimestamp);\n  }\n  if (!publishedContract) {\n    throw new Error(`No published contract found for ${contractName} at version by '${THIRDWEB_DEPLOYER}'`);\n  }\n  return publishedContract;\n}\n\n/**\n * Generate salt for deployment with Create2\n * Note: Salt component is generated by appending `tw` (thirdweb) to the bytecode\n *\n * @internal\n * @param bytecode: Creation bytecode of the contract to deploy\n */\nfunction getSaltHash(bytecode) {\n  const bytecodePrefixed = bytecode.startsWith(\"0x\") ? bytecode : `0x${bytecode}`;\n  const bytecodeHash = utils.id(bytecodePrefixed);\n  const salt = `tw.${bytecodeHash}`;\n  const saltHash = utils.id(salt);\n  return saltHash;\n}\n\n/**\n *\n * Construct init-bytecode, packed with salthash.\n * This hex data is intended to be sent to the CREATE2 factory address\n *\n * @internal\n * @param bytecode: Creation bytecode of the contract to deploy\n * @param encodedArgs: Abi-encoded constructor params\n */\nfunction getInitBytecodeWithSalt(bytecode, encodedArgs, salt) {\n  const bytecodePrefixed = bytecode.startsWith(\"0x\") ? bytecode : `0x${bytecode}`;\n  const saltHash = salt ? utils.id(salt) : getSaltHash(bytecodePrefixed);\n  const initBytecodeWithSalt = utils.solidityPack([\"bytes32\", \"bytes\", \"bytes\"], [saltHash, bytecodePrefixed, encodedArgs]);\n  return initBytecodeWithSalt;\n}\n\n/**\n * Pre-compute a contract's deployment address for a CREATE2 deployment.\n *\n * @public\n * @param bytecode: Creation bytecode of the contract to deploy\n * @param encodedArgs: Abi-encoded constructor params\n * @param create2FactoryAddress\n */\nfunction computeDeploymentAddress(bytecode, encodedArgs, create2FactoryAddress, salt) {\n  const bytecodePrefixed = bytecode.startsWith(\"0x\") ? bytecode : `0x${bytecode}`;\n  const saltHash = salt ? utils.id(salt) : getSaltHash(bytecodePrefixed);\n\n  // 1. create init bytecode hash with contract's bytecode and encoded args\n  const initBytecode = utils.solidityPack([\"bytes\", \"bytes\"], [bytecodePrefixed, encodedArgs]);\n\n  // 2. abi-encode pack the deployer address, salt, and bytecode hash\n  const deployInfoPacked = utils.solidityPack([\"bytes1\", \"address\", \"bytes32\", \"bytes32\"], [\"0xff\", create2FactoryAddress, saltHash, utils.solidityKeccak256([\"bytes\"], [initBytecode])]);\n\n  // 3. hash the packed deploy info\n  const hashedDeployInfo = utils.solidityKeccak256([\"bytes\"], [deployInfoPacked]);\n\n  // 4. return last 20 bytes (40 characters) of the hash -- this is the predicted address\n  return `0x${hashedDeployInfo.slice(26)}`;\n}\n\n/**\n *\n * @param abi\n * @returns\n * @internal\n */\nfunction extractConstructorParamsFromAbi(abi) {\n  const parsedAbi = AbiSchema.parse(abi || []);\n  for (const input of parsedAbi) {\n    if (input.type === \"constructor\") {\n      return input.inputs || [];\n    }\n  }\n  return [];\n}\nconst caches = {\n  deploymentPresets: {}\n};\n\n/**\n * Returns the RoyaltyEngineV1 address for a given chain\n * @param chainId - the chain id\n * @public\n */\nfunction getRoyaltyEngineV1ByChainId(chainId) {\n  return ROYALTY_ENGINE_V1_ADDRESS[chainId] || constants.AddressZero;\n}\nconst ROYALTY_ENGINE_V1_ADDRESS = {\n  [ChainId.Mainnet]: \"0x0385603ab55642cb4dd5de3ae9e306809991804f\",\n  [ChainId.Goerli]: \"0xEF770dFb6D5620977213f55f99bfd781D04BBE15\",\n  [ChainId.BinanceSmartChainMainnet]: \"0xEF770dFb6D5620977213f55f99bfd781D04BBE15\",\n  [ChainId.Polygon]: \"0x28EdFcF0Be7E86b07493466e7631a213bDe8eEF2\",\n  [ChainId.Mumbai]: \"0x0a01E11887f727D1b1Cd81251eeEE9BEE4262D07\",\n  [ChainId.Avalanche]: \"0xEF770dFb6D5620977213f55f99bfd781D04BBE15\",\n  [ChainId.Optimism]: \"0xEF770dFb6D5620977213f55f99bfd781D04BBE15\",\n  [ChainId.Arbitrum]: \"0xEF770dFb6D5620977213f55f99bfd781D04BBE15\"\n};\nasync function computeDeploymentInfo(contractType, provider, storage, create2Factory, contractOptions, clientId, secretKey) {\n  const contractName = contractOptions && contractOptions.contractName;\n  const version = contractOptions && contractOptions.version;\n  let publisherAddress = contractOptions && contractOptions.publisherAddress;\n  let metadata = contractOptions && contractOptions.metadata;\n  invariant(contractName || metadata, \"Require contract name or metadata\");\n  if (contractName && caches.deploymentPresets[contractName]) {\n    return caches.deploymentPresets[contractName];\n  }\n\n  // Different treatment for WETH contract\n  if (contractName === \"WETH9\") {\n    const address = computeDeploymentAddress(bytecode, [], create2Factory);\n    const contractDeployed = await isContractDeployed(address, provider);\n    let initBytecodeWithSalt = \"\";\n    if (!contractDeployed) {\n      initBytecodeWithSalt = getInitBytecodeWithSalt(bytecode, []);\n    }\n    return {\n      name: contractName,\n      type: contractType,\n      transaction: {\n        predictedAddress: address,\n        to: create2Factory,\n        data: initBytecodeWithSalt\n      }\n    };\n  }\n  if (!metadata) {\n    invariant(contractName, \"Require contract name\");\n    if (!publisherAddress) {\n      publisherAddress = THIRDWEB_DEPLOYER;\n    }\n    const publishedContract = await fetchPublishedContractFromPolygon(publisherAddress, contractName, version, storage, clientId, secretKey);\n    metadata = (await fetchAndCacheDeployMetadata(publishedContract.metadataUri, storage)).compilerMetadata;\n  }\n  const encodedArgs = await encodeConstructorParamsForImplementation(metadata, provider, storage, create2Factory, contractOptions?.constructorParams, clientId, secretKey);\n  const address = computeDeploymentAddress(metadata.bytecode, encodedArgs, create2Factory);\n  const contractDeployed = await isContractDeployed(address, provider);\n  let initBytecodeWithSalt = \"\";\n  if (!contractDeployed) {\n    initBytecodeWithSalt = getInitBytecodeWithSalt(metadata.bytecode, encodedArgs);\n  }\n  return {\n    name: contractName,\n    type: contractType,\n    transaction: {\n      predictedAddress: address,\n      to: create2Factory,\n      data: initBytecodeWithSalt\n    },\n    encodedArgs\n  };\n}\n\n/**\n * @internal\n *\n * Determine constructor params required by an implementation contract.\n * Return abi-encoded params.\n */\nasync function encodeConstructorParamsForImplementation(compilerMetadata, provider, storage, create2Factory, constructorParamMap, clientId, secretKey) {\n  const constructorParams = extractConstructorParamsFromAbi(compilerMetadata.abi);\n  const constructorParamTypes = constructorParams.map(p => {\n    if (p.type === \"tuple[]\") {\n      return utils.ParamType.from(p);\n    } else {\n      return p.type;\n    }\n  });\n  const constructorParamValues = await Promise.all(constructorParams.map(async p => {\n    if (constructorParamMap && constructorParamMap[p.name]) {\n      if (constructorParamMap[p.name].type) {\n        invariant(constructorParamMap[p.name].type === p.type, `Provided type ${constructorParamMap[p.name].type} doesn't match the actual type ${p.type} from Abi`);\n      }\n      return constructorParamMap[p.name].value;\n    }\n    if (p.name && p.name.includes(\"nativeTokenWrapper\")) {\n      const chainId = (await provider.getNetwork()).chainId;\n      let nativeTokenWrapperAddress = getNativeTokenByChainId(chainId).wrapped.address;\n      if (nativeTokenWrapperAddress === constants.AddressZero) {\n        const deploymentInfo = await computeDeploymentInfo(\"infra\", provider, storage, create2Factory, {\n          contractName: \"WETH9\"\n        }, clientId, secretKey);\n        if (!caches.deploymentPresets[\"WETH9\"]) {\n          caches.deploymentPresets[\"WETH9\"] = deploymentInfo;\n        }\n        nativeTokenWrapperAddress = deploymentInfo.transaction.predictedAddress;\n      }\n      return nativeTokenWrapperAddress;\n    } else if (p.name && p.name.includes(\"trustedForwarder\")) {\n      if (compilerMetadata.name === \"Pack\") {\n        // EOAForwarder for Pack\n        const deploymentInfo = await computeDeploymentInfo(\"infra\", provider, storage, create2Factory, {\n          contractName: \"ForwarderEOAOnly\"\n        }, clientId, secretKey);\n        if (!caches.deploymentPresets[\"ForwarderEOAOnly\"]) {\n          caches.deploymentPresets[\"ForwarderEOAOnly\"] = deploymentInfo;\n        }\n        return deploymentInfo.transaction.predictedAddress;\n      }\n      const deploymentInfo = await computeDeploymentInfo(\"infra\", provider, storage, create2Factory, {\n        contractName: \"Forwarder\"\n      }, clientId, secretKey);\n      if (!caches.deploymentPresets[\"Forwarder\"]) {\n        caches.deploymentPresets[\"Forwarder\"] = deploymentInfo;\n      }\n      return deploymentInfo.transaction.predictedAddress;\n    } else if (p.name && p.name.includes(\"royaltyEngineAddress\")) {\n      const chainId = (await provider.getNetwork()).chainId;\n      return getRoyaltyEngineV1ByChainId(chainId);\n    } else {\n      throw new Error(\"Can't resolve constructor arguments\");\n    }\n  }));\n  const encodedArgs = utils.defaultAbiCoder.encode(constructorParamTypes, constructorParamValues);\n  return encodedArgs;\n}\n\n/**\n *\n * @internal\n * @param provider\n * @param storage\n * @param create2Factory\n */\nasync function computeEOAForwarderAddress(provider, storage, create2Factory, clientId, secretKey) {\n  if (!create2Factory || create2Factory === \"\") {\n    create2Factory = await getCreate2FactoryAddress(provider);\n  }\n  return (await computeDeploymentInfo(\"infra\", provider, storage, create2Factory, {\n    contractName: \"ForwarderEOAOnly\"\n  }, clientId, secretKey)).transaction.predictedAddress;\n}\n\n/**\n *\n * @internal\n * @param provider\n * @param storage\n * @param create2Factory\n */\nasync function computeForwarderAddress(provider, storage, create2Factory, clientId, secretKey) {\n  if (!create2Factory || create2Factory === \"\") {\n    create2Factory = await getCreate2FactoryAddress(provider);\n  }\n  return (await computeDeploymentInfo(\"infra\", provider, storage, create2Factory, {\n    contractName: \"Forwarder\"\n  }, clientId, secretKey)).transaction.predictedAddress;\n}\n\n/**\n * @internal\n */\nconst ForwardRequest = [{\n  name: \"from\",\n  type: \"address\"\n}, {\n  name: \"to\",\n  type: \"address\"\n}, {\n  name: \"value\",\n  type: \"uint256\"\n}, {\n  name: \"gas\",\n  type: \"uint256\"\n}, {\n  name: \"nonce\",\n  type: \"uint256\"\n}, {\n  name: \"data\",\n  type: \"bytes\"\n}];\nconst ChainAwareForwardRequest = [{\n  name: \"from\",\n  type: \"address\"\n}, {\n  name: \"to\",\n  type: \"address\"\n}, {\n  name: \"value\",\n  type: \"uint256\"\n}, {\n  name: \"gas\",\n  type: \"uint256\"\n}, {\n  name: \"nonce\",\n  type: \"uint256\"\n}, {\n  name: \"data\",\n  type: \"bytes\"\n}, {\n  name: \"chainid\",\n  type: \"uint256\"\n}];\n\n/**\n * @internal\n */\nconst BiconomyForwarderAbi = [{\n  inputs: [{\n    internalType: \"address\",\n    name: \"from\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"batchId\",\n    type: \"uint256\"\n  }],\n  name: \"getNonce\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}];\nconst _nonces = {};\nconst _noncesSyncTimestamp = {};\n\n/**\n * @internal\n */\nasync function getAndIncrementNonce(forwarder, forwarderFunction, forwarderArgs) {\n  // address is only used for internal caching :)\n  const address = forwarderArgs.join(\"|\");\n  const timestamp = _noncesSyncTimestamp[address];\n  // if it's within 2 seconds we're optimistically increment the nonce\n  // should we always sync?\n  const shouldSync = Date.now() - timestamp >= 2000;\n  if (!(address in _nonces) || shouldSync) {\n    const nonceResult = await forwarder.functions[forwarderFunction](...forwarderArgs);\n    if (Array.isArray(nonceResult) && nonceResult.length > 0) {\n      _nonces[address] = BigNumber.from(nonceResult[0]);\n    } else {\n      _nonces[address] = BigNumber.from(nonceResult);\n    }\n    _noncesSyncTimestamp[address] = Date.now();\n  }\n  const nonce = _nonces[address];\n  _nonces[address] = BigNumber.from(_nonces[address]).add(1);\n  return nonce;\n}\n\n/**\n * @internal\n */\n\n/**\n * @internal\n */\n\n/**\n * @internal\n */\n\n/**\n * eip712 sign typed data with different wallet handling including ledger live\n * @internal\n */\nasync function signTypedDataInternal(signerInput, domain, types, message) {\n  // Handle ERC4337Signer\n  let signer = signerInput;\n  if (signerInput.originalSigner) {\n    signer = signerInput.originalSigner;\n  }\n  const provider = signer?.provider;\n  if (!provider) {\n    throw new Error(\"missing provider\");\n  }\n  const payload = utils._TypedDataEncoder.getPayload(domain, types, message);\n  let signature = \"\";\n  const signerAddress = (await signer.getAddress()).toLowerCase();\n\n  // an indirect way for accessing walletconnect's underlying provider\n  if (provider?.provider?.isWalletConnect) {\n    signature = await provider.send(\"eth_signTypedData\", [(await signer.getAddress()).toLowerCase(), JSON.stringify(payload)]);\n  } else {\n    try {\n      signature = await signer._signTypedData(domain, types, message);\n    } catch (err) {\n      if (err?.message?.includes(\"eth_signTypedData_v4\")) {\n        signature = await provider.send(\"eth_signTypedData\", [signerAddress, JSON.stringify(payload)]);\n      } else {\n        // magic.link signer only supports this way\n        try {\n          await provider.send(\"eth_signTypedData_v4\", [signerAddress, JSON.stringify(payload)]);\n        } catch (finalErr) {\n          throw finalErr;\n        }\n      }\n    }\n  }\n\n  // fix ledger live where signature result in v = 0, 1. ethers magically fix it in split/join.\n  return {\n    payload,\n    signature: utils.joinSignature(utils.splitSignature(signature))\n  };\n}\nconst NAME_ABI = [{\n  inputs: [],\n  name: \"name\",\n  outputs: [{\n    internalType: \"string\",\n    name: \"\",\n    type: \"string\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}];\nconst DOMAIN_SEPARATOR_ABI = [{\n  constant: true,\n  inputs: [],\n  name: \"DOMAIN_SEPARATOR\",\n  outputs: [{\n    internalType: \"bytes32\",\n    name: \"\",\n    type: \"bytes32\"\n  }],\n  payable: false,\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"getDomainSeperator\",\n  outputs: [{\n    internalType: \"bytes32\",\n    name: \"\",\n    type: \"bytes32\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}];\nconst NONCES_ABI = [{\n  inputs: [{\n    internalType: \"address\",\n    name: \"owner\",\n    type: \"address\"\n  }],\n  name: \"nonces\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"user\",\n    type: \"address\"\n  }],\n  name: \"getNonce\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"nonce\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}];\nasync function getSignerNonce(signer, contractAddress) {\n  const contract = new Contract(contractAddress, NONCES_ABI, signer);\n  try {\n    return await contract.nonces(await signer.getAddress());\n  } catch (err) {\n    return await contract.getNonce(await signer.getAddress());\n  }\n}\nasync function getDomainSeperator(signer, contractAddress) {\n  const contract = new Contract(contractAddress, DOMAIN_SEPARATOR_ABI, signer);\n  try {\n    return await contract.DOMAIN_SEPARATOR();\n  } catch (err) {\n    try {\n      return await contract.getDomainSeperator();\n    } catch (err2) {\n      console.error(\"Error getting domain separator\", err2);\n    }\n  }\n}\nasync function getTokenName(signer, contractAddress) {\n  return new Contract(contractAddress, NAME_ABI, signer).name();\n}\n\n/**\n * Polygon chain has different EIP712 domain separator for USDC, DAI compared to other chains and slightly different than EIP-2612.\n */\nasync function getChainDomainSeperator(signer, domain) {\n  const contractDomainSeparator = await getDomainSeperator(signer, domain.verifyingContract);\n  const polygonDomain = {\n    name: domain.name,\n    version: domain.version,\n    verifyingContract: domain.verifyingContract,\n    salt: utils.hexZeroPad(BigNumber.from(domain.chainId).toHexString(), 32)\n  };\n  if (utils._TypedDataEncoder.hashDomain(polygonDomain) === contractDomainSeparator) {\n    return polygonDomain;\n  }\n  return domain;\n}\n\n/**\n * @internal\n */\nasync function signEIP2612Permit(signer, currencyAddress, owner, spender, value, deadline, nonce) {\n  const domain = await getChainDomainSeperator(signer, {\n    name: await getTokenName(signer, currencyAddress),\n    version: \"1\",\n    chainId: await signer.getChainId(),\n    verifyingContract: currencyAddress\n  });\n  nonce = nonce || (await getSignerNonce(signer, currencyAddress)).toString();\n  deadline = deadline || constants.MaxUint256;\n  const message = {\n    owner,\n    spender,\n    value,\n    nonce,\n    deadline\n  };\n  const types = {\n    Permit: [{\n      name: \"owner\",\n      type: \"address\"\n    }, {\n      name: \"spender\",\n      type: \"address\"\n    }, {\n      name: \"value\",\n      type: \"uint256\"\n    }, {\n      name: \"nonce\",\n      type: \"uint256\"\n    }, {\n      name: \"deadline\",\n      type: \"uint256\"\n    }]\n  };\n  const {\n    signature\n  } = await signTypedDataInternal(signer, domain, types, message);\n  return {\n    message,\n    signature\n  };\n}\nclass TransactionContext {\n  constructor(options) {\n    this.args = options.args;\n    this.overrides = options.overrides || {};\n    this.provider = options.provider;\n    this.signer = options.signer;\n    this.storage = options.storage;\n\n    // Connect provider to signer if it isn't already connected\n    if (!this.signer.provider) {\n      this.signer = this.signer.connect(this.provider);\n    }\n  }\n  get getSigner() {\n    return this.signer;\n  }\n  get getProvider() {\n    return this.provider;\n  }\n  get getStorage() {\n    return this.storage;\n  }\n  getArgs() {\n    return this.args;\n  }\n  getOverrides() {\n    return this.overrides;\n  }\n  getValue() {\n    return this.overrides.value || 0;\n  }\n  setArgs(args) {\n    this.args = args;\n    return this;\n  }\n  setOverrides(overrides) {\n    this.overrides = overrides;\n    return this;\n  }\n  updateOverrides(overrides) {\n    this.overrides = {\n      ...this.overrides,\n      ...overrides\n    };\n    return this;\n  }\n  setValue(value) {\n    this.updateOverrides({\n      value\n    });\n    return this;\n  }\n  setGasLimit(gasLimit) {\n    this.updateOverrides({\n      gasLimit\n    });\n    return this;\n  }\n  setGasPrice(gasPrice) {\n    this.updateOverrides({\n      gasPrice\n    });\n    return this;\n  }\n  setNonce(nonce) {\n    this.updateOverrides({\n      nonce\n    });\n    return this;\n  }\n  setMaxFeePerGas(maxFeePerGas) {\n    this.updateOverrides({\n      maxFeePerGas\n    });\n    return this;\n  }\n  setMaxPriorityFeePerGas(maxPriorityFeePerGas) {\n    this.updateOverrides({\n      maxPriorityFeePerGas\n    });\n    return this;\n  }\n  setType(type) {\n    this.updateOverrides({\n      type\n    });\n    return this;\n  }\n  setAccessList(accessList) {\n    this.updateOverrides({\n      accessList\n    });\n    return this;\n  }\n  setCustomData(customData) {\n    this.updateOverrides({\n      customData\n    });\n    return this;\n  }\n  setCcipReadEnabled(ccipReadEnabled) {\n    this.updateOverrides({\n      ccipReadEnabled\n    });\n    return this;\n  }\n  /**\n   * Set a multiple to multiply the gas limit by\n   *\n   * @example\n   * ```js\n   * // Set the gas limit multiple to 1.2 (increase by 20%)\n   * tx.setGasLimitMultiple(1.2)\n   * ```\n   */\n  setGasLimitMultiple(factor) {\n    // If gasLimit override is set, we can just set it synchronously\n    if (BigNumber.isBigNumber(this.overrides.gasLimit)) {\n      this.overrides.gasLimit = BigNumber.from(Math.floor(BigNumber.from(this.overrides.gasLimit).toNumber() * factor));\n    } else {\n      // Otherwise, set a gas multiple to use later\n      this.gasMultiple = factor;\n    }\n  }\n\n  /**\n   * Estimate the total gas cost of this transaction (in both ether and wei)\n   */\n  async estimateGasCost() {\n    const [gasLimit, gasPrice] = await Promise.all([this.estimateGasLimit(), this.getGasPrice()]);\n    const gasCost = gasLimit.mul(gasPrice);\n    return {\n      ether: utils.formatEther(gasCost),\n      wei: gasCost\n    };\n  }\n\n  /**\n   * Calculates the gas price for transactions (adding a 10% tip buffer)\n   */\n  async getGasPrice() {\n    return getGasPrice(this.provider);\n  }\n\n  /**\n   * Get the address of the transaction signer\n   */\n  async getSignerAddress() {\n    return this.signer.getAddress();\n  }\n\n  /**\n   * Get gas overrides for the transaction\n   */\n  async getGasOverrides() {\n    return getDefaultGasOverrides(this.provider);\n  }\n\n  /**\n   * Calculates the priority fee per gas according (adding a 10% buffer)\n   */\n  getPreferredPriorityFee(defaultPriorityFeePerGas) {\n    const extraTip = defaultPriorityFeePerGas.div(100).mul(10); // + 10%\n    const txGasPrice = defaultPriorityFeePerGas.add(extraTip);\n    return txGasPrice;\n  }\n}\nclass Transaction extends TransactionContext {\n  static fromContractWrapper(options) {\n    const signer = options.contractWrapper.getSigner();\n    if (!signer) {\n      throw new Error(\"Cannot create a transaction without a signer. Please ensure that you have a connected signer.\");\n    }\n    const optionsWithContract = {\n      ...options,\n      contract: options.contractWrapper.writeContract,\n      provider: options.contractWrapper.getProvider(),\n      signer,\n      gasless: options.contractWrapper.options.gasless,\n      storage: options.contractWrapper.storage\n    };\n    return new Transaction(optionsWithContract);\n  }\n  static async fromContractInfo(options) {\n    const storage = options.storage;\n    let contractAbi = options.contractAbi;\n    if (!contractAbi) {\n      try {\n        const metadata = await fetchContractMetadataFromAddress(options.contractAddress, options.provider, storage);\n        contractAbi = metadata.abi;\n      } catch {\n        throw new Error(`Could resolve contract metadata for address ${options.contractAddress}. Please pass the contract ABI manually with the 'contractAbi' option.`);\n      }\n    }\n    const contract = new Contract(options.contractAddress, contractAbi, options.provider);\n    const optionsWithContract = {\n      ...options,\n      storage,\n      contract\n    };\n    return new Transaction(optionsWithContract);\n  }\n  constructor(options) {\n    super({\n      args: options.args,\n      overrides: options.overrides,\n      provider: options.provider,\n      signer: options.signer,\n      storage: options.storage\n    });\n    this.method = options.method;\n    this.gaslessOptions = options.gasless;\n    this.parse = options.parse;\n\n    // Always connect the signer to the contract\n    this.contract = options.contract.connect(this.signer);\n\n    // Create new storage instance if one isn't provided\n    this.storage = options.storage;\n  }\n  getTarget() {\n    return this.contract.address;\n  }\n  getMethod() {\n    return this.method;\n  }\n  getGaslessOptions() {\n    return this.gaslessOptions;\n  }\n  setGaslessOptions(options) {\n    this.gaslessOptions = options;\n    return this;\n  }\n  setParse(parse) {\n    this.parse = parse;\n    return this;\n  }\n\n  /**\n   * Encode the function data for this transaction\n   */\n  encode() {\n    return this.contract.interface.encodeFunctionData(this.method, this.args);\n  }\n\n  /**\n   * Get the signed transaction\n   */\n  async sign() {\n    const populatedTx = await this.populateTransaction();\n    const signedTx = await this.contract.signer.signTransaction(populatedTx);\n    return signedTx;\n  }\n  async populateTransaction() {\n    const gasOverrides = await this.getGasOverrides();\n    const overrides = {\n      ...gasOverrides,\n      ...this.overrides\n    };\n\n    // First, if no gasLimit is passed, call estimate gas ourselves\n    if (!overrides.gasLimit) {\n      overrides.gasLimit = await this.estimateGasLimit();\n    }\n    const tx = await this.contract.populateTransaction[this.method](...this.args, overrides);\n    const populatedTx = await this.contract.signer.populateTransaction(tx);\n    return populatedTx;\n  }\n\n  /**\n   * Simulate the transaction on-chain without executing\n   */\n  async simulate() {\n    if (!this.contract.callStatic[this.method]) {\n      throw this.functionError();\n    }\n    try {\n      return await this.contract.callStatic[this.method](...this.args, ...(this.overrides.value ? [{\n        value: this.overrides.value\n      }] : []));\n    } catch (err) {\n      throw await this.transactionError(err);\n    }\n  }\n\n  /**\n   * Estimate the gas limit of this transaction\n   */\n  async estimateGasLimit() {\n    if (!this.contract.estimateGas[this.method]) {\n      throw this.functionError();\n    }\n    try {\n      const gasEstimate = await this.contract.estimateGas[this.method](...this.args, this.overrides);\n      if (this.gasMultiple) {\n        return BigNumber.from(Math.floor(BigNumber.from(gasEstimate).toNumber() * this.gasMultiple));\n      }\n      return gasEstimate;\n    } catch (err) {\n      // If gas estimation fails, we'll call static to get a better error message\n      await this.simulate();\n\n      // If transaction simulation (static call) doesn't throw, then throw a generic error\n      throw await this.transactionError(err);\n    }\n  }\n\n  /**\n   * Send the transaction without waiting for it to be mined.\n   */\n  async send() {\n    if (!this.contract.functions[this.method]) {\n      throw this.functionError();\n    }\n    if (this.gaslessOptions && (\"openzeppelin\" in this.gaslessOptions || \"biconomy\" in this.gaslessOptions)) {\n      return this.sendGasless();\n    }\n    const gasOverrides = await this.getGasOverrides();\n    const overrides = {\n      ...gasOverrides,\n      ...this.overrides\n    };\n\n    // First, if no gasLimit is passed, call estimate gas ourselves\n    if (!overrides.gasLimit) {\n      overrides.gasLimit = await this.estimateGasLimit();\n      try {\n        // for dynamic contracts, add 30% to the gas limit to account for multiple delegate calls\n        const abi = JSON.parse(this.contract.interface.format(\"json\"));\n        if (isRouterContract(abi)) {\n          overrides.gasLimit = overrides.gasLimit.mul(110).div(100);\n        }\n      } catch (err) {\n        console.warn(\"Error raising gas limit\", err);\n      }\n    }\n\n    // Now there should be no gas estimate errors\n    try {\n      return await this.contract.functions[this.method](...this.args, overrides);\n    } catch (err) {\n      throw await this.transactionError(err);\n    }\n  }\n\n  /**\n   * Send the transaction and wait for it to be mined\n   */\n  async execute() {\n    const tx = await this.send();\n    let receipt;\n    try {\n      receipt = await tx.wait();\n    } catch (err) {\n      // If tx.wait() fails, it just gives us a generic \"transaction failed\"\n      // error. So instead, we need to call static to get an informative error message\n      await this.simulate();\n\n      // If transaction simulation (static call) doesn't throw, then throw with the message that we have\n      throw await this.transactionError(err);\n    }\n    if (this.parse) {\n      return this.parse(receipt);\n    }\n    return {\n      receipt\n    };\n  }\n\n  /**\n   * Execute the transaction with gasless\n   */\n  async sendGasless() {\n    const tx = await this.prepareGasless();\n    const txHash = await defaultGaslessSendFunction(tx, this.signer, this.provider, this.storage, this.gaslessOptions);\n\n    // Need to poll here because ethers.provider.getTransaction lies about the type\n    // It can actually return null, which can happen if we're still in gasless API send queue\n    let sentTx;\n    let iteration = 1;\n    while (!sentTx) {\n      try {\n        sentTx = await this.provider.getTransaction(txHash);\n      } catch (err) {\n        // some providers can throw an error if the tx is very recent\n      }\n      // Exponential (ish) backoff for polling\n      if (!sentTx) {\n        await new Promise(resolve => setTimeout(resolve, Math.min(iteration * 1000, 10000)));\n        iteration++;\n      }\n\n      // Timeout if we still don't have it after a while\n      if (iteration > 20) {\n        throw new Error(`Unable to retrieve transaction with hash ${txHash}`);\n      }\n    }\n    return sentTx;\n  }\n\n  /**\n   * @internal\n   * @returns\n   */\n  async prepareGasless() {\n    invariant(this.gaslessOptions && (\"openzeppelin\" in this.gaslessOptions || \"biconomy\" in this.gaslessOptions), \"No gasless options set on this transaction!\");\n    const signerAddress = await this.getSignerAddress();\n    const args = [...this.args];\n    if (this.method === \"multicall\" && Array.isArray(this.args[0]) && args[0].length > 0) {\n      args[0] = args[0].map(tx => utils.solidityPack([\"bytes\", \"address\"], [tx, signerAddress]));\n    }\n    invariant(this.signer, \"Cannot execute gasless transaction without valid signer\");\n    const [{\n      chainId\n    }, from] = await Promise.all([this.provider.getNetwork(), this.overrides.from || signerAddress]);\n    const to = this.contract.address;\n    const value = this.overrides?.value || 0;\n    if (BigNumber.from(value).gt(0)) {\n      throw new Error(\"Cannot send native token value with gasless transaction\");\n    }\n    const data = this.contract.interface.encodeFunctionData(this.method, args);\n    let gas = BigNumber.from(0);\n    try {\n      const gasEstimate = await this.contract.estimateGas[this.method](...args);\n      gas = gasEstimate.mul(2);\n    } catch (e) {\n      // ignore\n    }\n\n    // in some cases WalletConnect doesn't properly give an estimate for how much gas it would actually use.\n    // as a fix, we're setting it to a high arbitrary number (500k) as the gas limit that should cover for most function calls.\n    if (gas.lt(100000)) {\n      gas = BigNumber.from(500000);\n    }\n\n    // check for gas override in callOverrides\n    if (this.overrides.gasLimit && BigNumber.from(this.overrides.gasLimit).gt(gas)) {\n      gas = BigNumber.from(this.overrides.gasLimit);\n    }\n    return {\n      from,\n      to,\n      data,\n      chainId,\n      gasLimit: gas,\n      functionName: this.method,\n      functionArgs: args,\n      callOverrides: this.overrides\n    };\n  }\n  functionError() {\n    return new Error(`Contract \"${this.contract.address}\" does not have function \"${this.method}\"`);\n  }\n\n  /**\n   * Create a nicely formatted error message with tx metadata and solidity stack trace\n   */\n  async transactionError(error) {\n    const provider = this.provider;\n\n    // Get metadata for transaction to populate into error\n    const [network, from] = await Promise.all([provider.getNetwork(), this.overrides.from || this.getSignerAddress()]);\n    const to = this.contract.address;\n    const data = this.encode();\n    const value = BigNumber.from(this.overrides.value || 0);\n    const rpcUrl = provider.connection?.url;\n\n    // Render function signature with arguments filled in\n    const functionSignature = this.contract.interface.getFunction(this.method);\n    const methodArgs = this.args.map(arg => {\n      if (JSON.stringify(arg).length <= 80) {\n        return JSON.stringify(arg);\n      }\n      return JSON.stringify(arg, undefined, 2);\n    });\n    const joinedArgs = methodArgs.join(\", \").length <= 80 ? methodArgs.join(\", \") : \"\\n\" + methodArgs.map(arg => \"  \" + arg.split(\"\\n\").join(\"\\n  \")).join(\",\\n\") + \"\\n\";\n    const method = `${functionSignature.name}(${joinedArgs})`;\n    const hash = error.transactionHash || error.transaction?.hash || error.receipt?.transactionHash;\n\n    // Parse the revert reason from the error\n    const reason = parseRevertReason(error);\n\n    // Get contract sources for stack trace\n    let sources = undefined;\n    let contractName = undefined;\n    try {\n      const metadata = await fetchContractMetadataFromAddress(this.contract.address, this.provider, this.storage);\n      if (metadata.name) {\n        contractName = metadata.name;\n      }\n      if (metadata.metadata.sources) {\n        sources = await fetchSourceFilesFromMetadata(metadata, this.storage);\n      }\n    } catch (err) {\n      // no-op\n    }\n    return new TransactionError({\n      reason,\n      from,\n      to,\n      method,\n      data,\n      network,\n      rpcUrl,\n      value,\n      hash,\n      contractName,\n      sources\n    }, error);\n  }\n}\nclass DeployTransaction extends TransactionContext {\n  constructor(options) {\n    super(options);\n    this.factory = options.factory;\n    this.events = options.events;\n  }\n  encode() {\n    return utils.hexlify(utils.concat([this.factory.bytecode, this.factory.interface.encodeDeploy(this.args)]));\n  }\n  getTarget() {\n    return constants.AddressZero;\n  }\n  getMethod() {\n    return \"deploy\";\n  }\n  async sign() {\n    const populatedTx = await this.populateTransaction();\n    return this.signer.signTransaction(populatedTx);\n  }\n  async simulate() {\n    const populatedTx = await this.populateTransaction();\n    return this.signer.call(populatedTx);\n  }\n  async estimateGasLimit() {\n    try {\n      const gasOverrides = await this.getGasOverrides();\n      const overrides = {\n        ...gasOverrides,\n        ...this.overrides\n      };\n      const populatedTx = this.factory.getDeployTransaction(...this.args, overrides);\n      return this.signer.estimateGas(populatedTx);\n    } catch (err) {\n      // No need to do simulation here, since there can't be revert errors\n      throw await this.deployError(err);\n    }\n  }\n  async send() {\n    try {\n      const populatedTx = await this.populateTransaction();\n      return await this.signer.sendTransaction(populatedTx);\n    } catch (err) {\n      throw await this.deployError(err);\n    }\n  }\n  async execute() {\n    const tx = await this.send();\n    try {\n      await tx.wait();\n    } catch (err) {\n      // If tx.wait() fails, it just gives us a generic \"transaction failed\"\n      // error. So instead, we need to call static to get an informative error message\n      await this.simulate();\n\n      // If transaction simulation (static call) doesn't throw, then throw with the message that we have\n      throw await this.deployError(err);\n    }\n    const contractAddress = utils.getContractAddress({\n      from: tx.from,\n      nonce: tx.nonce\n    });\n\n    // TODO: Remove when we delete events from deploy\n    if (this.events) {\n      this.events.emit(\"contractDeployed\", {\n        status: \"completed\",\n        contractAddress,\n        transactionHash: tx.hash\n      });\n    }\n    return contractAddress;\n  }\n  async populateTransaction() {\n    const gasOverrides = await this.getGasOverrides();\n    const overrides = {\n      ...gasOverrides,\n      ...this.overrides\n    };\n\n    // First, if no gasLimit is passed, call estimate gas ourselves\n    if (!overrides.gasLimit) {\n      overrides.gasLimit = await this.estimateGasLimit();\n    }\n    return this.factory.getDeployTransaction(...this.args, overrides);\n  }\n\n  /**\n   * Create a nicely formatted error message with tx metadata and solidity stack trace\n   */\n  async deployError(error) {\n    const provider = this.provider;\n\n    // Get metadata for transaction to populate into error\n    const [network, from] = await Promise.all([provider.getNetwork(), this.overrides.from || this.getSignerAddress()]);\n    const data = this.encode();\n    const value = BigNumber.from(this.overrides.value || 0);\n    const rpcUrl = provider.connection?.url;\n    const methodArgs = this.args.map(arg => {\n      if (JSON.stringify(arg).length <= 80) {\n        return JSON.stringify(arg);\n      }\n      return JSON.stringify(arg, undefined, 2);\n    });\n    const joinedArgs = methodArgs.join(\", \").length <= 80 ? methodArgs.join(\", \") : \"\\n\" + methodArgs.map(arg => \"  \" + arg.split(\"\\n\").join(\"\\n  \")).join(\",\\n\") + \"\\n\";\n    const method = `deployContract(${joinedArgs})`;\n    const hash = error.transactionHash || error.transaction?.hash || error.receipt?.transactionHash;\n\n    // Parse the revert reason from the error\n    const reason = parseRevertReason(error);\n    return new TransactionError({\n      reason,\n      from,\n      method,\n      data,\n      network,\n      rpcUrl,\n      value,\n      hash\n    }, error);\n  }\n}\nasync function defaultGaslessSendFunction(transaction, signer, provider, storage, gaslessOptions) {\n  if (gaslessOptions && \"biconomy\" in gaslessOptions) {\n    return biconomySendFunction(transaction, signer, provider, gaslessOptions);\n  }\n  return defenderSendFunction(transaction, signer, provider, storage, gaslessOptions);\n}\nasync function biconomySendFunction(transaction, signer, provider, gaslessOptions) {\n  const request = await biconomyPrepareRequest(transaction, signer, provider, gaslessOptions);\n  const response = await fetch(\"https://api.biconomy.io/api/v2/meta-tx/native\", request);\n  if (response.ok) {\n    const resp = await response.json();\n    if (!resp.txHash) {\n      throw new Error(`relay transaction failed: ${resp.log}`);\n    }\n    return resp.txHash;\n  }\n  throw new Error(`relay transaction failed with status: ${response.status} (${response.statusText})`);\n}\nasync function defenderSendFunction(transaction, signer, provider, storage, gaslessOptions) {\n  invariant(gaslessOptions && \"openzeppelin\" in gaslessOptions, \"calling openzeppelin gasless transaction without openzeppelin config in the SDK options\");\n  const request = await defenderPrepareRequest(transaction, signer, provider, storage, gaslessOptions);\n  const response = await fetch(gaslessOptions.openzeppelin.relayerUrl, request);\n  if (response.ok) {\n    const resp = await response.json();\n    if (!resp.result) {\n      throw new Error(`Relay transaction failed: ${resp.message}`);\n    }\n    const result = JSON.parse(resp.result);\n    return result.txHash;\n  }\n  throw new Error(`relay transaction failed with status: ${response.status} (${response.statusText})`);\n}\nasync function defenderPrepareRequest(transaction, signer, provider, storage, gaslessOptions) {\n  invariant(gaslessOptions && \"openzeppelin\" in gaslessOptions, \"calling openzeppelin gasless transaction without openzeppelin config in the SDK options\");\n  invariant(signer, \"provider is not set\");\n  invariant(provider, \"provider is not set\");\n  const forwarderAddress = gaslessOptions.openzeppelin.relayerForwarderAddress || (gaslessOptions.openzeppelin.useEOAForwarder ? CONTRACT_ADDRESSES[transaction.chainId].openzeppelinForwarderEOA || (await computeEOAForwarderAddress(provider, storage)) : CONTRACT_ADDRESSES[transaction.chainId].openzeppelinForwarder || (await computeForwarderAddress(provider, storage)));\n  const forwarder = new Contract(forwarderAddress, ForwarderABI, provider);\n  const nonce = await getAndIncrementNonce(forwarder, \"getNonce\", [transaction.from]);\n  let domain;\n  let types;\n  let message;\n  if (gaslessOptions.experimentalChainlessSupport) {\n    domain = {\n      name: \"GSNv2 Forwarder\",\n      version: \"0.0.1\",\n      verifyingContract: forwarderAddress\n    };\n    types = {\n      ForwardRequest: ChainAwareForwardRequest\n    };\n    message = {\n      from: transaction.from,\n      to: transaction.to,\n      value: BigNumber.from(0).toString(),\n      gas: BigNumber.from(transaction.gasLimit).toString(),\n      nonce: BigNumber.from(nonce).toString(),\n      data: transaction.data,\n      chainid: BigNumber.from(transaction.chainId).toString()\n    };\n  } else {\n    domain = {\n      name: gaslessOptions.openzeppelin.domainName,\n      version: gaslessOptions.openzeppelin.domainVersion,\n      chainId: transaction.chainId,\n      verifyingContract: forwarderAddress\n    };\n    types = {\n      ForwardRequest\n    };\n    message = {\n      from: transaction.from,\n      to: transaction.to,\n      value: BigNumber.from(0).toString(),\n      gas: BigNumber.from(transaction.gasLimit).toString(),\n      nonce: BigNumber.from(nonce).toString(),\n      data: transaction.data\n    };\n  }\n  let signature;\n\n  // if the executing function is \"approve\" and matches with erc20 approve signature\n  // and if the token supports permit, then we use permit for gasless instead of approve.\n  if (transaction.functionName === \"approve\" && transaction.functionArgs.length === 2) {\n    const spender = transaction.functionArgs[0];\n    const amount = transaction.functionArgs[1];\n    // TODO: support DAI permit by signDAIPermit\n    const {\n      message: permit,\n      signature: sig\n    } = await signEIP2612Permit(signer, transaction.to, transaction.from, spender, amount);\n    const {\n      r,\n      s,\n      v\n    } = utils.splitSignature(sig);\n    message = {\n      to: transaction.to,\n      owner: permit.owner,\n      spender: permit.spender,\n      value: BigNumber.from(permit.value).toString(),\n      nonce: BigNumber.from(permit.nonce).toString(),\n      deadline: BigNumber.from(permit.deadline).toString(),\n      r,\n      s,\n      v\n    };\n    signature = sig;\n  } else {\n    const {\n      signature: sig\n    } = await signTypedDataInternal(signer, domain, types, message);\n    signature = sig;\n  }\n  let messageType = \"forward\";\n\n  // if has owner property then it's permit :)\n  if (message?.owner) {\n    messageType = \"permit\";\n  }\n  return {\n    method: \"POST\",\n    body: JSON.stringify({\n      request: message,\n      signature,\n      forwarderAddress,\n      type: messageType\n    })\n  };\n}\nasync function prepareGaslessRequest(tx) {\n  const gaslessTx = await tx.prepareGasless();\n  const gaslessOptions = tx.getGaslessOptions();\n  if (gaslessOptions && \"biconomy\" in gaslessOptions) {\n    const request = await biconomyPrepareRequest(gaslessTx, tx.getSigner, tx.getProvider, gaslessOptions);\n    return {\n      url: \"https://api.biconomy.io/api/v2/meta-tx/native\",\n      ...request\n    };\n  } else {\n    invariant(gaslessOptions && \"openzeppelin\" in gaslessOptions, \"calling openzeppelin gasless transaction without openzeppelin config in the SDK options\");\n    const request = await defenderPrepareRequest(gaslessTx, tx.getSigner, tx.getProvider, tx.getStorage, gaslessOptions);\n    return {\n      url: gaslessOptions.openzeppelin.relayerUrl,\n      ...request\n    };\n  }\n}\nasync function biconomyPrepareRequest(transaction, signer, provider, gaslessOptions) {\n  invariant(gaslessOptions && \"biconomy\" in gaslessOptions, \"calling biconomySendFunction without biconomy\");\n  invariant(signer && provider, \"signer and provider must be set\");\n  const forwarder = new Contract(getContractAddressByChainId(transaction.chainId, \"biconomyForwarder\"), BiconomyForwarderAbi, provider);\n  const batchId = 0;\n  const batchNonce = await getAndIncrementNonce(forwarder, \"getNonce\", [transaction.from, batchId]);\n  const request = {\n    from: transaction.from,\n    to: transaction.to,\n    token: constants.AddressZero,\n    txGas: transaction.gasLimit.toNumber(),\n    tokenGasPrice: \"0\",\n    batchId,\n    batchNonce: batchNonce.toNumber(),\n    deadline: Math.floor(Date.now() / 1000 + (gaslessOptions && \"biconomy\" in gaslessOptions && gaslessOptions.biconomy?.deadlineSeconds || 3600)),\n    data: transaction.data\n  };\n  const hashToSign = utils.arrayify(utils.solidityKeccak256([\"address\", \"address\", \"address\", \"uint256\", \"uint256\", \"uint256\", \"uint256\", \"uint256\", \"bytes32\"], [request.from, request.to, request.token, request.txGas, request.tokenGasPrice, request.batchId, request.batchNonce, request.deadline, utils.keccak256(request.data)]));\n  const signature = await signer.signMessage(hashToSign);\n  return {\n    method: \"POST\",\n    body: JSON.stringify({\n      from: transaction.from,\n      apiId: gaslessOptions.biconomy.apiId,\n      params: [request, signature],\n      to: transaction.to,\n      gasLimit: transaction.gasLimit.toHexString()\n    }),\n    headers: {\n      \"x-api-key\": gaslessOptions.biconomy.apiKey,\n      \"Content-Type\": \"application/json;charset=utf-8\"\n    }\n  };\n}\n\n/**\n * @internal\n */\n\n/**\n * Handles metadata for a Contract\n * @remarks Read and update metadata for this contract\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * const metadata = await contract.metadata.get();\n * await contract.metadata.set({\n *   name: \"My Contract\",\n *   description: \"My contract description\"\n * })\n * ```\n * @public\n */\nclass ContractMetadata {\n  featureName = FEATURE_METADATA.name;\n  constructor(contractWrapper, schema, storage) {\n    this.contractWrapper = contractWrapper;\n    this.schema = schema;\n    this.storage = storage;\n  }\n  /**\n   * @internal\n   */\n  parseOutputMetadata(metadata) {\n    return this.schema.output.parseAsync(metadata);\n  }\n\n  /**\n   * @internal\n   */\n  parseInputMetadata(metadata) {\n    return this.schema.input.parseAsync(metadata);\n  }\n  /**\n   * Get the metadata of this contract\n   * @remarks Get the metadata of a contract\n   * @example\n   * ```javascript\n   * const metadata = await contract.metadata.get();\n   * console.log(metadata);\n   * ```\n   * @public\n   * @returns the metadata of the given contract\n   * @twfeature ContractMetadata\n   */\n  async get() {\n    let data;\n    if (this.supportsContractMetadata(this.contractWrapper)) {\n      const uri = await this.contractWrapper.read(\"contractURI\", []);\n      if (uri && uri.includes(\"://\")) {\n        data = await this.storage.downloadJSON(uri);\n      }\n    }\n    if (!data) {\n      try {\n        // try fetching metadata from bytecode and / or contract itself\n        let contractName;\n        try {\n          if (hasFunction(\"name\", this.contractWrapper)) {\n            contractName = await this.contractWrapper.read(\"name\", []);\n          }\n        } catch (err) {\n          // no-op\n        }\n        let contractSymbol;\n        try {\n          if (hasFunction(\"symbol\", this.contractWrapper)) {\n            contractSymbol = await this.contractWrapper.read(\"symbol\", []);\n          }\n        } catch (err) {\n          // no-op\n        }\n        let publishedMetadata;\n        try {\n          publishedMetadata = await fetchContractMetadataFromAddress(this.contractWrapper.address, this.contractWrapper.getProvider(), this.storage, this.contractWrapper.options);\n        } catch (err) {}\n        data = {\n          name: contractName || publishedMetadata?.name,\n          symbol: contractSymbol,\n          description: publishedMetadata?.info.title\n        };\n      } catch (e) {\n        throw new Error(\"Could not fetch contract metadata\");\n      }\n    }\n    return this.parseOutputMetadata(data);\n  }\n\n  /**\n   * Set the metadata of this contract\n   * @remarks OVERWRITE the metadata of a contract\n   * @example\n   * ```javascript\n   * await contract.metadata.set({\n   *   name: \"My Contract\",\n   *   description: \"My contract description\"\n   * })\n   * ```\n   * @public\n   * @param metadata - the metadata to set\n   * @twfeature ContractMetadata\n   */\n  set = /* @__PURE__ */buildTransactionFunction(async metadata => {\n    const uri = await this._parseAndUploadMetadata(metadata);\n    const wrapper = this.contractWrapper;\n    if (this.supportsContractMetadata(wrapper)) {\n      return Transaction.fromContractWrapper({\n        contractWrapper: this.contractWrapper,\n        method: \"setContractURI\",\n        args: [uri],\n        parse: receipt => {\n          return {\n            receipt,\n            data: this.get\n          };\n        }\n      });\n    } else {\n      throw new ExtensionNotImplementedError(FEATURE_METADATA);\n    }\n  });\n\n  /**\n   * Update the metadata of a contract\n   * @remarks Update the metadata of a contract\n   * @example\n   * ```javascript\n   * await contract.metadata.update({\n   *   description: \"My new contract description\"\n   * })\n   * ```\n   * @public\n   * @param metadata - the metadata to update\n   * @twfeature ContractMetadata\n   * */\n  update = /* @__PURE__ */buildTransactionFunction(async metadata => {\n    return await this.set.prepare({\n      ...(await this.get()),\n      ...metadata\n    });\n  });\n\n  /**\n   *\n   * @internal\n   * @param metadata - the metadata to set\n   * @returns\n   */\n  async _parseAndUploadMetadata(metadata) {\n    const parsedMetadata = await this.parseInputMetadata(metadata);\n    return this.storage.upload(parsedMetadata);\n  }\n  supportsContractMetadata(contractWrapper) {\n    return detectContractFeature(contractWrapper, \"ContractMetadata\");\n  }\n}\n\n/**\n *\n * @internal\n */\nconst roleMap = {\n  admin: \"\",\n  transfer: \"TRANSFER_ROLE\",\n  minter: \"MINTER_ROLE\",\n  pauser: \"PAUSER_ROLE\",\n  lister: \"LISTER_ROLE\",\n  asset: \"ASSET_ROLE\",\n  unwrap: \"UNWRAP_ROLE\",\n  factory: \"FACTORY_ROLE\",\n  signer: \"SIGNER_ROLE\"\n};\n\n/**\n * @public\n */\n\n/**\n * @public\n */\nconst ALL_ROLES = /* @__PURE__ */Object.keys(roleMap);\n\n/**\n * @internal\n */\nfunction getRoleHash(role) {\n  if (role === \"admin\") {\n    return utils.hexZeroPad([0], 32);\n  }\n  return utils.id(roleMap[role]);\n}\n\n/**\n * Handle contract permissions\n * @remarks Configure roles and permissions for a contract, to restrict certain actions.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * const rolesAndMembers = await contract.roles.getAll();\n * await contract.roles.grantRole(\"admin\", \"0x...\");\n * ```\n * @public\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars -- TO BE REMOVED IN V4\nclass ContractRoles {\n  featureName = FEATURE_PERMISSIONS.name;\n\n  /**\n   * @internal\n   * @remarks This is used for typing inside react hooks which is why it has to be public.\n   */\n\n  constructor(contractWrapper, roles) {\n    this.contractWrapper = contractWrapper;\n    this.roles = roles;\n  }\n\n  /** **************************\n   * READ FUNCTIONS\n   ****************************/\n\n  /**\n   * Get all members of all roles\n   * @remarks See {@link ContractRoles.get} to get a list of addresses that are members of a specific role.\n   * @example\n   * ```javascript\n   * const rolesAndMembers = await contract.roles.getAll();\n   * ```\n   * @returns A record of {@link Role}s to lists of addresses that are members of the given role.\n   * @throws If the contract does not support roles this will throw an error.\n   *\n   * @public\n   * @twfeature PermissionsEnumerable\n   */\n  async getAll() {\n    invariant(this.roles.length, \"this contract has no support for roles\");\n    const roles = {};\n    for (const role of this.roles) {\n      roles[role] = await this.get(role);\n    }\n    return roles;\n  }\n\n  /**\n   * Get all members of a specific role\n   * @remarks See {@link ContractRoles.getAll} to get get a list of addresses for all supported roles on the contract.\n   * @param role - The Role to to get a memberlist for.\n   * @returns The list of addresses that are members of the specific role.\n   * @throws If you are requesting a role that does not exist on the contract this will throw an error.\n   *\n   * @example Say you want to get the list of addresses that are members of the minter role.\n   * ```javascript\n   * const minterAddresses = await contract.roles.get(\"minter\");\n   * ```\n   *\n   * @public\n   * @twfeature Permissions\n   */\n  async get(role) {\n    invariant(this.roles.includes(role), `this contract does not support the \"${role}\" role`);\n    const wrapper = this.contractWrapper;\n    if (hasFunction(\"getRoleMemberCount\", wrapper) && hasFunction(\"getRoleMember\", wrapper)) {\n      const roleHash = getRoleHash(role);\n      const count = (await wrapper.read(\"getRoleMemberCount\", [roleHash])).toNumber();\n      return await Promise.all(Array.from(Array(count).keys()).map(i => wrapper.read(\"getRoleMember\", [roleHash, i])));\n    }\n    throw new Error(\"Contract does not support enumerating roles. Please implement IPermissionsEnumerable to unlock this functionality.\");\n  }\n\n  /**\n   * Overwrite the list of members for specific roles\n   *\n   * @remarks Every role in the list will be overwritten with the new list of addresses provided with them.\n   * If you want to add or remove addresses for a single address use {@link ContractRoles.grant} and {@link ContractRoles.revoke} respectively instead.\n   * @param rolesWithAddresses - A record of {@link Role}s to lists of addresses that should be members of the given role.\n   * @throws If you are requesting a role that does not exist on the contract this will throw an error.\n   * @example Say you want to overwrite the list of addresses that are members of the minter role.\n   * ```javascript\n   * const minterAddresses = await contract.roles.get(\"minter\");\n   * await contract.roles.setAll({\n   *  minter: []\n   * });\n   * console.log(await contract.roles.get(\"minter\")); // No matter what members had the role before, the new list will be set to []\n   * ```\n   * @public\n   * @twfeature Permissions\n   *\n   * */\n  setAll = /* @__PURE__ */buildTransactionFunction(async rolesWithAddresses => {\n    const contractEncoder = new ContractEncoder(this.contractWrapper);\n    const roles = Object.keys(rolesWithAddresses);\n    invariant(roles.length, \"you must provide at least one role to set\");\n    invariant(roles.every(role => this.roles.includes(role)), \"this contract does not support the given role\");\n    const currentRoles = await this.getAll();\n    const encoded = [];\n    // add / remove admin role at the end so we don't revoke admin then grant\n    const sortedRoles = roles.sort(role => role === \"admin\" ? 1 : -1);\n    for (let i = 0; i < sortedRoles.length; i++) {\n      const role = sortedRoles[i];\n      const addresses = await Promise.all(rolesWithAddresses[role]?.map(async addressOrEns => await resolveAddress(addressOrEns)) || []);\n      const currentAddresses = await Promise.all(currentRoles[role]?.map(async addressOrEns => await resolveAddress(addressOrEns)) || []);\n      const toAdd = addresses.filter(address => !currentAddresses.includes(address));\n      const toRemove = currentAddresses.filter(address => !addresses.includes(address));\n      if (toAdd.length) {\n        toAdd.forEach(address => {\n          encoded.push(contractEncoder.encode(\"grantRole\", [getRoleHash(role), address]));\n        });\n      }\n      if (toRemove.length) {\n        for (let j = 0; j < toRemove.length; j++) {\n          const address = toRemove[j];\n          const revokeFunctionName = await this.getRevokeRoleFunctionName(address);\n          encoded.push(contractEncoder.encode(revokeFunctionName, [getRoleHash(role), address]));\n        }\n      }\n    }\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"multicall\",\n      args: [encoded]\n    });\n  });\n\n  /**\n   * Throws an error if an address is missing the roles specified.\n   *\n   * @param roles - The roles to check\n   * @param address - The address to check\n   *\n   * @internal\n   */\n  async verify(roles, address) {\n    await Promise.all(roles.map(async role => {\n      const members = await this.get(role);\n      const resolvedAddress = await resolveAddress(address);\n      if (!members.map(a => a.toLowerCase()).includes(resolvedAddress.toLowerCase())) {\n        throw new MissingRoleError(resolvedAddress, role);\n      }\n    }));\n  }\n\n  /** **************************\n   * WRITE FUNCTIONS\n   ****************************/\n\n  /**\n   * Grant a role to a specific address\n   *\n   * @remarks Make sure you are sure you want to grant the role to the address.\n   *\n   * @example\n   * ```javascript\n   * await contract.roles.grant(\"minter\", \"{{wallet_address}}\");\n   * ```\n   *\n   * @param role - The {@link Role} to grant to the address\n   * @param address - The address to grant the role to\n   * @returns The transaction receipt\n   * @throws If you are trying to grant does not exist on the contract this will throw an error.\n   *\n   * @public\n   * @twfeature Permissions\n   */\n  grant = /* @__PURE__ */buildTransactionFunction(async (role, address) => {\n    invariant(this.roles.includes(role), `this contract does not support the \"${role}\" role`);\n    const resolvedAddress = await resolveAddress(address);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"grantRole\",\n      args: [getRoleHash(role), resolvedAddress]\n    });\n  });\n\n  /**\n   * Revoke a role from a specific address\n   *\n   * @remarks\n   *\n   * -- Caution --\n   *\n   * This will let you remove yourself from the role, too.\n   * If you remove yourself from the admin role, you will no longer be able to administer the contract.\n   * There is no way to recover from this.\n   *\n   * @example\n   * ```javascript\n   * await contract.roles.revoke(\"minter\", \"{{wallet_address}}\");\n   * ```\n   *\n   * @param role - The {@link Role} to revoke\n   * @param address - The address to revoke the role from\n   * @returns The transaction receipt\n   * @throws If you are trying to revoke does not exist on the module this will throw an error.\n   *\n   * @public\n   * @twfeature Permissions\n   */\n  revoke = /* @__PURE__ */buildTransactionFunction(async (role, address) => {\n    invariant(this.roles.includes(role), `this contract does not support the \"${role}\" role`);\n    const resolvedAddress = await resolveAddress(address);\n    const revokeFunctionName = await this.getRevokeRoleFunctionName(resolvedAddress);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: revokeFunctionName,\n      args: [getRoleHash(role), resolvedAddress]\n    });\n  });\n\n  /** **************************\n   * PRIVATE FUNCTIONS\n   ****************************/\n\n  async getRevokeRoleFunctionName(address) {\n    const resolvedAddress = await resolveAddress(address);\n    const signerAddress = await this.contractWrapper.getSignerAddress();\n    if (signerAddress.toLowerCase() === resolvedAddress.toLowerCase()) {\n      return \"renounceRole\";\n    }\n    return \"revokeRole\";\n  }\n}\n\n/**\n * Handle contract royalties\n * @remarks Configure royalties for an entire contract or a particular token.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * const royaltyInfo = await contract.royalties.getDefaultRoyaltyInfo();\n * await contract.roles.setTokenRoyaltyInfo(tokenId, {\n *   seller_fee_basis_points: 100, // 1% royalty fee\n *   fee_recipient: \"0x...\", // the fee recipient\n * });\n * ```\n * @public\n */\nclass ContractRoyalty {\n  featureName = FEATURE_ROYALTY.name;\n  constructor(contractWrapper, metadata) {\n    this.contractWrapper = contractWrapper;\n    this.metadata = metadata;\n  }\n\n  /**\n   * Get the royalty recipient and fee\n   * @returns - The royalty recipient and BPS\n   * @example\n   * ```javascript\n   * const royaltyInfo = await contract.royalties.getDefaultRoyaltyInfo();\n   * console.log(royaltyInfo.fee_recipient);\n   * console.log(royaltyInfo.seller_fee_basis_points);\n   * ```\n   * @public\n   * @twfeature Royalty\n   */\n  async getDefaultRoyaltyInfo() {\n    const [royaltyRecipient, royaltyBps] = await this.contractWrapper.read(\"getDefaultRoyaltyInfo\", []);\n    // parse it on the way out to make sure we default things if they are not set\n    return CommonRoyaltySchema.parseAsync({\n      fee_recipient: royaltyRecipient,\n      seller_fee_basis_points: royaltyBps\n    });\n  }\n\n  /**\n   * Get the royalty recipient and fee of a particular token\n   * @returns - The royalty recipient and BPS\n   * @example\n   * ```javascript\n   * const royaltyInfo = await contract.royalties.getDefaultRoyaltyInfo();\n   * console.log(royaltyInfo.fee_recipient);\n   * console.log(royaltyInfo.seller_fee_basis_points);\n   * ```\n   * @public\n   * @twfeature Royalty\n   */\n  async getTokenRoyaltyInfo(tokenId) {\n    const [royaltyRecipient, royaltyBps] = await this.contractWrapper.read(\"getRoyaltyInfoForToken\", [tokenId]);\n    return CommonRoyaltySchema.parseAsync({\n      fee_recipient: royaltyRecipient,\n      seller_fee_basis_points: royaltyBps\n    });\n  }\n\n  /**\n   * Set the royalty recipient and fee\n   * @param royaltyData - the royalty recipient and fee\n   *  @example\n   * ```javascript\n   * await contract.roles.setDefaultRoyaltyInfo({\n   *   seller_fee_basis_points: 100, // 1% royalty fee\n   *   fee_recipient: \"0x...\", // the fee recipient\n   * });\n   * ```\n   * @public\n   * @twfeature Royalty\n   */\n  setDefaultRoyaltyInfo = /* @__PURE__ */buildTransactionFunction(async royaltyData => {\n    // read the metadata from the contract\n    const oldMetadata = await this.metadata.get();\n\n    // update the metadata with the new royalty data\n    // if one of the keys is \"undefined\" it will be ignored (which is the desired behavior)\n    const mergedMetadata = await this.metadata.parseInputMetadata({\n      ...oldMetadata,\n      ...royaltyData\n    });\n\n    // why not use this.metadata.set()? - because that would end up sending it's own separate transaction to `setContractURI`\n    // but we want to send both the `setRoyaltyInfo` and `setContractURI` in one transaction!\n    const contractURI = await this.metadata._parseAndUploadMetadata(mergedMetadata);\n    if (hasFunction(\"setContractURI\", this.contractWrapper)) {\n      const contractEncoder = new ContractEncoder(this.contractWrapper);\n      // encode both the functions we want to send\n      const encoded = [contractEncoder.encode(\"setDefaultRoyaltyInfo\", [mergedMetadata.fee_recipient, mergedMetadata.seller_fee_basis_points]), contractEncoder.encode(\"setContractURI\", [contractURI])];\n      // actually send the transaction and return the receipt + a way to get the new royalty info\n\n      return Transaction.fromContractWrapper({\n        contractWrapper: this.contractWrapper,\n        method: \"multicall\",\n        args: [encoded],\n        parse: receipt => ({\n          receipt,\n          data: () => this.getDefaultRoyaltyInfo()\n        })\n      });\n    } else {\n      throw new Error(\"Updating royalties requires implementing ContractMetadata in your contract to support marketplaces like OpenSea.\");\n    }\n  });\n\n  /**\n   * Set the royalty recipient and fee for a particular token\n   * @param tokenId - the token id\n   * @param royaltyData - the royalty recipient and fee\n   * @example\n   * ```javascript\n   * const tokenId = 0;\n   * await contract.roles.setTokenRoyaltyInfo(tokenId, {\n   *   seller_fee_basis_points: 100, // 1% royalty fee\n   *   fee_recipient: \"0x...\", // the fee recipient\n   * });\n   * ```\n   * @public\n   * @twfeature Royalty\n   */\n  setTokenRoyaltyInfo = /* @__PURE__ */buildTransactionFunction(async (tokenId, royaltyData) => {\n    const parsedRoyaltyData = CommonRoyaltySchema.parse(royaltyData);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"setRoyaltyInfoForToken\",\n      args: [tokenId, parsedRoyaltyData.fee_recipient, parsedRoyaltyData.seller_fee_basis_points],\n      parse: receipt => ({\n        receipt,\n        data: () => this.getDefaultRoyaltyInfo()\n      })\n    });\n  });\n}\n\n/**\n * Handle primary sales recipients\n * @remarks Configure primary sale recipients for an entire contract.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * const salesRecipient = await contract.sales.getRecipient();\n * await contract.sales.setRecipient(recipientWalletAddress);\n * ```\n * @public\n */\nclass ContractPrimarySale {\n  featureName = FEATURE_PRIMARY_SALE.name;\n  constructor(contractWrapper) {\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * Get the primary sale recipient\n   * @returns the wallet address.\n   * @example\n   * ```javascript\n   * const salesRecipient = await contract.sales.getRecipient();\n   * ```\n   * @public\n   * @twfeature PrimarySale\n   */\n  async getRecipient() {\n    const result = await this.contractWrapper.read(\"primarySaleRecipient\", []);\n    return result;\n  }\n\n  /**\n   * Set the primary sale recipient\n   * @param recipient - the wallet address\n   * @example\n   * ```javascript\n   * await contract.sales.setRecipient(recipientWalletAddress);\n   * ```\n   * @public\n   * @twfeature PrimarySale\n   */\n  setRecipient = /* @__PURE__ */buildTransactionFunction(async recipient => {\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"setPrimarySaleRecipient\",\n      args: [recipient]\n    });\n  });\n}\nconst FALLBACK_METADATA = {\n  name: \"Failed to load NFT metadata\"\n};\n\n/**\n * fetches the token metadata\n * @param tokenId - the id (to get it back in the output)\n * @param tokenUri - the uri to fetch\n * @param storage - which storage to fetch from\n *\n * @internal\n */\nasync function fetchTokenMetadata(tokenId, tokenUri, storage) {\n  // check for base64 encoded JSON\n  if (tokenUri.startsWith(\"data:application/json;base64\") && typeof Buffer !== \"undefined\") {\n    const base64 = tokenUri.split(\",\")[1];\n    const jsonMetadata = JSON.parse(Buffer.from(base64, \"base64\").toString(\"utf-8\"));\n    return CommonNFTOutput.parse({\n      ...jsonMetadata,\n      id: BigNumber.from(tokenId).toString(),\n      uri: tokenUri\n    });\n  }\n  // handle dynamic id URIs (2 possible formats)\n  const parsedUri = tokenUri.replace(\"{id}\", utils.hexZeroPad(BigNumber.from(tokenId).toHexString(), 32).slice(2));\n  let jsonMetadata;\n  try {\n    jsonMetadata = await storage.downloadJSON(parsedUri);\n  } catch (err) {\n    const unparsedTokenIdUri = tokenUri.replace(\"{id}\", BigNumber.from(tokenId).toString());\n    try {\n      jsonMetadata = await storage.downloadJSON(unparsedTokenIdUri);\n    } catch (e) {\n      console.warn(`failed to get token metadata: ${JSON.stringify({\n        tokenId: tokenId.toString(),\n        tokenUri\n      })} -- falling back to default metadata`);\n      jsonMetadata = FALLBACK_METADATA;\n    }\n  }\n  return CommonNFTOutput.parse({\n    ...jsonMetadata,\n    id: BigNumber.from(tokenId).toString(),\n    uri: tokenUri\n  });\n}\n\n// Used for marketplace to fetch NFT metadata from contract address + tokenId\n/**\n * @internal\n * @param contractAddress\n * @param provider\n * @param tokenId\n * @param storage\n */\nasync function fetchTokenMetadataForContract(contractAddress, provider, tokenId, storage) {\n  let uri;\n  const erc165 = new Contract(contractAddress, ERC165Abi, provider);\n  const [isERC721, isERC1155] = await Promise.all([erc165.supportsInterface(InterfaceId_IERC721), erc165.supportsInterface(InterfaceId_IERC1155)]);\n  if (isERC721) {\n    const erc721 = new Contract(contractAddress, IERC721MetadataAbi, provider);\n    uri = await erc721.tokenURI(tokenId);\n  } else if (isERC1155) {\n    const erc1155 = new Contract(contractAddress, Erc1155MetadataAbi, provider);\n    uri = await erc1155.uri(tokenId);\n  } else {\n    throw Error(\"Contract must implement ERC 1155 or ERC 721.\");\n  }\n  if (!uri) {\n    // no uri found, return fallback metadata\n    return CommonNFTOutput.parse({\n      ...FALLBACK_METADATA,\n      id: BigNumber.from(tokenId).toString(),\n      uri: \"\"\n    });\n  }\n  return fetchTokenMetadata(tokenId, uri, storage);\n}\n\n/**\n * @internal\n * @param metadata\n * @param storage\n */\nasync function uploadOrExtractURI(metadata, storage) {\n  if (typeof metadata === \"string\") {\n    return metadata;\n  } else {\n    return await storage.upload(CommonNFTInput.parse(metadata));\n  }\n}\n\n/**\n * @internal\n * @param metadatas\n * @param storage\n * @param startNumber\n * @param contractAddress\n * @param signerAddress\n * @param options\n */\nasync function uploadOrExtractURIs(metadatas, storage, startNumber, options) {\n  if (isUriList(metadatas)) {\n    return metadatas;\n  } else if (isMetadataList(metadatas)) {\n    const uris = await storage.uploadBatch(metadatas.map(m => CommonNFTInput.parse(m)), {\n      rewriteFileNames: {\n        fileStartNumber: startNumber || 0\n      },\n      onProgress: options?.onProgress\n    });\n    return uris;\n  } else {\n    throw new Error(\"NFT metadatas must all be of the same type (all URI or all NFTMetadataInput)\");\n  }\n}\nfunction getBaseUriFromBatch(uris) {\n  const baseUri = uris[0].substring(0, uris[0].lastIndexOf(\"/\"));\n  for (let i = 0; i < uris.length; i++) {\n    const uri = uris[i].substring(0, uris[i].lastIndexOf(\"/\"));\n    if (baseUri !== uri) {\n      throw new Error(`Can only create batches with the same base URI for every entry in the batch. Expected '${baseUri}' but got '${uri}'`);\n    }\n  }\n\n  // Ensure that baseUri ends with trailing slash\n  return baseUri.replace(/\\/$/, \"\") + \"/\";\n}\nfunction isUriList(metadatas) {\n  return metadatas.find(m => typeof m !== \"string\") === undefined;\n}\nfunction isMetadataList(metadatas) {\n  return metadatas.find(m => typeof m !== \"object\") === undefined;\n}\n\n/**\n * Handles delayed reveal logic\n * @public\n */\nclass DelayedReveal {\n  constructor(contractWrapper, storage, featureName, nextTokenIdToMintFn) {\n    this.featureName = featureName;\n    this.nextTokenIdToMintFn = nextTokenIdToMintFn;\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n  }\n\n  /**\n   * Create a batch of encrypted NFTs that can be revealed at a later time.\n   * @remarks Create a batch of encrypted NFTs that can be revealed at a later time.\n   * @example\n   * ```javascript\n   * // the real NFTs, these will be encrypted until your reveal them!\n   * const realNFTs = [{\n   *   name: \"Common NFT #1\",\n   *   description: \"Common NFT, one of many.\",\n   *   image: fs.readFileSync(\"path/to/image.png\"),\n   * }, {\n   *   name: \"Super Rare NFT #2\",\n   *   description: \"You got a Super Rare NFT!\",\n   *   image: fs.readFileSync(\"path/to/image.png\"),\n   * }];\n   * // A placeholder NFT that people will get immediately in their wallet, until the reveal happens!\n   * const placeholderNFT = {\n   *   name: \"Hidden NFT\",\n   *   description: \"Will be revealed next week!\"\n   * };\n   * // Create and encrypt the NFTs\n   * await contract.revealer.createDelayedRevealBatch(\n   *   placeholderNFT,\n   *   realNFTs,\n   *   \"my secret password\",\n   * );\n   * ```\n   * @public\n   * @param placeholder - the placeholder NFT to show before the reveal\n   * @param metadatas - the final NFTs that will be hidden\n   * @param password - the password that will be used to reveal these NFTs\n   * @param options - additional options like upload progress\n   */\n  createDelayedRevealBatch = /* @__PURE__ */buildTransactionFunction(async (placeholder, metadatas, password, options) => {\n    if (!password) {\n      throw new Error(\"Password is required\");\n    }\n    const placeholderUris = await this.storage.uploadBatch([CommonNFTInput.parse(placeholder)], {\n      rewriteFileNames: {\n        fileStartNumber: 0\n      }\n    });\n    const placeholderUri = getBaseUriFromBatch(placeholderUris);\n    const startFileNumber = await this.nextTokenIdToMintFn();\n    const uris = await this.storage.uploadBatch(metadatas.map(m => CommonNFTInput.parse(m)), {\n      onProgress: options?.onProgress,\n      rewriteFileNames: {\n        fileStartNumber: startFileNumber.toNumber()\n      }\n    });\n    const baseUri = getBaseUriFromBatch(uris);\n    const baseUriId = await this.contractWrapper.read(\"getBaseURICount\", []);\n    const hashedPassword = await this.hashDelayRevealPassword(baseUriId, password);\n    const encryptedBaseUri = await this.contractWrapper.read(\"encryptDecrypt\", [utils.toUtf8Bytes(baseUri), hashedPassword]);\n    let data;\n    const legacyContract = await this.isLegacyContract();\n    if (legacyContract) {\n      data = encryptedBaseUri;\n    } else {\n      const chainId = await this.contractWrapper.getChainID();\n      const provenanceHash = utils.solidityKeccak256([\"bytes\", \"bytes\", \"uint256\"], [utils.toUtf8Bytes(baseUri), hashedPassword, chainId]);\n      data = utils.defaultAbiCoder.encode([\"bytes\", \"bytes32\"], [encryptedBaseUri, provenanceHash]);\n    }\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"lazyMint\",\n      args: [uris.length, placeholderUri.endsWith(\"/\") ? placeholderUri : `${placeholderUri}/`, data],\n      parse: receipt => {\n        const events = this.contractWrapper.parseLogs(\"TokensLazyMinted\", receipt?.logs);\n        const startingIndex = events[0].args.startTokenId;\n        const endingIndex = events[0].args.endTokenId;\n        const results = [];\n        for (let id = startingIndex; id.lte(endingIndex); id = id.add(1)) {\n          results.push({\n            id,\n            receipt\n          });\n        }\n        return results;\n      }\n    });\n  });\n\n  /**\n   * Reveal a batch of hidden NFTs\n   * @remarks Reveal the NFTs of a batch using the password.\n   * @example\n   * ```javascript\n   * // the batch to reveal\n   * const batchId = 0;\n   * // reveal the batch\n   * await contract.revealer.reveal(batchId, \"my secret password\");\n   * ```\n   * @public\n   * @param batchId - the id of the batch to reveal\n   * @param password - the password\n   */\n  reveal = /* @__PURE__ */buildTransactionFunction(async (batchId, password) => {\n    if (!password) {\n      throw new Error(\"Password is required\");\n    }\n    const key = await this.hashDelayRevealPassword(batchId, password);\n    // performing the reveal locally to make sure it'd succeed before sending the transaction\n    try {\n      const decryptedUri = await this.contractWrapper.callStatic().reveal(batchId, key);\n      // basic sanity check for making sure decryptedUri is valid\n      // this is optional because invalid decryption key would result in non-utf8 bytes and\n      // ethers would throw when trying to decode it\n      if (!decryptedUri.includes(\"://\") || !decryptedUri.endsWith(\"/\")) {\n        throw new Error(\"invalid password\");\n      }\n    } catch (e) {\n      throw new Error(\"invalid password\");\n    }\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"reveal\",\n      args: [batchId, key]\n    });\n  });\n\n  /**\n   * Gets the list of unrevealed NFT batches.\n   * @remarks Gets the list of unrevealed NFT batches.\n   * @example\n   * ```javascript\n   * const batches = await contract.revealer.getBatchesToReveal();\n   * ```\n   * @public\n   */\n  async getBatchesToReveal() {\n    const count = await this.contractWrapper.read(\"getBaseURICount\", []);\n    if (count.isZero()) {\n      return [];\n    }\n    const countRangeArray = Array.from(Array(count.toNumber()).keys());\n    // map over to get the base uri indices, which should be the end token id of every batch\n    const uriIndices = await Promise.all(countRangeArray.map(i => {\n      if (hasFunction(\"getBatchIdAtIndex\", this.contractWrapper)) {\n        return this.contractWrapper.read(\"getBatchIdAtIndex\", [i]);\n      }\n      if (hasFunction(\"baseURIIndices\", this.contractWrapper)) {\n        return this.contractWrapper.read(\"baseURIIndices\", [i]);\n      }\n      throw new Error(\"Contract does not have getBatchIdAtIndex or baseURIIndices.\");\n    }));\n\n    // first batch always start from 0. don't need to fetch the last batch so pop it from the range array\n    const uriIndicesWithZeroStart = uriIndices.slice(0, uriIndices.length - 1);\n\n    // returns the token uri for each batches. first batch always starts from token id 0.\n    const tokenMetadatas = await Promise.all(Array.from([0, ...uriIndicesWithZeroStart]).map(i => this.getNftMetadata(i.toString())));\n\n    // index is the uri indices, which is end token id. different from uris\n    const legacyContract = await this.isLegacyContract();\n    const encryptedUriData = await Promise.all(Array.from([...uriIndices]).map(i => legacyContract ? this.getLegacyEncryptedData(i) : this.contractWrapper.read(\"encryptedData\", [i])));\n    const encryptedBaseUris = encryptedUriData.map(data => {\n      if (utils.hexDataLength(data) > 0) {\n        if (legacyContract) {\n          return data;\n        }\n        const result = utils.defaultAbiCoder.decode([\"bytes\", \"bytes32\"], data);\n        return result[0];\n      } else {\n        return data;\n      }\n    });\n    return tokenMetadatas.map((meta, index) => ({\n      batchId: BigNumber.from(index),\n      batchUri: meta.uri,\n      placeholderMetadata: meta\n    })).filter((_, index) => utils.hexDataLength(encryptedBaseUris[index]) > 0);\n  }\n\n  /**\n   * Algorithm to hash delay reveal password, so we don't broadcast the input password on-chain.\n   *\n   * @internal\n   */\n  async hashDelayRevealPassword(batchTokenIndex, password) {\n    const chainId = await this.contractWrapper.getChainID();\n    const contractAddress = this.contractWrapper.address;\n    return utils.solidityKeccak256([\"string\", \"uint256\", \"uint256\", \"address\"], [password, chainId, batchTokenIndex, contractAddress]);\n  }\n  async getNftMetadata(tokenId) {\n    return fetchTokenMetadataForContract(this.contractWrapper.address, this.contractWrapper.getProvider(), tokenId, this.storage);\n  }\n  async isLegacyContract() {\n    if (hasFunction(\"contractVersion\", this.contractWrapper)) {\n      try {\n        const version = await this.contractWrapper.read(\"contractVersion\", []);\n        return version <= 2;\n      } catch (e) {\n        return false;\n      }\n    }\n    return false;\n  }\n  async getLegacyEncryptedData(index) {\n    const legacy = new Contract(this.contractWrapper.address, DeprecatedAbi, this.contractWrapper.getProvider());\n    const result = await legacy.functions[\"encryptedBaseURI\"](index);\n    if (result.length > 0) {\n      return result[0];\n    } else {\n      return \"0x\";\n    }\n  }\n}\nfunction abstractContractModelToLegacy(model) {\n  return {\n    startTimestamp: model.startTimestamp,\n    maxClaimableSupply: model.maxClaimableSupply,\n    supplyClaimed: model.supplyClaimed,\n    merkleRoot: model.merkleRoot,\n    pricePerToken: model.pricePerToken,\n    currency: model.currency,\n    quantityLimitPerTransaction: model.maxClaimablePerWallet,\n    waitTimeInSecondsBetweenClaims: model.waitTimeInSecondsBetweenClaims || 0\n  };\n}\nfunction abstractContractModelToNew(model) {\n  return {\n    startTimestamp: model.startTimestamp,\n    maxClaimableSupply: model.maxClaimableSupply,\n    supplyClaimed: model.supplyClaimed,\n    merkleRoot: model.merkleRoot,\n    pricePerToken: model.pricePerToken,\n    currency: model.currency,\n    quantityLimitPerWallet: model.maxClaimablePerWallet,\n    metadata: model.metadata || \"\"\n  };\n}\n\n/**\n * @internal\n * @param quantity\n * @param tokenDecimals\n */\nfunction convertQuantityToBigNumber(quantity, tokenDecimals) {\n  if (quantity === \"unlimited\") {\n    return constants.MaxUint256;\n  } else {\n    return utils.parseUnits(quantity, tokenDecimals);\n  }\n}\nfunction isNativeToken(tokenAddress) {\n  return tokenAddress.toLowerCase() === NATIVE_TOKEN_ADDRESS || tokenAddress.toLowerCase() === constants.AddressZero;\n}\n\n/**\n *\n * @param provider\n * @param asset\n * @returns\n * @internal\n */\nasync function fetchCurrencyMetadata(provider, asset) {\n  if (isNativeToken(asset)) {\n    const network = await provider.getNetwork();\n    const nativeToken = getNativeTokenByChainId(network.chainId);\n    return {\n      name: nativeToken.name,\n      symbol: nativeToken.symbol,\n      decimals: nativeToken.decimals\n    };\n  } else {\n    const erc20 = new Contract(asset, IERC20MetadataAbi, provider);\n    const [name, symbol, decimals] = await Promise.all([erc20.name(), erc20.symbol(), erc20.decimals()]);\n    return {\n      name,\n      symbol,\n      decimals\n    };\n  }\n}\nasync function parseSnapshotInputs(inputs) {\n  const chunkSize = 25000;\n  const chunks = Array.from({\n    length: Math.ceil(inputs.length / chunkSize)\n  }, (_, i) => inputs.slice(i * chunkSize, i * chunkSize + chunkSize));\n  const results = [];\n  for (const chunk of chunks) {\n    results.push(...(await SnapshotInputSchema.parseAsync(chunk)));\n  }\n  return results;\n}\n\n// shard using the first 2 hex character of the address\n// this splits the merkle tree into 256 shards\n// shard files will be 00.json, 01.json, 02.json, ..., ff.json\nconst SHARD_NYBBLES = 2;\nlet SnapshotFormatVersion = /*#__PURE__*/function (SnapshotFormatVersion) {\n  SnapshotFormatVersion[SnapshotFormatVersion[\"V1\"] = 1] = \"V1\";\n  SnapshotFormatVersion[SnapshotFormatVersion[\"V2\"] = 2] = \"V2\";\n  return SnapshotFormatVersion;\n}({}); // address, maxClaimable, price, currencyAddress\nclass ShardedMerkleTree {\n  constructor(storage, baseUri, originalEntriesUri, shardNybbles, tokenDecimals) {\n    this.storage = storage;\n    this.shardNybbles = shardNybbles;\n    this.baseUri = baseUri;\n    this.originalEntriesUri = originalEntriesUri;\n    this.tokenDecimals = tokenDecimals;\n    this.shards = {};\n    this.trees = {};\n  }\n  static async fromUri(uri, storage) {\n    try {\n      const shardedMerkleTreeInfo = await storage.downloadJSON(uri);\n      if (shardedMerkleTreeInfo.isShardedMerkleTree) {\n        return ShardedMerkleTree.fromShardedMerkleTreeInfo(shardedMerkleTreeInfo, storage);\n      }\n    } catch (e) {\n      return undefined;\n    }\n  }\n  static async fromShardedMerkleTreeInfo(info, storage) {\n    return new ShardedMerkleTree(storage, info.baseUri, info.originalEntriesUri, info.shardNybbles, info.tokenDecimals);\n  }\n  static hashEntry(entry, tokenDecimals, currencyDecimals, snapshotFormatVersion) {\n    switch (snapshotFormatVersion) {\n      case SnapshotFormatVersion.V1:\n        return utils.solidityKeccak256([\"address\", \"uint256\"], [entry.address, convertQuantityToBigNumber(entry.maxClaimable, tokenDecimals)]);\n      case SnapshotFormatVersion.V2:\n        return utils.solidityKeccak256([\"address\", \"uint256\", \"uint256\", \"address\"], [entry.address, convertQuantityToBigNumber(entry.maxClaimable, tokenDecimals), convertQuantityToBigNumber(entry.price || \"unlimited\", currencyDecimals), entry.currencyAddress || constants.AddressZero]);\n    }\n  }\n  static async fetchAndCacheDecimals(cache, provider, currencyAddress) {\n    if (!currencyAddress) {\n      return 18;\n    }\n    // cache decimals for each currency to avoid refetching for every address\n    let currencyDecimals = cache[currencyAddress];\n    if (currencyDecimals === undefined) {\n      const currencyMetadata = await fetchCurrencyMetadata(provider, currencyAddress);\n      currencyDecimals = currencyMetadata.decimals;\n      cache[currencyAddress] = currencyDecimals;\n    }\n    return currencyDecimals;\n  }\n  static async buildAndUpload(snapshotInput, tokenDecimals, provider, storage, snapshotFormatVersion) {\n    let shardNybbles = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : SHARD_NYBBLES;\n    const inputs = await parseSnapshotInputs(snapshotInput);\n\n    // TODO Could also derive shardNybbles from input size\n    const shards = {};\n    for (const snapshotEntry of inputs) {\n      const shard = snapshotEntry.address.slice(2, 2 + shardNybbles).toLowerCase();\n      if (shards[shard] === undefined) {\n        shards[shard] = [];\n      }\n      shards[shard].push(snapshotEntry);\n    }\n    const currencyDecimalMap = {};\n    // create shard => subtree root map\n    const subTrees = await Promise.all(Object.entries(shards).map(async _ref => {\n      let [shard, entries] = _ref;\n      return [shard, new MerkleTree(await Promise.all(entries.map(async entry => {\n        // cache decimals for each currency to avoid refetching for every address\n        const currencyDecimals = await ShardedMerkleTree.fetchAndCacheDecimals(currencyDecimalMap, provider, entry.currencyAddress);\n        return ShardedMerkleTree.hashEntry(entry, tokenDecimals, currencyDecimals, snapshotFormatVersion);\n      })), utils.keccak256, {\n        sort: true\n      }).getHexRoot()];\n    }));\n    const roots = Object.fromEntries(subTrees);\n    // create master tree from shard => subtree root map\n    const tree = new MerkleTree(Object.values(roots), utils.keccak256, {\n      sort: true\n    });\n    const shardsToUpload = [];\n    for (const [shardId, entries] of Object.entries(shards)) {\n      const data = {\n        proofs: tree.getProof(roots[shardId]).map(value => \"0x\" + value.data.toString(\"hex\")),\n        entries\n      };\n      shardsToUpload.push({\n        data: JSON.stringify(data),\n        name: `${shardId}.json`\n      });\n    }\n    const uris = await storage.uploadBatch(shardsToUpload);\n    const baseUri = uris[0].slice(0, uris[0].lastIndexOf(\"/\"));\n    const originalEntriesUri = await storage.upload(inputs);\n    const shardedMerkleInfo = {\n      merkleRoot: tree.getHexRoot(),\n      baseUri,\n      originalEntriesUri,\n      shardNybbles,\n      tokenDecimals,\n      isShardedMerkleTree: true\n    };\n    const masterUri = await storage.upload(shardedMerkleInfo);\n    return {\n      shardedMerkleInfo,\n      uri: masterUri\n    };\n  }\n  async getProof(address, provider, snapshotFormatVersion) {\n    const shardId = address.slice(2, 2 + this.shardNybbles).toLowerCase();\n    let shard = this.shards[shardId];\n    const currencyDecimalMap = {};\n    if (shard === undefined) {\n      try {\n        shard = this.shards[shardId] = await this.storage.downloadJSON(`${this.baseUri}/${shardId}.json`);\n        const hashedEntries = await Promise.all(shard.entries.map(async entry => {\n          // cache decimals for each currency to avoid refetching for every address\n          const currencyDecimals = await ShardedMerkleTree.fetchAndCacheDecimals(currencyDecimalMap, provider, entry.currencyAddress);\n          return ShardedMerkleTree.hashEntry(entry, this.tokenDecimals, currencyDecimals, snapshotFormatVersion);\n        }));\n        this.trees[shardId] = new MerkleTree(hashedEntries, utils.keccak256, {\n          sort: true\n        });\n      } catch (e) {\n        return null;\n      }\n    }\n    const entry = shard.entries.find(i => i.address.toLowerCase() === address.toLowerCase());\n    if (!entry) {\n      return null;\n    }\n    const currencyDecimals = await ShardedMerkleTree.fetchAndCacheDecimals(currencyDecimalMap, provider, entry.currencyAddress);\n    const leaf = ShardedMerkleTree.hashEntry(entry, this.tokenDecimals, currencyDecimals, snapshotFormatVersion);\n    const proof = this.trees[shardId].getProof(leaf).map(i => \"0x\" + i.data.toString(\"hex\"));\n    return SnapshotEntryWithProofSchema.parseAsync({\n      ...entry,\n      proof: proof.concat(shard.proofs)\n    });\n  }\n  async getAllEntries() {\n    try {\n      return await this.storage.downloadJSON(this.originalEntriesUri);\n    } catch (e) {\n      console.warn(\"Could not fetch original snapshot entries\", e);\n      return [];\n    }\n  }\n}\nasync function fetchSnapshotEntryForAddress(address, merkleRoot, merkleMetadata, provider, storage, snapshotFormatVersion) {\n  if (!merkleMetadata) {\n    return null;\n  }\n  const snapshotUri = merkleMetadata[merkleRoot];\n  if (snapshotUri) {\n    const raw = await storage.downloadJSON(snapshotUri);\n    if (raw.isShardedMerkleTree && raw.merkleRoot === merkleRoot) {\n      const merkleTree = await ShardedMerkleTree.fromShardedMerkleTreeInfo(raw, storage);\n      return await merkleTree.getProof(address, provider, snapshotFormatVersion);\n    }\n    // legacy non-sharded, just fetch it all and filter out\n    const snapshotData = await SnapshotSchema.parseAsync(raw);\n    if (merkleRoot === snapshotData.merkleRoot) {\n      return snapshotData.claims.find(c => c.address.toLowerCase() === address.toLowerCase()) || null;\n    }\n  }\n  return null;\n}\nfunction legacyContractModelToAbstract(model) {\n  return {\n    startTimestamp: model.startTimestamp,\n    maxClaimableSupply: model.maxClaimableSupply,\n    supplyClaimed: model.supplyClaimed,\n    merkleRoot: model.merkleRoot.toString(),\n    pricePerToken: model.pricePerToken,\n    currency: model.currency,\n    maxClaimablePerWallet: model.quantityLimitPerTransaction,\n    waitTimeInSecondsBetweenClaims: model.waitTimeInSecondsBetweenClaims\n  };\n}\nfunction newContractModelToAbstract(model) {\n  return {\n    startTimestamp: model.startTimestamp,\n    maxClaimableSupply: model.maxClaimableSupply,\n    supplyClaimed: model.supplyClaimed,\n    merkleRoot: model.merkleRoot.toString(),\n    pricePerToken: model.pricePerToken,\n    currency: model.currency,\n    maxClaimablePerWallet: model.quantityLimitPerWallet,\n    waitTimeInSecondsBetweenClaims: 0,\n    metadata: model.metadata\n  };\n}\n\n/**\n * @internal\n */\nclass RPCConnectionHandler extends EventEmitter {\n  constructor(network, options) {\n    super();\n    try {\n      this.options = SDKOptionsSchema.parse(options);\n    } catch (optionParseError) {\n      console.error(\"invalid sdk options object passed, falling back to default options\", optionParseError);\n      this.options = SDKOptionsSchema.parse({});\n    }\n    const [signer, provider] = getSignerAndProvider(network, this.options);\n    this.network = network;\n    this.signer = signer;\n    this.provider = provider;\n  }\n  /**\n   * The function to call whenever the network changes, such as when the users connects their wallet, disconnects their wallet, the connected chain changes, etc.\n   *\n   * @param network - a network, signer or provider that ethers js can interpret\n   */\n  updateSignerOrProvider(network) {\n    const [signer, provider] = getSignerAndProvider(network, this.options);\n    this.network = network;\n    this.signer = signer;\n    this.provider = provider;\n  }\n  /**\n   *\n   * @returns whether or not a signer is set, `true` if there is no signer so the class is in \"read only\" mode\n   */\n  isReadOnly() {\n    return !isSigner(this.signer);\n  }\n\n  /**\n   * Explicitly get the active signer.\n   * @returns the active signer, if there is one\n   */\n  getSigner() {\n    return this.signer;\n  }\n\n  /**\n   * Explicitly get the active provider.\n   * @returns the active provider\n   */\n  getProvider() {\n    return this.provider;\n  }\n\n  /**\n   *\n   * @returns the current signer if there is one, otherwise the active provider\n   */\n  getSignerOrProvider() {\n    return this.getSigner() || this.getProvider();\n  }\n}\n\n/**\n * @internal\n */\nclass ContractWrapper extends RPCConnectionHandler {\n  isValidContract = false;\n  customOverrides = () => ({});\n  /**\n   * @internal\n   */\n\n  constructor(network, contractAddress, contractAbi, options, storage) {\n    super(network, options);\n    this.abi = contractAbi;\n    this.address = contractAddress;\n    // set up the contract\n    this.writeContract = new Contract(contractAddress, contractAbi, this.getSignerOrProvider());\n    // setup the read only contract\n    this.readContract = this.writeContract.connect(this.getProvider());\n    this.storage = storage;\n  }\n  updateSignerOrProvider(network) {\n    // update the underlying base class\n    super.updateSignerOrProvider(network);\n    // re-connect the contract with the new signer / provider\n    this.writeContract = this.writeContract.connect(this.getSignerOrProvider());\n    // setup the read only contract\n    this.readContract = this.writeContract.connect(this.getProvider());\n  }\n  updateAbi(updatedAbi) {\n    // re-connect the contract with the new signer / provider\n    this.writeContract = new Contract(this.address, updatedAbi, this.getSignerOrProvider());\n\n    // setup the read only contract\n    this.readContract = this.writeContract.connect(this.getProvider());\n    this.abi = AbiSchema.parse(updatedAbi);\n  }\n\n  /**\n   * @internal\n   */\n  async getChainID() {\n    const provider = this.getProvider();\n    const {\n      chainId\n    } = await provider.getNetwork();\n    return chainId;\n  }\n  /**\n   * @internal\n   */\n  async getSignerAddress() {\n    const signer = this.getSigner();\n    if (!signer) {\n      throw new Error(\"This action requires a connected wallet to sign the transaction. Please pass a valid signer to the SDK.\");\n    }\n    return await signer.getAddress();\n  }\n\n  /**\n   * @internal\n   */\n  callStatic() {\n    return this.writeContract.callStatic;\n  }\n\n  /**\n   * @internal\n   */\n  async getCallOverrides() {\n    return getDefaultGasOverrides(this.getProvider());\n  }\n\n  /**\n   * @internal\n   */\n  emitTransactionEvent(status, transactionHash) {\n    this.emit(EventType.Transaction, {\n      status,\n      transactionHash\n    });\n  }\n\n  /**\n   * @internal\n   */\n  async multiCall(encoded) {\n    return this.sendTransaction(\"multicall\", [encoded]);\n  }\n\n  /**\n   * @internal\n   */\n  async estimateGas(fn, args) {\n    return this.writeContract.estimateGas[fn](...args);\n  }\n\n  /**\n   * @internal\n   */\n  withTransactionOverride(hook) {\n    this.customOverrides = hook;\n  }\n\n  /**\n   *\n   * @param functionName The function name on the contract to call\n   * @param args The arguments to be passed to the functionName\n   * @returns The return value of the function call\n   */\n  async read(functionName, args) {\n    const functions = extractFunctionsFromAbi(AbiSchema.parse(this.abi)).filter(f => f.name === functionName);\n    if (!functions.length) {\n      throw new Error(`Function \"${functionName.toString()}\" not found in contract. Check your dashboard for the list of functions available`);\n    }\n    const fn = functions.find(f => f.name === functionName && f.inputs.length === args.length);\n\n    // TODO extract this and re-use for deploy function to check constructor args\n    if (!fn) {\n      throw new Error(`Function \"${functionName.toString()}\" requires ${functions[0].inputs.length} arguments, but ${args.length} were provided.\\nExpected function signature: ${functions[0].signature}`);\n    }\n    const ethersFnName = `${functionName.toString()}(${fn.inputs.map(i => i.type).join()})`;\n\n    // check if the function exists on the contract, otherwise use the name passed in\n    const fnName = ethersFnName in this.readContract.functions ? ethersFnName : functionName;\n    if (fn.stateMutability === \"view\" || fn.stateMutability === \"pure\") {\n      // read function\n      const result = await this.readContract[fnName.toString()](...args);\n      return result;\n    }\n    throw new Error(\"Cannot call a write function with read()\");\n  }\n\n  /**\n   * @internal\n   */\n  async call(functionName) {\n    let args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    let overrides = arguments.length > 2 ? arguments[2] : undefined;\n    // parse last arg as tx options if present\n    const txOptions = overrides ? await CallOverrideSchema.parseAsync(overrides) : undefined;\n    const functions = extractFunctionsFromAbi(AbiSchema.parse(this.abi)).filter(f => f.name === functionName);\n    if (!functions.length) {\n      throw new Error(`Function \"${functionName}\" not found in contract. Check your dashboard for the list of functions available`);\n    }\n    const fn = functions.find(f => f.name === functionName && f.inputs.length === args.length);\n\n    // TODO extract this and re-use for deploy function to check constructor args\n    if (!fn) {\n      throw new Error(`Function \"${functionName}\" requires ${functions[0].inputs.length} arguments, but ${args.length} were provided.\\nExpected function signature: ${functions[0].signature}`);\n    }\n    const ethersFnName = `${functionName}(${fn.inputs.map(i => i.type).join()})`;\n\n    // check if the function exists on the contract, otherwise use the name passed in\n    const fnName = ethersFnName in this.readContract.functions ? ethersFnName : functionName;\n\n    // TODO validate each argument\n    if (fn.stateMutability === \"view\" || fn.stateMutability === \"pure\") {\n      // read function\n      return txOptions ? this.readContract[fnName](...args, txOptions) : this.readContract[fnName](...args);\n    } else {\n      // write function\n      const receipt = await this.sendTransaction(fnName, args, txOptions);\n      return {\n        receipt\n      };\n    }\n  }\n\n  /**\n   * @internal\n   */\n  async sendTransaction(\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  fn, args, callOverrides) {\n    if (!callOverrides) {\n      callOverrides = await this.getCallOverrides();\n    }\n    // if a custom override is set, merge our override with the custom one\n    callOverrides = {\n      ...callOverrides,\n      ...this.customOverrides()\n    };\n    // clear up the override (single use)\n    this.customOverrides = () => ({});\n    if (this.options?.gasless && (\"openzeppelin\" in this.options.gasless || \"biconomy\" in this.options.gasless)) {\n      if (fn === \"multicall\" && Array.isArray(args[0]) && args[0].length > 0) {\n        const from = await this.getSignerAddress();\n        args[0] = args[0].map(tx => utils.solidityPack([\"bytes\", \"address\"], [tx, from]));\n      }\n      const provider = this.getProvider();\n      const txHash = await this.sendGaslessTransaction(fn, args, callOverrides);\n      this.emitTransactionEvent(\"submitted\", txHash);\n      const receipt = await provider.waitForTransaction(txHash);\n      this.emitTransactionEvent(\"completed\", txHash);\n      return receipt;\n    } else {\n      // one time verification that this is a valid contract (to avoid sending funds to wrong addresses)\n      if (!this.isValidContract) {\n        const code = await this.getProvider().getCode(this.address);\n        this.isValidContract = code !== \"0x\";\n        if (!this.isValidContract) {\n          throw new Error(\"The address you're trying to send a transaction to is not a smart contract. Make sure you are on the correct network and the contract address is correct\");\n        }\n      }\n      const tx = await this.sendTransactionByFunction(fn, args, callOverrides);\n      this.emitTransactionEvent(\"submitted\", tx.hash);\n\n      // tx.wait() can fail so we need to wrap it with a catch\n      let receipt;\n      try {\n        receipt = await tx.wait();\n      } catch (err) {\n        try {\n          // If tx.wait() fails, it just gives us a generic \"transaction failed\"\n          // error. So instead, we need to call static to get an informative error message\n          await this.writeContract.callStatic[fn](...args, ...(callOverrides.value ? [{\n            value: callOverrides.value\n          }] : []));\n        } catch (staticErr) {\n          throw await this.formatError(staticErr, fn, args, callOverrides);\n        }\n        throw await this.formatError(err, fn, args, callOverrides);\n      }\n      this.emitTransactionEvent(\"completed\", tx.hash);\n      return receipt;\n    }\n  }\n\n  /**\n   * @internal\n   */\n  async sendTransactionByFunction(fn, args, callOverrides) {\n    const func = this.writeContract.functions[fn];\n    if (!func) {\n      throw new Error(`invalid function: \"${fn.toString()}\"`);\n    }\n\n    // First, if no gasLimit is passed, call estimate gas ourselves\n    if (!callOverrides.gasLimit) {\n      try {\n        callOverrides.gasLimit = await this.writeContract.estimateGas[fn](...args, callOverrides);\n      } catch (e) {\n        // If gas estimation fails, we'll call static to get a better error message\n        try {\n          await this.writeContract.callStatic[fn](...args, ...(callOverrides.value ? [{\n            value: callOverrides.value\n          }] : []));\n        } catch (err) {\n          throw await this.formatError(err, fn, args, callOverrides);\n        }\n      }\n    }\n\n    // Now there should be no gas estimate errors\n    try {\n      return await func(...args, callOverrides);\n    } catch (err) {\n      throw await this.formatError(err, fn, args, callOverrides);\n    }\n  }\n  async formatError(error, fn, args, callOverrides) {\n    const provider = this.getProvider();\n\n    // Get metadata for transaction to populate into error\n    const network = await provider.getNetwork();\n    const from = await (callOverrides.from || this.getSignerAddress());\n    const to = this.address;\n    const data = this.readContract.interface.encodeFunctionData(fn, args);\n    const value = BigNumber.from(callOverrides.value || 0);\n    const rpcUrl = provider.connection?.url;\n\n    // Render function signature with arguments filled in\n    const functionSignature = this.readContract.interface.getFunction(fn);\n    const methodArgs = args.map(arg => {\n      if (JSON.stringify(arg).length <= 80) {\n        return JSON.stringify(arg);\n      }\n      return JSON.stringify(arg, undefined, 2);\n    });\n    const joinedArgs = methodArgs.join(\", \").length <= 80 ? methodArgs.join(\", \") : \"\\n\" + methodArgs.map(arg => \"  \" + arg.split(\"\\n\").join(\"\\n  \")).join(\",\\n\") + \"\\n\";\n    const method = `${functionSignature.name}(${joinedArgs})`;\n    const hash = error.transactionHash || error.transaction?.hash || error.receipt?.transactionHash;\n\n    // Parse the revert reason from the error\n    const reason = parseRevertReason(error);\n\n    // Get contract sources for stack trace\n    let sources = undefined;\n    let contractName = undefined;\n    try {\n      const metadata = await fetchContractMetadataFromAddress(this.address, this.getProvider(), this.storage, this.options);\n      if (metadata.name) {\n        contractName = metadata.name;\n      }\n      if (metadata.metadata.sources) {\n        sources = await fetchSourceFilesFromMetadata(metadata, this.storage);\n      }\n    } catch (err) {\n      // no-op\n    }\n    return new TransactionError({\n      reason,\n      from,\n      to,\n      method,\n      data,\n      network,\n      rpcUrl,\n      value,\n      hash,\n      contractName,\n      sources\n    }, error);\n  }\n\n  /**\n   * @internal\n   */\n  async sendGaslessTransaction(fn) {\n    let args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    let callOverrides = arguments.length > 2 ? arguments[2] : undefined;\n    const signer = this.getSigner();\n    invariant(signer, \"Cannot execute gasless transaction without valid signer\");\n    const chainId = await this.getChainID();\n    const from = await this.getSignerAddress();\n    const to = this.writeContract.address;\n    const value = callOverrides?.value || 0;\n    if (BigNumber.from(value).gt(0)) {\n      throw new Error(\"Cannot send native token value with gasless transaction\");\n    }\n    const data = this.writeContract.interface.encodeFunctionData(fn, args);\n    let gas = BigNumber.from(0);\n    try {\n      const gasEstimate = await this.readContract.estimateGas[fn](...args);\n      gas = gasEstimate.mul(2);\n    } catch (e) {\n      // ignore\n    }\n\n    // in some cases WalletConnect doesn't properly gives an estimate for how much gas it would actually use.\n    // as a fix, we're setting it to a high arbitrary number (500k) as the gas limit that should cover for most function calls.\n    if (gas.lt(100000)) {\n      gas = BigNumber.from(500000);\n    }\n\n    // check for gas override in callOverrides\n    if (callOverrides.gasLimit && BigNumber.from(callOverrides.gasLimit).gt(gas)) {\n      gas = BigNumber.from(callOverrides.gasLimit);\n    }\n    const tx = {\n      from,\n      to,\n      data,\n      chainId,\n      gasLimit: gas,\n      functionName: fn.toString(),\n      functionArgs: args,\n      callOverrides\n    };\n    return await this.defaultGaslessSendFunction(tx);\n  }\n  async signTypedData(signer, domain, types, message) {\n    this.emit(EventType.Signature, {\n      status: \"submitted\",\n      message,\n      signature: \"\"\n    });\n    const {\n      signature: sig\n    } = await signTypedDataInternal(signer, domain, types, message);\n    this.emit(EventType.Signature, {\n      status: \"completed\",\n      message,\n      signature: sig\n    });\n    return sig;\n  }\n  parseLogs(eventName, logs) {\n    if (!logs || logs.length === 0) {\n      return [];\n    }\n    const topic = this.writeContract.interface.getEventTopic(eventName);\n    const parsedLogs = logs.filter(x => x.topics.indexOf(topic) >= 0);\n    return parsedLogs.map(l => this.writeContract.interface.parseLog(l));\n  }\n  async defaultGaslessSendFunction(transaction) {\n    if (this.options.gasless && \"biconomy\" in this.options.gasless) {\n      return this.biconomySendFunction(transaction);\n    }\n    return this.defenderSendFunction(transaction);\n  }\n  async biconomySendFunction(transaction) {\n    invariant(this.options.gasless && \"biconomy\" in this.options.gasless, \"calling biconomySendFunction without biconomy\");\n    const signer = this.getSigner();\n    const provider = this.getProvider();\n    invariant(signer && provider, \"signer and provider must be set\");\n    const forwarder = new Contract(getContractAddressByChainId(transaction.chainId, \"biconomyForwarder\"), BiconomyForwarderAbi, provider);\n    const batchId = 0;\n    const batchNonce = await getAndIncrementNonce(forwarder, \"getNonce\", [transaction.from, batchId]);\n    const request = {\n      from: transaction.from,\n      to: transaction.to,\n      token: constants.AddressZero,\n      txGas: transaction.gasLimit.toNumber(),\n      tokenGasPrice: \"0\",\n      batchId,\n      batchNonce: batchNonce.toNumber(),\n      deadline: Math.floor(Date.now() / 1000 + (this.options?.gasless && \"biconomy\" in this.options.gasless && this.options.gasless.biconomy?.deadlineSeconds || 3600)),\n      data: transaction.data\n    };\n    const hashToSign = utils.arrayify(utils.solidityKeccak256([\"address\", \"address\", \"address\", \"uint256\", \"uint256\", \"uint256\", \"uint256\", \"uint256\", \"bytes32\"], [request.from, request.to, request.token, request.txGas, request.tokenGasPrice, request.batchId, request.batchNonce, request.deadline, utils.keccak256(request.data)]));\n    this.emit(EventType.Signature, {\n      status: \"submitted\",\n      message: hashToSign,\n      signature: \"\"\n    });\n    const signature = await signer.signMessage(hashToSign);\n    this.emit(EventType.Signature, {\n      status: \"completed\",\n      message: hashToSign,\n      signature\n    });\n    const response = await fetch(\"https://api.biconomy.io/api/v2/meta-tx/native\", {\n      method: \"POST\",\n      body: JSON.stringify({\n        from: transaction.from,\n        apiId: this.options.gasless.biconomy.apiId,\n        params: [request, signature],\n        to: transaction.to,\n        gasLimit: transaction.gasLimit.toHexString()\n      }),\n      headers: {\n        \"x-api-key\": this.options.gasless.biconomy.apiKey,\n        \"Content-Type\": \"application/json;charset=utf-8\"\n      }\n    });\n    if (response.ok) {\n      const resp = await response.json();\n      if (!resp.txHash) {\n        throw new Error(`relay transaction failed: ${resp.log}`);\n      }\n      return resp.txHash;\n    }\n    throw new Error(`relay transaction failed with status: ${response.status} (${response.statusText})`);\n  }\n  async defenderSendFunction(transaction) {\n    invariant(this.options.gasless && \"openzeppelin\" in this.options.gasless, \"calling openzeppelin gasless transaction without openzeppelin config in the SDK options\");\n    const signer = this.getSigner();\n    const provider = this.getProvider();\n    invariant(signer, \"provider is not set\");\n    invariant(provider, \"provider is not set\");\n    const forwarderAddress = this.options.gasless.openzeppelin.relayerForwarderAddress || (this.options.gasless.openzeppelin.useEOAForwarder ? CONTRACT_ADDRESSES[transaction.chainId].openzeppelinForwarderEOA || (await computeEOAForwarderAddress(this.getProvider(), this.storage, \"\", this.options.clientId, this.options.secretKey)) : CONTRACT_ADDRESSES[transaction.chainId].openzeppelinForwarder || (await computeForwarderAddress(this.getProvider(), this.storage, \"\", this.options.clientId, this.options.secretKey)));\n    const forwarder = new Contract(forwarderAddress, ForwarderABI, provider);\n    const nonce = await getAndIncrementNonce(forwarder, \"getNonce\", [transaction.from]);\n    let domain;\n    let types;\n    let message;\n    if (this.options.gasless.experimentalChainlessSupport) {\n      domain = {\n        name: \"GSNv2 Forwarder\",\n        version: \"0.0.1\",\n        verifyingContract: forwarderAddress\n      };\n      types = {\n        ForwardRequest: ChainAwareForwardRequest\n      };\n      message = {\n        from: transaction.from,\n        to: transaction.to,\n        value: BigNumber.from(0).toString(),\n        gas: BigNumber.from(transaction.gasLimit).toString(),\n        nonce: BigNumber.from(nonce).toString(),\n        data: transaction.data,\n        chainid: BigNumber.from(transaction.chainId).toString()\n      };\n    } else {\n      domain = {\n        name: this.options.gasless.openzeppelin.domainName,\n        version: this.options.gasless.openzeppelin.domainVersion,\n        chainId: transaction.chainId,\n        verifyingContract: forwarderAddress\n      };\n      types = {\n        ForwardRequest\n      };\n      message = {\n        from: transaction.from,\n        to: transaction.to,\n        value: BigNumber.from(0).toString(),\n        gas: BigNumber.from(transaction.gasLimit).toString(),\n        nonce: BigNumber.from(nonce).toString(),\n        data: transaction.data\n      };\n    }\n    let signature;\n    this.emit(EventType.Signature, {\n      status: \"submitted\",\n      message,\n      signature: \"\"\n    });\n\n    // if the executing function is \"approve\" and matches with erc20 approve signature\n    // and if the token supports permit, then we use permit for gasless instead of approve.\n    if (transaction.functionName === \"approve\" && transaction.functionArgs.length === 2) {\n      const spender = transaction.functionArgs[0];\n      const amount = transaction.functionArgs[1];\n      // TODO: support DAI permit by signDAIPermit\n      const {\n        message: permit,\n        signature: sig\n      } = await signEIP2612Permit(signer, this.writeContract.address, transaction.from, spender, amount);\n      const {\n        r,\n        s,\n        v\n      } = utils.splitSignature(sig);\n      message = {\n        to: this.address,\n        owner: permit.owner,\n        spender: permit.spender,\n        value: BigNumber.from(permit.value).toString(),\n        nonce: BigNumber.from(permit.nonce).toString(),\n        deadline: BigNumber.from(permit.deadline).toString(),\n        r,\n        s,\n        v\n      };\n      signature = sig;\n    } else {\n      const {\n        signature: sig\n      } = await signTypedDataInternal(signer, domain, types, message);\n      signature = sig;\n    }\n    let messageType = \"forward\";\n\n    // if has owner property then it's permit :)\n    if (message?.owner) {\n      messageType = \"permit\";\n    }\n    const body = JSON.stringify({\n      request: message,\n      signature,\n      forwarderAddress,\n      type: messageType\n    });\n    this.emit(EventType.Signature, {\n      status: \"completed\",\n      message,\n      signature\n    });\n    const response = await fetch(this.options.gasless.openzeppelin.relayerUrl, {\n      method: \"POST\",\n      body\n    });\n    if (response.ok) {\n      const resp = await response.json();\n      if (!resp.result) {\n        throw new Error(`Relay transaction failed: ${resp.message}`);\n      }\n      const result = JSON.parse(resp.result);\n      return result.txHash;\n    }\n    throw new Error(`relay transaction failed with status: ${response.status} (${response.statusText})`);\n  }\n}\nasync function approveErc20Allowance(contractToApprove, currencyAddress, price, quantity, tokenDecimals) {\n  const signer = contractToApprove.getSigner();\n  const provider = contractToApprove.getProvider();\n  const erc20 = new ContractWrapper(signer || provider, currencyAddress, ERC20Abi, contractToApprove.options, contractToApprove.storage);\n  const owner = await contractToApprove.getSignerAddress();\n  const spender = contractToApprove.address;\n  const allowance = await erc20.read(\"allowance\", [owner, spender]);\n  const totalPrice = BigNumber.from(price).mul(BigNumber.from(quantity)).div(utils.parseUnits(\"1\", tokenDecimals));\n  if (allowance.lt(totalPrice)) {\n    await erc20.sendTransaction(\"approve\", [spender, allowance.add(totalPrice)]);\n  }\n}\n\n/**\n *\n * @param provider\n * @param inputPrice\n * @param currencyAddress\n * @returns\n * @internal\n */\nasync function normalizePriceValue(provider, inputPrice, currencyAddress) {\n  const metadata = await fetchCurrencyMetadata(provider, currencyAddress);\n  return utils.parseUnits(AmountSchema.parse(inputPrice), metadata.decimals);\n}\n\n/**\n * Returns proofs and the overrides required for the transaction.\n * @internal\n * @returns - `overrides` and `proofs` as an object.\n */\nasync function prepareClaim(addressToClaim, quantity, activeClaimCondition, merkleMetadataFetcher, tokenDecimals, contractWrapper, storage, checkERC20Allowance, snapshotFormatVersion) {\n  let maxClaimable = convertQuantityToBigNumber(activeClaimCondition.maxClaimablePerWallet, tokenDecimals);\n  let proofs = [utils.hexZeroPad([0], 32)];\n  let priceInProof = activeClaimCondition.price; // the price to send to the contract in claim proofs\n  let currencyAddressInProof = activeClaimCondition.currencyAddress;\n  try {\n    if (!activeClaimCondition.merkleRootHash.toString().startsWith(constants.AddressZero)) {\n      const snapshotEntry = await fetchSnapshotEntryForAddress(addressToClaim, activeClaimCondition.merkleRootHash.toString(), await merkleMetadataFetcher(), contractWrapper.getProvider(), storage, snapshotFormatVersion);\n      if (snapshotEntry) {\n        proofs = snapshotEntry.proof;\n        // override only if not default values (unlimited for quantity, zero addr for currency)\n        maxClaimable = snapshotEntry.maxClaimable === \"unlimited\" ? constants.MaxUint256 : utils.parseUnits(snapshotEntry.maxClaimable, tokenDecimals);\n        priceInProof = snapshotEntry.price === undefined || snapshotEntry.price === \"unlimited\" ? constants.MaxUint256 : await normalizePriceValue(contractWrapper.getProvider(), snapshotEntry.price, snapshotEntry.currencyAddress || constants.AddressZero);\n        currencyAddressInProof = snapshotEntry.currencyAddress || constants.AddressZero;\n      } else {\n        // if no snapshot entry, and it's a v1 format (exclusive allowlist) then address can't claim\n        if (snapshotFormatVersion === SnapshotFormatVersion.V1) {\n          throw new Error(\"No claim found for this address\");\n        }\n        // but if its snapshot v2 (override list behavior) then address can still claim with default settings\n      }\n    }\n  } catch (e) {\n    // have to handle the valid error case that we *do* want to throw on\n    if (e?.message === \"No claim found for this address\") {\n      throw e;\n    }\n    // other errors we wanna ignore and try to continue\n    console.warn(\"failed to check claim condition merkle root hash, continuing anyways\", e);\n  }\n  const overrides = (await contractWrapper.getCallOverrides()) || {};\n  // the actual price to check allowance against\n  // if proof price is unlimited, then we use the price from the claim condition\n  // this mimics the contract behavior\n  const pricePerToken = priceInProof.toString() !== constants.MaxUint256.toString() ? priceInProof : activeClaimCondition.price;\n  // same for currency address\n  const currencyAddress = currencyAddressInProof !== constants.AddressZero ? currencyAddressInProof : activeClaimCondition.currencyAddress;\n  if (pricePerToken.gt(0)) {\n    if (isNativeToken(currencyAddress)) {\n      overrides[\"value\"] = BigNumber.from(pricePerToken).mul(quantity).div(utils.parseUnits(\"1\", tokenDecimals));\n    } else if (checkERC20Allowance) {\n      await approveErc20Allowance(contractWrapper, currencyAddress, pricePerToken, quantity, tokenDecimals);\n    }\n  }\n  return {\n    overrides,\n    proofs,\n    maxClaimable,\n    price: pricePerToken,\n    currencyAddress: currencyAddress,\n    priceInProof,\n    currencyAddressInProof\n  };\n}\n\n/**\n * Create a snapshot (merkle tree) from a list of addresses and uploads it to IPFS\n * @param snapshotInput - the list of addresses to hash\n * @param tokenDecimals - the token decimals\n * @param provider\n * @param storage - the storage to upload to\n * @param snapshotFormatVersion\n * @returns the generated snapshot and URI\n * @internal\n */\nasync function createSnapshot(snapshotInput, tokenDecimals, provider, storage, snapshotFormatVersion) {\n  const input = await parseSnapshotInputs(snapshotInput);\n  const addresses = input.map(i => i.address);\n  const hasDuplicates = new Set(addresses).size < addresses.length;\n  if (hasDuplicates) {\n    throw new DuplicateLeafsError();\n  }\n  const tree = await ShardedMerkleTree.buildAndUpload(input, tokenDecimals, provider, storage, snapshotFormatVersion);\n  return {\n    merkleRoot: tree.shardedMerkleInfo.merkleRoot,\n    snapshotUri: tree.uri\n  };\n}\nfunction compare(a, b) {\n  const left = BigNumber.from(a);\n  const right = BigNumber.from(b);\n  if (left.eq(right)) {\n    return 0;\n  } else if (left.gt(right)) {\n    return 1;\n  } else {\n    return -1;\n  }\n}\n\n/**\n * @internal\n * Decorates claim conditions with merkle roots from snapshots if present\n * @param claimConditionInputs\n * @param tokenDecimals\n * @param provider\n * @param storage\n * @param snapshotFormatVersion\n */\nasync function processSnapshotData(claimConditionInputs, tokenDecimals, provider, storage, snapshotFormatVersion) {\n  const snapshotInfos = [];\n  const inputsWithSnapshots = await Promise.all(claimConditionInputs.map(async conditionInput => {\n    // check snapshots and upload if provided\n    if (conditionInput.snapshot && conditionInput.snapshot.length > 0) {\n      const snapshotInfo = await createSnapshot(conditionInput.snapshot, tokenDecimals, provider, storage, snapshotFormatVersion);\n      snapshotInfos.push(snapshotInfo);\n      conditionInput.merkleRootHash = snapshotInfo.merkleRoot;\n    } else {\n      // if no snapshot is passed or empty, reset the merkle root\n      conditionInput.merkleRootHash = utils.hexZeroPad([0], 32);\n    }\n    // fill condition with defaults values if not provided\n    return conditionInput;\n  }));\n  return {\n    inputsWithSnapshots,\n    snapshotInfos\n  };\n}\n\n/**\n * Converts a local SDK model to contract model\n * @param c\n * @param tokenDecimals\n * @param provider\n * @param storage\n * @internal\n */\nasync function convertToContractModel(c, tokenDecimals, provider, storage) {\n  const currency = c.currencyAddress === constants.AddressZero ? NATIVE_TOKEN_ADDRESS : c.currencyAddress;\n  const maxClaimableSupply = convertQuantityToBigNumber(c.maxClaimableSupply, tokenDecimals);\n  const maxClaimablePerWallet = convertQuantityToBigNumber(c.maxClaimablePerWallet, tokenDecimals);\n  let metadataOrUri;\n  if (c.metadata) {\n    if (typeof c.metadata === \"string\") {\n      metadataOrUri = c.metadata;\n    } else {\n      metadataOrUri = await storage.upload(c.metadata);\n    }\n  }\n  return {\n    startTimestamp: c.startTime,\n    maxClaimableSupply,\n    supplyClaimed: 0,\n    maxClaimablePerWallet,\n    pricePerToken: await normalizePriceValue(provider, c.price, currency),\n    currency,\n    merkleRoot: c.merkleRootHash.toString(),\n    waitTimeInSecondsBetweenClaims: c.waitInSeconds || 0,\n    metadata: metadataOrUri\n  };\n}\n\n/**\n * Create and uploads snapshots + converts claim conditions to contract format\n * @param claimConditionInputs\n * @param tokenDecimals\n * @param provider\n * @param storage\n * @param snapshotFormatVersion\n * @internal\n */\nasync function processClaimConditionInputs(claimConditionInputs, tokenDecimals, provider, storage, snapshotFormatVersion) {\n  const {\n    inputsWithSnapshots,\n    snapshotInfos\n  } = await processSnapshotData(claimConditionInputs, tokenDecimals, provider, storage, snapshotFormatVersion);\n  const parsedInputs = await ClaimConditionInputArray.parseAsync(inputsWithSnapshots);\n  // Convert processed inputs to the format the contract expects, and sort by timestamp\n  const sortedConditions = (await Promise.all(parsedInputs.map(c => convertToContractModel(c, tokenDecimals, provider, storage)))).sort((a, b) => {\n    return compare(a.startTimestamp, b.startTimestamp);\n  });\n  return {\n    snapshotInfos,\n    sortedConditions\n  };\n}\n\n/**\n *\n * @param providerOrSigner\n * @param asset\n * @param price\n * @returns\n * @internal\n */\nasync function fetchCurrencyValue(providerOrSigner, asset, price) {\n  const metadata = await fetchCurrencyMetadata(providerOrSigner, asset);\n  return {\n    ...metadata,\n    value: BigNumber.from(price),\n    displayValue: utils.formatUnits(price, metadata.decimals)\n  };\n}\n\n/**\n * @internal\n * @param merkleRoot\n * @param merkleMetadata\n * @param storage\n */\nasync function fetchSnapshot(merkleRoot, merkleMetadata, storage) {\n  if (!merkleMetadata) {\n    return null;\n  }\n  const snapshotUri = merkleMetadata[merkleRoot];\n  if (snapshotUri) {\n    const raw = await storage.downloadJSON(snapshotUri);\n    if (raw.isShardedMerkleTree && raw.merkleRoot === merkleRoot) {\n      const smt = await ShardedMerkleTree.fromUri(snapshotUri, storage);\n      return smt?.getAllEntries() || null;\n    } else {\n      const snapshotData = await SnapshotSchema.parseAsync(raw);\n      if (merkleRoot === snapshotData.merkleRoot) {\n        return snapshotData.claims.map(claim => ({\n          address: claim.address,\n          maxClaimable: claim.maxClaimable,\n          price: claim.price,\n          currencyAddress: claim.currencyAddress\n        }));\n      }\n    }\n  }\n  return null;\n}\n\n/**\n * @internal\n * @param bn\n * @param tokenDecimals\n */\nfunction convertToReadableQuantity(bn, tokenDecimals) {\n  if (bn.toString() === constants.MaxUint256.toString()) {\n    return \"unlimited\";\n  } else {\n    return utils.formatUnits(bn, tokenDecimals);\n  }\n}\n\n/**\n * Transforms a contract model to local model\n * @param pm\n * @param tokenDecimals\n * @param provider\n * @param merkleMetadata\n * @param storage\n * @param shouldDownloadSnapshot\n * @internal\n */\nasync function transformResultToClaimCondition(pm, tokenDecimals, provider, merkleMetadata, storage, shouldDownloadSnapshot) {\n  const cv = await fetchCurrencyValue(provider, pm.currency, pm.pricePerToken);\n  const maxClaimableSupply = convertToReadableQuantity(pm.maxClaimableSupply, tokenDecimals);\n  const maxClaimablePerWallet = convertToReadableQuantity(pm.maxClaimablePerWallet, tokenDecimals);\n  const availableSupply = convertToReadableQuantity(BigNumber.from(pm.maxClaimableSupply).sub(pm.supplyClaimed), tokenDecimals);\n  const currentMintSupply = convertToReadableQuantity(pm.supplyClaimed, tokenDecimals);\n  let resolvedMetadata;\n  if (pm.metadata) {\n    resolvedMetadata = await storage.downloadJSON(pm.metadata);\n  }\n  return ClaimConditionOutputSchema.parseAsync({\n    startTime: pm.startTimestamp,\n    maxClaimableSupply,\n    maxClaimablePerWallet,\n    currentMintSupply,\n    availableSupply,\n    waitInSeconds: pm.waitTimeInSecondsBetweenClaims?.toString(),\n    price: BigNumber.from(pm.pricePerToken),\n    currency: pm.currency,\n    currencyAddress: pm.currency,\n    currencyMetadata: cv,\n    merkleRootHash: pm.merkleRoot,\n    snapshot: shouldDownloadSnapshot ? await fetchSnapshot(pm.merkleRoot, merkleMetadata, storage) : undefined,\n    metadata: resolvedMetadata\n  });\n}\n\n/**\n * @internal\n * @param index\n * @param claimConditionInput\n * @param existingConditions\n */\nasync function updateExistingClaimConditions(index, claimConditionInput, existingConditions) {\n  if (index >= existingConditions.length) {\n    throw Error(`Index out of bounds - got index: ${index} with ${existingConditions.length} conditions`);\n  }\n  // merge input with existing claim condition\n  const priceDecimals = existingConditions[index].currencyMetadata.decimals;\n  const priceInWei = existingConditions[index].price;\n  const priceInTokens = utils.formatUnits(priceInWei, priceDecimals);\n\n  // merge existing (output format) with incoming (input format)\n  const newConditionParsed = await ClaimConditionInputSchema.parseAsync({\n    ...existingConditions[index],\n    price: priceInTokens,\n    ...claimConditionInput\n  });\n\n  // convert to output claim condition\n  const mergedConditionOutput = await ClaimConditionOutputSchema.parseAsync({\n    ...newConditionParsed,\n    price: priceInWei\n  });\n  return existingConditions.map((existingOutput, i) => {\n    let newConditionAtIndex;\n    if (i === index) {\n      newConditionAtIndex = mergedConditionOutput;\n    } else {\n      newConditionAtIndex = existingOutput;\n    }\n    const formattedPrice = utils.formatUnits(newConditionAtIndex.price, priceDecimals);\n    return {\n      ...newConditionAtIndex,\n      price: formattedPrice // manually transform back to input price type\n    };\n  });\n}\n\nlet Status = /*#__PURE__*/function (Status) {\n  Status[Status[\"UNSET\"] = 0] = \"UNSET\";\n  Status[Status[\"Created\"] = 1] = \"Created\";\n  Status[Status[\"Completed\"] = 2] = \"Completed\";\n  Status[Status[\"Cancelled\"] = 3] = \"Cancelled\";\n  Status[Status[\"Active\"] = 4] = \"Active\";\n  Status[Status[\"Expired\"] = 5] = \"Expired\";\n  return Status;\n}({});\nlet ClaimEligibility = /*#__PURE__*/function (ClaimEligibility) {\n  ClaimEligibility[\"NotEnoughSupply\"] = \"There is not enough supply to claim.\";\n  ClaimEligibility[\"AddressNotAllowed\"] = \"This address is not on the allowlist.\";\n  ClaimEligibility[\"WaitBeforeNextClaimTransaction\"] = \"Not enough time since last claim transaction. Please wait.\";\n  ClaimEligibility[\"ClaimPhaseNotStarted\"] = \"Claim phase has not started yet.\";\n  ClaimEligibility[\"AlreadyClaimed\"] = \"You have already claimed the token.\";\n  ClaimEligibility[\"WrongPriceOrCurrency\"] = \"Incorrect price or currency.\";\n  ClaimEligibility[\"OverMaxClaimablePerWallet\"] = \"Cannot claim more than maximum allowed quantity.\";\n  ClaimEligibility[\"NotEnoughTokens\"] = \"There are not enough tokens in the wallet to pay for the claim.\";\n  ClaimEligibility[\"NoActiveClaimPhase\"] = \"There is no active claim phase at the moment. Please check back in later.\";\n  ClaimEligibility[\"NoClaimConditionSet\"] = \"There is no claim condition set.\";\n  ClaimEligibility[\"NoWallet\"] = \"No wallet connected.\";\n  ClaimEligibility[\"Unknown\"] = \"No claim conditions found.\";\n  return ClaimEligibility;\n}({});\n\n/**\n * Manages claim conditions for NFT Drop contracts\n * @public\n */\nclass DropClaimConditions {\n  constructor(contractWrapper, metadata, storage) {\n    this.storage = storage;\n    this.contractWrapper = contractWrapper;\n    this.metadata = metadata;\n  }\n\n  /** ***************************************\n   * READ FUNCTIONS\n   *****************************************/\n\n  /**\n   * Get the currently active claim condition\n   *\n   * @returns the claim condition metadata\n   */\n  async getActive(options) {\n    const cc = await this.get();\n    const metadata = await this.metadata.get();\n    return await transformResultToClaimCondition(cc, await this.getTokenDecimals(), this.contractWrapper.getProvider(), metadata.merkle || {}, this.storage, options?.withAllowList || false);\n  }\n  async get(conditionId) {\n    if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {\n      const contractModel = await this.contractWrapper.read(\"claimCondition\", []);\n      return legacyContractModelToAbstract(contractModel);\n    } else if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {\n      const id = conditionId !== undefined ? conditionId : await this.contractWrapper.read(\"getActiveClaimConditionId\", []);\n      const contractModel = await this.contractWrapper.read(\"getClaimConditionById\", [id]);\n      return legacyContractModelToAbstract(contractModel);\n    } else if (this.isNewSinglePhaseDrop(this.contractWrapper)) {\n      const contractModel = await this.contractWrapper.read(\"claimCondition\", []);\n      return newContractModelToAbstract(contractModel);\n    } else if (this.isNewMultiphaseDrop(this.contractWrapper)) {\n      const id = conditionId !== undefined ? conditionId : await this.contractWrapper.read(\"getActiveClaimConditionId\", []);\n      const contractModel = await this.contractWrapper.read(\"getClaimConditionById\", [id]);\n      return newContractModelToAbstract(contractModel);\n    } else {\n      throw new Error(\"Contract does not support claim conditions\");\n    }\n  }\n\n  /**\n   * Get all the claim conditions\n   *\n   * @returns the claim conditions metadata\n   */\n  async getAll(options) {\n    if (this.isLegacyMultiPhaseDrop(this.contractWrapper) || this.isNewMultiphaseDrop(this.contractWrapper)) {\n      const [currentStartId, countBn] = await this.contractWrapper.read(\"claimCondition\", []);\n      const startId = currentStartId.toNumber();\n      const count = countBn.toNumber();\n      const conditions = [];\n      for (let i = startId; i < startId + count; i++) {\n        conditions.push(this.get(i));\n      }\n      const [metadata, decimals, ...fetchedConditions] = await Promise.all([this.metadata.get(), this.getTokenDecimals(), ...conditions]);\n      return Promise.all(fetchedConditions.map(c => transformResultToClaimCondition(c, decimals, this.contractWrapper.getProvider(), metadata.merkle, this.storage, options?.withAllowList || false)));\n    } else {\n      return [await this.getActive(options)];\n    }\n  }\n\n  /**\n   * Can Claim\n   *\n   * @remarks Check if the drop can currently be claimed.\n   *\n   * @example\n   * ```javascript\n   * // Quantity of tokens to check claimability of\n   * const quantity = 1;\n   * const canClaim = await contract.canClaim(quantity);\n   * ```\n   */\n  async canClaim(quantity, addressToCheck) {\n    // TODO switch to use verifyClaim\n    if (addressToCheck) {\n      addressToCheck = await resolveAddress(addressToCheck);\n    }\n    return (await this.getClaimIneligibilityReasons(quantity, addressToCheck)).length === 0;\n  }\n\n  /**\n   * For any claim conditions that a particular wallet is violating,\n   * this function returns human readable information about the\n   * breaks in the condition that can be used to inform the user.\n   *\n   * @param quantity - The desired quantity that would be claimed.\n   * @param addressToCheck - The wallet address, defaults to the connected wallet.\n   *\n   */\n  async getClaimIneligibilityReasons(quantity, addressToCheck) {\n    const reasons = [];\n    let activeConditionIndex;\n    let claimCondition;\n    const decimals = await this.getTokenDecimals();\n    const quantityWithDecimals = utils.parseUnits(AmountSchema.parse(quantity), decimals);\n    if (addressToCheck === undefined) {\n      try {\n        addressToCheck = await this.contractWrapper.getSignerAddress();\n      } catch (err) {\n        console.warn(\"failed to get signer address\", err);\n      }\n    }\n\n    // if we have been unable to get a signer address, we can't check eligibility, so return a NoWallet error reason\n    if (!addressToCheck) {\n      return [ClaimEligibility.NoWallet];\n    }\n    const resolvedAddress = await resolveAddress(addressToCheck);\n    try {\n      claimCondition = await this.getActive();\n    } catch (err) {\n      if (includesErrorMessage(err, \"!CONDITION\") || includesErrorMessage(err, \"no active mint condition\")) {\n        reasons.push(ClaimEligibility.NoClaimConditionSet);\n        return reasons;\n      }\n      console.warn(\"failed to get active claim condition\", err);\n      reasons.push(ClaimEligibility.Unknown);\n      return reasons;\n    }\n    if (claimCondition.availableSupply !== \"unlimited\") {\n      const supplyWithDecimals = utils.parseUnits(claimCondition.availableSupply, decimals);\n      if (supplyWithDecimals.lt(quantityWithDecimals)) {\n        reasons.push(ClaimEligibility.NotEnoughSupply);\n        return reasons;\n      }\n    }\n\n    // check for merkle root inclusion\n    const merkleRootArray = utils.stripZeros(claimCondition.merkleRootHash);\n    const hasAllowList = merkleRootArray.length > 0;\n    let allowListEntry = null;\n    if (hasAllowList) {\n      allowListEntry = await this.getClaimerProofs(resolvedAddress);\n      if (!allowListEntry && (this.isLegacySinglePhaseDrop(this.contractWrapper) || this.isLegacyMultiPhaseDrop(this.contractWrapper))) {\n        // exclusive allowlist behavior\n        reasons.push(ClaimEligibility.AddressNotAllowed);\n        return reasons;\n      }\n      if (allowListEntry) {\n        try {\n          const claimVerification = await this.prepareClaim(quantity, false, decimals, resolvedAddress);\n          let validMerkleProof;\n          if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {\n            activeConditionIndex = await this.contractWrapper.read(\"getActiveClaimConditionId\", []);\n            // legacy verifyClaimerMerkleProofs function\n            [validMerkleProof] = await this.contractWrapper.read(\"verifyClaimMerkleProof\", [activeConditionIndex, resolvedAddress, quantity, claimVerification.proofs, claimVerification.maxClaimable]);\n            if (!validMerkleProof) {\n              reasons.push(ClaimEligibility.AddressNotAllowed);\n              return reasons;\n            }\n          } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {\n            [validMerkleProof] = await this.contractWrapper.read(\"verifyClaimMerkleProof\", [resolvedAddress, quantity, {\n              proof: claimVerification.proofs,\n              maxQuantityInAllowlist: claimVerification.maxClaimable\n            }]);\n            if (!validMerkleProof) {\n              reasons.push(ClaimEligibility.AddressNotAllowed);\n              return reasons;\n            }\n          } else if (this.isNewSinglePhaseDrop(this.contractWrapper)) {\n            await this.contractWrapper.read(\"verifyClaim\", [resolvedAddress, quantity, claimVerification.currencyAddress, claimVerification.price, {\n              proof: claimVerification.proofs,\n              quantityLimitPerWallet: claimVerification.maxClaimable,\n              currency: claimVerification.currencyAddressInProof,\n              pricePerToken: claimVerification.priceInProof\n            }]);\n          } else if (this.isNewMultiphaseDrop(this.contractWrapper)) {\n            activeConditionIndex = await this.contractWrapper.read(\"getActiveClaimConditionId\", []);\n            await this.contractWrapper.read(\"verifyClaim\", [activeConditionIndex, resolvedAddress, quantity, claimVerification.currencyAddress, claimVerification.price, {\n              proof: claimVerification.proofs,\n              quantityLimitPerWallet: claimVerification.maxClaimable,\n              currency: claimVerification.currencyAddressInProof,\n              pricePerToken: claimVerification.priceInProof\n            }]);\n          }\n        } catch (e) {\n          console.warn(\"Merkle proof verification failed:\", \"reason\" in e ? e.reason : e);\n          const reason = e.reason;\n          switch (reason) {\n            case \"!Qty\":\n              reasons.push(ClaimEligibility.OverMaxClaimablePerWallet);\n              break;\n            case \"!PriceOrCurrency\":\n              reasons.push(ClaimEligibility.WrongPriceOrCurrency);\n              break;\n            case \"!MaxSupply\":\n              reasons.push(ClaimEligibility.NotEnoughSupply);\n              break;\n            case \"cant claim yet\":\n              reasons.push(ClaimEligibility.ClaimPhaseNotStarted);\n              break;\n            default:\n              {\n                reasons.push(ClaimEligibility.AddressNotAllowed);\n                break;\n              }\n          }\n          return reasons;\n        }\n      }\n    }\n    if (this.isNewSinglePhaseDrop(this.contractWrapper) || this.isNewMultiphaseDrop(this.contractWrapper)) {\n      let claimedSupply = BigNumber.from(0);\n      let maxClaimable = convertQuantityToBigNumber(claimCondition.maxClaimablePerWallet, decimals);\n      try {\n        claimedSupply = await this.getSupplyClaimedByWallet(resolvedAddress);\n      } catch (e) {\n        // no-op\n      }\n      if (allowListEntry) {\n        maxClaimable = convertQuantityToBigNumber(allowListEntry.maxClaimable, decimals);\n      }\n      if (maxClaimable.gt(0) && maxClaimable.lt(claimedSupply.add(quantityWithDecimals))) {\n        reasons.push(ClaimEligibility.OverMaxClaimablePerWallet);\n        return reasons;\n      }\n\n      // if there is no allowlist, or if there is an allowlist and the address is not in it\n      // if maxClaimable is 0, we consider it as the address is not allowed\n      if (!hasAllowList || hasAllowList && !allowListEntry) {\n        if (maxClaimable.lte(claimedSupply) || maxClaimable.eq(0)) {\n          reasons.push(ClaimEligibility.AddressNotAllowed);\n          return reasons;\n        }\n      }\n    }\n\n    // check for claim timestamp between claims (ONLY FOR LEGACY)\n    if (this.isLegacySinglePhaseDrop(this.contractWrapper) || this.isLegacyMultiPhaseDrop(this.contractWrapper)) {\n      let [lastClaimedTimestamp, timestampForNextClaim] = [BigNumber.from(0), BigNumber.from(0)];\n      if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {\n        activeConditionIndex = await this.contractWrapper.read(\"getActiveClaimConditionId\", []);\n        [lastClaimedTimestamp, timestampForNextClaim] = await this.contractWrapper.read(\"getClaimTimestamp\", [activeConditionIndex, resolvedAddress]);\n      } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {\n        // check for claim timestamp between claims\n        [lastClaimedTimestamp, timestampForNextClaim] = await this.contractWrapper.read(\"getClaimTimestamp\", [resolvedAddress]);\n      }\n      const now = BigNumber.from(Date.now()).div(1000);\n      if (lastClaimedTimestamp.gt(0) && now.lt(timestampForNextClaim)) {\n        // contract will return MaxUint256 if user has already claimed and cannot claim again\n        if (timestampForNextClaim.eq(constants.MaxUint256)) {\n          reasons.push(ClaimEligibility.AlreadyClaimed);\n        } else {\n          reasons.push(ClaimEligibility.WaitBeforeNextClaimTransaction);\n        }\n        return reasons;\n      }\n    }\n\n    // if not within a browser conetext, check for wallet balance.\n    // In browser context, let the wallet do that job\n    if (claimCondition.price.gt(0) && isNode()) {\n      const totalPrice = claimCondition.price.mul(BigNumber.from(quantity));\n      const provider = this.contractWrapper.getProvider();\n      if (isNativeToken(claimCondition.currencyAddress)) {\n        const balance = await provider.getBalance(resolvedAddress);\n        if (balance.lt(totalPrice)) {\n          reasons.push(ClaimEligibility.NotEnoughTokens);\n        }\n      } else {\n        const erc20 = new ContractWrapper(provider, claimCondition.currencyAddress, ERC20Abi, {}, this.storage);\n        const balance = await erc20.read(\"balanceOf\", [resolvedAddress]);\n        if (balance.lt(totalPrice)) {\n          reasons.push(ClaimEligibility.NotEnoughTokens);\n        }\n      }\n    }\n    return reasons;\n  }\n\n  /**\n   * Returns allow list information and merkle proofs for the given address.\n   * @param claimerAddress - the claimer address\n   * @param claimConditionId - optional the claim condition id to get the proofs for\n   */\n  async getClaimerProofs(claimerAddress, claimConditionId) {\n    const claimCondition = await this.get(claimConditionId);\n    const merkleRoot = claimCondition.merkleRoot;\n    const merkleRootArray = utils.stripZeros(merkleRoot);\n    if (merkleRootArray.length > 0) {\n      const metadata = await this.metadata.get();\n      const resolvedAddress = await resolveAddress(claimerAddress);\n      return await fetchSnapshotEntryForAddress(resolvedAddress, merkleRoot.toString(), metadata.merkle, this.contractWrapper.getProvider(), this.storage, this.getSnapshotFormatVersion());\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Get the total supply claimed by a specific wallet\n   * @param walletAddress the wallet address to check\n   * @returns the total supply claimed\n   */\n  async getSupplyClaimedByWallet(walletAddress) {\n    const resolvedAddress = await resolveAddress(walletAddress);\n    if (this.isNewSinglePhaseDrop(this.contractWrapper)) {\n      return await this.contractWrapper.read(\"getSupplyClaimedByWallet\", [resolvedAddress]);\n    }\n    if (this.isNewMultiphaseDrop(this.contractWrapper)) {\n      const activeClaimConditionId = await this.contractWrapper.read(\"getActiveClaimConditionId\", []);\n      return await this.contractWrapper.read(\"getSupplyClaimedByWallet\", [activeClaimConditionId, resolvedAddress]);\n    }\n    throw new Error(\"This contract does not support the getSupplyClaimedByWallet function\");\n  }\n\n  /** ***************************************\n   * WRITE FUNCTIONS\n   *****************************************/\n\n  /**\n   * Set public mint conditions\n   *\n   * @remarks Sets the public mint conditions that need to be fullfiled by users to claim NFTs.\n   *\n   * @example\n   * ```javascript\n   * const presaleStartTime = new Date();\n   * const publicSaleStartTime = new Date(Date.now() + 60 * 60 * 24 * 1000);\n   *\n   * // Optionally specify addresses that can claim\n   * const snapshots = ['0x...', '0x...']\n   *\n   * // Or alternatively, you can pass snapshots with the max number of NFTs each address can claim\n   * // const snapshots = [{ address: '0x...', maxClaimable: 1 }, { address: '0x...', maxClaimable: 2 }]\n   *\n   * const claimConditions = [\n   *   {\n   *     startTime: presaleStartTime, // start the presale now\n   *     maxClaimableSupply: 2, // limit how many mints for this presale\n   *     price: 0.01, // presale price\n   *     snapshot: snapshots, // limit minting to only certain addresses\n   *   },\n   *   {\n   *     startTime: publicSaleStartTime, // 24h after presale, start public sale\n   *     price: 0.08, // public sale price\n   *   }\n   * ]);\n   *\n   * await dropContract.claimConditions.set(claimConditions);\n   * ```\n   *\n   * @param claimConditionInputs - The claim conditions\n   * @param resetClaimEligibilityForAll - Whether to reset the state of who already claimed NFTs previously\n   */\n  set = /* @__PURE__ */buildTransactionFunction((() => {\n    var _this = this;\n    return async function (claimConditionInputs) {\n      let resetClaimEligibilityForAll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      let claimConditionsProcessed = claimConditionInputs;\n      if (_this.isLegacySinglePhaseDrop(_this.contractWrapper) || _this.isNewSinglePhaseDrop(_this.contractWrapper)) {\n        resetClaimEligibilityForAll = true;\n        if (claimConditionInputs.length === 0) {\n          claimConditionsProcessed = [{\n            startTime: new Date(0),\n            currencyAddress: constants.AddressZero,\n            price: 0,\n            maxClaimableSupply: 0,\n            maxClaimablePerWallet: 0,\n            waitInSeconds: 0,\n            merkleRootHash: utils.hexZeroPad([0], 32),\n            snapshot: []\n          }];\n        } else if (claimConditionInputs.length > 1) {\n          throw new Error(\"Single phase drop contract cannot have multiple claim conditions, only one is allowed\");\n        }\n      }\n\n      // if using new snapshot format, make sure that maxClaimablePerWallet is set if allowlist is set as well\n      if (_this.isNewSinglePhaseDrop(_this.contractWrapper) || _this.isNewMultiphaseDrop(_this.contractWrapper)) {\n        claimConditionsProcessed.forEach(cc => {\n          if (cc.snapshot && cc.snapshot.length > 0 && (cc.maxClaimablePerWallet === undefined || cc.maxClaimablePerWallet === \"unlimited\")) {\n            throw new Error(\"maxClaimablePerWallet must be set to a specific value when an allowlist is set.\\n\" + \"Example: Set it to 0 to only allow addresses in the allowlist to claim the amount specified in the allowlist.\\n\" + \"contract.claimConditions.set([{ snapshot: [{ address: '0x...', maxClaimable: 1 }], maxClaimablePerWallet: 0 }])\");\n          }\n          if (cc.snapshot && cc.snapshot.length > 0 && cc.maxClaimablePerWallet?.toString() === \"0\" && cc.snapshot.map(s => {\n            if (typeof s === \"string\") {\n              return 0;\n            } else {\n              return Number(s.maxClaimable?.toString() || 0);\n            }\n          }).reduce((acc, current) => {\n            return acc + current;\n          }, 0) === 0) {\n            throw new Error(\"maxClaimablePerWallet is set to 0, and all addresses in the allowlist have max claimable 0. This means that no one can claim.\");\n          }\n        });\n      }\n\n      // process inputs\n      const {\n        snapshotInfos,\n        sortedConditions\n      } = await processClaimConditionInputs(claimConditionsProcessed, await _this.getTokenDecimals(), _this.contractWrapper.getProvider(), _this.storage, _this.getSnapshotFormatVersion());\n      const merkleInfo = {};\n      snapshotInfos.forEach(s => {\n        merkleInfo[s.merkleRoot] = s.snapshotUri;\n      });\n      const metadata = await _this.metadata.get();\n      const encoded = [];\n\n      // upload new merkle roots to snapshot URIs if updated\n      if (!deepEqual(metadata.merkle, merkleInfo)) {\n        const mergedMetadata = await _this.metadata.parseInputMetadata({\n          ...metadata,\n          merkle: merkleInfo\n        });\n        // using internal method to just upload, avoids one contract call\n        const contractURI = await _this.metadata._parseAndUploadMetadata(mergedMetadata);\n\n        // TODO (cc) we could write the merkle tree info on the claim condition metadata instead\n        // TODO (cc) but we still need to maintain the behavior here for older contracts\n        if (hasFunction(\"setContractURI\", _this.contractWrapper)) {\n          const contractEncoder = new ContractEncoder(_this.contractWrapper);\n          encoded.push(contractEncoder.encode(\"setContractURI\", [contractURI]));\n        } else {\n          throw new Error(\"Setting a merkle root requires implementing ContractMetadata in your contract to support storing a merkle root.\");\n        }\n      }\n      const cw = _this.contractWrapper;\n      const baseContractEncoder = new ContractEncoder(cw);\n      if (_this.isLegacySinglePhaseDrop(cw)) {\n        const contractEncoderLegacy = new ContractEncoder(cw);\n        encoded.push(contractEncoderLegacy.encode(\"setClaimConditions\", [abstractContractModelToLegacy(sortedConditions[0]), resetClaimEligibilityForAll]));\n      } else if (_this.isLegacyMultiPhaseDrop(cw)) {\n        encoded.push(baseContractEncoder.encode(\"setClaimConditions\", [sortedConditions.map(abstractContractModelToLegacy), resetClaimEligibilityForAll]));\n      } else if (_this.isNewSinglePhaseDrop(cw)) {\n        encoded.push(baseContractEncoder.encode(\"setClaimConditions\", [abstractContractModelToNew(sortedConditions[0]), resetClaimEligibilityForAll]));\n      } else if (_this.isNewMultiphaseDrop(cw)) {\n        encoded.push(baseContractEncoder.encode(\"setClaimConditions\", [sortedConditions.map(abstractContractModelToNew), resetClaimEligibilityForAll]));\n      } else {\n        throw new Error(\"Contract does not support claim conditions\");\n      }\n      if (hasFunction(\"multicall\", _this.contractWrapper)) {\n        return Transaction.fromContractWrapper({\n          contractWrapper: _this.contractWrapper,\n          method: \"multicall\",\n          args: [encoded]\n        });\n      }\n      throw new Error(\"Contract does not support multicall\");\n    };\n  })());\n\n  /**\n   * Update a single claim condition with new data.\n   *\n   * @param index - the index of the claim condition to update, as given by the index from the result of `getAll()`\n   * @param claimConditionInput - the new data to update, previous data will be retained\n   */\n  update = /* @__PURE__ */buildTransactionFunction(async (index, claimConditionInput) => {\n    const existingConditions = await this.getAll();\n    const newConditionInputs = await updateExistingClaimConditions(index, claimConditionInput, existingConditions);\n    return await this.set.prepare(newConditionInputs);\n  });\n\n  /** ***************************************\n   * PRIVATE FUNCTIONS\n   *****************************************/\n\n  async getTokenDecimals() {\n    if (detectContractFeature(this.contractWrapper, \"ERC20\")) {\n      return this.contractWrapper.read(\"decimals\", []);\n    } else {\n      return Promise.resolve(0);\n    }\n  }\n\n  /**\n   * Returns proofs and the overrides required for the transaction.\n   *\n   * @returns - `overrides` and `proofs` as an object.\n   * @internal\n   */\n  async prepareClaim(quantity, checkERC20Allowance) {\n    let decimals = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let address = arguments.length > 3 ? arguments[3] : undefined;\n    const addressToClaim = address ? address : await this.contractWrapper.getSignerAddress();\n    return prepareClaim(addressToClaim, quantity, await this.getActive(), async () => (await this.metadata.get()).merkle, decimals, this.contractWrapper, this.storage, checkERC20Allowance, this.getSnapshotFormatVersion());\n  }\n  async getClaimArguments(destinationAddress, quantity, claimVerification) {\n    const resolvedAddress = await resolveAddress(destinationAddress);\n    if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {\n      return [resolvedAddress, quantity, claimVerification.currencyAddress, claimVerification.price, claimVerification.proofs, claimVerification.maxClaimable];\n    } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {\n      return [resolvedAddress, quantity, claimVerification.currencyAddress, claimVerification.price, {\n        proof: claimVerification.proofs,\n        maxQuantityInAllowlist: claimVerification.maxClaimable\n      }, utils.toUtf8Bytes(\"\")];\n    }\n    return [resolvedAddress, quantity, claimVerification.currencyAddress, claimVerification.price, {\n      proof: claimVerification.proofs,\n      quantityLimitPerWallet: claimVerification.maxClaimable,\n      pricePerToken: claimVerification.priceInProof,\n      currency: claimVerification.currencyAddressInProof\n    }, utils.toUtf8Bytes(\"\")];\n  }\n\n  /**\n   * Construct a claim transaction without executing it.\n   * This is useful for estimating the gas cost of a claim transaction, overriding transaction options and having fine grained control over the transaction execution.\n   * @param destinationAddress\n   * @param quantity\n   * @param options\n   *\n   * @deprecated Use `contract.erc721.claim.prepare(...args)` instead\n   */\n  async getClaimTransaction(destinationAddress, quantity, options) {\n    // TODO: Transaction Sequence Pattern\n    if (options?.pricePerToken) {\n      throw new Error(\"Price per token is be set via claim conditions by calling `contract.erc721.claimConditions.set()`\");\n    }\n    const claimVerification = await this.prepareClaim(quantity, options?.checkERC20Allowance === undefined ? true : options.checkERC20Allowance, await this.getTokenDecimals());\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"claim\",\n      args: await this.getClaimArguments(destinationAddress, quantity, claimVerification),\n      overrides: claimVerification.overrides\n    });\n  }\n  isNewSinglePhaseDrop(contractWrapper) {\n    return detectContractFeature(contractWrapper, \"ERC721ClaimConditionsV2\") || detectContractFeature(contractWrapper, \"ERC20ClaimConditionsV2\");\n  }\n  isNewMultiphaseDrop(contractWrapper) {\n    return detectContractFeature(contractWrapper, \"ERC721ClaimPhasesV2\") || detectContractFeature(contractWrapper, \"ERC20ClaimPhasesV2\");\n  }\n  isLegacySinglePhaseDrop(contractWrapper) {\n    return detectContractFeature(contractWrapper, \"ERC721ClaimConditionsV1\") || detectContractFeature(contractWrapper, \"ERC20ClaimConditionsV1\");\n  }\n  isLegacyMultiPhaseDrop(contractWrapper) {\n    return detectContractFeature(contractWrapper, \"ERC721ClaimPhasesV1\") || detectContractFeature(contractWrapper, \"ERC20ClaimPhasesV1\");\n  }\n  getSnapshotFormatVersion() {\n    return this.isLegacyMultiPhaseDrop(this.contractWrapper) || this.isLegacySinglePhaseDrop(this.contractWrapper) ? SnapshotFormatVersion.V1 : SnapshotFormatVersion.V2;\n  }\n}\n\n/**\n * Manages claim conditions for Edition Drop contracts\n * @public\n */\nclass DropErc1155ClaimConditions {\n  constructor(contractWrapper, metadata, storage) {\n    this.storage = storage;\n    this.contractWrapper = contractWrapper;\n    this.metadata = metadata;\n  }\n\n  /** ***************************************\n   * READ FUNCTIONS\n   *****************************************/\n\n  /**\n   * Get the currently active claim condition\n   *\n   * @returns the claim condition metadata\n   */\n  async getActive(tokenId, options) {\n    const mc = await this.get(tokenId);\n    const metadata = await this.metadata.get();\n    return await transformResultToClaimCondition(mc, 0, this.contractWrapper.getProvider(), metadata.merkle, this.storage, options?.withAllowList || false);\n  }\n  async get(tokenId, conditionId) {\n    if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {\n      const contractModel = await this.contractWrapper.read(\"claimCondition\", [tokenId]);\n      return legacyContractModelToAbstract(contractModel);\n    } else if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {\n      const id = conditionId !== undefined ? conditionId : await this.contractWrapper.read(\"getActiveClaimConditionId\", [tokenId]);\n      const contractModel = await this.contractWrapper.read(\"getClaimConditionById\", [tokenId, id]);\n      return legacyContractModelToAbstract(contractModel);\n    } else if (this.isNewSinglePhaseDrop(this.contractWrapper)) {\n      const contractModel = await this.contractWrapper.read(\"claimCondition\", [tokenId]);\n      return newContractModelToAbstract(contractModel);\n    } else if (this.isNewMultiphaseDrop(this.contractWrapper)) {\n      const id = conditionId !== undefined ? conditionId : await this.contractWrapper.read(\"getActiveClaimConditionId\", [tokenId]);\n      const contractModel = await this.contractWrapper.read(\"getClaimConditionById\", [tokenId, id]);\n      return newContractModelToAbstract(contractModel);\n    } else {\n      throw new Error(\"Contract does not support claim conditions\");\n    }\n  }\n\n  /**\n   * Get all the claim conditions\n   *\n   * @returns the claim conditions metadata\n   */\n  async getAll(tokenId, options) {\n    if (this.isLegacyMultiPhaseDrop(this.contractWrapper) || this.isNewMultiphaseDrop(this.contractWrapper)) {\n      const claimCondition = await this.contractWrapper.read(\"claimCondition\", [tokenId]);\n      const startId = claimCondition.currentStartId.toNumber();\n      const count = claimCondition.count.toNumber();\n      const conditions = [];\n      for (let i = startId; i < startId + count; i++) {\n        conditions.push(await this.get(tokenId, i));\n      }\n      const metadata = await this.metadata.get();\n      return Promise.all(conditions.map(c => transformResultToClaimCondition(c, 0, this.contractWrapper.getProvider(), metadata.merkle, this.storage, options?.withAllowList || false)));\n    } else {\n      return [await this.getActive(tokenId, options)];\n    }\n  }\n\n  /**\n   * Can Claim\n   *\n   * @remarks Check if a particular NFT can currently be claimed by a given user.\n   *\n   * @example\n   * ```javascript\n   * // Quantity of tokens to check claimability of\n   * const quantity = 1;\n   * const canClaim = await contract.canClaim(quantity);\n   * ```\n   */\n  async canClaim(tokenId, quantity, addressToCheck) {\n    // TODO switch to use verifyClaim\n    if (addressToCheck) {\n      addressToCheck = await resolveAddress(addressToCheck);\n    }\n    return (await this.getClaimIneligibilityReasons(tokenId, quantity, addressToCheck)).length === 0;\n  }\n\n  /**\n   * For any claim conditions that a particular wallet is violating,\n   * this function returns human-readable information about the\n   * breaks in the condition that can be used to inform the user.\n   *\n   * @param tokenId - the token id to check\n   * @param quantity - The desired quantity that would be claimed.\n   * @param addressToCheck - The wallet address, defaults to the connected wallet.\n   *\n   */\n  async getClaimIneligibilityReasons(tokenId, quantity, addressToCheck) {\n    const reasons = [];\n    let activeConditionIndex;\n    let claimCondition;\n    if (addressToCheck === undefined) {\n      try {\n        addressToCheck = await this.contractWrapper.getSignerAddress();\n      } catch (err) {\n        console.warn(\"failed to get signer address\", err);\n      }\n    }\n\n    // if we have been unable to get a signer address, we can't check eligibility, so return a NoWallet error reason\n    if (!addressToCheck) {\n      return [ClaimEligibility.NoWallet];\n    }\n    const resolvedAddress = await resolveAddress(addressToCheck);\n    try {\n      claimCondition = await this.getActive(tokenId);\n    } catch (err) {\n      if (includesErrorMessage(err, \"!CONDITION\") || includesErrorMessage(err, \"no active mint condition\")) {\n        reasons.push(ClaimEligibility.NoClaimConditionSet);\n        return reasons;\n      }\n      reasons.push(ClaimEligibility.Unknown);\n      return reasons;\n    }\n    if (claimCondition.availableSupply !== \"unlimited\") {\n      if (BigNumber.from(claimCondition.availableSupply).lt(quantity)) {\n        reasons.push(ClaimEligibility.NotEnoughSupply);\n        return reasons;\n      }\n    }\n\n    // check for merkle root inclusion\n    const merkleRootArray = utils.stripZeros(claimCondition.merkleRootHash);\n    const hasAllowList = merkleRootArray.length > 0;\n    let allowListEntry = null;\n    if (hasAllowList) {\n      allowListEntry = await this.getClaimerProofs(tokenId, resolvedAddress);\n      if (!allowListEntry && (this.isLegacySinglePhaseDrop(this.contractWrapper) || this.isLegacyMultiPhaseDrop(this.contractWrapper))) {\n        // exclusive allowlist behavior\n        reasons.push(ClaimEligibility.AddressNotAllowed);\n        return reasons;\n      }\n      if (allowListEntry) {\n        try {\n          const claimVerification = await this.prepareClaim(tokenId, quantity, false, resolvedAddress);\n          let validMerkleProof;\n          if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {\n            activeConditionIndex = await this.contractWrapper.read(\"getActiveClaimConditionId\", [tokenId]);\n            // legacy verifyClaimerMerkleProofs function\n            [validMerkleProof] = await this.contractWrapper.read(\"verifyClaimMerkleProof\", [activeConditionIndex, resolvedAddress, tokenId, quantity, claimVerification.proofs, claimVerification.maxClaimable]);\n            if (!validMerkleProof) {\n              reasons.push(ClaimEligibility.AddressNotAllowed);\n              return reasons;\n            }\n          } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {\n            [validMerkleProof] = await this.contractWrapper.read(\"verifyClaimMerkleProof\", [tokenId, resolvedAddress, quantity, {\n              proof: claimVerification.proofs,\n              maxQuantityInAllowlist: claimVerification.maxClaimable\n            }]);\n            if (!validMerkleProof) {\n              reasons.push(ClaimEligibility.AddressNotAllowed);\n              return reasons;\n            }\n          } else if (this.isNewSinglePhaseDrop(this.contractWrapper)) {\n            await this.contractWrapper.read(\"verifyClaim\", [tokenId, resolvedAddress, quantity, claimVerification.currencyAddress, claimVerification.price, {\n              proof: claimVerification.proofs,\n              quantityLimitPerWallet: claimVerification.maxClaimable,\n              currency: claimVerification.currencyAddressInProof,\n              pricePerToken: claimVerification.priceInProof\n            }]);\n          } else if (this.isNewMultiphaseDrop(this.contractWrapper)) {\n            activeConditionIndex = await this.contractWrapper.read(\"getActiveClaimConditionId\", [tokenId]);\n            await this.contractWrapper.read(\"verifyClaim\", [activeConditionIndex, resolvedAddress, tokenId, quantity, claimVerification.currencyAddress, claimVerification.price, {\n              proof: claimVerification.proofs,\n              quantityLimitPerWallet: claimVerification.maxClaimable,\n              currency: claimVerification.currencyAddressInProof,\n              pricePerToken: claimVerification.priceInProof\n            }]);\n          }\n        } catch (e) {\n          console.warn(\"Merkle proof verification failed:\", \"reason\" in e ? e.reason : e);\n          const reason = e.reason;\n          switch (reason) {\n            case \"!Qty\":\n              reasons.push(ClaimEligibility.OverMaxClaimablePerWallet);\n              break;\n            case \"!PriceOrCurrency\":\n              reasons.push(ClaimEligibility.WrongPriceOrCurrency);\n              break;\n            case \"!MaxSupply\":\n              reasons.push(ClaimEligibility.NotEnoughSupply);\n              break;\n            case \"cant claim yet\":\n              reasons.push(ClaimEligibility.ClaimPhaseNotStarted);\n              break;\n            default:\n              {\n                reasons.push(ClaimEligibility.AddressNotAllowed);\n                break;\n              }\n          }\n          return reasons;\n        }\n      }\n    }\n    if (this.isNewSinglePhaseDrop(this.contractWrapper) || this.isNewMultiphaseDrop(this.contractWrapper)) {\n      let claimedSupply = BigNumber.from(0);\n      let maxClaimable = convertQuantityToBigNumber(claimCondition.maxClaimablePerWallet, 0);\n      try {\n        claimedSupply = await this.getSupplyClaimedByWallet(tokenId, resolvedAddress);\n      } catch (e) {\n        // no-op\n      }\n      if (allowListEntry) {\n        maxClaimable = convertQuantityToBigNumber(allowListEntry.maxClaimable, 0);\n      }\n      if (maxClaimable.gt(0) && maxClaimable.lt(claimedSupply.add(quantity))) {\n        reasons.push(ClaimEligibility.OverMaxClaimablePerWallet);\n        return reasons;\n      }\n\n      // if there is no allowlist, or if there is an allowlist and the address is not in it\n      // if maxClaimable is 0, we consider it as the address is not allowed\n      if (!hasAllowList || hasAllowList && !allowListEntry) {\n        if (maxClaimable.lte(claimedSupply) || maxClaimable.eq(0)) {\n          reasons.push(ClaimEligibility.AddressNotAllowed);\n          return reasons;\n        }\n      }\n    }\n\n    // check for claim timestamp between claims\n    let [lastClaimedTimestamp, timestampForNextClaim] = [BigNumber.from(0), BigNumber.from(0)];\n    if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {\n      activeConditionIndex = await this.contractWrapper.read(\"getActiveClaimConditionId\", [tokenId]);\n      [lastClaimedTimestamp, timestampForNextClaim] = await this.contractWrapper.read(\"getClaimTimestamp\", [tokenId, activeConditionIndex, resolvedAddress]);\n    } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {\n      [lastClaimedTimestamp, timestampForNextClaim] = await this.contractWrapper.read(\"getClaimTimestamp\", [tokenId, resolvedAddress]);\n    }\n    const now = BigNumber.from(Date.now()).div(1000);\n    if (lastClaimedTimestamp.gt(0) && now.lt(timestampForNextClaim)) {\n      // contract will return MaxUint256 if user has already claimed and cannot claim again\n      if (timestampForNextClaim.eq(constants.MaxUint256)) {\n        reasons.push(ClaimEligibility.AlreadyClaimed);\n      } else {\n        reasons.push(ClaimEligibility.WaitBeforeNextClaimTransaction);\n      }\n      return reasons;\n    }\n\n    // if not within a browser conetext, check for wallet balance.\n    // In browser context, let the wallet do that job\n    if (claimCondition.price.gt(0) && isNode()) {\n      const totalPrice = claimCondition.price.mul(quantity);\n      const provider = this.contractWrapper.getProvider();\n      if (isNativeToken(claimCondition.currencyAddress)) {\n        const balance = await provider.getBalance(resolvedAddress);\n        if (balance.lt(totalPrice)) {\n          reasons.push(ClaimEligibility.NotEnoughTokens);\n        }\n      } else {\n        const erc20 = new ContractWrapper(provider, claimCondition.currencyAddress, ERC20Abi, {}, this.storage);\n        const balance = await erc20.read(\"balanceOf\", [resolvedAddress]);\n        if (balance.lt(totalPrice)) {\n          reasons.push(ClaimEligibility.NotEnoughTokens);\n        }\n      }\n    }\n    return reasons;\n  }\n\n  /**\n   * Returns allow list information and merkle proofs for the given address.\n   * @param tokenId - the token ID to check\n   * @param claimerAddress - the claimer address\n   * @param claimConditionId - optional the claim condition id to get the proofs for\n   */\n  async getClaimerProofs(tokenId, claimerAddress, claimConditionId) {\n    const claimCondition = await this.get(tokenId, claimConditionId);\n    const merkleRoot = claimCondition.merkleRoot;\n    const merkleRootArray = utils.stripZeros(merkleRoot);\n    if (merkleRootArray.length > 0) {\n      const metadata = await this.metadata.get();\n      const resolvedAddress = await resolveAddress(claimerAddress);\n      return await fetchSnapshotEntryForAddress(resolvedAddress, merkleRoot.toString(), metadata.merkle, this.contractWrapper.getProvider(), this.storage, this.getSnapshotFormatVersion());\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Get the total supply claimed by a specific wallet\n   * @param walletAddress the wallet address to check\n   * @returns the total supply claimed\n   */\n  async getSupplyClaimedByWallet(tokenId, walletAddress) {\n    const resolvedAddress = await resolveAddress(walletAddress);\n    if (this.isNewSinglePhaseDrop(this.contractWrapper)) {\n      return await this.contractWrapper.read(\"getSupplyClaimedByWallet\", [tokenId, resolvedAddress]);\n    }\n    if (this.isNewMultiphaseDrop(this.contractWrapper)) {\n      const activeClaimConditionId = await this.contractWrapper.read(\"getActiveClaimConditionId\", [tokenId]);\n      return await this.contractWrapper.read(\"getSupplyClaimedByWallet\", [tokenId, activeClaimConditionId, resolvedAddress]);\n    }\n    throw new Error(\"This contract does not support the getSupplyClaimedByWallet function\");\n  }\n\n  /** ***************************************\n   * WRITE FUNCTIONS\n   *****************************************/\n\n  /**\n   * Set claim conditions on a single NFT\n   *\n   * @remarks Sets the public mint conditions that need to be fulfilled by users to claim a particular NFT in this contract.\n   *\n   * @example\n   * ```javascript\n   * const presaleStartTime = new Date();\n   * const publicSaleStartTime = new Date(Date.now() + 60 * 60 * 24 * 1000);\n   *\n   * // Optionally specify addresses that can claim\n   * const snapshots = ['0x...', '0x...']\n   *\n   * // Or alternatively, you can pass snapshots with the max number of NFTs each address can claim\n   * // const snapshots = [{ address: '0x...', maxClaimable: 1 }, { address: '0x...', maxClaimable: 2 }]\n   *\n   * const claimConditions = [\n   *   {\n   *     startTime: presaleStartTime, // start the presale now\n   *     maxClaimableSupply: 2, // limit how many mints for this presale\n   *     price: 0.01, // presale price\n   *     snapshot: snapshots, // limit minting to only certain addresses\n   *   },\n   *   {\n   *     startTime: publicSaleStartTime, // 24h after presale, start public sale\n   *     price: 0.08, // public sale price\n   *   }\n   * ]);\n   *\n   * const tokenId = 0; // the id of the NFT to set claim conditions on\n   * await dropContract.claimConditions.set(tokenId, claimConditions);\n   * ```\n   *\n   * @param tokenId - The id of the NFT to set the claim conditions on\n   * @param claimConditionInputs - The claim conditions\n   * @param resetClaimEligibilityForAll - Whether to reset the state of who already claimed NFTs previously\n   */\n  set = /* @__PURE__ */buildTransactionFunction((() => {\n    var _this = this;\n    return async function (tokenId, claimConditionInputs) {\n      let resetClaimEligibilityForAll = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      return _this.setBatch.prepare([{\n        tokenId,\n        claimConditions: claimConditionInputs\n      }], resetClaimEligibilityForAll);\n    };\n  })());\n\n  /**\n   * Set claim conditions on multiple NFTs at once\n   *\n   * @remarks Sets the claim conditions that need to be fulfilled by users to claim the given NFTs in this contract.\n   *\n   * @example\n   * ```javascript\n   * const claimConditionsForTokens = [\n   *   {\n   *     tokenId: 0,\n   *     claimConditions: [{\n   *       startTime: new Date(), // start the claim phase now\n   *       maxClaimableSupply: 2, // limit how many mints for this tokenId\n   *       price: 0.01, // price for this tokenId\n   *       snapshot: ['0x...', '0x...'], // limit minting to only certain addresses\n   *     }]\n   *   },\n   *   {\n   *     tokenId: 1,\n   *     claimConditions: [{\n   *       startTime: new Date(),\n   *       price: 0.08, // different price for this tokenId\n   *     }]\n   *   },\n   * ];\n   *\n   * await dropContract.claimConditions.setBatch(claimConditionsForTokens);\n   * ```\n   *\n   * @param claimConditionsForToken - The claim conditions for each NFT\n   * @param resetClaimEligibilityForAll - Whether to reset the state of who already claimed NFTs previously\n   */\n  setBatch = /* @__PURE__ */buildTransactionFunction((() => {\n    var _this2 = this;\n    return async function (claimConditionsForToken) {\n      let resetClaimEligibilityForAll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      const merkleInfo = {};\n      const processedClaimConditions = await Promise.all(claimConditionsForToken.map(async _ref => {\n        let {\n          tokenId,\n          claimConditions\n        } = _ref;\n        // sanitize for single phase deletions\n        let claimConditionsProcessed = claimConditions;\n        if (_this2.isLegacySinglePhaseDrop(_this2.contractWrapper)) {\n          resetClaimEligibilityForAll = true;\n          if (claimConditions.length === 0) {\n            claimConditionsProcessed = [{\n              startTime: new Date(0),\n              currencyAddress: constants.AddressZero,\n              price: 0,\n              maxClaimableSupply: 0,\n              maxClaimablePerWallet: 0,\n              waitInSeconds: 0,\n              merkleRootHash: utils.hexZeroPad([0], 32),\n              snapshot: []\n            }];\n          } else if (claimConditions.length > 1) {\n            throw new Error(\"Single phase drop contract cannot have multiple claim conditions, only one is allowed\");\n          }\n        }\n        // if using new snapshot format, make sure that maxClaimablePerWallet is set if allowlist is set as well\n        if (_this2.isNewSinglePhaseDrop(_this2.contractWrapper) || _this2.isNewMultiphaseDrop(_this2.contractWrapper)) {\n          claimConditionsProcessed.forEach(cc => {\n            if (cc.snapshot && cc.snapshot.length > 0 && (cc.maxClaimablePerWallet === undefined || cc.maxClaimablePerWallet === \"unlimited\")) {\n              throw new Error(\"maxClaimablePerWallet must be set to a specific value when an allowlist is set.\\n\" + \"Set it to 0 to only allow addresses in the allowlist to claim the amount specified in the allowlist.\" + \"\\n\\nex:\\n\" + \"contract.claimConditions.set(tokenId, [{ snapshot: [{ address: '0x...', maxClaimable: 1 }], maxClaimablePerWallet: 0 }])\");\n            }\n            if (cc.snapshot && cc.snapshot.length > 0 && cc.maxClaimablePerWallet?.toString() === \"0\" && cc.snapshot.map(s => {\n              if (typeof s === \"string\") {\n                return 0;\n              } else {\n                return Number(s.maxClaimable?.toString() || 0);\n              }\n            }).reduce((acc, current) => {\n              return acc + current;\n            }, 0) === 0) {\n              throw new Error(\"maxClaimablePerWallet is set to 0, and all addresses in the allowlist have max claimable 0. This means that no one can claim.\");\n            }\n          });\n        }\n        // process inputs\n        const {\n          snapshotInfos,\n          sortedConditions\n        } = await processClaimConditionInputs(claimConditionsProcessed, 0, _this2.contractWrapper.getProvider(), _this2.storage, _this2.getSnapshotFormatVersion());\n        snapshotInfos.forEach(s => {\n          merkleInfo[s.merkleRoot] = s.snapshotUri;\n        });\n        return {\n          tokenId,\n          sortedConditions\n        };\n      }));\n      const metadata = await _this2.metadata.get();\n      const encoded = [];\n\n      // keep the old merkle roots from other tokenIds\n      for (const key of Object.keys(metadata.merkle || {})) {\n        merkleInfo[key] = metadata.merkle[key];\n      }\n\n      // upload new merkle roots to snapshot URIs if updated\n      if (!deepEqual(metadata.merkle, merkleInfo)) {\n        const mergedMetadata = await _this2.metadata.parseInputMetadata({\n          ...metadata,\n          merkle: merkleInfo\n        });\n        // using internal method to just upload, avoids one contract call\n        const contractURI = await _this2.metadata._parseAndUploadMetadata(mergedMetadata);\n        if (hasFunction(\"setContractURI\", _this2.contractWrapper)) {\n          const contractEncoder = new ContractEncoder(_this2.contractWrapper);\n          encoded.push(contractEncoder.encode(\"setContractURI\", [contractURI]));\n        } else {\n          throw new Error(\"Setting a merkle root requires implementing ContractMetadata in your contract to support storing a merkle root.\");\n        }\n      }\n      processedClaimConditions.forEach(_ref2 => {\n        let {\n          tokenId,\n          sortedConditions\n        } = _ref2;\n        const baseContractEncoder = new ContractEncoder(_this2.contractWrapper);\n        if (_this2.isLegacySinglePhaseDrop(_this2.contractWrapper)) {\n          const legacyContractEncoder = new ContractEncoder(_this2.contractWrapper);\n          encoded.push(legacyContractEncoder.encode(\"setClaimConditions\", [tokenId, abstractContractModelToLegacy(sortedConditions[0]), resetClaimEligibilityForAll]));\n        } else if (_this2.isLegacyMultiPhaseDrop(_this2.contractWrapper)) {\n          encoded.push(baseContractEncoder.encode(\"setClaimConditions\", [tokenId, sortedConditions.map(abstractContractModelToLegacy), resetClaimEligibilityForAll]));\n        } else if (_this2.isNewSinglePhaseDrop(_this2.contractWrapper)) {\n          encoded.push(baseContractEncoder.encode(\"setClaimConditions\", [tokenId, abstractContractModelToNew(sortedConditions[0]), resetClaimEligibilityForAll]));\n        } else if (_this2.isNewMultiphaseDrop(_this2.contractWrapper)) {\n          encoded.push(baseContractEncoder.encode(\"setClaimConditions\", [tokenId, sortedConditions.map(abstractContractModelToNew), resetClaimEligibilityForAll]));\n        } else {\n          throw new Error(\"Contract does not support claim conditions\");\n        }\n      });\n      if (hasFunction(\"multicall\", _this2.contractWrapper)) {\n        return Transaction.fromContractWrapper({\n          contractWrapper: _this2.contractWrapper,\n          method: \"multicall\",\n          args: [encoded]\n        });\n      }\n      throw new Error(\"Contract does not support multicall\");\n    };\n  })());\n\n  /**\n   * Update a single claim condition with new data.\n   * @param tokenId - the token id to update\n   * @param index - the index of the claim condition to update, as given by the index from the result of `getAll()`\n   * @param claimConditionInput - the new data to update, previous data will be retained\n   */\n  update = /* @__PURE__ */buildTransactionFunction(async (tokenId, index, claimConditionInput) => {\n    const existingConditions = await this.getAll(tokenId);\n    const newConditionInputs = await updateExistingClaimConditions(index, claimConditionInput, existingConditions);\n    return await this.set.prepare(tokenId, newConditionInputs);\n  });\n\n  /**\n   * Returns proofs and the overrides required for the transaction.\n   *\n   * @returns - `overrides` and `proofs` as an object.\n   */\n  async prepareClaim(tokenId, quantity, checkERC20Allowance, address) {\n    const addressToClaim = await resolveAddress(address ? address : await this.contractWrapper.getSignerAddress());\n    return prepareClaim(addressToClaim, quantity, await this.getActive(tokenId), async () => (await this.metadata.get()).merkle, 0, this.contractWrapper, this.storage, checkERC20Allowance, this.getSnapshotFormatVersion());\n  }\n  async getClaimArguments(tokenId, destinationAddress, quantity, claimVerification) {\n    const resolvedAddress = await resolveAddress(destinationAddress);\n    if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {\n      return [resolvedAddress, tokenId, quantity, claimVerification.currencyAddress, claimVerification.price, claimVerification.proofs, claimVerification.maxClaimable];\n    } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {\n      return [resolvedAddress, tokenId, quantity, claimVerification.currencyAddress, claimVerification.price, {\n        proof: claimVerification.proofs,\n        maxQuantityInAllowlist: claimVerification.maxClaimable\n      }, utils.toUtf8Bytes(\"\")];\n    }\n    return [resolvedAddress, tokenId, quantity, claimVerification.currencyAddress, claimVerification.price, {\n      proof: claimVerification.proofs,\n      quantityLimitPerWallet: claimVerification.maxClaimable,\n      pricePerToken: claimVerification.priceInProof,\n      currency: claimVerification.currencyAddressInProof\n    }, utils.toUtf8Bytes(\"\")];\n  }\n\n  /**\n   * Construct a claim transaction without executing it.\n   * This is useful for estimating the gas cost of a claim transaction, overriding transaction options and having fine grained control over the transaction execution.\n   * @param destinationAddress - Address you want to send the token to\n   * @param tokenId - Id of the token you want to claim\n   * @param quantity - Quantity of the tokens you want to claim\n   *\n   * @deprecated Use `contract.erc1155.claim.prepare(...args)` instead\n   */\n  async getClaimTransaction(destinationAddress, tokenId, quantity, options) {\n    if (options?.pricePerToken) {\n      throw new Error(\"Price per token should be set via claim conditions by calling `contract.erc1155.claimConditions.set()`\");\n    }\n    const claimVerification = await this.prepareClaim(tokenId, quantity, options?.checkERC20Allowance || true);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"claim\",\n      args: await this.getClaimArguments(tokenId, destinationAddress, quantity, claimVerification),\n      overrides: claimVerification.overrides\n    });\n  }\n  isNewSinglePhaseDrop(contractWrapper) {\n    return detectContractFeature(contractWrapper, \"ERC1155ClaimConditionsV2\");\n  }\n  isNewMultiphaseDrop(contractWrapper) {\n    return detectContractFeature(contractWrapper, \"ERC1155ClaimPhasesV2\");\n  }\n  isLegacySinglePhaseDrop(contractWrapper) {\n    return detectContractFeature(contractWrapper, \"ERC1155ClaimConditionsV1\");\n  }\n  isLegacyMultiPhaseDrop(contractWrapper) {\n    return detectContractFeature(contractWrapper, \"ERC1155ClaimPhasesV1\");\n  }\n  getSnapshotFormatVersion() {\n    return this.isLegacyMultiPhaseDrop(this.contractWrapper) || this.isLegacySinglePhaseDrop(this.contractWrapper) ? SnapshotFormatVersion.V1 : SnapshotFormatVersion.V2;\n  }\n}\n\n/**\n * Mint Many ERC20 Tokens at once\n * @remarks Token batch minting functionality that handles unit parsing for you.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * await contract.token.mint.batch.to(walletAddress, [nftMetadata1, nftMetadata2, ...]);\n * ```\n * @public\n */\n\nclass Erc20BatchMintable {\n  featureName = FEATURE_TOKEN_BATCH_MINTABLE.name;\n  constructor(erc20, contractWrapper) {\n    this.erc20 = erc20;\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * Mint Tokens To Many Wallets\n   *\n   * @remarks Mint tokens to many wallets in one transaction.\n   *\n   * @example\n   * ```javascript\n   * // Data of the tokens you want to mint\n   * const data = [\n   *   {\n   *     toAddress: \"{{wallet_address}}\", // Address to mint tokens to\n   *     amount: 0.2, // How many tokens to mint to specified address\n   *   },\n   *  {\n   *    toAddress: \"0x...\",\n   *    amount: 1.4,\n   *  }\n   * ]\n   *\n   * await contract.token.mint.batch(data);\n   * ```\n   */\n  to = /* @__PURE__ */buildTransactionFunction(async args => {\n    const encoded = [];\n    const contractEncoder = new ContractEncoder(this.contractWrapper);\n    for (const arg of args) {\n      encoded.push(contractEncoder.encode(\"mintTo\", [await resolveAddress(arg.toAddress), await this.erc20.normalizeAmount(arg.amount)]));\n    }\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"multicall\",\n      args: [encoded]\n    });\n  });\n}\nclass Erc20Burnable {\n  featureName = FEATURE_TOKEN_BURNABLE.name;\n  constructor(erc20, contractWrapper) {\n    this.erc20 = erc20;\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * Burn Tokens\n   *\n   * @remarks Burn tokens held by the connected wallet\n   *\n   * @example\n   * ```javascript\n   * // The amount of this token you want to burn\n   * const amount = 1.2;\n   *\n   * await contract.token.burn.tokens(amount);\n   * ```\n   */\n  tokens = /* @__PURE__ */buildTransactionFunction(async amount => {\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"burn\",\n      args: [await this.erc20.normalizeAmount(amount)]\n    });\n  });\n\n  /**\n   * Burn Tokens\n   *\n   * @remarks Burn tokens held by the specified wallet\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet sending the tokens\n   * const holderAddress = \"{{wallet_address}}\";\n   *\n   * // The amount of this token you want to burn\n   * const amount = 1.2;\n   *\n   * await contract.token.burn.from(holderAddress, amount);\n   * ```\n   */\n  from = /* @__PURE__ */buildTransactionFunction(async (holder, amount) => {\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"burnFrom\",\n      args: [await resolveAddress(holder), await this.erc20.normalizeAmount(amount)]\n    });\n  });\n}\n\n/**\n * Configure and claim ERC20 tokens\n * @remarks Manage claim phases and claim ERC20 tokens that have been lazily minted.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * await contract.token.drop.claim.to(\"0x...\", quantity);\n * ```\n */\n\nclass Erc20ClaimableWithConditions {\n  featureName = FEATURE_TOKEN_CLAIM_CONDITIONS_V2.name;\n  /**\n   * Configure claim conditions\n   * @remarks Define who can claim NFTs in the collection, when and how many.\n   * @example\n   * ```javascript\n   * const presaleStartTime = new Date();\n   * const publicSaleStartTime = new Date(Date.now() + 60 * 60 * 24 * 1000);\n   * const claimConditions = [\n   *   {\n   *     startTime: presaleStartTime, // start the presale now\n   *     maxClaimableSupply: 2, // limit how many mints for this presale\n   *     price: 0.01, // presale price\n   *     snapshot: ['0x...', '0x...'], // limit minting to only certain addresses\n   *   },\n   *   {\n   *     startTime: publicSaleStartTime, // 24h after presale, start public sale\n   *     price: 0.08, // public sale price\n   *   }\n   * ]);\n   * await contract.token.drop.claim.conditions.set(claimConditions);\n   * ```\n   */\n\n  constructor(erc20, contractWrapper, storage) {\n    this.erc20 = erc20;\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n    const metadata = new ContractMetadata(this.contractWrapper, CustomContractSchema, this.storage);\n    this.conditions = new DropClaimConditions(this.contractWrapper, metadata, this.storage);\n  }\n\n  /**\n   * Claim a certain amount of tokens to a specific Wallet\n   *\n   * @remarks Let the specified wallet claim Tokens.\n   *\n   * @example\n   * ```javascript\n   * const address = \"{{wallet_address}}\"; // address of the wallet you want to claim the NFTs\n   * const quantity = 42.69; // how many tokens you want to claim\n   *\n   * const tx = await contract.token.drop.claim.to(address, quantity);\n   * const receipt = tx.receipt; // the transaction receipt\n   * ```\n   *\n   * @param destinationAddress - Address you want to send the token to\n   * @param amount - Quantity of the tokens you want to claim\n   * @param checkERC20Allowance - Optional, check if the wallet has enough ERC20 allowance to claim the tokens, and if not, approve the transfer\n   * @param claimData\n   * @returns - The transaction receipt\n   */\n  to = /* @__PURE__ */buildTransactionFunction(async (destinationAddress, amount, options) => {\n    const quantity = await this.erc20.normalizeAmount(amount);\n    return await this.conditions.getClaimTransaction(destinationAddress, quantity, options);\n  });\n}\n\n/**\n * Configure and claim ERC20 tokens\n * @remarks Manage claim phases and claim ERC20 tokens that have been lazily minted.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * await contract.token.drop.claim.to(\"0x...\", quantity);\n * ```\n */\n\nclass Erc20Droppable {\n  /**\n   * Configure claim conditions\n   * @remarks Define who can claim NFTs in the collection, when and how many.\n   * @example\n   * ```javascript\n   * const presaleStartTime = new Date();\n   * const publicSaleStartTime = new Date(Date.now() + 60 * 60 * 24 * 1000);\n   * const claimConditions = [\n   *   {\n   *     startTime: presaleStartTime, // start the presale now\n   *     maxClaimableSupply: 2, // limit how many mints for this presale\n   *     price: 0.01, // presale price\n   *     snapshot: ['0x...', '0x...'], // limit minting to only certain addresses\n   *   },\n   *   {\n   *     startTime: publicSaleStartTime, // 24h after presale, start public sale\n   *     price: 0.08, // public sale price\n   *   }\n   * ]);\n   * await contract.nft.drop.claim.conditions.set(claimConditions);\n   * ```\n   */\n\n  constructor(erc20, contractWrapper, storage) {\n    this.erc20 = erc20;\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n    this.claim = new Erc20ClaimableWithConditions(this.erc20, this.contractWrapper, this.storage);\n  }\n}\n\n/**\n * Mint ERC20 Tokens\n * @remarks Token minting functionality that handles unit parsing for you.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * await contract.nft.mint.to(walletAddress, nftMetadata);\n * ```\n * @public\n */\n\nclass Erc20Mintable {\n  featureName = FEATURE_TOKEN_MINTABLE.name;\n\n  /**\n   * Batch mint Tokens to many addresses\n   */\n\n  constructor(erc20, contractWrapper) {\n    this.erc20 = erc20;\n    this.contractWrapper = contractWrapper;\n    this.batch = this.detectErc20BatchMintable();\n  }\n\n  /**\n   * Mint Tokens\n   *\n   * @remarks Mint tokens to a specified address.\n   *\n   * @example\n   * ```javascript\n   * const toAddress = \"{{wallet_address}}\"; // Address of the wallet you want to mint the tokens to\n   * const amount = \"1.5\"; // The amount of this token you want to mint\n   * await contract.token.mint.to(toAddress, amount);\n   * ```\n   */\n  to = /* @__PURE__ */buildTransactionFunction(async (to, amount) => {\n    return await this.getMintTransaction(to, amount);\n  });\n\n  /**\n   * @deprecated Use `contract.erc20.mint.prepare(...args)` instead\n   */\n  async getMintTransaction(to, amount) {\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"mintTo\",\n      args: [await resolveAddress(to), await this.erc20.normalizeAmount(amount)]\n    });\n  }\n  detectErc20BatchMintable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC20BatchMintable\")) {\n      return new Erc20BatchMintable(this.erc20, this.contractWrapper);\n    }\n    return undefined;\n  }\n}\nasync function setErc20Allowance(contractToApprove, value, currencyAddress, overrides) {\n  if (isNativeToken(currencyAddress)) {\n    overrides[\"value\"] = value;\n  } else {\n    const signer = contractToApprove.getSigner();\n    const provider = contractToApprove.getProvider();\n    const erc20 = new ContractWrapper(signer || provider, currencyAddress, ERC20Abi, contractToApprove.options, contractToApprove.storage);\n    const owner = await contractToApprove.getSignerAddress();\n    const spender = contractToApprove.address;\n    const allowance = await erc20.read(\"allowance\", [owner, spender]);\n    if (allowance.lt(value)) {\n      // approve overrides the previous allowance, set it to the minimum required for this tx\n      await erc20.sendTransaction(\"approve\", [spender, value]);\n    }\n    return overrides;\n  }\n}\n\n/**\n * Enables generating ERC20 Tokens with rules and an associated signature, which can then be minted by anyone securely\n * @public\n */\n// TODO consolidate into a single class\n\nclass Erc20SignatureMintable {\n  featureName = FEATURE_TOKEN_SIGNATURE_MINTABLE.name;\n  constructor(contractWrapper, roles) {\n    this.contractWrapper = contractWrapper;\n    this.roles = roles;\n  }\n\n  /**\n   * Mint tokens from a signature\n   *\n   * @remarks Mint a certain amount of tokens from a previously generated signature.\n   *\n   * @example\n   * ```javascript\n   * // see how to craft a payload to sign in the `generate()` documentation\n   * const signedPayload = contract.erc20.signature.generate(payload);\n   *\n   * // Use the signed payload to mint the tokens\n   * const tx = contract.erc20.signature.mint(signedPayload);\n   * ```\n   * @param signedPayload - the previously generated payload and signature with {@link Erc20SignatureMintable.generate}\n   * @twfeature ERC20SignatureMintable\n   */\n  mint = /* @__PURE__ */buildTransactionFunction(async signedPayload => {\n    const mintRequest = signedPayload.payload;\n    const signature = signedPayload.signature;\n    const message = await this.mapPayloadToContractStruct(mintRequest);\n    const overrides = await this.contractWrapper.getCallOverrides();\n    // TODO: Transaction Sequence Pattern\n    await setErc20Allowance(this.contractWrapper, BigNumber.from(message.price), mintRequest.currencyAddress, overrides);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"mintWithSignature\",\n      args: [message, signature],\n      overrides\n    });\n  });\n\n  /**\n   * Mint any number of generated tokens signatures at once\n   * @remarks Mint multiple token signatures in one transaction. Note that this is only possible for free mints (cannot batch mints with a price attached to it for security reasons)\n   * @param signedPayloads - the array of signed payloads to mint\n   * @twfeature ERC20SignatureMintable\n   */\n  mintBatch = /* @__PURE__ */buildTransactionFunction(async signedPayloads => {\n    const contractPayloads = await Promise.all(signedPayloads.map(async s => {\n      const message = await this.mapPayloadToContractStruct(s.payload);\n      const signature = s.signature;\n      const price = s.payload.price;\n      if (BigNumber.from(price).gt(0)) {\n        throw new Error(\"Can only batch free mints. For mints with a price, use regular mint()\");\n      }\n      return {\n        message,\n        signature\n      };\n    }));\n    const contractEncoder = new ContractEncoder(this.contractWrapper);\n    const encoded = contractPayloads.map(p => {\n      return contractEncoder.encode(\"mintWithSignature\", [p.message, p.signature]);\n    });\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"multicall\",\n      args: [encoded]\n    });\n  });\n\n  /**\n   * Verify that a payload is correctly signed\n   * @param signedPayload - the payload to verify\n   * @twfeature ERC20SignatureMintable\n   *\n   * ```javascript\n   * const startTime = new Date();\n   * const endTime = new Date(Date.now() + 60 * 60 * 24 * 1000);\n   * const payload = {\n   *   quantity: 4.2, // The quantity of tokens to be minted\n   *   to: {{wallet_address}}, // Who will receive the tokens\n   *   price: 0.5, // the price to pay for minting those tokens\n   *   currencyAddress: NATIVE_TOKEN_ADDRESS, // the currency to pay with\n   *   mintStartTime: startTime, // can mint anytime from now\n   *   mintEndTime: endTime, // to 24h from now,\n   *   primarySaleRecipient: \"0x...\", // custom sale recipient for this token mint\n   * };\n   *\n   * const signedPayload = await contract.erc20.signature.generate(payload);\n   * // Now you can verify if the signed payload is valid\n   * const isValid = await contract.erc20.signature.verify(signedPayload);\n   * ```\n   */\n  async verify(signedPayload) {\n    const mintRequest = signedPayload.payload;\n    const signature = signedPayload.signature;\n    const message = await this.mapPayloadToContractStruct(mintRequest);\n    const verification = await this.contractWrapper.read(\"verify\", [message, signature]);\n    return verification[0];\n  }\n\n  /**\n   * Generate a signature that can be used to mint a certain amount of tokens\n   *\n   * @remarks Takes in a quantity of tokens, some conditions for how it can be minted and signs it with your private key. The generated signature can then be used to mint those tokens using the exact payload and signature generated.\n   *\n   * @example\n   * ```javascript\n   * const startTime = new Date();\n   * const endTime = new Date(Date.now() + 60 * 60 * 24 * 1000);\n   * const payload = {\n   *   quantity: 4.2, // The quantity of tokens to be minted\n   *   to: {{wallet_address}}, // Who will receive the tokens\n   *   price: 0.5, // the price to pay for minting those tokens\n   *   currencyAddress: NATIVE_TOKEN_ADDRESS, // the currency to pay with\n   *   mintStartTime: startTime, // can mint anytime from now\n   *   mintEndTime: endTime, // to 24h from now,\n   *   primarySaleRecipient: \"0x...\", // custom sale recipient for this token mint\n   * };\n   *\n   * const signedPayload = await contract.erc20.signature.generate(payload);\n   * // now anyone can use these to mint the NFT using `contract.erc20.signature.mint(signedPayload)`\n   * ```\n   * @param mintRequest - the payload to sign\n   * @returns the signed payload and the corresponding signature\n   * @twfeature ERC20SignatureMintable\n   */\n  async generate(mintRequest) {\n    return (await this.generateBatch([mintRequest]))[0];\n  }\n\n  /**\n   * Generate a batch of signatures that can be used to mint many token signatures.\n   *\n   * @remarks See {@link Erc20SignatureMintable.generate}\n   *\n   * @param payloadsToSign - the payloads to sign\n   * @returns an array of payloads and signatures\n   * @twfeature ERC20SignatureMintable\n   */\n  async generateBatch(payloadsToSign) {\n    await this.roles?.verify([\"minter\"], await this.contractWrapper.getSignerAddress());\n    const parsedRequests = await Promise.all(payloadsToSign.map(m => Signature20PayloadInput.parseAsync(m)));\n    const chainId = await this.contractWrapper.getChainID();\n    const signer = this.contractWrapper.getSigner();\n    invariant(signer, \"No signer available\");\n\n    // ERC20Permit (EIP-712) spec differs from signature mint 721, 1155.\n    const name = await this.contractWrapper.read(\"name\", []);\n    return await Promise.all(parsedRequests.map(async m => {\n      const finalPayload = await Signature20PayloadOutput.parseAsync(m);\n      const signature = await this.contractWrapper.signTypedData(signer, {\n        name,\n        version: \"1\",\n        chainId,\n        verifyingContract: this.contractWrapper.address\n      }, {\n        MintRequest: MintRequest20\n      }, await this.mapPayloadToContractStruct(finalPayload));\n      return {\n        payload: finalPayload,\n        signature: signature.toString()\n      };\n    }));\n  }\n\n  /** ******************************\n   * PRIVATE FUNCTIONS\n   *******************************/\n  /**\n   * Maps a payload to the format expected by the contract\n   *\n   * @internal\n   *\n   * @param mintRequest - The payload to map.\n   * @returns - The mapped payload.\n   */\n  async mapPayloadToContractStruct(mintRequest) {\n    const normalizedPrice = await normalizePriceValue(this.contractWrapper.getProvider(), mintRequest.price, mintRequest.currencyAddress);\n    const amountWithDecimals = utils.parseUnits(mintRequest.quantity, await this.contractWrapper.read(\"decimals\", []));\n    return {\n      to: mintRequest.to,\n      primarySaleRecipient: mintRequest.primarySaleRecipient,\n      quantity: amountWithDecimals,\n      price: normalizedPrice,\n      currency: mintRequest.currencyAddress,\n      validityEndTimestamp: mintRequest.mintEndTime,\n      validityStartTimestamp: mintRequest.mintStartTime,\n      uid: mintRequest.uid\n    };\n  }\n}\n\n/**\n * Checks whether the given DetectableFeature is defined\n * @internal\n * @param namespace The namespace to check\n * @param feature The corresponding feature\n */\nfunction assertEnabled(namespace, feature) {\n  if (!namespace) {\n    throw new ExtensionNotImplementedError(feature);\n  }\n  return namespace;\n}\nasync function normalizeAmount(contractWrapper, amount) {\n  const decimals = await contractWrapper.read(\"decimals\", []);\n  return utils.parseUnits(AmountSchema.parse(amount), decimals);\n}\n\n/**\n * Standard ERC20 Token functions\n * @remarks Basic functionality for a ERC20 contract that handles all unit transformation for you.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * await contract.erc20.transfer(walletAddress, amount);\n * ```\n * @public\n */\nclass Erc20 {\n  featureName = FEATURE_TOKEN.name;\n  /**\n   * Mint tokens\n   */\n\n  get chainId() {\n    return this._chainId;\n  }\n  constructor(contractWrapper, storage, chainId) {\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n    this.mintable = this.detectErc20Mintable();\n    this.burnable = this.detectErc20Burnable();\n    this.droppable = this.detectErc20Droppable();\n    this.signatureMintable = this.detectErc20SignatureMintable();\n    this._chainId = chainId;\n  }\n\n  /**\n   * @internal\n   */\n  onNetworkUpdated(network) {\n    this.contractWrapper.updateSignerOrProvider(network);\n  }\n\n  /**\n   * @internal\n   */\n  getAddress() {\n    return this.contractWrapper.address;\n  }\n\n  ////// Standard ERC20 Extension //////\n\n  /**\n   * Get the token metadata\n   * @remarks name, symbol, etc...\n   * @example\n   * ```javascript\n   * const token = await contract.erc20.get();\n   * ```\n   * @returns The token metadata\n   * @twfeature ERC20\n   */\n  async get() {\n    return await fetchCurrencyMetadata(this.contractWrapper.getProvider(), this.getAddress());\n  }\n\n  /**\n   * Get token balance for the currently connected wallet\n   *\n   * @remarks Get a wallets token balance.\n   *\n   * @example\n   * ```javascript\n   * const balance = await contract.erc20.balance();\n   * ```\n   *\n   * @returns The balance of a specific wallet.\n   * @twfeature ERC20\n   */\n  async balance() {\n    return await this.balanceOf(await this.contractWrapper.getSignerAddress());\n  }\n\n  /**\n   * Get token balance for a specific wallet\n   *\n   * @remarks Get a wallets token balance.\n   *\n   * @example\n   * ```javascript\n   * const walletAddress = \"{{wallet_address}}\";\n   * const balance = await contract.erc20.balanceOf(walletAddress);\n   * ```\n   *\n   * @returns The balance of a specific wallet.\n   * @twfeature ERC20\n   */\n  async balanceOf(address) {\n    return this.getValue(await this.contractWrapper.read(\"balanceOf\", [await resolveAddress(address)]));\n  }\n\n  /**\n   * Get the total supply for this token\n   * @remarks Get how much supply has been minted\n   * @example\n   * ```javascript\n   * const balance = await contract.erc20.totalSupply();\n   * ```\n   * @twfeature ERC20\n   */\n  async totalSupply() {\n    return await this.getValue(await this.contractWrapper.read(\"totalSupply\", []));\n  }\n\n  /**\n   * Get token allowance\n   *\n   * @remarks Get the allowance of a 'spender' wallet over the connected wallet's funds - the allowance of a different address for a token is the amount of tokens that the `spender` wallet is allowed to spend on behalf of the connected wallet.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet to check token allowance\n   * const spenderAddress = \"0x...\";\n   * const allowance = await contract.erc20.allowance(spenderAddress);\n   * ```\n   *\n   * @returns The allowance of one wallet over anothers funds.\n   * @twfeature ERC20\n   */\n  async allowance(spender) {\n    const [owner, spenderAddress] = await Promise.all([this.contractWrapper.getSignerAddress(), resolveAddress(spender)]);\n    return await this.allowanceOf(owner, spenderAddress);\n  }\n\n  /**\n   * Get token allowance of a specific wallet\n   *\n   * @remarks Get the allowance of one wallet over another wallet's funds - the allowance of a different address for a token is the amount of tokens that the wallet is allowed to spend on behalf of the specified wallet.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet who owns the funds\n   * const owner = \"{{wallet_address}}\";\n   * // Address of the wallet to check token allowance\n   * const spender = \"0x...\";\n   * const allowance = await contract.erc20.allowanceOf(owner, spender);\n   * ```\n   *\n   * @returns The allowance of one wallet over anothers funds.\n   * @twfeature ERC20\n   */\n  async allowanceOf(owner, spender) {\n    const args = await Promise.all([resolveAddress(owner), resolveAddress(spender)]);\n    return await this.getValue(await this.contractWrapper.read(\"allowance\", args));\n  }\n\n  /**\n   * Transfer tokens\n   *\n   * @remarks Transfer tokens from the connected wallet to another wallet.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet you want to send the tokens to\n   * const toAddress = \"0x...\";\n   * // The amount of tokens you want to send\n   * const amount = 0.1;\n   * await contract.erc20.transfer(toAddress, amount);\n   * ```\n   * @twfeature ERC20\n   */\n  transfer = /* @__PURE__ */buildTransactionFunction(async (to, amount) => {\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"transfer\",\n      args: await Promise.all([resolveAddress(to), this.normalizeAmount(amount)])\n    });\n  });\n\n  /**\n   * Transfer tokens from a specific address\n   *\n   * @remarks Transfer tokens from one wallet to another\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet sending the tokens\n   * const fromAddress = \"{{wallet_address}}\";\n   * // Address of the wallet you want to send the tokens to\n   * const toAddress = \"0x...\";\n   * // The number of tokens you want to send\n   * const amount = 1.2\n   * // Note that the connected wallet must have approval to transfer the tokens of the fromAddress\n   * await contract.erc20.transferFrom(fromAddress, toAddress, amount);\n   * ```\n   * @twfeature ERC20\n   */\n  transferFrom = /* @__PURE__ */buildTransactionFunction(async (from, to, amount) => {\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"transferFrom\",\n      args: await Promise.all([resolveAddress(from), resolveAddress(to), this.normalizeAmount(amount)])\n    });\n  });\n\n  /**\n   * Set token allowance\n   * @remarks Allows the specified `spender` wallet to transfer the given `amount` of tokens to another wallet\n   * @example\n   * ```javascript\n   * // Address of the wallet to allow transfers from\n   * const spenderAddress = \"0x...\";\n   * // The number of tokens to give as allowance\n   * const amount = 100\n   * await contract.erc20.setAllowance(spenderAddress, amount);\n   * ```\n   * @twfeature ERC20\n   */\n  setAllowance = /* @__PURE__ */buildTransactionFunction(async (spender, amount) => {\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"approve\",\n      args: await Promise.all([resolveAddress(spender), this.normalizeAmount(amount)])\n    });\n  });\n\n  /**\n   * Transfer tokens to many wallets\n   *\n   * @remarks Mint tokens from the connected wallet to many wallets\n   *\n   * @example\n   * ```javascript\n   * // Data of the tokens you want to mint\n   * const data = [\n   *   {\n   *     toAddress: \"{{wallet_address}}\", // Address to mint tokens to\n   *     amount: 100, // How many tokens to mint to specified address\n   *   },\n   *  {\n   *    toAddress: \"0x...\",\n   *    amount: 100,\n   *  }\n   * ]\n   *\n   * await contract.erc20.transferBatch(data);\n   * ```\n   */\n  transferBatch = /* @__PURE__ */buildTransactionFunction(async args => {\n    const contractEncoder = new ContractEncoder(this.contractWrapper);\n    const encoded = (await Promise.all(args.map(arg => Promise.all([this.normalizeAmount(arg.amount), resolveAddress(arg.toAddress)])))).map(_ref => {\n      let [amountWithDecimals, address] = _ref;\n      return contractEncoder.encode(\"transfer\", [address, amountWithDecimals]);\n    });\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"multicall\",\n      args: [encoded]\n    });\n  });\n\n  ////// ERC20 Mintable Extension //////\n\n  /**\n   * Mint tokens\n   *\n   * @remarks Mint tokens to the connected wallet.\n   *\n   * @example\n   * ```javascript\n   * const amount = \"1.5\"; // The amount of this token you want to mint\n   * await contract.erc20.mint(amount);\n   * ```\n   * @twfeature ERC20Mintable\n   */\n  mint = /* @__PURE__ */buildTransactionFunction(async amount => {\n    return this.mintTo.prepare(await this.contractWrapper.getSignerAddress(), amount);\n  });\n\n  /**\n   * Mint tokens to a specific wallet\n   *\n   * @remarks Mint tokens to a specified address.\n   *\n   * @example\n   * ```javascript\n   * const toAddress = \"{{wallet_address}}\"; // Address of the wallet you want to mint the tokens to\n   * const amount = \"1.5\"; // The amount of this token you want to mint\n   * await contract.erc20.mintTo(toAddress, amount);\n   * ```\n   * @twfeature ERC20Mintable\n   */\n  mintTo = /* @__PURE__ */buildTransactionFunction(async (receiver, amount) => {\n    return assertEnabled(this.mintable, FEATURE_TOKEN_MINTABLE).to.prepare(receiver, amount);\n  });\n\n  /**\n   * Construct a mint transaction without executing it\n   * @remarks This is useful for estimating the gas cost of a mint transaction, overriding transaction options and having fine grained control over the transaction execution.\n   * @param receiver - Address you want to send the token to\n   * @param amount - The amount of tokens you want to mint\n   *\n   * @deprecated Use `contract.erc20.mint.prepare(...args)` instead\n   * @twfeature ERC20Mintable\n   */\n  async getMintTransaction(receiver, amount) {\n    return assertEnabled(this.mintable, FEATURE_TOKEN_MINTABLE).getMintTransaction(receiver, amount);\n  }\n\n  ////// ERC20 BatchMintable Extension //////\n\n  /**\n   * Mint tokens to many wallets\n   *\n   * @remarks Mint tokens to many wallets in one transaction.\n   *\n   * @example\n   * ```javascript\n   * // Data of the tokens you want to mint\n   * const data = [\n   *   {\n   *     toAddress: \"{{wallet_address}}\", // Address to mint tokens to\n   *     amount: 0.2, // How many tokens to mint to specified address\n   *   },\n   *  {\n   *    toAddress: \"0x...\",\n   *    amount: 1.4,\n   *  }\n   * ]\n   *\n   * await contract.mintBatchTo(data);\n   * ```\n   * @twfeature ERC20BatchMintable\n   */\n  mintBatchTo = /* @__PURE__ */buildTransactionFunction(async args => {\n    return assertEnabled(this.mintable?.batch, FEATURE_TOKEN_BATCH_MINTABLE).to.prepare(args);\n  });\n\n  ////// ERC20 Burnable Extension //////\n\n  /**\n   * Burn tokens\n   *\n   * @remarks Burn tokens held by the connected wallet\n   *\n   * @example\n   * ```javascript\n   * // The amount of this token you want to burn\n   * const amount = 1.2;\n   *\n   * await contract.erc20.burn(amount);\n   * ```\n   * @twfeature ERC20Burnable\n   */\n  burn = /* @__PURE__ */buildTransactionFunction(async amount => {\n    return assertEnabled(this.burnable, FEATURE_TOKEN_BURNABLE).tokens.prepare(amount);\n  });\n\n  /**\n   * Burn tokens from a specific wallet\n   *\n   * @remarks Burn tokens held by the specified wallet\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet sending the tokens\n   * const holderAddress = \"{{wallet_address}}\";\n   *\n   * // The amount of this token you want to burn\n   * const amount = 1.2;\n   *\n   * await contract.erc20.burnFrom(holderAddress, amount);\n   * ```\n   * @twfeature ERC20Burnable\n   */\n  burnFrom = /* @__PURE__ */buildTransactionFunction(async (holder, amount) => {\n    return assertEnabled(this.burnable, FEATURE_TOKEN_BURNABLE).from.prepare(holder, amount);\n  });\n\n  ////// ERC20 Claimable Extension //////\n\n  /**\n   * Claim tokens\n   *\n   * @remarks Let the specified wallet claim Tokens.\n   *\n   * @example\n   * ```javascript\n   * const address = \"{{wallet_address}}\"; // address of the wallet you want to claim the NFTs\n   * const quantity = 42.69; // how many tokens you want to claim\n   *\n   * const tx = await contract.erc20.claim(address, quantity);\n   * const receipt = tx.receipt; // the transaction receipt\n   * ```\n   *\n   * @param destinationAddress - Address you want to send the token to\n   * @param amount - Quantity of the tokens you want to claim\n   * @param checkERC20Allowance - Optional, check if the wallet has enough ERC20 allowance to claim the tokens, and if not, approve the transfer\n   * @param claimData\n   * @returns - The transaction receipt\n   * @twfeature ERC20ClaimPhasesV2 | ERC20ClaimPhasesV1 | ERC20ClaimConditionsV2 | ERC20ClaimConditionsV1\n   */\n  claim = /* @__PURE__ */buildTransactionFunction(async (amount, options) => {\n    return this.claimTo.prepare(await this.contractWrapper.getSignerAddress(), amount, options);\n  });\n\n  /**\n   * Claim tokens to a specific wallet\n   *\n   * @remarks Let the specified wallet claim Tokens.\n   *\n   * @example\n   * ```javascript\n   * const address = \"{{wallet_address}}\"; // address of the wallet you want to claim the NFTs\n   * const quantity = 42.69; // how many tokens you want to claim\n   *\n   * const tx = await contract.erc20.claim(address, quantity);\n   * const receipt = tx.receipt; // the transaction receipt\n   * ```\n   *\n   * @param destinationAddress - Address you want to send the token to\n   * @param amount - Quantity of the tokens you want to claim\n   * @param checkERC20Allowance - Optional, check if the wallet has enough ERC20 allowance to claim the tokens, and if not, approve the transfer\n   * @param claimData\n   * @returns - The transaction receipt\n   * @twfeature ERC20ClaimPhasesV2 | ERC20ClaimPhasesV1 | ERC20ClaimConditionsV2 | ERC20ClaimConditionsV1\n   */\n  claimTo = /* @__PURE__ */buildTransactionFunction(async (destinationAddress, amount, options) => {\n    return assertEnabled(this.droppable?.claim, FEATURE_TOKEN_CLAIM_CONDITIONS_V2).to.prepare(destinationAddress, amount, options);\n  });\n\n  /**\n   * Configure claim conditions\n   * @remarks Define who can claim NFTs in the collection, when and how many.\n   * @example\n   * ```javascript\n   * const presaleStartTime = new Date();\n   * const publicSaleStartTime = new Date(Date.now() + 60 * 60 * 24 * 1000);\n   * const claimConditions = [\n   *   {\n   *     startTime: presaleStartTime, // start the presale now\n   *     maxClaimableSupply: 2, // limit how many mints for this presale\n   *     price: 0.01, // presale price\n   *     snapshot: ['0x...', '0x...'], // limit minting to only certain addresses\n   *   },\n   *   {\n   *     startTime: publicSaleStartTime, // 24h after presale, start public sale\n   *     price: 0.08, // public sale price\n   *   }\n   * ]);\n   * await contract.erc20.claimConditions.set(claimConditions);\n   * ```\n   * @twfeature ERC20ClaimPhasesV2 | ERC20ClaimPhasesV1 | ERC20ClaimConditionsV2 | ERC20ClaimConditionsV1\n   */\n  get claimConditions() {\n    return assertEnabled(this.droppable?.claim, FEATURE_TOKEN_CLAIM_CONDITIONS_V2).conditions;\n  }\n\n  ////// ERC20 SignatureMint Extension //////\n\n  /**\n   * Mint with signature\n   * @remarks Generate dynamic tokens with your own signature, and let others mint them using that signature.\n   * @example\n   * ```javascript\n   * // see how to craft a payload to sign in the `contract.erc20.signature.generate()` documentation\n   * const signedPayload = contract.erc20.signature().generate(payload);\n   *\n   * // now the payload can be used to mint tokens\n   * const tx = contract.erc20.signature.mint(signedPayload);\n   * ```\n   * @twfeature ERC20SignatureMintable\n   */\n  get signature() {\n    return assertEnabled(this.signatureMintable, FEATURE_TOKEN_SIGNATURE_MINTABLE);\n  }\n\n  /** ******************************\n   * PRIVATE FUNCTIONS\n   *******************************/\n\n  /**\n   * returns the wei amount from a token amount\n   * @internal\n   * @param amount\n   */\n  async normalizeAmount(amount) {\n    return normalizeAmount(this.contractWrapper, amount);\n  }\n\n  /**\n   * @internal\n   */\n  async getValue(value) {\n    return await fetchCurrencyValue(this.contractWrapper.getProvider(), this.getAddress(), BigNumber.from(value));\n  }\n  detectErc20Mintable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC20\")) {\n      return new Erc20Mintable(this, this.contractWrapper);\n    }\n    return undefined;\n  }\n  detectErc20Burnable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC20Burnable\")) {\n      return new Erc20Burnable(this, this.contractWrapper);\n    }\n    return undefined;\n  }\n  detectErc20Droppable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC20ClaimConditionsV1\") || detectContractFeature(this.contractWrapper, \"ERC20ClaimConditionsV2\") || detectContractFeature(this.contractWrapper, \"ERC20ClaimPhasesV1\") || detectContractFeature(this.contractWrapper, \"ERC20ClaimPhasesV2\")) {\n      return new Erc20Droppable(this, this.contractWrapper, this.storage);\n    }\n    return undefined;\n  }\n  detectErc20SignatureMintable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC20SignatureMintable\")) {\n      return new Erc20SignatureMintable(this.contractWrapper);\n    }\n    return undefined;\n  }\n}\n\n/**\n * Mint Many ERC721 NFTs at once\n * @remarks NFT batch minting functionality that handles IPFS storage for you.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * await contract.nft.mint.batch.to(walletAddress, [nftMetadata1, nftMetadata2, ...]);\n * ```\n * @public\n */\n\nclass Erc721BatchMintable {\n  featureName = FEATURE_NFT_BATCH_MINTABLE.name;\n  constructor(erc721, contractWrapper, storage) {\n    this.erc721 = erc721;\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n  }\n\n  /**\n   * Mint Many unique NFTs\n   *\n   * @remarks Mint many unique NFTs at once to a specified wallet.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet you want to mint the NFT to\n   * const walletAddress = \"{{wallet_address}}\";\n   *\n   * // Custom metadata of the NFTs you want to mint.\n   * const metadatas = [{\n   *   name: \"Cool NFT #1\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   * }, {\n   *   name: \"Cool NFT #2\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/other/image.png\"),\n   * }];\n   *\n   * const tx = await contract.mint.batch.to(walletAddress, metadatas);\n   * const receipt = tx[0].receipt; // same transaction receipt for all minted NFTs\n   * const firstTokenId = tx[0].id; // token id of the first minted NFT\n   * const firstNFT = await tx[0].data(); // (optional) fetch details of the first minted NFT\n   * ```\n   */\n  to = /* @__PURE__ */buildTransactionFunction(async (to, metadatas) => {\n    const [uris, resolvedAddress] = await Promise.all([uploadOrExtractURIs(metadatas, this.storage), resolveAddress(to)]);\n    const contractEncoder = new ContractEncoder(this.contractWrapper);\n    const encoded = uris.map(uri => contractEncoder.encode(\"mintTo\", [resolvedAddress, uri]));\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"multicall\",\n      args: [encoded],\n      parse: receipt => {\n        const events = this.contractWrapper.parseLogs(\"TokensMinted\", receipt.logs);\n        if (events.length === 0 || events.length < metadatas.length) {\n          throw new Error(\"TokenMinted event not found, minting failed\");\n        }\n        return events.map(e => {\n          const id = e.args.tokenIdMinted;\n          return {\n            id,\n            receipt,\n            data: () => this.erc721.get(id)\n          };\n        });\n      }\n    });\n  });\n}\n\n/**\n * Configure and claim ERC721 NFTs\n * @remarks Manage claim phases and claim ERC721 NFTs that have been lazily minted.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * await contract.erc721.claim(quantity);\n * await contract.erc721.claimConditions.getActive();\n * ```\n */\n\nclass Erc721ClaimableWithConditions {\n  featureName = FEATURE_NFT_CLAIM_CONDITIONS_V2.name;\n\n  /**\n   * Configure claim conditions\n   * @remarks Define who can claim NFTs in the collection, when and how many.\n   * @example\n   * ```javascript\n   * const presaleStartTime = new Date();\n   * const publicSaleStartTime = new Date(Date.now() + 60 * 60 * 24 * 1000);\n   * const claimConditions = [\n   *   {\n   *     startTime: presaleStartTime, // start the presale now\n   *     maxClaimableSupply: 2, // limit how many mints for this presale\n   *     price: 0.01, // presale price\n   *     snapshot: ['0x...', '0x...'], // limit minting to only certain addresses\n   *   },\n   *   {\n   *     startTime: publicSaleStartTime, // 24h after presale, start public sale\n   *     price: 0.08, // public sale price\n   *   }\n   * ]);\n   * await contract.erc721.claimConditions.set(claimConditions);\n   * ```\n   */\n\n  constructor(erc721, contractWrapper, storage) {\n    this.erc721 = erc721;\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n    const metadata = new ContractMetadata(this.contractWrapper, CustomContractSchema, this.storage);\n    this.conditions = new DropClaimConditions(this.contractWrapper, metadata, this.storage);\n  }\n\n  /**\n   * Claim unique NFTs to a specific Wallet\n   *\n   * @remarks Let the specified wallet claim NFTs.\n   *\n   * @example\n   * ```javascript\n   * const address = \"{{wallet_address}}\"; // address of the wallet you want to claim the NFTs\n   * const quantity = 1; // how many unique NFTs you want to claim\n   *\n   * const tx = await contract.erc721.claimTo(address, quantity);\n   * const receipt = tx[0].receipt; // the transaction receipt\n   * const claimedTokenId = tx[0].id; // the id of the first NFT claimed\n   * const claimedNFT = await tx[0].data(); // (optional) get the first claimed NFT metadata\n   * ```\n   *\n   * @param destinationAddress - Address you want to send the token to\n   * @param quantity - Quantity of the tokens you want to claim\n   * @param options\n   * @returns - an array of results containing the id of the token claimed, the transaction receipt and a promise to optionally fetch the nft metadata\n   */\n  to = /* @__PURE__ */buildTransactionFunction(async (destinationAddress, quantity, options) => {\n    // TODO: Transaction Sequence Pattern\n    const tx = await this.conditions.getClaimTransaction(destinationAddress, quantity, options);\n    tx.setParse(receipt => {\n      const event = this.contractWrapper.parseLogs(\"TokensClaimed\", receipt?.logs);\n      const startingIndex = event[0].args.startTokenId;\n      const endingIndex = startingIndex.add(quantity);\n      const results = [];\n      for (let id = startingIndex; id.lt(endingIndex); id = id.add(1)) {\n        results.push({\n          id,\n          receipt,\n          data: () => this.erc721.get(id)\n        });\n      }\n      return results;\n    });\n    return tx;\n  });\n}\nasync function calculateClaimCost(contractWrapper, pricePerToken, quantity, currencyAddress, checkERC20Allowance) {\n  let overrides = {};\n  const currency = currencyAddress || NATIVE_TOKEN_ADDRESS;\n  const normalizedPrice = await normalizePriceValue(contractWrapper.getProvider(), pricePerToken, currency);\n  const totalCost = normalizedPrice.mul(quantity);\n  if (totalCost.gt(0)) {\n    if (currency === NATIVE_TOKEN_ADDRESS) {\n      overrides = {\n        value: totalCost\n      };\n    } else if (currency !== NATIVE_TOKEN_ADDRESS && checkERC20Allowance) {\n      await approveErc20Allowance(contractWrapper, currency, totalCost, quantity, 0);\n    }\n  }\n  return overrides;\n}\n\n/**\n * Configure and claim ERC721 NFTs\n * @remarks Manage claim phases and claim ERC721 NFTs that have been lazily minted.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * await contract.erc721.claim(tokenId, quantity);\n * ```\n */\n\nclass Erc721Claimable {\n  featureName = FEATURE_NFT_CLAIM_CUSTOM.name;\n  constructor(erc721, contractWrapper) {\n    this.erc721 = erc721;\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * Construct a claim transaction without executing it.\n   * This is useful for estimating the gas cost of a claim transaction, overriding transaction options and having fine grained control over the transaction execution.\n   * @param destinationAddress - Address you want to send the token to\n   * @param tokenId - Id of the token you want to claim\n   * @param quantity - Quantity of the tokens you want to claim\n   * @param options - Options for claiming the NFTs\n   *\n   * @deprecated Use `contract.erc721.claim.prepare(...args)` instead\n   */\n  async getClaimTransaction(destinationAddress, quantity, options) {\n    // TODO: Transaction Sequence Pattern\n    let overrides = {};\n    if (options && options.pricePerToken) {\n      overrides = await calculateClaimCost(this.contractWrapper, options.pricePerToken, quantity, options.currencyAddress, options.checkERC20Allowance);\n    }\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"claim\",\n      args: [destinationAddress, quantity],\n      overrides\n    });\n  }\n\n  /**\n   * Claim NFTs to a specific Wallet\n   *\n   * @remarks Let the specified wallet claim NFTs.\n   *\n   * @example\n   * ```javascript\n   * const address = \"{{wallet_address}}\"; // address of the wallet you want to claim the NFTs\n   * const quantity = 1; // how many NFTs you want to claim\n   *\n   * const tx = await contract.erc721.claimTo(address, quantity);\n   * const receipt = tx[0].receipt; // the transaction receipt\n   * ```\n   *\n   * @param destinationAddress - Address you want to send the token to\n   * @param quantity - Quantity of the tokens you want to claim\n   * @param options - Options for claiming the NFTs\n   *\n   * @returns - Receipt for the transaction\n   */\n  to = /* @__PURE__ */buildTransactionFunction(async (destinationAddress, quantity, options) => {\n    // TODO: Transaction Sequence Pattern\n    const tx = await this.getClaimTransaction(destinationAddress, quantity, options);\n    tx.setParse(receipt => {\n      const event = this.contractWrapper.parseLogs(\"TokensClaimed\", receipt?.logs);\n      const startingIndex = event[0].args.startTokenId;\n      const endingIndex = startingIndex.add(quantity);\n      const results = [];\n      for (let id = startingIndex; id.lt(endingIndex); id = id.add(1)) {\n        results.push({\n          id,\n          receipt,\n          data: () => this.erc721.get(id)\n        });\n      }\n      return results;\n    });\n    return tx;\n  });\n}\n\n/**\n * Lazily mint and claim ERC721 NFTs\n * @remarks Manage claim phases and claim ERC721 NFTs that have been lazily minted.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * await contract.drop.claim(quantity);\n * ```\n */\n\nclass Erc721LazyMintable {\n  featureName = FEATURE_NFT_LAZY_MINTABLE.name;\n\n  /**\n   * Delayed reveal\n   * @remarks Create a batch of encrypted NFTs that can be revealed at a later time.\n   * @example\n   * ```javascript\n   * // the real NFTs, these will be encrypted until you reveal them\n   * const realNFTs = [{\n   *   name: \"Common NFT #1\",\n   *   description: \"Common NFT, one of many.\",\n   *   image: fs.readFileSync(\"path/to/image.png\"),\n   * }, {\n   *   name: \"Super Rare NFT #2\",\n   *   description: \"You got a Super Rare NFT!\",\n   *   image: fs.readFileSync(\"path/to/image.png\"),\n   * }];\n   * // A placeholder NFT that people will get immediately in their wallet, and will be converted to the real NFT at reveal time\n   * const placeholderNFT = {\n   *   name: \"Hidden NFT\",\n   *   description: \"Will be revealed next week!\"\n   * };\n   * // Create and encrypt the NFTs\n   * await contract.nft.drop.revealer.createDelayedRevealBatch(\n   *   placeholderNFT,\n   *   realNFTs,\n   *   \"my secret password\",\n   * );\n   * // Whenever you're ready, reveal your NFTs at any time\n   * const batchId = 0; // the batch to reveal\n   * await contract.erc721.revealer.reveal(batchId, \"my secret password\");\n   * ```\n   */\n\n  constructor(erc721, contractWrapper, storage) {\n    this.erc721 = erc721;\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n    this.revealer = this.detectErc721Revealable();\n  }\n\n  /**\n   * Create a batch of unique NFTs to be claimed in the future\n   *\n   * @remarks Create batch allows you to create a batch of many unique NFTs in one transaction.\n   *\n   * @example\n   * ```javascript\n   * // Custom metadata of the NFTs to create\n   * const metadatas = [{\n   *   name: \"Cool NFT\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   * }, {\n   *   name: \"Cool NFT\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"),\n   * }];\n   *\n   * const results = await contract.erc721.lazyMint(metadatas); // uploads and creates the NFTs on chain\n   * const firstTokenId = results[0].id; // token id of the first created NFT\n   * const firstNFT = await results[0].data(); // (optional) fetch details of the first created NFT\n   * ```\n   *\n   * @param metadatas - The metadata to include in the batch.\n   * @param options - optional upload progress callback\n   */\n  lazyMint = /* @__PURE__ */buildTransactionFunction(async (metadatas, options) => {\n    const startFileNumber = await this.erc721.nextTokenIdToMint();\n    const batch = await uploadOrExtractURIs(metadatas, this.storage, startFileNumber.toNumber(), options);\n    // ensure baseUri is the same for the entire batch\n    const baseUri = getBaseUriFromBatch(batch);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"lazyMint\",\n      args: [batch.length, baseUri.endsWith(\"/\") ? baseUri : `${baseUri}/`, utils.toUtf8Bytes(\"\")],\n      parse: receipt => {\n        const event = this.contractWrapper.parseLogs(\"TokensLazyMinted\", receipt?.logs);\n        const startingIndex = event[0].args.startTokenId;\n        const endingIndex = event[0].args.endTokenId;\n        const results = [];\n        for (let id = startingIndex; id.lte(endingIndex); id = id.add(1)) {\n          results.push({\n            id,\n            receipt,\n            data: () => this.erc721.getTokenMetadata(id)\n          });\n        }\n        return results;\n      }\n    });\n  });\n\n  /** ******************************\n   * PRIVATE FUNCTIONS\n   *******************************/\n  detectErc721Revealable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC721Revealable\")) {\n      return new DelayedReveal(this.contractWrapper, this.storage, FEATURE_NFT_REVEALABLE.name, () => this.erc721.nextTokenIdToMint());\n    }\n    return undefined;\n  }\n}\n\n/**\n * Mint ERC721 NFTs\n * @remarks NFT minting functionality that handles IPFS storage for you.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * await contract.nft.mint.to(walletAddress, nftMetadata);\n * ```\n * @public\n */\n\nclass Erc721Mintable {\n  featureName = FEATURE_NFT_MINTABLE.name;\n  constructor(erc721, contractWrapper, storage) {\n    this.erc721 = erc721;\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n    this.batch = this.detectErc721BatchMintable();\n  }\n\n  /**\n   * Mint a unique NFT\n   *\n   * @remarks Mint a unique NFT to a specified wallet.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet you want to mint the NFT to\n   * const walletAddress = \"{{wallet_address}}\";\n   *\n   * // Custom metadata of the NFT, note that you can fully customize this metadata with other properties.\n   * const metadata = {\n   *   name: \"Cool NFT\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   * };\n   *\n   * const tx = await contract.nft.mint.to(walletAddress, metadata);\n   * const receipt = tx.receipt; // the transaction receipt\n   * const tokenId = tx.id; // the id of the NFT minted\n   * const nft = await tx.data(); // (optional) fetch details of minted NFT\n   * ```\n   */\n  to = /* @__PURE__ */buildTransactionFunction(async (to, metadata) => {\n    const [uri, toAddress] = await Promise.all([uploadOrExtractURI(metadata, this.storage), resolveAddress(to)]);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"mintTo\",\n      args: [toAddress, uri],\n      parse: receipt => {\n        const event = this.contractWrapper.parseLogs(\"Transfer\", receipt?.logs);\n        if (event.length === 0) {\n          throw new Error(\"TransferEvent event not found\");\n        }\n        const id = event[0].args.tokenId;\n        return {\n          id,\n          receipt,\n          data: () => this.erc721.get(id)\n        };\n      }\n    });\n  });\n\n  /**\n   * @deprecated Use `contract.erc721.mint.prepare(...args)` instead\n   */\n  async getMintTransaction(to, metadata) {\n    return this.to.prepare(await resolveAddress(to), metadata);\n  }\n  detectErc721BatchMintable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC721BatchMintable\")) {\n      return new Erc721BatchMintable(this.erc721, this.contractWrapper, this.storage);\n    }\n    return undefined;\n  }\n}\n\n/**\n * List owned ERC721 NFTs\n * @remarks Easily list all the NFTs from a ERC721 contract, owned by a certain wallet.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * const walletAddress = \"0x...\";\n * const ownedNFTs = await contract.nft.query.owned.all(walletAddress);\n * ```\n * @public\n */\n\nclass Erc721Enumerable {\n  featureName = FEATURE_NFT_ENUMERABLE.name;\n  constructor(erc721, contractWrapper) {\n    this.erc721 = erc721;\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * Get all NFTs owned by a specific wallet\n   *\n   * @remarks Get all the data associated with the NFTs owned by a specific wallet.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet to get the NFTs of\n   * const address = \"{{wallet_address}}\";\n   * const nfts = await contract.nft.query.owned.all(address);\n   * ```\n   * @param walletAddress - the wallet address to query, defaults to the connected wallet\n   * @returns The NFT metadata for all NFTs in the contract.\n   */\n  async all(walletAddress) {\n    const tokenIds = await this.tokenIds(walletAddress);\n    return await Promise.all(tokenIds.map(tokenId => this.erc721.get(tokenId.toString())));\n  }\n\n  /**\n   * Get all token ids of NFTs owned by a specific wallet.\n   * @param walletAddress - the wallet address to query, defaults to the connected wallet\n   */\n  async tokenIds(walletAddress) {\n    const address = await resolveAddress(walletAddress || (await this.contractWrapper.getSignerAddress()));\n    const balance = await this.contractWrapper.read(\"balanceOf\", [address]);\n    const indices = Array.from(Array(balance.toNumber()).keys());\n    return await Promise.all(indices.map(i => this.contractWrapper.read(\"tokenOfOwnerByIndex\", [address, i])));\n  }\n}\n\n/**\n * List owned ERC721 NFTs\n * @remarks Easily list all the NFTs from a ERC721 contract, owned by a certain wallet.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * const walletAddress = \"0x...\";\n * const ownedNFTs = await contract.nft.query.owned.all(walletAddress);\n * ```\n * @public\n */\n\nclass Erc721AQueryable {\n  featureName = FEATURE_NFT_QUERYABLE.name;\n  constructor(erc721, contractWrapper) {\n    this.erc721 = erc721;\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * Get all NFTs owned by a specific wallet\n   *\n   * @remarks Get all the data associated with the NFTs owned by a specific wallet.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet to get the NFTs of\n   * const address = \"{{wallet_address}}\";\n   * const nfts = await contract.nft.query.owned.all(address);\n   * ```\n   * @param walletAddress - the wallet address to query, defaults to the connected wallet\n   * @returns The NFT metadata for all NFTs in the contract.\n   */\n  async all(walletAddress) {\n    const tokenIds = await this.tokenIds(walletAddress);\n    return await Promise.all(tokenIds.map(tokenId => this.erc721.get(tokenId.toString())));\n  }\n\n  /**\n   * Get all token ids of NFTs owned by a specific wallet.\n   * @param walletAddress - the wallet address to query, defaults to the connected wallet\n   */\n  async tokenIds(walletAddress) {\n    const address = await resolveAddress(walletAddress || (await this.contractWrapper.getSignerAddress()));\n    return await this.contractWrapper.read(\"tokensOfOwner\", [address]);\n  }\n}\n\n/**\n * List ERC721 NFTs\n * @remarks Easily list all the NFTs in a ERC721 contract.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * const nfts = await contract.nft.query.all();\n * ```\n * @public\n */\n\nclass Erc721Supply {\n  featureName = FEATURE_NFT_SUPPLY.name;\n  constructor(erc721, contractWrapper) {\n    this.erc721 = erc721;\n    this.contractWrapper = contractWrapper;\n    this.owned = this.detectErc721Owned();\n  }\n\n  /**\n   * Get all NFTs\n   *\n   * @remarks Get all the data associated with every NFT in this contract.\n   *\n   * By default, returns the first 100 NFTs, use queryParams to fetch more.\n   *\n   * @example\n   * ```javascript\n   * const nfts = await contract.nft.query.all();\n   * ```\n   * @param queryParams - optional filtering to only fetch a subset of results.\n   * @returns The NFT metadata for all NFTs queried.\n   */\n  async all(queryParams) {\n    let startTokenId = BigNumber.from(0);\n    if (hasFunction(\"startTokenId\", this.contractWrapper)) {\n      startTokenId = await this.contractWrapper.read(\"startTokenId\", []);\n    }\n    const start = BigNumber.from(queryParams?.start || 0).add(startTokenId).toNumber();\n    const count = BigNumber.from(queryParams?.count || DEFAULT_QUERY_ALL_COUNT).toNumber();\n    const maxSupply = await this.erc721.nextTokenIdToMint();\n    const maxId = Math.min(maxSupply.add(startTokenId).toNumber(), start + count);\n    return await Promise.all([...Array(maxId - start).keys()].map(i => this.erc721.get((start + i).toString())));\n  }\n\n  /**\n   * Return all the owners of each token id in this contract\n   * @returns\n   */\n  async allOwners() {\n    let totalCount;\n    let startTokenId = BigNumber.from(0);\n    if (hasFunction(\"startTokenId\", this.contractWrapper)) {\n      startTokenId = await this.contractWrapper.read(\"startTokenId\", []);\n    }\n    try {\n      totalCount = await this.erc721.totalClaimedSupply();\n    } catch (e) {\n      totalCount = await this.totalCount();\n    }\n    totalCount = totalCount.add(startTokenId);\n\n    // TODO use multicall3 if available\n    // TODO can't call toNumber() here, this can be a very large number\n    const arr = [...new Array(totalCount.toNumber()).keys()];\n    const owners = await Promise.all(arr.map(i => this.erc721.ownerOf(i).catch(() => constants.AddressZero)));\n    return arr.map(i => ({\n      tokenId: i,\n      owner: owners[i]\n    })).filter(o => o.owner !== constants.AddressZero);\n  }\n\n  /**\n   * Get the number of NFTs minted\n   * @remarks This returns the total number of NFTs minted in this contract, **not** the total supply of a given token.\n   *\n   * @returns the total number of NFTs minted in this contract\n   * @public\n   */\n  async totalCount() {\n    return await this.erc721.nextTokenIdToMint();\n  }\n\n  /**\n   * Get the number of NFTs of this contract currently owned by end users\n   * @returns the total number of NFTs of this contract in circulation (minted & not burned)\n   * @public\n   */\n  async totalCirculatingSupply() {\n    return await this.contractWrapper.read(\"totalSupply\", []);\n  }\n  detectErc721Owned() {\n    if (detectContractFeature(this.contractWrapper, \"ERC721Enumerable\")) {\n      return new Erc721Enumerable(this.erc721, this.contractWrapper);\n    } else if (detectContractFeature(this.contractWrapper, \"ERC721AQueryable\")) {\n      return new Erc721AQueryable(this.erc721, this.contractWrapper);\n    }\n    return undefined;\n  }\n}\n\n/**\n * @internal\n */\nconst TieredDropPayloadSchema = /* @__PURE__ */(() => BaseSignaturePayloadInput.extend({\n  tierPriority: z.array(z.string()),\n  royaltyRecipient: AddressOrEnsSchema.default(constants.AddressZero),\n  royaltyBps: BasisPointsSchema.default(0),\n  quantity: BigNumberSchema.default(1)\n}))();\nclass Erc721TieredDrop {\n  featureName = FEATURE_NFT_TIERED_DROP.name;\n  constructor(erc721, contractWrapper, storage) {\n    this.erc721 = erc721;\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n  }\n  async getMetadataInTier(tier) {\n    const tiers = await this.contractWrapper.read(\"getMetadataForAllTiers\", []);\n    const batches = tiers.find(t => t.tier === tier);\n    if (!batches) {\n      throw new Error(\"Tier not found in contract.\");\n    }\n    const nfts = await Promise.all(batches.ranges.map((range, i) => {\n      const nftsInRange = [];\n      const baseUri = batches.baseURIs[i];\n      for (let j = range.startIdInclusive.toNumber(); j < range.endIdNonInclusive.toNumber(); j++) {\n        const uri = baseUri.endsWith(\"/\") ? `${baseUri}${j}` : `${baseUri}/${j}`;\n        const metadata = this.storage.downloadJSON(uri);\n        nftsInRange.push(metadata);\n      }\n      return nftsInRange;\n    }).flat());\n    return nfts;\n  }\n  async getTokensInTier(tier) {\n    const endIndex = await this.contractWrapper.read(\"getTokensInTierLen\", []);\n    if (endIndex.eq(0)) {\n      return [];\n    }\n    const ranges = await this.contractWrapper.read(\"getTokensInTier\", [tier, 0, endIndex]);\n    const nfts = await Promise.all(ranges.map(range => {\n      const nftsInRange = [];\n      for (let i = range.startIdInclusive.toNumber(); i < range.endIdNonInclusive.toNumber(); i++) {\n        nftsInRange.push(this.erc721.get(i));\n      }\n      return nftsInRange;\n    }).flat());\n    return nfts;\n  }\n  createBatchWithTier = /* @__PURE__ */buildTransactionFunction(async (metadatas, tier, options) => {\n    // TODO: Change this to on extension\n    const startFileNumber = await this.erc721.nextTokenIdToMint();\n    const batch = await uploadOrExtractURIs(metadatas, this.storage, startFileNumber.toNumber(), options);\n    const baseUri = getBaseUriFromBatch(batch);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"lazyMint\",\n      args: [batch.length, baseUri.endsWith(\"/\") ? baseUri : `${baseUri}/`, tier, utils.toUtf8Bytes(\"\")],\n      parse: receipt => {\n        const event = this.contractWrapper.parseLogs(\"TokensLazyMinted\", receipt?.logs);\n        const startingIndex = event[0].args[1];\n        const endingIndex = event[0].args[2];\n        const results = [];\n        for (let id = startingIndex; id.lte(endingIndex); id = id.add(1)) {\n          results.push({\n            id,\n            receipt,\n            data: () => this.erc721.getTokenMetadata(id)\n          });\n        }\n        return results;\n      }\n    });\n  });\n  createDelayedRevealBatchWithTier = /* @__PURE__ */buildTransactionFunction(async (placeholder, metadatas, password, tier, options) => {\n    if (!password) {\n      throw new Error(\"Password is required\");\n    }\n    const placeholderUris = await this.storage.uploadBatch([CommonNFTInput.parse(placeholder)], {\n      rewriteFileNames: {\n        fileStartNumber: 0\n      }\n    });\n    const placeholderUri = getBaseUriFromBatch(placeholderUris);\n    const startFileNumber = await this.erc721.nextTokenIdToMint();\n    const uris = await this.storage.uploadBatch(metadatas.map(m => CommonNFTInput.parse(m)), {\n      onProgress: options?.onProgress,\n      rewriteFileNames: {\n        fileStartNumber: startFileNumber.toNumber()\n      }\n    });\n    const baseUri = getBaseUriFromBatch(uris);\n    const baseUriId = await this.contractWrapper.read(\"getBaseURICount\", []);\n    const chainId = await this.contractWrapper.getChainID();\n    const hashedPassword = utils.solidityKeccak256([\"string\", \"uint256\", \"uint256\", \"address\"], [password, chainId, baseUriId, this.contractWrapper.address]);\n    const encryptedBaseUri = await this.contractWrapper.read(\"encryptDecrypt\", [utils.toUtf8Bytes(baseUri), hashedPassword]);\n    const provenanceHash = utils.solidityKeccak256([\"bytes\", \"bytes\", \"uint256\"], [utils.toUtf8Bytes(baseUri), hashedPassword, chainId]);\n    const data = utils.defaultAbiCoder.encode([\"bytes\", \"bytes32\"], [encryptedBaseUri, provenanceHash]);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"lazyMint\",\n      args: [uris.length, placeholderUri.endsWith(\"/\") ? placeholderUri : `${placeholderUri}/`, tier, data],\n      parse: receipt => {\n        const event = this.contractWrapper.parseLogs(\"TokensLazyMinted\", receipt?.logs);\n        const startingIndex = event[0].args[1];\n        const endingIndex = event[0].args[2];\n        const results = [];\n        for (let id = startingIndex; id.lte(endingIndex); id = id.add(1)) {\n          results.push({\n            id,\n            receipt,\n            data: () => this.erc721.getTokenMetadata(id)\n          });\n        }\n        return results;\n      }\n    });\n  });\n  reveal = /* @__PURE__ */buildTransactionFunction(async (batchId, password) => {\n    if (!password) {\n      throw new Error(\"Password is required\");\n    }\n    const chainId = await this.contractWrapper.getChainID();\n    const key = utils.solidityKeccak256([\"string\", \"uint256\", \"uint256\", \"address\"], [password, chainId, batchId, this.contractWrapper.address]);\n    // performing the reveal locally to make sure it'd succeed before sending the transaction\n    try {\n      const decryptedUri = await this.contractWrapper.callStatic().reveal(batchId, key);\n      // basic sanity check for making sure decryptedUri is valid\n      // this is optional because invalid decryption key would result in non-utf8 bytes and\n      // ethers would throw when trying to decode it\n      if (!decryptedUri.includes(\"://\") || !decryptedUri.endsWith(\"/\")) {\n        throw new Error(\"invalid password\");\n      }\n    } catch (e) {\n      throw new Error(\"invalid password\");\n    }\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"reveal\",\n      args: [batchId, key]\n    });\n  });\n  async generate(payloadToSign) {\n    const [payload] = await this.generateBatch([payloadToSign]);\n    return payload;\n  }\n  async generateBatch(payloadsToSign) {\n    const parsedPayloads = await Promise.all(payloadsToSign.map(payload => TieredDropPayloadSchema.parseAsync(payload)));\n    const chainId = await this.contractWrapper.getChainID();\n    const signer = this.contractWrapper.getSigner();\n    invariant(signer, \"No signer available\");\n    return await Promise.all(parsedPayloads.map(async payload => {\n      const signature = await this.contractWrapper.signTypedData(signer, {\n        name: \"SignatureAction\",\n        version: \"1\",\n        chainId,\n        verifyingContract: this.contractWrapper.address\n      }, {\n        GenericRequest: GenericRequest\n      }, await this.mapPayloadToContractStruct(payload));\n      return {\n        payload,\n        signature: signature.toString()\n      };\n    }));\n  }\n  async verify(signedPayload) {\n    const message = await this.mapPayloadToContractStruct(signedPayload.payload);\n    const verification = await this.contractWrapper.read(\"verify\", [message, signedPayload.signature]);\n    return verification[0];\n  }\n  async claimWithSignature(signedPayload) {\n    const message = await this.mapPayloadToContractStruct(signedPayload.payload);\n    const normalizedTotalPrice = await normalizePriceValue(this.contractWrapper.getProvider(), signedPayload.payload.price, signedPayload.payload.currencyAddress);\n    const overrides = await this.contractWrapper.getCallOverrides();\n    await setErc20Allowance(this.contractWrapper, normalizedTotalPrice, signedPayload.payload.currencyAddress, overrides);\n    const receipt = await this.contractWrapper.sendTransaction(\"claimWithSignature\", [message, signedPayload.signature], overrides);\n    const event = this.contractWrapper.parseLogs(\"TokensClaimed\", receipt?.logs);\n    const startingIndex = event[0].args.startTokenId;\n    const endingIndex = startingIndex.add(event[0].args.quantityClaimed);\n    const results = [];\n    for (let id = startingIndex; id.lt(endingIndex); id = id.add(1)) {\n      results.push({\n        id,\n        receipt,\n        data: () => this.erc721.get(id)\n      });\n    }\n    return results;\n  }\n  async mapPayloadToContractStruct(payload) {\n    const normalizedTotalPrice = await normalizePriceValue(this.contractWrapper.getProvider(), payload.price, payload.currencyAddress);\n    const data = utils.defaultAbiCoder.encode([\"string[]\", \"address\", \"address\", \"uint256\", \"address\", \"uint256\", \"uint256\", \"address\"], [payload.tierPriority, payload.to, payload.royaltyRecipient, payload.royaltyBps, payload.primarySaleRecipient, payload.quantity, normalizedTotalPrice, payload.currencyAddress]);\n    return {\n      uid: payload.uid,\n      validityStartTimestamp: payload.mintStartTime,\n      validityEndTimestamp: payload.mintEndTime,\n      data\n    };\n  }\n}\nclass Erc721Burnable {\n  featureName = FEATURE_NFT_BURNABLE.name;\n  constructor(contractWrapper) {\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * Burn NFTs\n   *\n   * @remarks Burn NFTs held by the connected wallet\n   *\n   * @example\n   * ```javascript\n   * // The token ID of the NFT you want to burn\n   * const tokenId = 0;\n   *\n   * await contract.nft.burn.token(tokenId);\n   * ```\n   */\n  token = /* @__PURE__ */buildTransactionFunction(async tokenId => {\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"burn\",\n      args: [tokenId]\n    });\n  });\n}\nfunction toWei(amount) {\n  return utils.parseEther(AmountSchema.parse(amount));\n}\n\n/**\n * Claim ERC721 NFTs from a Zora Drop\n * @remarks Purchase NFTs on a Zora Drop\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * await contract.erc721.claim(tokenId, quantity);\n * ```\n */\nclass Erc721ClaimableZora {\n  featureName = FEATURE_NFT_CLAIM_ZORA.name;\n  constructor(erc721, contractWrapper) {\n    this.erc721 = erc721;\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * Claim NFT\n   *\n   * @remarks Let the specified wallet claim NFTs.\n   *\n   * @example\n   * ```javascript\n   * const address = \"{{wallet_address}}\"; // address of the wallet you want to claim the NFTs\n   * const quantity = 1; // how many NFTs you want to claim\n   *\n   * const tx = await contract.erc721.claimTo(address, quantity);\n   * const receipt = tx[0].receipt; // the transaction receipt\n   * ```\n   *\n   * @param destinationAddress - Address you want to send the token to, needs to be the connected wallet address\n   * @param quantity - Quantity of the tokens you want to claim\n   * @param options - Not applicable\n   *\n   * @returns - Receipt for the transaction\n   */\n  to = /* @__PURE__ */buildTransactionFunction(async (destinationAddress, quantity, options) => {\n    // TODO validation on destinationAddr / options\n    const signerAddress = await this.contractWrapper.getSigner()?.getAddress();\n    if (destinationAddress !== signerAddress) {\n      throw new Error(\"Zora Drop: Destination address must match connected wallet address\");\n    }\n    if (options?.pricePerToken) {\n      throw new Error(\"Zora Drop: Custom pricePerToken is not supported. Price is automatically calculated\");\n    }\n    const saleDetails = await this.getSaleDetails();\n    const price = saleDetails.publicSalePrice;\n    const zoraFee = toWei(\"0.000777\");\n    const totalPrice = BigNumber.from(price).add(zoraFee).mul(quantity);\n    const tx = Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"purchase\",\n      args: [quantity],\n      overrides: {\n        value: totalPrice\n      }\n    });\n    tx.setParse(receipt => {\n      const event = this.contractWrapper.parseLogs(\"Sale\", receipt?.logs);\n      const startingIndex = event[0].args.firstPurchasedTokenId;\n      const endingIndex = startingIndex.add(quantity);\n      const results = [];\n      for (let id = startingIndex; id.lt(endingIndex); id = id.add(1)) {\n        results.push({\n          id,\n          receipt,\n          data: () => this.erc721.get(id)\n        });\n      }\n      return results;\n    });\n    return tx;\n  });\n  async getSaleDetails() {\n    return this.contractWrapper.read(\"saleDetails\", []);\n  }\n}\nclass Erc721LoyaltyCard {\n  featureName = FEATURE_NFT_LOYALTY_CARD.name;\n  constructor(contractWrapper) {\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * Cancel loyalty card NFTs\n   *\n   * @remarks Cancel loyalty card NFTs held by the connected wallet\n   *\n   * @example\n   * ```javascript\n   * // The token ID of the loyalty card you want to cancel\n   * const tokenId = 0;\n   *\n   * await contract.nft.loyaltyCard.cancel(tokenId);\n   * ```\n   */\n  cancel = /* @__PURE__ */buildTransactionFunction(async tokenId => {\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"cancel\",\n      args: [tokenId]\n    });\n  });\n\n  /**\n   * Revoke loyalty card NFTs\n   *\n   * @remarks Revoke loyalty card NFTs held by some owner.\n   *\n   * @example\n   * ```javascript\n   * // The token ID of the loyalty card you want to revoke\n   * const tokenId = 0;\n   *\n   * await contract.nft.loyaltyCard.revoke(tokenId);\n   * ```\n   */\n  revoke = /* @__PURE__ */buildTransactionFunction(async tokenId => {\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"revoke\",\n      args: [tokenId]\n    });\n  });\n}\nclass Erc721UpdatableMetadata {\n  featureName = FEATURE_NFT_UPDATABLE_METADATA.name;\n  constructor(contractWrapper, storage) {\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n  }\n\n  /**\n   * Update the metadata of an NFT\n   *\n   * @remarks Update the metadata of an NFT\n   *\n   * @example\n   * ```javascript\n   * // The token ID of the NFT whose metadata you want to update\n   * const tokenId = 0;\n   * // The new metadata\n   * const metadata = { name: \"My NFT\", description: \"My NFT description\"\"}\n   *\n   * await contract.nft.metadata.update(tokenId, metadata);\n   * ```\n   */\n  update = /* @__PURE__ */buildTransactionFunction(async (tokenId, metadata) => {\n    const uri = await uploadOrExtractURI(metadata, this.storage);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"setTokenURI\",\n      args: [tokenId, uri]\n    });\n  });\n}\n\n/**\n * Set shared metadata for ERC721 NFTs (Open Edition)\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * await contract.erc721.sharedMetadata.set(metadata);\n * ```\n */\nclass Erc721SharedMetadata {\n  featureName = FEATURE_NFT_SHARED_METADATA.name;\n  constructor(contractWrapper, storage) {\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n  }\n\n  /**\n   * Get Shared Metadata\n   *\n   * @remarks Get the shared metadata for the Open Edition NFTs.\n   *\n   * @example\n   * ```javascript\n   * const contract = await sdk.getContract(\"{{contract_address}}\");\n   *\n   * const tx = await contract.erc721.sharedMetadata.get();\n   * ```\n   *\n   * @returns - The shared metadata for the Open Edition NFTs.\n   */\n  async get() {\n    const metadata = await this.contractWrapper.read(\"sharedMetadata\", []);\n    if (metadata.every(value => value === \"\")) {\n      return undefined;\n    }\n    return {\n      name: metadata.name,\n      description: metadata.description,\n      image: metadata.imageURI,\n      animation_url: metadata.animationURI\n    };\n  }\n\n  /**\n   * Set Shared Metadata\n   *\n   * @remarks Set the shared metadata for the Open Edition NFTs.\n   *\n   * @example\n   * ```javascript\n   * const metadata = {\n   *  name: \"My NFT\",\n   *  description: \"This is my NFT\",\n   *  image: ...\n   *  animation_url: ...\n   * };\n   *\n   * const contract = await sdk.getContract(\"{{contract_address}}\");\n   *\n   * const tx = await contract.erc721.sharedMetadata.set(metadata);\n   * ```\n   *\n   * @param metadata - The metadata you want to set for the shared metadata.\n   *\n   * @returns - Receipt for the transaction\n   */\n  set = /* @__PURE__ */buildTransactionFunction(async metadata => {\n    const parsedMetadata = BasicNFTInput.parse(metadata);\n    // cleanup description\n    parsedMetadata.description = this.sanitizeJSONString(parsedMetadata.description);\n\n    // take the input and upload image and animation if it is not a URI already\n    const batch = [];\n    if (isFileOrBuffer(parsedMetadata.image)) {\n      batch.push(this.storage.upload(parsedMetadata.image));\n    } else if (typeof parsedMetadata.image === \"string\") {\n      batch.push(Promise.resolve(parsedMetadata.image));\n    } else {\n      batch.push(Promise.resolve(undefined));\n    }\n    if (isFileOrBuffer(parsedMetadata.animation_url)) {\n      batch.push(this.storage.upload(parsedMetadata.animation_url));\n    } else if (typeof parsedMetadata.animation_url === \"string\") {\n      batch.push(Promise.resolve(parsedMetadata.animation_url));\n    } else {\n      batch.push(Promise.resolve(undefined));\n    }\n    const [imageUri, animationUri] = await Promise.all(batch);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"setSharedMetadata\",\n      args: [{\n        name: `${parsedMetadata.name || \"\"}`,\n        description: parsedMetadata.description || \"\",\n        imageURI: imageUri || \"\",\n        animationURI: animationUri || \"\"\n      }]\n    });\n  });\n  sanitizeJSONString(val) {\n    if (!val) {\n      return val;\n    }\n    const sanitized = JSON.stringify(val);\n    return sanitized.slice(1, sanitized.length - 1);\n  }\n}\n\n/**\n * Enables generating dynamic ERC721 NFTs with rules and an associated signature, which can then be minted by anyone securely\n * @public\n */\nclass Erc721WithQuantitySignatureMintable {\n  featureName = FEATURE_NFT_SIGNATURE_MINTABLE_V2.name;\n  constructor(contractWrapper, storage) {\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n  }\n\n  /**\n   * Mint a dynamically generated NFT\n   *\n   * @remarks Mint a dynamic NFT with a previously generated signature.\n   *\n   * @example\n   * ```javascript\n   * // see how to craft a payload to sign in the `generate()` documentation\n   * const signedPayload = contract.erc721.signature.generate(payload);\n   *\n   * // now anyone can mint the NFT\n   * const tx = contract.erc721.signature.mint(signedPayload);\n   * const receipt = tx.receipt; // the mint transaction receipt\n   * const mintedId = tx.id; // the id of the NFT minted\n   * ```\n   * @param signedPayload - the previously generated payload and signature with {@link Erc721WithQuantitySignatureMintable.generate}\n   * @twfeature ERC721SignatureMint\n   */\n  mint = /* @__PURE__ */buildTransactionFunction(async signedPayload => {\n    const mintRequest = signedPayload.payload;\n    const signature = signedPayload.signature;\n    const overrides = await this.contractWrapper.getCallOverrides();\n    const parse = receipt => {\n      const t = this.contractWrapper.parseLogs(\"TokensMintedWithSignature\", receipt.logs);\n      if (t.length === 0) {\n        throw new Error(\"No MintWithSignature event found\");\n      }\n      const id = t[0].args.tokenIdMinted;\n      return {\n        id,\n        receipt\n      };\n    };\n    if (await this.isLegacyNFTContract()) {\n      const message = await this.mapLegacyPayloadToContractStruct(mintRequest);\n      const price = message.price;\n\n      // TODO: Transaction Sequence Pattern\n      await setErc20Allowance(this.contractWrapper, price, mintRequest.currencyAddress, overrides);\n      return Transaction.fromContractWrapper({\n        contractWrapper: this.contractWrapper,\n        method: \"mintWithSignature\",\n        args: [message, signature],\n        overrides,\n        parse\n      });\n    } else {\n      const message = await this.mapPayloadToContractStruct(mintRequest);\n      const price = message.pricePerToken.mul(message.quantity);\n\n      // TODO: Transaction Sequence Pattern\n      await setErc20Allowance(this.contractWrapper, price, mintRequest.currencyAddress, overrides);\n      return Transaction.fromContractWrapper({\n        contractWrapper: this.contractWrapper,\n        method: \"mintWithSignature\",\n        args: [message, signature],\n        overrides,\n        parse\n      });\n    }\n  });\n\n  /**\n   * Mint any number of dynamically generated NFT at once\n   * @remarks Mint multiple dynamic NFTs in one transaction. Note that this is only possible for free mints (cannot batch mints with a price attached to it for security reasons)\n   * @param signedPayloads - the array of signed payloads to mint\n   * @twfeature ERC721SignatureMint\n   */\n  mintBatch = /* @__PURE__ */buildTransactionFunction(async signedPayloads => {\n    const isLegacyNFTContract = await this.isLegacyNFTContract();\n    const contractPayloads = (await Promise.all(signedPayloads.map(s => isLegacyNFTContract ? this.mapLegacyPayloadToContractStruct(s.payload) : this.mapPayloadToContractStruct(s.payload)))).map((message, index) => {\n      const s = signedPayloads[index];\n      const signature = s.signature;\n      const price = s.payload.price;\n      if (BigNumber.from(price).gt(0)) {\n        throw new Error(\"Can only batch free mints. For mints with a price, use regular mint()\");\n      }\n      return {\n        message,\n        signature\n      };\n    });\n    const contractEncoder = new ContractEncoder(this.contractWrapper);\n    const encoded = contractPayloads.map(p => {\n      if (isLegacyNFTContract) {\n        return contractEncoder.encode(\"mintWithSignature\", [p.message, p.signature]);\n      } else {\n        return contractEncoder.encode(\"mintWithSignature\", [p.message, p.signature]);\n      }\n    });\n    if (hasFunction(\"multicall\", this.contractWrapper)) {\n      return Transaction.fromContractWrapper({\n        contractWrapper: this.contractWrapper,\n        method: \"multicall\",\n        args: [encoded],\n        parse: receipt => {\n          const events = this.contractWrapper.parseLogs(\"TokensMintedWithSignature\", receipt.logs);\n          if (events.length === 0) {\n            throw new Error(\"No MintWithSignature event found\");\n          }\n          return events.map(log => ({\n            id: log.args.tokenIdMinted,\n            receipt\n          }));\n        }\n      });\n    } else {\n      throw new Error(\"Multicall not available on this contract!\");\n    }\n  });\n\n  /**\n   * Verify that a payload is correctly signed\n   * @param signedPayload - the payload to verify\n   * @twfeature ERC721SignatureMint\n   *\n   * @example\n   * ```javascript\n   * const nftMetadata = {\n   *   name: \"Cool NFT #1\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   * };\n   *\n   * const startTime = new Date();\n   * const endTime = new Date(Date.now() + 60 * 60 * 24 * 1000);\n   * const payload = {\n   *   metadata: nftMetadata, // The NFT to mint\n   *   to: {{wallet_address}}, // Who will receive the NFT\n   *   quantity: 2, // the quantity of NFTs to mint\n   *   price: 0.5, // the price per NFT\n   *   currencyAddress: NATIVE_TOKEN_ADDRESS, // the currency to pay with\n   *   mintStartTime: startTime, // can mint anytime from now\n   *   mintEndTime: endTime, // to 24h from now\n   *   royaltyRecipient: \"0x...\", // custom royalty recipient for this NFT\n   *   royaltyBps: 100, // custom royalty fees for this NFT (in bps)\n   *   primarySaleRecipient: \"0x...\", // custom sale recipient for this NFT\n   * };\n   *\n   * const signedPayload = await contract.erc721.signature.generate(payload);\n   * // Now you can verify if the signed payload is valid\n   * const isValid = await contract.erc721.signature.verify(signedPayload);\n   * ```\n   */\n  async verify(signedPayload) {\n    const isLegacyNFTContract = await this.isLegacyNFTContract();\n    const mintRequest = signedPayload.payload;\n    const signature = signedPayload.signature;\n    let message;\n    let verification;\n    if (isLegacyNFTContract) {\n      message = await this.mapLegacyPayloadToContractStruct(mintRequest);\n      verification = await this.contractWrapper.read(\"verify\", [message, signature]);\n    } else {\n      message = await this.mapPayloadToContractStruct(mintRequest);\n      verification = await this.contractWrapper.read(\"verify\", [message, signature]);\n    }\n    return verification[0];\n  }\n\n  /**\n   * Generate a signature that can be used to mint a dynamic NFT\n   *\n   * @remarks Takes in an NFT and some information about how it can be minted, uploads the metadata and signs it with your private key. The generated signature can then be used to mint an NFT using the exact payload and signature generated.\n   *\n   * @example\n   * ```javascript\n   * const nftMetadata = {\n   *   name: \"Cool NFT #1\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   * };\n   *\n   * const startTime = new Date();\n   * const endTime = new Date(Date.now() + 60 * 60 * 24 * 1000);\n   * const payload = {\n   *   metadata: nftMetadata, // The NFT to mint\n   *   to: {{wallet_address}}, // Who will receive the NFT\n   *   quantity: 2, // the quantity of NFTs to mint\n   *   price: 0.5, // the price per NFT\n   *   currencyAddress: NATIVE_TOKEN_ADDRESS, // the currency to pay with\n   *   mintStartTime: startTime, // can mint anytime from now\n   *   mintEndTime: endTime, // to 24h from now\n   *   royaltyRecipient: \"0x...\", // custom royalty recipient for this NFT\n   *   royaltyBps: 100, // custom royalty fees for this NFT (in bps)\n   *   primarySaleRecipient: \"0x...\", // custom sale recipient for this NFT\n   * };\n   *\n   * const signedPayload = await contract.erc721.signature.generate(payload);\n   * // now anyone can use these to mint the NFT using `contract.erc721.signature.mint(signedPayload)`\n   * ```\n   * @param mintRequest - the payload to sign\n   * @returns the signed payload and the corresponding signature\n   * @twfeature ERC721SignatureMint\n   */\n  async generate(mintRequest) {\n    return (await this.generateBatch([mintRequest]))[0];\n  }\n\n  /**\n   * Genrate a batch of signatures that can be used to mint many dynamic NFTs.\n   *\n   * @remarks See {@link Erc721WithQuantitySignatureMintable.generate}\n   *\n   * @param payloadsToSign - the payloads to sign\n   * @returns an array of payloads and signatures\n   * @twfeature ERC721SignatureMint\n   */\n  async generateBatch(payloadsToSign) {\n    const isLegacyNFTContract = await this.isLegacyNFTContract();\n    const parsedRequests = await Promise.all(payloadsToSign.map(m => Signature721WithQuantityInput.parseAsync(m)));\n    const metadatas = parsedRequests.map(r => r.metadata);\n    const uris = await uploadOrExtractURIs(metadatas, this.storage);\n    const chainId = await this.contractWrapper.getChainID();\n    const signer = this.contractWrapper.getSigner();\n    invariant(signer, \"No signer available\");\n    return await Promise.all(parsedRequests.map(async (m, i) => {\n      const uri = uris[i];\n      const finalPayload = await Signature721WithQuantityOutput.parseAsync({\n        ...m,\n        uri\n      });\n      let signature;\n      if (isLegacyNFTContract) {\n        signature = await this.contractWrapper.signTypedData(signer, {\n          name: \"TokenERC721\",\n          version: \"1\",\n          chainId,\n          verifyingContract: this.contractWrapper.address\n        }, {\n          MintRequest: MintRequest721\n        }, await this.mapLegacyPayloadToContractStruct(finalPayload));\n      } else {\n        signature = await this.contractWrapper.signTypedData(signer, {\n          name: \"SignatureMintERC721\",\n          version: \"1\",\n          chainId,\n          verifyingContract: await this.contractWrapper.address\n        }, {\n          MintRequest: MintRequest721withQuantity\n        },\n        // TYPEHASH\n        await this.mapPayloadToContractStruct(finalPayload));\n      }\n      return {\n        payload: finalPayload,\n        signature: signature.toString()\n      };\n    }));\n  }\n\n  /** ******************************\n   * PRIVATE FUNCTIONS\n   *******************************/\n\n  /**\n   * Maps a payload to the format expected by the contract\n   *\n   * @internal\n   *\n   * @param mintRequest - The payload to map.\n   * @returns - The mapped payload.\n   */\n  async mapPayloadToContractStruct(mintRequest) {\n    const normalizedPricePerToken = await normalizePriceValue(this.contractWrapper.getProvider(), mintRequest.price, mintRequest.currencyAddress);\n    return {\n      to: mintRequest.to,\n      royaltyRecipient: mintRequest.royaltyRecipient,\n      royaltyBps: mintRequest.royaltyBps,\n      primarySaleRecipient: mintRequest.primarySaleRecipient,\n      uri: mintRequest.uri,\n      quantity: mintRequest.quantity,\n      pricePerToken: normalizedPricePerToken,\n      currency: mintRequest.currencyAddress,\n      validityStartTimestamp: mintRequest.mintStartTime,\n      validityEndTimestamp: mintRequest.mintEndTime,\n      uid: mintRequest.uid\n    };\n  }\n  async mapLegacyPayloadToContractStruct(mintRequest) {\n    const normalizedPricePerToken = await normalizePriceValue(this.contractWrapper.getProvider(), mintRequest.price, mintRequest.currencyAddress);\n    return {\n      to: mintRequest.to,\n      price: normalizedPricePerToken,\n      uri: mintRequest.uri,\n      currency: mintRequest.currencyAddress,\n      validityEndTimestamp: mintRequest.mintEndTime,\n      validityStartTimestamp: mintRequest.mintStartTime,\n      uid: mintRequest.uid,\n      royaltyRecipient: mintRequest.royaltyRecipient,\n      royaltyBps: mintRequest.royaltyBps,\n      primarySaleRecipient: mintRequest.primarySaleRecipient\n    };\n  }\n  async isLegacyNFTContract() {\n    return detectContractFeature(this.contractWrapper, \"ERC721SignatureMintV1\");\n  }\n}\n\n/**\n * Standard ERC721 NFT functions\n * @remarks Basic functionality for a ERC721 contract that handles IPFS storage for you.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * await contract.erc721.transfer(walletAddress, tokenId);\n * ```\n * @public\n */\nclass Erc721 {\n  featureName = FEATURE_NFT.name;\n  get chainId() {\n    return this._chainId;\n  }\n  constructor(contractWrapper, storage, chainId) {\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n    this.query = this.detectErc721Enumerable();\n    this.mintable = this.detectErc721Mintable();\n    this.burnable = this.detectErc721Burnable();\n    this.lazyMintable = this.detectErc721LazyMintable();\n    this.tieredDropable = this.detectErc721TieredDrop();\n    this.signatureMintable = this.detectErc721SignatureMintable();\n    this.claimWithConditions = this.detectErc721ClaimableWithConditions();\n    this.claimCustom = this.detectErc721Claimable();\n    this.claimZora = this.detectErc721ClaimableZora();\n    this.erc721SharedMetadata = this.detectErc721SharedMetadata();\n    this.loyaltyCard = this.detectErc721LoyaltyCard();\n    this.updatableMetadata = this.detectErc721UpdatableMetadata();\n    this._chainId = chainId;\n  }\n\n  /**\n   * @internal\n   */\n  onNetworkUpdated(network) {\n    this.contractWrapper.updateSignerOrProvider(network);\n  }\n  getAddress() {\n    return this.contractWrapper.address;\n  }\n\n  ////// Standard ERC721 Extension //////\n\n  /**\n   * Get a single NFT\n   *\n   * @example\n   * ```javascript\n   * const tokenId = 0;\n   * const nft = await contract.erc721.get(tokenId);\n   * ```\n   * @param tokenId - the tokenId of the NFT to retrieve\n   * @returns The NFT metadata\n   * @twfeature ERC721\n   */\n  async get(tokenId) {\n    const [owner, metadata] = await Promise.all([this.ownerOf(tokenId).catch(() => constants.AddressZero), this.getTokenMetadata(tokenId).catch(() => ({\n      id: tokenId.toString(),\n      uri: \"\",\n      ...FALLBACK_METADATA\n    }))]);\n    return {\n      owner,\n      metadata,\n      type: \"ERC721\",\n      supply: \"1\"\n    };\n  }\n\n  /**\n   * Get the current owner of an NFT\n   *\n   * @param tokenId - the tokenId of the NFT\n   * @returns the address of the owner\n   * @twfeature ERC721\n   */\n  async ownerOf(tokenId) {\n    return await this.contractWrapper.read(\"ownerOf\", [tokenId]);\n  }\n\n  /**\n   * Get NFT balance of a specific wallet\n   *\n   * @remarks Get a wallets NFT balance (number of NFTs in this contract owned by the wallet).\n   *\n   * @example\n   * ```javascript\n   * const walletAddress = \"{{wallet_address}}\";\n   * const balance = await contract.erc721.balanceOf(walletAddress);\n   * console.log(balance);\n   * ```\n   * @twfeature ERC721\n   */\n  async balanceOf(address) {\n    return await this.contractWrapper.read(\"balanceOf\", [await resolveAddress(address)]);\n  }\n\n  /**\n   * Get NFT balance for the currently connected wallet\n   */\n  async balance() {\n    return await this.balanceOf(await this.contractWrapper.getSignerAddress());\n  }\n\n  /**\n   * Get whether this wallet has approved transfers from the given operator\n   * @param address - the wallet address\n   * @param operator - the operator address\n   */\n  async isApproved(address, operator) {\n    const [_address, _operator] = await Promise.all([resolveAddress(address), resolveAddress(operator)]);\n    return await this.contractWrapper.read(\"isApprovedForAll\", [_address, _operator]);\n  }\n\n  /**\n   * Transfer an NFT\n   *\n   * @remarks Transfer an NFT from the connected wallet to another wallet.\n   *\n   * @example\n   * ```javascript\n   * const walletAddress = \"{{wallet_address}}\";\n   * const tokenId = 0;\n   * await contract.erc721.transfer(walletAddress, tokenId);\n   * ```\n   * @twfeature ERC721\n   */\n  transfer = /* @__PURE__ */buildTransactionFunction(async (to, tokenId) => {\n    const [from, _to] = await Promise.all([this.contractWrapper.getSignerAddress(), resolveAddress(to)]);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"transferFrom(address,address,uint256)\",\n      args: [from, _to, tokenId]\n    });\n  });\n\n  /**\n   * Transfer an NFT from a specific wallet\n   *\n   * @remarks Transfer an NFT from the given wallet to another wallet.\n   *\n   * @example\n   * ```javascript\n   * const fromWalletAddress = \"{{wallet_address}}\";\n   * const toWalletAddress = \"{{wallet_address}}\";\n   * const tokenId = 0;\n   * await contract.erc721.transferFrom(fromWalletAddress, toWalletAddress, tokenId);\n   * ```\n   * @twfeature ERC721\n   */\n  transferFrom = /* @__PURE__ */buildTransactionFunction(async (from, to, tokenId) => {\n    const [fromAddress, toAddress] = await Promise.all([resolveAddress(from), resolveAddress(to)]);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"transferFrom(address,address,uint256)\",\n      args: [fromAddress, toAddress, tokenId]\n    });\n  });\n\n  /**\n   * Set approval for all NFTs\n   * @remarks Approve or remove operator as an operator for the caller. Operators can call transferFrom or safeTransferFrom for any token owned by the caller.\n   * @example\n   * ```javascript\n   * const operator = \"{{wallet_address}}\";\n   * await contract.erc721.setApprovalForAll(operator, true);\n   * ```\n   * @param operator - the operator's address\n   * @param approved - whether to approve or remove\n   * @twfeature ERC721\n   */\n  setApprovalForAll = /* @__PURE__ */buildTransactionFunction(async (operator, approved) => {\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"setApprovalForAll\",\n      args: [await resolveAddress(operator), approved]\n    });\n  });\n\n  /**\n   * Set approval for a single NFT\n   * @remarks Approve an operator for the NFT owner. Operators can call transferFrom or safeTransferFrom for the specified token.\n   * @example\n   * ```javascript\n   * const operator = \"{{wallet_address}}\";\n   * const tokenId = 0;\n   * await contract.erc721.setApprovalForToken(operator, tokenId);\n   * ```\n   * @param operator - the operator's address\n   * @param tokenId - the tokenId to give approval for\n   *\n   * @internal\n   */\n  setApprovalForToken = /* @__PURE__ */buildTransactionFunction(async (operator, tokenId) => {\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"approve\",\n      args: [await resolveAddress(operator), tokenId]\n    });\n  });\n\n  ////// ERC721 Supply Extension //////\n\n  /**\n   * Get all NFTs\n   *\n   * @remarks Get all the data associated with every NFT in this contract.\n   *\n   * By default, returns the first 100 NFTs, use queryParams to fetch more.\n   *\n   * @example\n   * ```javascript\n   * const nfts = await contract.erc721.getAll();\n   * console.log(nfts);\n   * ```\n   * @param queryParams - optional filtering to only fetch a subset of results.\n   * @returns The NFT metadata for all NFTs queried.\n   * @twfeature ERC721Supply | ERC721Enumerable\n   */\n  async getAll(queryParams) {\n    return assertEnabled(this.query, FEATURE_NFT_SUPPLY).all(queryParams);\n  }\n\n  /**\n   * Get all NFT owners\n   * @example\n   * ```javascript\n   * const owners = await contract.erc721.getAllOwners();\n   * console.log(owners);\n   * ```\n   * @returns an array of token ids and owners\n   * @twfeature ERC721Supply | ERC721Enumerable\n   */\n  async getAllOwners() {\n    return assertEnabled(this.query, FEATURE_NFT_SUPPLY).allOwners();\n  }\n\n  /**\n   * Get the total number of NFTs minted\n   * @remarks This returns the total number of NFTs minted in this contract, **not** the total supply of a given token.\n   * @example\n   * ```javascript\n   * const count = await contract.erc721.totalCount();\n   * console.log(count);\n   * ```\n   *\n   * @returns the total number of NFTs minted in this contract\n   * @public\n   */\n  async totalCount() {\n    return this.nextTokenIdToMint();\n  }\n\n  /**\n   * Get the total count NFTs minted in this contract\n   * @twfeature ERC721Supply | ERC721Enumerable\n   */\n  async totalCirculatingSupply() {\n    return assertEnabled(this.query, FEATURE_NFT_SUPPLY).totalCirculatingSupply();\n  }\n\n  ////// ERC721 Enumerable Extension //////\n\n  /**\n   * Get all NFTs owned by a specific wallet\n   *\n   * @remarks Get all the data associated with the NFTs owned by a specific wallet.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet to get the NFTs of\n   * const address = \"{{wallet_address}}\";\n   * const nfts = await contract.erc721.getOwned(address);\n   * console.log(nfts);\n   * ```\n   * @param walletAddress - the wallet address to query, defaults to the connected wallet\n   * @returns The NFT metadata for all NFTs in the contract.\n   * @twfeature ERC721Supply | ERC721Enumerable\n   */\n  async getOwned(walletAddress) {\n    if (walletAddress) {\n      walletAddress = await resolveAddress(walletAddress);\n    }\n    if (this.query?.owned) {\n      return this.query.owned.all(walletAddress);\n    } else {\n      const [address, allOwners] = await Promise.all([walletAddress || this.contractWrapper.getSignerAddress(), this.getAllOwners()]);\n      return await Promise.all((allOwners || []).filter(i => address?.toLowerCase() === i.owner?.toLowerCase()).map(i => this.get(i.tokenId)));\n    }\n  }\n\n  /**\n   * Get all token ids of NFTs owned by a specific wallet.\n   * @param walletAddress - the wallet address to query, defaults to the connected wallet\n   */\n  async getOwnedTokenIds(walletAddress) {\n    if (walletAddress) {\n      walletAddress = await resolveAddress(walletAddress);\n    }\n    if (this.query?.owned) {\n      return this.query.owned.tokenIds(walletAddress);\n    } else {\n      const [address, allOwners] = await Promise.all([walletAddress || this.contractWrapper.getSignerAddress(), this.getAllOwners()]);\n      return (allOwners || []).filter(i => address?.toLowerCase() === i.owner?.toLowerCase()).map(i => BigNumber.from(i.tokenId));\n    }\n  }\n\n  ////// ERC721 Mintable Extension //////\n\n  /**\n   * Mint an NFT\n   *\n   * @remarks Mint an NFT to the connected wallet.\n   *\n   * @example\n   * ```javascript\n   * // Custom metadata of the NFT, note that you can fully customize this metadata with other properties.\n   * const metadata = {\n   *   name: \"Cool NFT\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   * };\n   *\n   * const tx = await contract.erc721.mint(metadata);\n   * const receipt = tx.receipt; // the transaction receipt\n   * const tokenId = tx.id; // the id of the NFT minted\n   * const nft = await tx.data(); // (optional) fetch details of minted NFT\n   * ```\n   * @twfeature ERC721Mintable\n   */\n  mint = /* @__PURE__ */buildTransactionFunction(async metadata => {\n    return this.mintTo.prepare(await this.contractWrapper.getSignerAddress(), metadata);\n  });\n\n  /**\n   * Mint an NFT to a specific wallet\n   *\n   * @remarks Mint a unique NFT to a specified wallet.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet you want to mint the NFT to\n   * const walletAddress = \"{{wallet_address}}\";\n   *\n   * // Custom metadata of the NFT, note that you can fully customize this metadata with other properties.\n   * const metadata = {\n   *   name: \"Cool NFT\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   * };\n   *\n   * const tx = await contract.erc721.mintTo(walletAddress, metadata);\n   * const receipt = tx.receipt; // the transaction receipt\n   * const tokenId = tx.id; // the id of the NFT minted\n   * const nft = await tx.data(); // (optional) fetch details of minted NFT\n   * ```\n   * @twfeature ERC721Mintable\n   */\n  mintTo = /* @__PURE__ */buildTransactionFunction(async (receiver, metadata) => {\n    return assertEnabled(this.mintable, FEATURE_NFT_MINTABLE).to.prepare(receiver, metadata);\n  });\n\n  /**\n   * Construct a mint transaction without executing it.\n   * This is useful for estimating the gas cost of a mint transaction, overriding transaction options and having fine grained control over the transaction execution.\n   * @param receiver - Address you want to send the token to\n   * @param metadata - The metadata of the NFT you want to mint\n   *\n   * @deprecated Use `contract.erc721.mint.prepare(...args)` instead\n   * @twfeature ERC721Mintable\n   */\n  async getMintTransaction(receiver, metadata) {\n    return this.mintTo.prepare(receiver, metadata);\n  }\n\n  ////// ERC721 Batch Mintable Extension //////\n\n  /**\n   * Mint many NFTs\n   *\n   * @remarks Mint many unique NFTs at once to the connected wallet\n   *\n   * @example\n   * ```javascript*\n   * // Custom metadata of the NFTs you want to mint.\n   * const metadatas = [{\n   *   name: \"Cool NFT #1\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   * }, {\n   *   name: \"Cool NFT #2\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/other/image.png\"),\n   * }];\n   *\n   * const tx = await contract.erc721.mintBatch(metadatas);\n   * const receipt = tx[0].receipt; // same transaction receipt for all minted NFTs\n   * const firstTokenId = tx[0].id; // token id of the first minted NFT\n   * const firstNFT = await tx[0].data(); // (optional) fetch details of the first minted NFT\n   * ```\n   * @twfeature ERC721BatchMintable\n   */\n  mintBatch = /* @__PURE__ */buildTransactionFunction(async metadatas => {\n    return this.mintBatchTo.prepare(await this.contractWrapper.getSignerAddress(), metadatas);\n  });\n\n  /**\n   * Mint many NFTs to a specific wallet\n   *\n   * @remarks Mint many unique NFTs at once to a specified wallet.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet you want to mint the NFT to\n   * const walletAddress = \"{{wallet_address}}\";\n   *\n   * // Custom metadata of the NFTs you want to mint.\n   * const metadatas = [{\n   *   name: \"Cool NFT #1\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   * }, {\n   *   name: \"Cool NFT #2\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/other/image.png\"),\n   * }];\n   *\n   * const tx = await contract.erc721.mintBatchTo(walletAddress, metadatas);\n   * const receipt = tx[0].receipt; // same transaction receipt for all minted NFTs\n   * const firstTokenId = tx[0].id; // token id of the first minted NFT\n   * const firstNFT = await tx[0].data(); // (optional) fetch details of the first minted NFT\n   * ```\n   * @twfeature ERC721BatchMintable\n   */\n  mintBatchTo = /* @__PURE__ */buildTransactionFunction(async (receiver, metadatas) => {\n    return assertEnabled(this.mintable?.batch, FEATURE_NFT_BATCH_MINTABLE).to.prepare(receiver, metadatas);\n  });\n\n  ////// ERC721 Burnable Extension //////\n\n  /**\n   * Burn a single NFT\n   * @param tokenId - the token Id to burn\n   *\n   * @example\n   * ```javascript\n   * const result = await contract.erc721.burn(tokenId);\n   * ```\n   * @twfeature ERC721Burnable\n   */\n  burn = /* @__PURE__ */buildTransactionFunction(async tokenId => {\n    return assertEnabled(this.burnable, FEATURE_NFT_BURNABLE).token.prepare(tokenId);\n  });\n\n  ////// ERC721 Loyalty Card Extension //////\n\n  /**\n   * Cancel loyalty card NFTs\n   *\n   * @remarks Cancel loyalty card NFTs held by the connected wallet\n   *\n   * @example\n   * ```javascript\n   * // The token ID of the loyalty card you want to cancel\n   * const tokenId = 0;\n   *\n   * const result = await contract.erc721.cancel(tokenId);\n   * ```\n   * @twfeature ERC721LoyaltyCard\n   */\n  cancel = /* @__PURE__ */buildTransactionFunction(async tokenId => {\n    return assertEnabled(this.loyaltyCard, FEATURE_NFT_LOYALTY_CARD).cancel.prepare(tokenId);\n  });\n\n  /**\n   * Revoke loyalty card NFTs\n   *\n   * @remarks Revoke loyalty card NFTs held by some owner.\n   *\n   * @example\n   * ```javascript\n   * // The token ID of the loyalty card you want to revoke\n   * const tokenId = 0;\n   *\n   * const result = await contract.erc721.revoke(tokenId);\n   * ```\n   * @twfeature ERC721LoyaltyCard\n   */\n  revoke = /* @__PURE__ */buildTransactionFunction(async tokenId => {\n    return assertEnabled(this.loyaltyCard, FEATURE_NFT_LOYALTY_CARD).revoke.prepare(tokenId);\n  });\n\n  ////// ERC721 LazyMint Extension //////\n\n  /**\n   * Lazy mint NFTs\n   *\n   * @remarks Create batch allows you to create a batch of many unique NFTs in one transaction.\n   *\n   * @example\n   * ```javascript\n   * // Custom metadata of the NFTs to create\n   * const metadatas = [{\n   *   name: \"Cool NFT\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   * }, {\n   *   name: \"Cool NFT\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"),\n   * }];\n   *\n   * const results = await contract.erc721.lazyMint(metadatas); // uploads and creates the NFTs on chain\n   * const firstTokenId = results[0].id; // token id of the first created NFT\n   * const firstNFT = await results[0].data(); // (optional) fetch details of the first created NFT\n   * ```\n   *\n   * @param metadatas - The metadata to include in the batch.\n   * @param options - optional upload progress callback\n   * @twfeature ERC721LazyMintable\n   */\n  lazyMint = /* @__PURE__ */buildTransactionFunction(async (metadatas, options) => {\n    return assertEnabled(this.lazyMintable, FEATURE_NFT_LAZY_MINTABLE).lazyMint.prepare(metadatas, options);\n  });\n\n  ////// ERC721 Metadata Extension //////\n\n  /**\n   * Update the metadata of an NFT\n   *\n   * @remarks Update the metadata of an NFT\n   *\n   * @example\n   * ```javascript\n   * // The token ID of the NFT whose metadata you want to update\n   * const tokenId = 0;\n   * // The new metadata\n   * const metadata = { name: \"My NFT\", description: \"My NFT description\"\"}\n   *\n   * await contract.erc721.update(tokenId, metadata);\n   * ```\n   * @twfeature ERC721UpdatableMetadata\n   */\n  update = /* @__PURE__ */buildTransactionFunction(async (tokenId, metadata) => {\n    return assertEnabled(this.updatableMetadata, FEATURE_NFT_UPDATABLE_METADATA).update.prepare(tokenId, metadata);\n  });\n\n  ////// ERC721 Claimable Extension //////\n\n  /**\n   * Claim NFTs\n   *\n   * @remarks Let the specified wallet claim NFTs.\n   *\n   * @example\n   * ```javascript\n   * const quantity = 1; // how many unique NFTs you want to claim\n   *\n   * const tx = await contract.erc721.claim(quantity);\n   * const receipt = tx.receipt; // the transaction receipt\n   * const claimedTokenId = tx.id; // the id of the NFT claimed\n   * const claimedNFT = await tx.data(); // (optional) get the claimed NFT metadata\n   * ```\n   *\n   * @param quantity - Quantity of the tokens you want to claim\n   *\n   * @returns - an array of results containing the id of the token claimed, the transaction receipt and a promise to optionally fetch the nft metadata\n   * @twfeature ERC721ClaimCustom | ERC721ClaimPhasesV2 | ERC721ClaimPhasesV1 | ERC721ClaimConditionsV2 | ERC721ClaimConditionsV1 | ERC721ClaimZora\n   */\n  claim = /* @__PURE__ */buildTransactionFunction(async (quantity, options) => {\n    return this.claimTo.prepare(await this.contractWrapper.getSignerAddress(), quantity, options);\n  });\n\n  /**\n   * Claim NFTs to a specific wallet\n   *\n   * @remarks Let the specified wallet claim NFTs.\n   *\n   * @example\n   * ```javascript\n   * const address = \"{{wallet_address}}\"; // address of the wallet you want to claim the NFTs\n   * const quantity = 1; // how many unique NFTs you want to claim\n   *\n   * const tx = await contract.erc721.claimTo(address, quantity);\n   * const receipt = tx.receipt; // the transaction receipt\n   * const claimedTokenId = tx.id; // the id of the NFT claimed\n   * const claimedNFT = await tx.data(); // (optional) get the claimed NFT metadata\n   * ```\n   *\n   * @param destinationAddress - Address you want to send the token to\n   * @param quantity - Quantity of the tokens you want to claim\n   * @param options\n   * @returns - an array of results containing the id of the token claimed, the transaction receipt and a promise to optionally fetch the nft metadata\n   * @twfeature ERC721ClaimCustom | ERC721ClaimPhasesV2 | ERC721ClaimPhasesV1 | ERC721ClaimConditionsV2 | ERC721ClaimConditionsV1 | ERC721ClaimZora\n   */\n  claimTo = /* @__PURE__ */buildTransactionFunction(async (destinationAddress, quantity, options) => {\n    const claimWithConditions = this.claimWithConditions;\n    const claim = this.claimCustom;\n    const claimZora = this.claimZora;\n    if (claimWithConditions) {\n      return claimWithConditions.to.prepare(destinationAddress, quantity, options);\n    }\n    if (claim) {\n      return claim.to.prepare(destinationAddress, quantity, options);\n    }\n    if (claimZora) {\n      return claimZora.to.prepare(destinationAddress, quantity, options);\n    }\n    throw new ExtensionNotImplementedError(FEATURE_NFT_CLAIM_CUSTOM);\n  });\n\n  /**\n   * Construct a claim transaction without executing it.\n   * This is useful for estimating the gas cost of a claim transaction, overriding transaction options and having fine grained control over the transaction execution.\n   * @param destinationAddress\n   * @param quantity\n   * @param options\n   *\n   * @deprecated Use `contract.erc721.claim.prepare(...args)` instead\n   * @twfeature ERC721ClaimCustom | ERC721ClaimPhasesV2 | ERC721ClaimPhasesV1 | ERC721ClaimConditionsV2 | ERC721ClaimConditionsV1\n   */\n  async getClaimTransaction(destinationAddress, quantity, options) {\n    const claimWithConditions = this.claimWithConditions;\n    const claim = this.claimCustom;\n    if (claimWithConditions) {\n      return claimWithConditions.conditions.getClaimTransaction(destinationAddress, quantity, options);\n    }\n    if (claim) {\n      return claim.getClaimTransaction(destinationAddress, quantity, options);\n    }\n    throw new ExtensionNotImplementedError(FEATURE_NFT_CLAIM_CUSTOM);\n  }\n\n  /**\n   * Get the claimed supply\n   *\n   * @remarks Get the number of claimed NFTs in this Drop.\n   *\n   * * @example\n   * ```javascript\n   * const claimedNFTCount = await contract.totalClaimedSupply();\n   * console.log(`NFTs claimed: ${claimedNFTCount}`);\n   * ```\n   * @returns the unclaimed supply\n   * @twfeature ERC721ClaimCustom | ERC721ClaimPhasesV2 | ERC721ClaimPhasesV1 | ERC721ClaimConditionsV2 | ERC721ClaimConditionsV1\n   */\n  async totalClaimedSupply() {\n    const contract = this.contractWrapper;\n    if (hasFunction(\"totalMinted\", contract)) {\n      return this.contractWrapper.read(\"totalMinted\", []);\n    }\n    if (hasFunction(\"nextTokenIdToClaim\", contract)) {\n      return this.contractWrapper.read(\"nextTokenIdToClaim\", []);\n    }\n    throw new Error(\"No function found on contract to get total claimed supply\");\n  }\n\n  /**\n   * Get the unclaimed supply\n   *\n   * @remarks Get the number of unclaimed NFTs in this Drop.\n   *\n   * * @example\n   * ```javascript\n   * const unclaimedNFTCount = await contract.totalUnclaimedSupply();\n   * console.log(`NFTs left to claim: ${unclaimedNFTCount}`);\n   * ```\n   * @returns the unclaimed supply\n   * @twfeature ERC721ClaimCustom | ERC721ClaimPhasesV2 | ERC721ClaimPhasesV1 | ERC721ClaimConditionsV2 | ERC721ClaimConditionsV1\n   */\n  async totalUnclaimedSupply() {\n    const [nextTokenIdToMint, totalClaimedSupply] = await Promise.all([this.nextTokenIdToMint(), this.totalClaimedSupply()]);\n    return nextTokenIdToMint.sub(totalClaimedSupply);\n  }\n\n  /**\n   * Configure claim conditions\n   * @remarks Define who can claim NFTs in the collection, when and how many.\n   * @example\n   * ```javascript\n   * const presaleStartTime = new Date();\n   * const publicSaleStartTime = new Date(Date.now() + 60 * 60 * 24 * 1000);\n   * const claimConditions = [\n   *   {\n   *     startTime: presaleStartTime, // start the presale now\n   *     maxClaimableSupply: 2, // limit how many mints for this presale\n   *     price: 0.01, // presale price\n   *     snapshot: ['0x...', '0x...'], // limit minting to only certain addresses\n   *   },\n   *   {\n   *     startTime: publicSaleStartTime, // 24h after presale, start public sale\n   *     price: 0.08, // public sale price\n   *   }\n   * ]);\n   * await contract.erc721.claimConditions.set(claimConditions);\n   * ```\n   * @twfeature ERC721ClaimPhasesV2 | ERC721ClaimPhasesV1 | ERC721ClaimConditionsV2 | ERC721ClaimConditionsV1\n   */\n  get claimConditions() {\n    return assertEnabled(this.claimWithConditions, FEATURE_NFT_CLAIM_CONDITIONS_V2).conditions;\n  }\n\n  ////// ERC721 Tiered Drop Extension //////\n\n  /**\n   * Tiered Drop\n   * @remarks Drop lazy minted NFTs using a tiered drop mechanism.\n   * @twfeature ERC721TieredDrop\n   */\n  get tieredDrop() {\n    return assertEnabled(this.tieredDropable, FEATURE_NFT_TIERED_DROP);\n  }\n\n  ////// ERC721 SignatureMint Extension //////\n\n  /**\n   * Mint with signature\n   * @remarks Generate dynamic NFTs with your own signature, and let others mint them using that signature.\n   * @example\n   * ```javascript\n   * // see how to craft a payload to sign in the `contract.erc721.signature.generate()` documentation\n   * const signedPayload = await contract.erc721.signature.generate(payload);\n   *\n   * // now anyone can mint the NFT\n   * const tx = await contract.erc721.signature.mint(signedPayload);\n   * const receipt = tx.receipt; // the mint transaction receipt\n   * const mintedId = tx.id; // the id of the NFT minted\n   * ```\n   * @twfeature ERC721SignatureMintV1 | ERC721SignatureMintV2\n   */\n  get signature() {\n    return assertEnabled(this.signatureMintable, FEATURE_NFT_SIGNATURE_MINTABLE_V2);\n  }\n\n  ////// ERC721 DelayedReveal Extension //////\n\n  /**\n   * Mint delayed reveal NFTs\n   * @remarks Create a batch of encrypted NFTs that can be revealed at a later time.\n   * @example\n   * ```javascript\n   * // the real NFTs, these will be encrypted until you reveal them\n   * const realNFTs = [{\n   *   name: \"Common NFT #1\",\n   *   description: \"Common NFT, one of many.\",\n   *   image: fs.readFileSync(\"path/to/image.png\"),\n   * }, {\n   *   name: \"Super Rare NFT #2\",\n   *   description: \"You got a Super Rare NFT!\",\n   *   image: fs.readFileSync(\"path/to/image.png\"),\n   * }];\n   * // A placeholder NFT that people will get immediately in their wallet, and will be converted to the real NFT at reveal time\n   * const placeholderNFT = {\n   *   name: \"Hidden NFT\",\n   *   description: \"Will be revealed next week!\"\n   * };\n   * // Create and encrypt the NFTs\n   * await contract.erc721.revealer.createDelayedRevealBatch(\n   *   placeholderNFT,\n   *   realNFTs,\n   *   \"my secret password\",\n   * );\n   * // Whenever you're ready, reveal your NFTs at any time\n   * const batchId = 0; // the batch to reveal\n   * await contract.erc721.revealer.reveal(batchId, \"my secret password\");\n   * ```\n   * @twfeature ERC721Revealable\n   */\n  get revealer() {\n    return assertEnabled(this.lazyMintable?.revealer, FEATURE_NFT_REVEALABLE);\n  }\n\n  ////// ERC721 Shared Metadata Extension (Open Edition) //////\n\n  /**\n   * Set shared metadata for all NFTs\n   * @remarks Set shared metadata for all NFTs in the collection. (Open Edition)\n   * @example\n   * ```javascript\n   * // defiine the metadata\n   * const metadata = {\n   *  name: \"Shared Metadata\",\n   *  description: \"Every NFT in this collection will share this metadata.\"\n   * };\n   *\n   *\n   * const tx = contract.erc721.sharedMetadata.set(metadata);\n   * ```\n   * @twfeature ERC721SharedMetadata\n   */\n  get sharedMetadata() {\n    return assertEnabled(this.erc721SharedMetadata, FEATURE_NFT_SHARED_METADATA);\n  }\n\n  /** ******************************\n   * PRIVATE FUNCTIONS\n   *******************************/\n\n  /**\n   * @internal\n   */\n  async getTokenMetadata(tokenId) {\n    const tokenUri = await this.contractWrapper.read(\"tokenURI\", [tokenId]);\n    if (!tokenUri) {\n      throw new NotFoundError();\n    }\n    return fetchTokenMetadata(tokenId, tokenUri, this.storage);\n  }\n\n  /**\n   * Return the next available token ID to mint\n   * @internal\n   */\n  async nextTokenIdToMint() {\n    if (hasFunction(\"nextTokenIdToMint\", this.contractWrapper)) {\n      let nextTokenIdToMint = await this.contractWrapper.read(\"nextTokenIdToMint\", []);\n      // handle open editions and contracts with startTokenId\n      if (hasFunction(\"startTokenId\", this.contractWrapper)) {\n        nextTokenIdToMint = nextTokenIdToMint.sub(await this.contractWrapper.read(\"startTokenId\", []));\n      }\n      return nextTokenIdToMint;\n    } else if (hasFunction(\"totalSupply\", this.contractWrapper)) {\n      return await this.contractWrapper.read(\"totalSupply\", []);\n    } else {\n      throw new Error(\"Contract requires either `nextTokenIdToMint` or `totalSupply` function available to determine the next token ID to mint\");\n    }\n  }\n  detectErc721Enumerable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC721Supply\") || hasFunction(\"nextTokenIdToMint\", this.contractWrapper)) {\n      return new Erc721Supply(this, this.contractWrapper);\n    }\n    return undefined;\n  }\n  detectErc721Mintable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC721Mintable\")) {\n      return new Erc721Mintable(this, this.contractWrapper, this.storage);\n    }\n    return undefined;\n  }\n  detectErc721Burnable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC721Burnable\")) {\n      return new Erc721Burnable(this.contractWrapper);\n    }\n    return undefined;\n  }\n  detectErc721LazyMintable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC721LazyMintable\")) {\n      return new Erc721LazyMintable(this, this.contractWrapper, this.storage);\n    }\n    return undefined;\n  }\n  detectErc721TieredDrop() {\n    if (detectContractFeature(this.contractWrapper, \"ERC721TieredDrop\")) {\n      return new Erc721TieredDrop(this, this.contractWrapper, this.storage);\n    }\n    return undefined;\n  }\n  detectErc721SignatureMintable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC721SignatureMintV1\") || detectContractFeature(this.contractWrapper, \"ERC721SignatureMintV2\")) {\n      return new Erc721WithQuantitySignatureMintable(this.contractWrapper, this.storage);\n    }\n    return undefined;\n  }\n  detectErc721ClaimableWithConditions() {\n    if (detectContractFeature(this.contractWrapper, \"ERC721ClaimConditionsV1\") || detectContractFeature(this.contractWrapper, \"ERC721ClaimConditionsV2\") || detectContractFeature(this.contractWrapper, \"ERC721ClaimPhasesV1\") || detectContractFeature(this.contractWrapper, \"ERC721ClaimPhasesV2\")) {\n      return new Erc721ClaimableWithConditions(this, this.contractWrapper, this.storage);\n    }\n    return undefined;\n  }\n  detectErc721Claimable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC721ClaimCustom\")) {\n      return new Erc721Claimable(this, this.contractWrapper);\n    }\n    return undefined;\n  }\n  detectErc721ClaimableZora() {\n    if (detectContractFeature(this.contractWrapper, \"ERC721ClaimZora\")) {\n      return new Erc721ClaimableZora(this, this.contractWrapper);\n    }\n    return undefined;\n  }\n  detectErc721SharedMetadata() {\n    if (detectContractFeature(this.contractWrapper, \"ERC721SharedMetadata\")) {\n      return new Erc721SharedMetadata(this.contractWrapper, this.storage);\n    }\n    return undefined;\n  }\n  detectErc721LoyaltyCard() {\n    if (detectContractFeature(this.contractWrapper, \"ERC721LoyaltyCard\")) {\n      return new Erc721LoyaltyCard(this.contractWrapper);\n    }\n    return undefined;\n  }\n  detectErc721UpdatableMetadata() {\n    if (detectContractFeature(this.contractWrapper, \"ERC721UpdatableMetadata\")) {\n      return new Erc721UpdatableMetadata(this.contractWrapper, this.storage);\n    }\n    return undefined;\n  }\n}\n\n/**\n * Mint Many ERC1155 NFTs at once\n * @remarks NFT batch minting functionality that handles IPFS storage for you.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * await contract.edition.mint.batch.to(walletAddress, [nftMetadataWithSupply1, nftMetadataWithSupply2, ...]);\n * ```\n * @public\n */\n\nclass Erc1155BatchMintable {\n  featureName = FEATURE_EDITION_BATCH_MINTABLE.name;\n  constructor(erc1155, contractWrapper, storage) {\n    this.erc1155 = erc1155;\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n  }\n\n  /**\n   * Mint Many NFTs with limited supplies\n   *\n   * @remarks Mint many different NFTs with limited supplies to a specified wallet.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet you want to mint the NFT to\n   * const toAddress = \"{{wallet_address}}\"\n   *\n   * // Custom metadata and supplies of your NFTs\n   * const metadataWithSupply = [{\n   *   supply: 50, // The number of this NFT you want to mint\n   *   metadata: {\n   *     name: \"Cool NFT #1\",\n   *     description: \"This is a cool NFT\",\n   *     image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   *   },\n   * }, {\n   *   supply: 100,\n   *   metadata: {\n   *     name: \"Cool NFT #2\",\n   *     description: \"This is a cool NFT\",\n   *     image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   *   },\n   * }];\n   *\n   * const tx = await contract.edition.mint.batch.to(toAddress, metadataWithSupply);\n   * const receipt = tx[0].receipt; // same transaction receipt for all minted NFTs\n   * const firstTokenId = tx[0].id; // token id of the first minted NFT\n   * const firstNFT = await tx[0].data(); // (optional) fetch details of the first minted NFT\n   * ```\n   */\n  to = /* @__PURE__ */buildTransactionFunction(async (to, metadataWithSupply) => {\n    const metadatas = metadataWithSupply.map(a => a.metadata);\n    const supplies = metadataWithSupply.map(a => a.supply);\n    const uris = await uploadOrExtractURIs(metadatas, this.storage);\n    const resolvedAddress = await resolveAddress(to);\n    const contractEncoder = new ContractEncoder(this.contractWrapper);\n    const encoded = await Promise.all(uris.map(async (uri, index) => contractEncoder.encode(\"mintTo\", [resolvedAddress, constants.MaxUint256, uri, supplies[index]])));\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"multicall\",\n      args: [encoded],\n      parse: receipt => {\n        const events = this.contractWrapper.parseLogs(\"TokensMinted\", receipt.logs);\n        if (events.length === 0 || events.length < metadatas.length) {\n          throw new Error(\"TokenMinted event not found, minting failed\");\n        }\n        return events.map(e => {\n          const id = e.args.tokenIdMinted;\n          return {\n            id,\n            receipt,\n            data: () => this.erc1155.get(id)\n          };\n        });\n      }\n    });\n  });\n}\nclass Erc1155Burnable {\n  featureName = FEATURE_EDITION_BURNABLE.name;\n  constructor(contractWrapper) {\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * Burn a specified amount of a NFTs\n   *\n   * @remarks Burn the specified NFTs from the connected wallet\n   *\n   * @param tokenId - the token Id to burn\n   * @param amount - amount to burn\n   *\n   * @example\n   * ```javascript\n   * // The token ID to burn NFTs of\n   * const tokenId = 0;\n   * // The amount of the NFT you want to burn\n   * const amount = 2;\n   *\n   * const result = await contract.edition.burn.tokens(tokenId, amount);\n   * ```\n   */\n  tokens = /* @__PURE__ */buildTransactionFunction(async (tokenId, amount) => {\n    const account = await this.contractWrapper.getSignerAddress();\n    return this.from.prepare(account, tokenId, amount);\n  });\n\n  /**\n   * Burn a specified amount of a NFTs\n   *\n   * @remarks Burn the specified NFTs from a specified wallet\n   *\n   * @param account - the address to burn NFTs from\n   * @param tokenId - the tokenId to burn\n   * @param amount - amount to burn\n   *\n   * @example\n   * ```javascript\n   * // The address of the wallet to burn NFTS from\n   * const account = \"0x...\";\n   * // The token ID to burn NFTs of\n   * const tokenId = 0;\n   * // The amount of this NFT you want to burn\n   * const amount = 2;\n   *\n   * const result = await contract.edition.burn.from(account, tokenId, amount);\n   * ```\n   */\n  from = /* @__PURE__ */buildTransactionFunction(async (account, tokenId, amount) => {\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"burn\",\n      args: [await resolveAddress(account), tokenId, amount]\n    });\n  });\n\n  /**\n   * Burn a batch of NFTs\n   *\n   * @remarks Burn the batch NFTs from the connected wallet\n   *\n   * @param tokenIds - the tokenIds to burn\n   * @param amounts - amount of each token to burn\n   *\n   * @example\n   * ```javascript\n   * // The token IDs to burn NFTs of\n   * const tokenIds = [0, 1];\n   * // The amounts of each NFT you want to burn\n   * const amounts = [2, 2];\n   *\n   * const result = await contract.edition.burn.batch(tokenIds, amounts);\n   * ```\n   */\n  batch = /* @__PURE__ */buildTransactionFunction(async (tokenIds, amounts) => {\n    const account = await this.contractWrapper.getSignerAddress();\n    return this.batchFrom.prepare(account, tokenIds, amounts);\n  });\n\n  /**\n   * Burn a batch of NFTs\n   *\n   * @remarks Burn the batch NFTs from the specified wallet\n   *\n   * @param account - the address to burn NFTs from\n   * @param tokenIds - the tokenIds to burn\n   * @param amounts - amount of each token to burn\n   *\n   * @example\n   * ```javascript\n   * // The address of the wallet to burn NFTS from\n   * const account = \"0x...\";\n   * // The token IDs to burn NFTs of\n   * const tokenIds = [0, 1];\n   * // The amounts of each NFT you want to burn\n   * const amounts = [2, 2];\n   *\n   * const result = await contract.edition.burn.batchFrom(account, tokenIds, amounts);\n   * ```\n   */\n  batchFrom = /* @__PURE__ */buildTransactionFunction(async (account, tokenIds, amounts) => {\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"burnBatch\",\n      args: [await resolveAddress(account), tokenIds, amounts]\n    });\n  });\n}\n\n/**\n * List ERC1155 NFTs\n * @remarks Easily list all the NFTs in a ERC1155 contract.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * const nfts = await contract.edition.query.all();\n * ```\n * @public\n */\n\nclass Erc1155Enumerable {\n  featureName = FEATURE_EDITION_ENUMERABLE.name;\n  constructor(erc1155, contractWrapper) {\n    this.erc1155 = erc1155;\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * Get All NFTs\n   *\n   * @remarks Get all the data associated with every NFT in this contract.\n   *\n   * By default, returns the first 100 NFTs, use queryParams to fetch more.\n   *\n   * @example\n   * ```javascript\n   * const nfts = await contract.edition.query.all();\n   * ```\n   * @param queryParams - optional filtering to only fetch a subset of results.\n   * @returns The NFT metadata for all NFTs queried.\n   */\n  async all(queryParams) {\n    const start = BigNumber.from(queryParams?.start || 0).toNumber();\n    const count = BigNumber.from(queryParams?.count || DEFAULT_QUERY_ALL_COUNT).toNumber();\n    const maxId = Math.min((await this.totalCount()).toNumber(), start + count);\n    return await Promise.all([...Array(maxId - start).keys()].map(i => this.erc1155.get((start + i).toString())));\n  }\n\n  /**\n   * Get the number of NFTs minted\n   * @remarks This returns the total number of NFTs minted in this contract, **not** the total supply of a given token.\n   *\n   * @returns the total number of NFTs minted in this contract\n   * @public\n   */\n  async totalCount() {\n    return await this.contractWrapper.read(\"nextTokenIdToMint\", []);\n  }\n\n  /**\n   * Get the supply of token for a given tokenId.\n   * @remarks This is **not** the sum of supply of all NFTs in the contract.\n   *\n   * @returns the total number of NFTs minted in this contract\n   * @public\n   */\n  async totalCirculatingSupply(tokenId) {\n    return await this.contractWrapper.read(\"totalSupply\", [tokenId]);\n  }\n\n  /**\n   * Get all NFTs owned by a specific wallet\n   *\n   * @remarks Get all the data associated with the NFTs owned by a specific wallet.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet to get the NFTs of\n   * const address = \"{{wallet_address}}\";\n   * const nfts = await contract.edition.query.owned(address);\n   * ```\n   *\n   * @returns The NFT metadata for all NFTs in the contract.\n   */\n  async owned(walletAddress) {\n    const [address, maxId] = await Promise.all([resolveAddress(walletAddress || (await this.contractWrapper.getSignerAddress())), this.contractWrapper.read(\"nextTokenIdToMint\", [])]);\n    const balances = await this.contractWrapper.read(\"balanceOfBatch\", [Array(maxId.toNumber()).fill(address), Array.from(Array(maxId.toNumber()).keys())]);\n    const ownedBalances = balances.map((b, i) => {\n      return {\n        tokenId: i,\n        balance: b\n      };\n    }).filter(b => b.balance.gt(0));\n    const nfts = (await Promise.all(ownedBalances.map(item => this.erc1155.get(item.tokenId.toString())))).map((editionMetadata, index) => ({\n      ...editionMetadata,\n      owner: address,\n      quantityOwned: ownedBalances[index].balance.toString()\n    }));\n    return nfts;\n  }\n}\nasync function getPrebuiltInfo(address, provider) {\n  try {\n    const contract = new Contract(address, IThirdwebContractABI, provider);\n    const [type, version] = await Promise.all([utils.toUtf8String(await contract.contractType()) // eslint-disable-next-line no-control-regex\n    .replace(/\\x00/g, \"\"), await contract.contractVersion()]);\n    return {\n      type,\n      version\n    };\n  } catch (e) {\n    return undefined;\n  }\n}\nclass Erc1155LazyMintable {\n  featureName = FEATURE_EDITION_LAZY_MINTABLE_V2.name;\n\n  /**\n   * Delayed reveal\n   * @remarks Create a batch of encrypted NFTs that can be revealed at a later time.\n   * @example\n   * ```javascript\n   * // the real NFTs, these will be encrypted until you reveal them\n   * const realNFTs = [{\n   *   name: \"Common NFT #1\",\n   *   description: \"Common NFT, one of many.\",\n   *   image: fs.readFileSync(\"path/to/image.png\"),\n   * }, {\n   *   name: \"Super Rare NFT #2\",\n   *   description: \"You got a Super Rare NFT!\",\n   *   image: fs.readFileSync(\"path/to/image.png\"),\n   * }];\n   * // A placeholder NFT that people will get immediately in their wallet, and will be converted to the real NFT at reveal time\n   * const placeholderNFT = {\n   *   name: \"Hidden NFT\",\n   *   description: \"Will be revealed next week!\"\n   * };\n   * // Create and encrypt the NFTs\n   * await contract.edition.drop.revealer.createDelayedRevealBatch(\n   *   placeholderNFT,\n   *   realNFTs,\n   *   \"my secret password\",\n   * );\n   * // Whenever you're ready, reveal your NFTs at any time\n   * const batchId = 0; // the batch to reveal\n   * await contract.edition.drop.revealer.reveal(batchId, \"my secret password\");\n   * ```\n   */\n\n  constructor(erc1155, contractWrapper, storage) {\n    this.erc1155 = erc1155;\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n    this.revealer = this.detectErc1155Revealable();\n  }\n\n  /**\n   * Create a batch of NFTs to be claimed in the future\n   *\n   * @remarks Create batch allows you to create a batch of many NFTs in one transaction.\n   *\n   * @example\n   * ```javascript\n   * // Custom metadata of the NFTs to create\n   * const metadatas = [{\n   *   name: \"Cool NFT\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   * }, {\n   *   name: \"Cool NFT\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"),\n   * }];\n   *\n   * const results = await contract.erc1155.lazyMint(metadatas); // uploads and creates the NFTs on chain\n   * const firstTokenId = results[0].id; // token id of the first created NFT\n   * const firstNFT = await results[0].data(); // (optional) fetch details of the first created NFT\n   * ```\n   *\n   * @param metadatas - The metadata to include in the batch.\n   * @param options - optional upload progress callback\n   */\n  lazyMint = /* @__PURE__ */buildTransactionFunction(async (metadatas, options) => {\n    const startFileNumber = await this.erc1155.nextTokenIdToMint();\n    const batch = await uploadOrExtractURIs(metadatas, this.storage, startFileNumber.toNumber(), options);\n    // ensure baseUri is the same for the entire batch\n    const baseUri = batch[0].substring(0, batch[0].lastIndexOf(\"/\"));\n    for (let i = 0; i < batch.length; i++) {\n      const uri = batch[i].substring(0, batch[i].lastIndexOf(\"/\"));\n      if (baseUri !== uri) {\n        throw new Error(`Can only create batches with the same base URI for every entry in the batch. Expected '${baseUri}' but got '${uri}'`);\n      }\n    }\n    const parse = receipt => {\n      const event = this.contractWrapper.parseLogs(\"TokensLazyMinted\", receipt?.logs);\n      const startingIndex = event[0].args.startTokenId;\n      const endingIndex = event[0].args.endTokenId;\n      const results = [];\n      for (let id = startingIndex; id.lte(endingIndex); id = id.add(1)) {\n        results.push({\n          id,\n          receipt,\n          data: () => this.erc1155.getTokenMetadata(id)\n        });\n      }\n      return results;\n    };\n    const prebuiltInfo = await getPrebuiltInfo(this.contractWrapper.address, this.contractWrapper.getProvider());\n    if (this.isLegacyEditionDropContract(this.contractWrapper, prebuiltInfo)) {\n      return Transaction.fromContractWrapper({\n        contractWrapper: this.contractWrapper,\n        method: \"lazyMint\",\n        args: [batch.length, `${baseUri.endsWith(\"/\") ? baseUri : `${baseUri}/`}`],\n        parse\n      });\n    } else {\n      // new contracts/extensions have support for delayed reveal that adds an extra parameter to lazyMint\n      return Transaction.fromContractWrapper({\n        contractWrapper: this.contractWrapper,\n        method: \"lazyMint\",\n        args: [batch.length, `${baseUri.endsWith(\"/\") ? baseUri : `${baseUri}/`}`, utils.toUtf8Bytes(\"\")],\n        parse\n      });\n    }\n  });\n\n  /** ******************************\n   * PRIVATE FUNCTIONS\n   *******************************/\n  detectErc1155Revealable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC1155Revealable\")) {\n      return new DelayedReveal(this.contractWrapper, this.storage, FEATURE_EDITION_REVEALABLE.name, () => this.erc1155.nextTokenIdToMint());\n    }\n    return undefined;\n  }\n  isLegacyEditionDropContract(contractWrapper, info) {\n    return info && info.type === \"DropERC1155\" && info.version < 3 || false;\n  }\n}\n\n/**\n * Mint ERC1155 NFTs\n * @remarks NFT minting functionality that handles IPFS storage for you.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * await contract.edition.mint.to(walletAddress, nftMetadata);\n * ```\n * @public\n */\n\nclass Erc1155Mintable {\n  featureName = FEATURE_EDITION_MINTABLE.name;\n\n  /**\n   * Batch mint Tokens to many addresses\n   */\n\n  constructor(erc1155, contractWrapper, storage) {\n    this.erc1155 = erc1155;\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n    this.batch = this.detectErc1155BatchMintable();\n  }\n\n  /**\n   * Mint an NFT with a limited supply\n   *\n   * @remarks Mint an NFT with a limited supply to a specified wallet.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet you want to mint the NFT to\n   * const toAddress = \"{{wallet_address}}\"\n   *\n   * // Custom metadata of the NFT, note that you can fully customize this metadata with other properties.\n   * const metadata = {\n   *   name: \"Cool NFT\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   * }\n   *\n   * const metadataWithSupply = {\n   *   metadata,\n   *   supply: 1000, // The number of this NFT you want to mint\n   * }\n   *\n   * const tx = await contract.edition.mint.to(toAddress, metadataWithSupply);\n   * const receipt = tx.receipt; // the transaction receipt\n   * const tokenId = tx.id; // the id of the NFT minted\n   * const nft = await tx.data(); // (optional) fetch details of minted NFT\n   * ```\n   *\n   */\n  to = /* @__PURE__ */buildTransactionFunction(async (to, metadataWithSupply) => {\n    const tx = await this.getMintTransaction(to, metadataWithSupply);\n    tx.setParse(receipt => {\n      const event = this.contractWrapper.parseLogs(\"TransferSingle\", receipt?.logs);\n      if (event.length === 0) {\n        throw new Error(\"TransferSingleEvent event not found\");\n      }\n      const id = event[0].args.id;\n      return {\n        id,\n        receipt,\n        data: () => this.erc1155.get(id.toString())\n      };\n    });\n    return tx;\n  });\n\n  /**\n   * @deprecated Use `contract.erc1155.mint.prepare(...args)` instead\n   */\n  async getMintTransaction(to, metadataWithSupply) {\n    const uri = await uploadOrExtractURI(metadataWithSupply.metadata, this.storage);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"mintTo\",\n      args: [await resolveAddress(to), constants.MaxUint256, uri, metadataWithSupply.supply]\n    });\n  }\n\n  /**\n   * Increase the supply of an existing NFT and mint it to a given wallet address\n   *\n   * @param to - the address to mint to\n   * @param tokenId - the token id of the NFT to increase supply of\n   * @param additionalSupply - the additional amount to mint\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet you want to mint the NFT to\n   * const toAddress = \"{{wallet_address}}\"\n   * const tokenId = 0;\n   * const additionalSupply = 1000;\n   *\n   * const tx = await contract.edition.mint.additionalSupplyTo(toAddress, tokenId, additionalSupply);\n   * ```\n   */\n  additionalSupplyTo = /* @__PURE__ */buildTransactionFunction(async (to, tokenId, additionalSupply) => {\n    const metadata = await this.erc1155.getTokenMetadata(tokenId);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"mintTo\",\n      args: [await resolveAddress(to), tokenId, metadata.uri, additionalSupply],\n      parse: receipt => {\n        return {\n          id: BigNumber.from(tokenId),\n          receipt,\n          data: () => this.erc1155.get(tokenId)\n        };\n      }\n    });\n  });\n  detectErc1155BatchMintable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC1155BatchMintable\")) {\n      return new Erc1155BatchMintable(this.erc1155, this.contractWrapper, this.storage);\n    }\n  }\n}\n\n/**\n * @internal\n */\nconst AirdropAddressInput = /* @__PURE__ */(() => z.object({\n  address: AddressOrEnsSchema,\n  quantity: AmountSchema.default(1)\n}))();\n\n/**\n * @internal\n */\nconst AirdropInputSchema = /* @__PURE__ */(() => z.union([z.array(z.string()).transform(async strings => await Promise.all(strings.map(address => AirdropAddressInput.parseAsync({\n  address\n})))), z.array(AirdropAddressInput)]))();\n\n/**\n * Configure and claim ERC1155 NFTs\n * @remarks Manage claim phases and claim ERC1155 NFTs that have been lazily minted.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * await contract.edition.drop.claim.to(\"0x...\", tokenId, quantity);\n * ```\n */\nclass ERC1155Claimable {\n  featureName = FEATURE_EDITION_CLAIM_CUSTOM.name;\n  constructor(contractWrapper) {\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * Construct a claim transaction without executing it.\n   * This is useful for estimating the gas cost of a claim transaction, overriding transaction options and having fine grained control over the transaction execution.\n   * @param destinationAddress - Address you want to send the token to\n   * @param tokenId - Id of the token you want to claim\n   * @param quantity - Quantity of the tokens you want to claim\n   * @param options - Options for claiming the NFTs\n   *\n   * @deprecated Use `contract.erc1155.claim.prepare(...args)` instead\n   */\n  async getClaimTransaction(destinationAddress, tokenId, quantity, options) {\n    let overrides = {};\n    if (options && options.pricePerToken) {\n      overrides = await calculateClaimCost(this.contractWrapper, options.pricePerToken, quantity, options.currencyAddress, options.checkERC20Allowance);\n    }\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"claim\",\n      args: [await resolveAddress(destinationAddress), tokenId, quantity],\n      overrides\n    });\n  }\n\n  /**\n   * Claim NFTs to a specific Wallet\n   *\n   * @remarks Let the specified wallet claim NFTs.\n   *\n   * @example\n   * ```javascript\n   * const address = \"{{wallet_address}}\"; // address of the wallet you want to claim the NFTs\n   * const tokenId = 0; // the id of the NFT you want to claim\n   * const quantity = 1; // how many NFTs you want to claim\n   *\n   * const tx = await contract.erc1155.claimTo(address, tokenId, quantity);\n   * const receipt = tx.receipt; // the transaction receipt\n   * ```\n   *\n   * @param destinationAddress - Address you want to send the token to\n   * @param tokenId - Id of the token you want to claim\n   * @param quantity - Quantity of the tokens you want to claim\n   * @param options - Options for claiming the NFTs\n   *\n   * @returns - Receipt for the transaction\n   */\n  to = /* @__PURE__ */buildTransactionFunction(async (destinationAddress, tokenId, quantity, options) => {\n    return await this.getClaimTransaction(destinationAddress, tokenId, quantity, options);\n  });\n}\n\n/**\n * Configure and claim ERC1155 NFTs\n * @remarks Manage claim phases and claim ERC1155 NFTs that have been lazily minted.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * await contract.erc1155.claim(tokenId, quantity);\n * await contract.erc1155.claimConditions.getActive(tokenId);\n * ```\n */\nclass Erc1155ClaimableWithConditions {\n  featureName = FEATURE_EDITION_CLAIM_CONDITIONS_V2.name;\n  constructor(contractWrapper, storage) {\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n    const metadata = new ContractMetadata(this.contractWrapper, CustomContractSchema, this.storage);\n    this.conditions = new DropErc1155ClaimConditions(contractWrapper, metadata, this.storage);\n  }\n\n  /**\n   * Claim NFTs to a specific Wallet\n   *\n   * @remarks Let the specified wallet claim NFTs.\n   *\n   * @example\n   * ```javascript\n   * const address = \"{{wallet_address}}\"; // address of the wallet you want to claim the NFTs\n   * const tokenId = 0; // the id of the NFT you want to claim\n   * const quantity = 1; // how many NFTs you want to claim\n   *\n   * const tx = await contract.erc1155.claimTo(address, tokenId, quantity);\n   * const receipt = tx.receipt; // the transaction receipt\n   * ```\n   *\n   * @param destinationAddress - Address you want to send the token to\n   * @param tokenId - Id of the token you want to claim\n   * @param quantity - Quantity of the tokens you want to claim\n   *\n   * @returns - Receipt for the transaction\n   */\n  to = /* @__PURE__ */buildTransactionFunction(async (destinationAddress, tokenId, quantity, options) => {\n    return await this.conditions.getClaimTransaction(destinationAddress, tokenId, quantity, options);\n  });\n}\n\n/**\n * Enables generating dynamic ERC1155 NFTs with rules and an associated signature, which can then be minted by anyone securely\n * @public\n */\nclass Erc1155SignatureMintable {\n  featureName = FEATURE_EDITION_SIGNATURE_MINTABLE.name;\n  constructor(contractWrapper, storage, roles) {\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n    this.roles = roles;\n  }\n\n  /**\n   * Mint a dynamically generated NFT\n   *\n   * @remarks Mint a dynamic NFT with a previously generated signature.\n   *\n   * @example\n   * ```javascript\n   * // see how to craft a payload to sign in the `generate()` documentation\n   * const signedPayload = contract.erc1155.signature.generate(payload);\n   *\n   * // now anyone can mint the NFT\n   * const tx = contract.erc1155.signature.mint(signedPayload);\n   * ```\n   * @param signedPayload - the previously generated payload and signature with {@link Erc1155SignatureMintable.generate}\n   * @twfeature ERC1155SignatureMintable\n   */\n  mint = /* @__PURE__ */buildTransactionFunction(async signedPayload => {\n    const mintRequest = signedPayload.payload;\n    const signature = signedPayload.signature;\n    const message = await this.mapPayloadToContractStruct(mintRequest);\n    const overrides = await this.contractWrapper.getCallOverrides();\n    // TODO: Transaction Sequence Pattern\n    await setErc20Allowance(this.contractWrapper, message.pricePerToken.mul(message.quantity), mintRequest.currencyAddress, overrides);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"mintWithSignature\",\n      args: [message, signature],\n      overrides,\n      parse: receipt => {\n        const t = this.contractWrapper.parseLogs(\"TokensMintedWithSignature\", receipt.logs);\n        if (t.length === 0) {\n          throw new Error(\"No MintWithSignature event found\");\n        }\n        const id = t[0].args.tokenIdMinted;\n        return {\n          id,\n          receipt\n        };\n      }\n    });\n  });\n\n  /**\n   * Mint any number of dynamically generated NFT at once\n   * @remarks Mint multiple dynamic NFTs in one transaction. Note that this is only possible for free mints (cannot batch mints with a price attached to it for security reasons)\n   *\n   * @example\n   * ```javascript\n   * // see how to craft a batch of payloads to sign in the `generateBatch()` documentation\n   * const signedPayloads = contract.erc1155.signature.generateBatch(payloads);\n   *\n   * // now anyone can mint the NFT\n   * const tx = contract.erc1155.signature.mintBatch(signedPayloads);\n   * ```\n   *\n   * @param signedPayloads - the array of signed payloads to mint\n   * @twfeature ERC1155SignatureMintable\n   */\n  mintBatch = /* @__PURE__ */buildTransactionFunction(async signedPayloads => {\n    const contractPayloads = await Promise.all(signedPayloads.map(async s => {\n      const message = await this.mapPayloadToContractStruct(s.payload);\n      const signature = s.signature;\n      const price = s.payload.price;\n      if (BigNumber.from(price).gt(0)) {\n        throw new Error(\"Can only batch free mints. For mints with a price, use regular mint()\");\n      }\n      return {\n        message,\n        signature\n      };\n    }));\n    const contractEncoder = new ContractEncoder(this.contractWrapper);\n    const encoded = contractPayloads.map(p => {\n      return contractEncoder.encode(\"mintWithSignature\", [p.message, p.signature]);\n    });\n    if (hasFunction(\"multicall\", this.contractWrapper)) {\n      return Transaction.fromContractWrapper({\n        contractWrapper: this.contractWrapper,\n        method: \"multicall\",\n        args: [encoded],\n        parse: receipt => {\n          const events = this.contractWrapper.parseLogs(\"TokensMintedWithSignature\", receipt.logs);\n          if (events.length === 0) {\n            throw new Error(\"No MintWithSignature event found\");\n          }\n          return events.map(log => ({\n            id: log.args.tokenIdMinted,\n            receipt\n          }));\n        }\n      });\n    } else {\n      throw new Error(\"Multicall not supported on this contract!\");\n    }\n  });\n\n  /**\n   * Verify that a payload is correctly signed\n   * @param signedPayload - the payload to verify\n   * @twfeature ERC1155SignatureMintable\n   *\n   * @example\n   * ```javascript\n   * const nftMetadata = {\n   *   name: \"Cool NFT #1\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   * };\n   *\n   * const startTime = new Date();\n   * const endTime = new Date(Date.now() + 60 * 60 * 24 * 1000);\n   * const payload = {\n   *   metadata: nftMetadata, // The NFT to mint\n   *   to: {{wallet_address}}, // Who will receive the NFT\n   *   quantity: 2, // the quantity of NFTs to mint\n   *   price: 0.5, // the price per NFT\n   *   currencyAddress: NATIVE_TOKEN_ADDRESS, // the currency to pay with\n   *   mintStartTime: startTime, // can mint anytime from now\n   *   mintEndTime: endTime, // to 24h from now\n   *   royaltyRecipient: \"0x...\", // custom royalty recipient for this NFT\n   *   royaltyBps: 100, // custom royalty fees for this NFT (in bps)\n   *   primarySaleRecipient: \"0x...\", // custom sale recipient for this NFT\n   * };\n   *\n   * const signedPayload = contract.erc1155.signature.generate(payload);\n   * // Now you can verify that the payload is valid\n   * const isValid = await contract.erc1155.signature.verify(signedPayload);\n   * ```\n   */\n  async verify(signedPayload) {\n    const mintRequest = signedPayload.payload;\n    const signature = signedPayload.signature;\n    const message = await this.mapPayloadToContractStruct(mintRequest);\n    const verification = await this.contractWrapper.read(\"verify\", [message, signature]);\n    return verification[0];\n  }\n\n  /**\n   * Generate a signature that can be used to mint an NFT dynamically.\n   *\n   * @remarks Takes in an NFT and some information about how it can be minted, uploads the metadata and signs it with your private key. The generated signature can then be used to mint an NFT using the exact payload and signature generated.\n   *\n   * @example\n   * ```javascript\n   * const nftMetadata = {\n   *   name: \"Cool NFT #1\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   * };\n   *\n   * const startTime = new Date();\n   * const endTime = new Date(Date.now() + 60 * 60 * 24 * 1000);\n   * const payload = {\n   *   metadata: nftMetadata, // The NFT to mint\n   *   to: {{wallet_address}}, // Who will receive the NFT\n   *   quantity: 2, // the quantity of NFTs to mint\n   *   price: 0.5, // the price per NFT\n   *   currencyAddress: NATIVE_TOKEN_ADDRESS, // the currency to pay with\n   *   mintStartTime: startTime, // can mint anytime from now\n   *   mintEndTime: endTime, // to 24h from now\n   *   royaltyRecipient: \"0x...\", // custom royalty recipient for this NFT\n   *   royaltyBps: 100, // custom royalty fees for this NFT (in bps)\n   *   primarySaleRecipient: \"0x...\", // custom sale recipient for this NFT\n   * };\n   *\n   * const signedPayload = await contract.erc1155.signature.generate(payload);\n   * // now anyone can use these to mint the NFT using `contract.erc1155.signature.mint(signedPayload)`\n   * ```\n   * @param payloadToSign - the payload to sign\n   * @returns the signed payload and the corresponding signature\n   * @twfeature ERC1155SignatureMintable\n   */\n  async generate(payloadToSign) {\n    const payload = {\n      ...payloadToSign,\n      tokenId: constants.MaxUint256\n    };\n    return this.generateFromTokenId(payload);\n  }\n\n  /**\n   * Generate a signature that can be used to mint additionaly supply to an existing NFT.\n   *\n   * @remarks Takes in a payload with the token ID of an existing NFT, and signs it with your private key. The generated signature can then be used to mint additional supply to the NFT using the exact payload and signature generated.\n   *\n   * @example\n   * ```javascript\n   * const nftMetadata = {\n   *   name: \"Cool NFT #1\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   * };\n   *\n   * const startTime = new Date();\n   * const endTime = new Date(Date.now() + 60 * 60 * 24 * 1000);\n   * const payload = {\n   *   tokenId: 0, // Instead of metadata, we specificy the token ID of the NFT to mint supply to\n   *   to: {{wallet_address}}, // Who will receive the NFT (or AddressZero for anyone)\n   *   quantity: 2, // the quantity of NFTs to mint\n   *   price: 0.5, // the price per NFT\n   *   currencyAddress: NATIVE_TOKEN_ADDRESS, // the currency to pay with\n   *   mintStartTime: startTime, // can mint anytime from now\n   *   mintEndTime: endTime, // to 24h from now\n   *   royaltyRecipient: \"0x...\", // custom royalty recipient for this NFT\n   *   royaltyBps: 100, // custom royalty fees for this NFT (in bps)\n   *   primarySaleRecipient: \"0x...\", // custom sale recipient for this NFT\n   * };\n   *\n   * const signedPayload = await contract.erc1155.signature.generateFromTokenId(payload);\n   * // now anyone can use these to mint the NFT using `contract.erc1155.signature.mint(signedPayload)`\n   * ```\n   * @param payloadToSign - the payload to sign\n   * @returns the signed payload and the corresponding signature\n   * @twfeature ERC1155SignatureMintable\n   */\n  async generateFromTokenId(payloadToSign) {\n    const payloads = await this.generateBatchFromTokenIds([payloadToSign]);\n    return payloads[0];\n  }\n\n  /**\n   * Generate a batch of signatures that can be used to mint many new NFTs dynamically.\n   *\n   * @remarks See {@link Erc1155SignatureMintable.generate}\n   *\n   * @param payloadsToSign - the payloads to sign\n   * @returns an array of payloads and signatures\n   * @twfeature ERC1155SignatureMintable\n   */\n  async generateBatch(payloadsToSign) {\n    const payloads = payloadsToSign.map(payload => ({\n      ...payload,\n      tokenId: constants.MaxUint256\n    }));\n    return this.generateBatchFromTokenIds(payloads);\n  }\n\n  /**\n   * Genrate a batch of signatures that can be used to mint new NFTs or additionaly supply to existing NFTs dynamically.\n   *\n   * @remarks See {@link Erc1155SignatureMintable.generateFromTokenId}\n   *\n   * @param payloadsToSign - the payloads to sign with tokenIds specified\n   * @returns an array of payloads and signatures\n   * @twfeature ERC1155SignatureMintable\n   */\n  async generateBatchFromTokenIds(payloadsToSign) {\n    await this.roles?.verify([\"minter\"], await this.contractWrapper.getSignerAddress());\n    const parsedRequests = await Promise.all(payloadsToSign.map(m => Signature1155PayloadInputWithTokenId.parseAsync(m)));\n    const metadatas = parsedRequests.map(r => r.metadata);\n    const uris = await uploadOrExtractURIs(metadatas, this.storage);\n    const chainId = await this.contractWrapper.getChainID();\n    const signer = this.contractWrapper.getSigner();\n    invariant(signer, \"No signer available\");\n    const contractInfo = await getPrebuiltInfo(this.contractWrapper.address, this.contractWrapper.getProvider());\n    const isLegacyContract = contractInfo?.type === \"TokenERC1155\";\n    return await Promise.all(parsedRequests.map(async (m, i) => {\n      const uri = uris[i];\n      const finalPayload = await Signature1155PayloadOutput.parseAsync({\n        ...m,\n        uri\n      });\n      const signature = await this.contractWrapper.signTypedData(signer, {\n        name: isLegacyContract ? \"TokenERC1155\" : \"SignatureMintERC1155\",\n        version: \"1\",\n        chainId,\n        verifyingContract: this.contractWrapper.address\n      }, {\n        MintRequest: MintRequest1155\n      },\n      // TYPEHASH\n      await this.mapPayloadToContractStruct(finalPayload));\n      return {\n        payload: finalPayload,\n        signature: signature.toString()\n      };\n    }));\n  }\n\n  /** ******************************\n   * PRIVATE FUNCTIONS\n   *******************************/\n\n  /**\n   * Maps a payload to the format expected by the contract\n   *\n   * @internal\n   *\n   * @param mintRequest - The payload to map.\n   * @returns - The mapped payload.\n   */\n  async mapPayloadToContractStruct(mintRequest) {\n    const normalizedPricePerToken = await normalizePriceValue(this.contractWrapper.getProvider(), mintRequest.price, mintRequest.currencyAddress);\n    return {\n      to: mintRequest.to,\n      tokenId: mintRequest.tokenId,\n      uri: mintRequest.uri,\n      quantity: mintRequest.quantity,\n      pricePerToken: normalizedPricePerToken,\n      currency: mintRequest.currencyAddress,\n      validityStartTimestamp: mintRequest.mintStartTime,\n      validityEndTimestamp: mintRequest.mintEndTime,\n      uid: mintRequest.uid,\n      royaltyRecipient: mintRequest.royaltyRecipient,\n      royaltyBps: mintRequest.royaltyBps,\n      primarySaleRecipient: mintRequest.primarySaleRecipient\n    };\n  }\n}\n\n/**\n * Standard ERC1155 NFT functions\n * @remarks Basic functionality for a ERC1155 contract that handles IPFS storage for you.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * await contract.erc1155.transfer(walletAddress, tokenId, quantity);\n * ```\n * @public\n */\nclass Erc1155 {\n  featureName = FEATURE_EDITION.name;\n  get chainId() {\n    return this._chainId;\n  }\n  constructor(contractWrapper, storage, chainId) {\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n    this.query = this.detectErc1155Enumerable();\n    this.mintable = this.detectErc1155Mintable();\n    this.burnable = this.detectErc1155Burnable();\n    this.lazyMintable = this.detectErc1155LazyMintable();\n    this.signatureMintable = this.detectErc1155SignatureMintable();\n    this.claimCustom = this.detectErc1155Claimable();\n    this.claimWithConditions = this.detectErc1155ClaimableWithConditions();\n    this._chainId = chainId;\n  }\n\n  /**\n   * @internal\n   */\n  onNetworkUpdated(network) {\n    this.contractWrapper.updateSignerOrProvider(network);\n  }\n  getAddress() {\n    return this.contractWrapper.address;\n  }\n\n  ////// Standard ERC1155 functions //////\n\n  /**\n   * Get a single NFT\n   *\n   * @example\n   * ```javascript\n   * const tokenId = 0;\n   * const nft = await contract.erc1155.get(tokenId);\n   * ```\n   * @param tokenId - the tokenId of the NFT to retrieve\n   * @returns The NFT metadata\n   * @twfeature ERC1155\n   */\n  async get(tokenId) {\n    const [supply, metadata] = await Promise.all([this.contractWrapper.read(\"totalSupply\", [tokenId]).catch(() => BigNumber.from(0)), this.getTokenMetadata(tokenId).catch(() => ({\n      id: tokenId.toString(),\n      uri: \"\",\n      ...FALLBACK_METADATA\n    }))]);\n    return {\n      owner: constants.AddressZero,\n      metadata,\n      type: \"ERC1155\",\n      supply: supply.toString()\n    };\n  }\n\n  /**\n   * Get the total supply of a specific token\n   * @example\n   * ```javascript\n   * const tokenId = 0;\n   * const nft = await contract.erc1155.totalSupply(tokenId);\n   * ```\n   * @param tokenId - The token ID to get the total supply of\n   * @returns the total supply\n   * @twfeature ERC1155\n   */\n  async totalSupply(tokenId) {\n    if (detectContractFeature(this.contractWrapper, \"ERC1155Supply\")) {\n      return await this.contractWrapper.read(\"totalSupply\", [tokenId]);\n    } else {\n      throw new ExtensionNotImplementedError(FEATURE_EDITION_SUPPLY);\n    }\n  }\n\n  /**\n   * Get NFT balance of a specific wallet\n   *\n   * @remarks Get a wallets NFT balance (number of NFTs in this contract owned by the wallet).\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet to check NFT balance\n   * const walletAddress = \"{{wallet_address}}\";\n   * const tokenId = 0; // Id of the NFT to check\n   * const balance = await contract.erc1155.balanceOf(walletAddress, tokenId);\n   * ```\n   * @twfeature ERC1155\n   */\n  async balanceOf(address, tokenId) {\n    return await this.contractWrapper.read(\"balanceOf\", [await resolveAddress(address), tokenId]);\n  }\n\n  /**\n   * Get NFT balance for the currently connected wallet\n   */\n  async balance(tokenId) {\n    return await this.balanceOf(await this.contractWrapper.getSignerAddress(), tokenId);\n  }\n\n  /**\n   * Get whether this wallet has approved transfers from the given operator\n   * @param address - the wallet address\n   * @param operator - the operator address\n   */\n  async isApproved(address, operator) {\n    return await this.contractWrapper.read(\"isApprovedForAll\", [await resolveAddress(address), await resolveAddress(operator)]);\n  }\n\n  /**\n   * Transfer an NFT\n   *\n   * @remarks Transfer an NFT from the connected wallet to another wallet.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet you want to send the NFT to\n   * const toAddress = \"{{wallet_address}}\";\n   * const tokenId = \"0\"; // The token ID of the NFT you want to send\n   * const amount = 3; // How many copies of the NFTs to transfer\n   * await contract.erc1155.transfer(toAddress, tokenId, amount);\n   * ```\n   * @twfeature ERC1155\n   */\n  transfer = /* @__PURE__ */buildTransactionFunction((() => {\n    var _this = this;\n    return async function (to, tokenId, amount) {\n      let data = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [0];\n      const from = await _this.contractWrapper.getSignerAddress();\n      return Transaction.fromContractWrapper({\n        contractWrapper: _this.contractWrapper,\n        method: \"safeTransferFrom\",\n        args: [from, await resolveAddress(to), tokenId, amount, data]\n      });\n    };\n  })());\n\n  /**\n   * Transfer an NFT from a specific wallet\n   *\n   * @remarks Transfer an NFT from a specific wallet to another wallet.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet you want to send the NFT to\n   * const toAddress = \"{{wallet_address}}\";\n   * const tokenId = \"0\"; // The token ID of the NFT you want to send\n   * const amount = 3; // How many copies of the NFTs to transfer\n   * await contract.erc1155.transfer(toAddress, tokenId, amount);\n   * ```\n   * @twfeature ERC1155\n   */\n  transferFrom = /* @__PURE__ */buildTransactionFunction((() => {\n    var _this2 = this;\n    return async function (from, to, tokenId, amount) {\n      let data = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [0];\n      return Transaction.fromContractWrapper({\n        contractWrapper: _this2.contractWrapper,\n        method: \"safeTransferFrom\",\n        args: [await resolveAddress(from), await resolveAddress(to), tokenId, amount, data]\n      });\n    };\n  })());\n\n  /**\n   * Set approval for all NFTs\n   * @remarks Approve or remove operator as an operator for the caller. Operators can call transferFrom or safeTransferFrom for any token owned by the caller.\n   * @example\n   * ```javascript\n   * const operator = \"{{wallet_address}}\";\n   * await contract.erc1155.setApprovalForAll(operator, true);\n   * ```\n   * @param operator - the operator's address\n   * @param approved - whether to approve or remove\n   * @twfeature ERC1155\n   */\n  setApprovalForAll = /* @__PURE__ */buildTransactionFunction(async (operator, approved) => {\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"setApprovalForAll\",\n      args: [operator, approved]\n    });\n  });\n\n  /**\n   * Airdrop multiple NFTs\n   *\n   * @remarks Airdrop one or multiple NFTs to the provided wallet addresses.\n   *\n   * @example\n   * ```javascript\n   * // The token ID of the NFT you want to airdrop\n   * const tokenId = \"0\";\n   * // Array of objects of addresses and quantities to airdrop NFTs to\n   * const addresses = [\n   *  {\n   *    address: \"0x...\",\n   *    quantity: 2,\n   *  },\n   *  {\n   *   address: \"0x...\",\n   *    quantity: 3,\n   *  },\n   * ];\n   * await contract.erc1155.airdrop(tokenId, addresses);\n   *\n   * // You can also pass an array of addresses, it will airdrop 1 NFT per address\n   * const tokenId = \"0\";\n   * const addresses = [\n   *  \"0x...\", \"0x...\", \"0x...\",\n   * ]\n   * await contract.erc1155.airdrop(tokenId, addresses);\n   * ```\n   * @twfeature ERC1155BatchTransferable\n   */\n  airdrop = /* @__PURE__ */buildTransactionFunction((() => {\n    var _this3 = this;\n    return async function (tokenId, addresses, fromAddress) {\n      let data = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [0];\n      const from = fromAddress ? await resolveAddress(fromAddress) : await _this3.contractWrapper.getSignerAddress();\n      const balanceOf = await _this3.balanceOf(from, tokenId);\n      const input = await AirdropInputSchema.parseAsync(addresses);\n      const totalToAirdrop = input.reduce((prev, curr) => {\n        return BigNumber.from(prev).add(BigNumber.from(curr?.quantity || 1));\n      }, BigNumber.from(0));\n      if (balanceOf.lt(BigNumber.from(totalToAirdrop))) {\n        throw new Error(`The caller owns ${balanceOf.toString()} NFTs, but wants to airdrop ${totalToAirdrop.toString()} NFTs.`);\n      }\n      const contractEncoder = new ContractEncoder(_this3.contractWrapper);\n      const encoded = input.map(_ref => {\n        let {\n          address: to,\n          quantity\n        } = _ref;\n        return contractEncoder.encode(\"safeTransferFrom\", [from, to, tokenId, quantity, data]);\n      });\n      return Transaction.fromContractWrapper({\n        contractWrapper: _this3.contractWrapper,\n        method: \"multicall\",\n        args: [encoded]\n      });\n    };\n  })());\n\n  /**\n   * Return the next available token ID to mint\n   * @internal\n   */\n  async nextTokenIdToMint() {\n    if (hasFunction(\"nextTokenIdToMint\", this.contractWrapper)) {\n      return await this.contractWrapper.read(\"nextTokenIdToMint\", []);\n    } else {\n      throw new Error(\"Contract requires the `nextTokenIdToMint` function available to determine the next token ID to mint\");\n    }\n  }\n\n  ////// ERC1155 Enumerable Extension //////\n\n  /**\n   * Get all NFTs\n   *\n   * @remarks Get all the data associated with every NFT in this contract.\n   *\n   * By default, returns the first 100 NFTs, use queryParams to fetch more.\n   *\n   * @example\n   * ```javascript\n   * const nfts = await contract.erc1155.getAll();\n   * ```\n   * @param queryParams - optional filtering to only fetch a subset of results.\n   * @returns The NFT metadata for all NFTs queried.\n   * @twfeature ERC1155Enumerable\n   */\n  async getAll(queryParams) {\n    return assertEnabled(this.query, FEATURE_EDITION_ENUMERABLE).all(queryParams);\n  }\n\n  /**\n   * Get the total number of NFTs minted\n   * @remarks This returns the total number of NFTs minted in this contract, **not** the total supply of a given token.\n   * @example\n   * ```javascript\n   * const count = await contract.erc1155.totalCount();\n   * console.log(count);\n   * ```\n   * @returns the total number of NFTs minted in this contract\n   * @public\n   * @twfeature ERC1155Enumerable\n   */\n  async totalCount() {\n    return assertEnabled(this.query, FEATURE_EDITION_ENUMERABLE).totalCount();\n  }\n\n  /**\n   * Get the total supply of a specific NFT\n   * @remarks This is **not** the sum of supply of all NFTs in the contract.\n   *\n   * @returns the total number of NFTs minted in this contract\n   * @public\n   * @twfeature ERC1155Enumerable\n   */\n  async totalCirculatingSupply(tokenId) {\n    return assertEnabled(this.query, FEATURE_EDITION_ENUMERABLE).totalCirculatingSupply(tokenId);\n  }\n\n  /**\n   * Get all NFTs owned by a specific wallet\n   *\n   * @remarks Get all the data associated with the NFTs owned by a specific wallet.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet to get the NFTs of\n   * const address = \"{{wallet_address}}\";\n   * const nfts = await contract.erc1155.getOwned(address);\n   * ```\n   *\n   * @returns The NFT metadata for all NFTs in the contract.\n   * @twfeature ERC1155Enumerable\n   */\n  async getOwned(walletAddress) {\n    if (walletAddress) {\n      walletAddress = await resolveAddress(walletAddress);\n    }\n    return assertEnabled(this.query, FEATURE_EDITION_ENUMERABLE).owned(walletAddress);\n  }\n\n  ////// ERC1155 Mintable Extension //////\n\n  /**\n   * Mint an NFT\n   *\n   * @remarks Mint an NFT with a limited supply to the connected wallet.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet you want to mint the NFT to\n   * const toAddress = \"{{wallet_address}}\"\n   *\n   * // Custom metadata of the NFT, note that you can fully customize this metadata with other properties.\n   * const metadata = {\n   *   name: \"Cool NFT\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   * }\n   *\n   * const metadataWithSupply = {\n   *   metadata,\n   *   supply: 1000, // The number of this NFT you want to mint\n   * }\n   *\n   * const tx = await contract.erc1155.mint(toAddress, metadataWithSupply);\n   * const receipt = tx.receipt; // the transaction receipt\n   * const tokenId = tx.id; // the id of the NFT minted\n   * const nft = await tx.data(); // (optional) fetch details of minted NFT\n   * ```\n   * @twfeature ERC1155Mintable\n   */\n  mint = /* @__PURE__ */buildTransactionFunction(async metadataWithSupply => {\n    return this.mintTo.prepare(await this.contractWrapper.getSignerAddress(), metadataWithSupply);\n  });\n\n  /**\n   * Mint an NFT to a specific wallet\n   *\n   * @remarks Mint an NFT with a limited supply to a specified wallet.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet you want to mint the NFT to\n   * const toAddress = \"{{wallet_address}}\"\n   *\n   * // Custom metadata of the NFT, note that you can fully customize this metadata with other properties.\n   * const metadata = {\n   *   name: \"Cool NFT\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   * }\n   *\n   * const metadataWithSupply = {\n   *   metadata,\n   *   supply: 1000, // The number of this NFT you want to mint\n   * }\n   *\n   * const tx = await contract.erc1155.mintTo(toAddress, metadataWithSupply);\n   * const receipt = tx.receipt; // the transaction receipt\n   * const tokenId = tx.id; // the id of the NFT minted\n   * const nft = await tx.data(); // (optional) fetch details of minted NFT\n   * ```\n   * @twfeature ERC1155Mintable\n   */\n  mintTo = /* @__PURE__ */buildTransactionFunction(async (receiver, metadataWithSupply) => {\n    return assertEnabled(this.mintable, FEATURE_EDITION_MINTABLE).to.prepare(receiver, metadataWithSupply);\n  });\n\n  /**\n   * Construct a mint transaction without executing it.\n   * This is useful for estimating the gas cost of a mint transaction, overriding transaction options and having fine grained control over the transaction execution.\n   * @param receiver - Address you want to send the token to\n   * @param metadataWithSupply - The metadata of the NFT you want to mint\n   *\n   * @deprecated Use `contract.erc1155.mint.prepare(...args)` instead\n   * @twfeature ERC1155Mintable\n   */\n  async getMintTransaction(receiver, metadataWithSupply) {\n    return assertEnabled(this.mintable, FEATURE_EDITION_MINTABLE).getMintTransaction(receiver, metadataWithSupply);\n  }\n\n  /**\n   * Increase the supply of an existing NFT\n   * @remarks Increase the supply of an existing NFT and mint it to the connected wallet address\n   * @example\n   * ```javascript\n   * const tokenId = 0;\n   * const additionalSupply = 1000;\n   * await contract.erc1155.mintAdditionalSupply(tokenId, additionalSupply);\n   * ```\n   *\n   * @param tokenId - the token id of the NFT to increase supply of\n   * @param additionalSupply - the additional amount to mint\n   * @twfeature ERC1155Mintable\n   */\n  mintAdditionalSupply = /* @__PURE__ */buildTransactionFunction(async (tokenId, additionalSupply) => {\n    return assertEnabled(this.mintable, FEATURE_EDITION_MINTABLE).additionalSupplyTo.prepare(await this.contractWrapper.getSignerAddress(), tokenId, additionalSupply);\n  });\n\n  /**\n   * Increase the supply of an existing NFT and mint it to a given wallet address\n   *\n   * @param to - the address to mint to\n   * @param tokenId - the token id of the NFT to increase supply of\n   * @param additionalSupply - the additional amount to mint\n   * @twfeature ERC1155Mintable\n   */\n  mintAdditionalSupplyTo = /* @__PURE__ */buildTransactionFunction(async (receiver, tokenId, additionalSupply) => {\n    return assertEnabled(this.mintable, FEATURE_EDITION_MINTABLE).additionalSupplyTo.prepare(receiver, tokenId, additionalSupply);\n  });\n\n  ////// ERC1155 BatchMintable Extension //////\n\n  /**\n   * Mint multiple NFTs at once\n   *\n   * @remarks Mint multiple different NFTs with limited supplies to the connected wallet.\n   *\n   * @example\n   * ```javascript\n   * // Custom metadata and supplies of your NFTs\n   * const metadataWithSupply = [{\n   *   supply: 50, // The number of this NFT you want to mint\n   *   metadata: {\n   *     name: \"Cool NFT #1\",\n   *     description: \"This is a cool NFT\",\n   *     image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   *   },\n   * }, {\n   *   supply: 100,\n   *   metadata: {\n   *     name: \"Cool NFT #2\",\n   *     description: \"This is a cool NFT\",\n   *     image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   *   },\n   * }];\n   *\n   * const tx = await contract.erc1155.mintBatch(metadataWithSupply);\n   * const receipt = tx[0].receipt; // same transaction receipt for all minted NFTs\n   * const firstTokenId = tx[0].id; // token id of the first minted NFT\n   * const firstNFT = await tx[0].data(); // (optional) fetch details of the first minted NFT\n   * ```\n   * @twfeature ERC1155BatchMintable\n   */\n  mintBatch = /* @__PURE__ */buildTransactionFunction(async metadataWithSupply => {\n    return this.mintBatchTo.prepare(await this.contractWrapper.getSignerAddress(), metadataWithSupply);\n  });\n\n  /**\n   * Mint multiple NFTs at once to a specific wallet\n   *\n   * @remarks Mint multiple different NFTs with limited supplies to a specified wallet.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet you want to mint the NFT to\n   * const toAddress = \"{{wallet_address}}\"\n   *\n   * // Custom metadata and supplies of your NFTs\n   * const metadataWithSupply = [{\n   *   supply: 50, // The number of this NFT you want to mint\n   *   metadata: {\n   *     name: \"Cool NFT #1\",\n   *     description: \"This is a cool NFT\",\n   *     image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   *   },\n   * }, {\n   *   supply: 100,\n   *   metadata: {\n   *     name: \"Cool NFT #2\",\n   *     description: \"This is a cool NFT\",\n   *     image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   *   },\n   * }];\n   *\n   * const tx = await contract.erc1155.mintBatchTo(toAddress, metadataWithSupply);\n   * const receipt = tx[0].receipt; // same transaction receipt for all minted NFTs\n   * const firstTokenId = tx[0].id; // token id of the first minted NFT\n   * const firstNFT = await tx[0].data(); // (optional) fetch details of the first minted NFT\n   * ```\n   * @twfeature ERC1155BatchMintable\n   */\n  mintBatchTo = /* @__PURE__ */buildTransactionFunction(async (receiver, metadataWithSupply) => {\n    return assertEnabled(this.mintable?.batch, FEATURE_EDITION_BATCH_MINTABLE).to.prepare(receiver, metadataWithSupply);\n  });\n\n  ////// ERC1155 Burnable Extension //////\n\n  /**\n   * Burn NFTs\n   *\n   * @remarks Burn the specified NFTs from the connected wallet\n   *\n   * @param tokenId - the token Id to burn\n   * @param amount - amount to burn\n   *\n   * @example\n   * ```javascript\n   * // The token ID to burn NFTs of\n   * const tokenId = 0;\n   * // The amount of the NFT you want to burn\n   * const amount = 2;\n   *\n   * const result = await contract.erc1155.burn(tokenId, amount);\n   * ```\n   * @twfeature ERC1155Burnable\n   */\n  burn = /* @__PURE__ */buildTransactionFunction(async (tokenId, amount) => {\n    return assertEnabled(this.burnable, FEATURE_EDITION_BURNABLE).tokens.prepare(tokenId, amount);\n  });\n\n  /**\n   * Burn NFTs from a specific wallet\n   *\n   * @remarks Burn the specified NFTs from a specified wallet\n   *\n   * @param account - the address to burn NFTs from\n   * @param tokenId - the tokenId to burn\n   * @param amount - amount to burn\n   *\n   * @example\n   * ```javascript\n   * // The address of the wallet to burn NFTS from\n   * const account = \"0x...\";\n   * // The token ID to burn NFTs of\n   * const tokenId = 0;\n   * // The amount of this NFT you want to burn\n   * const amount = 2;\n   *\n   * const result = await contract.erc1155.burnFrom(account, tokenId, amount);\n   * ```\n   * @twfeature ERC1155Burnable\n   */\n  burnFrom = /* @__PURE__ */buildTransactionFunction(async (account, tokenId, amount) => {\n    return assertEnabled(this.burnable, FEATURE_EDITION_BURNABLE).from.prepare(account, tokenId, amount);\n  });\n\n  /**\n   * Burn a batch of NFTs\n   *\n   * @remarks Burn the batch NFTs from the connected wallet\n   *\n   * @param tokenIds - the tokenIds to burn\n   * @param amounts - amount of each token to burn\n   *\n   * @example\n   * ```javascript\n   * // The token IDs to burn NFTs of\n   * const tokenIds = [0, 1];\n   * // The amounts of each NFT you want to burn\n   * const amounts = [2, 2];\n   *\n   * const result = await contract.erc1155.burnBatch(tokenIds, amounts);\n   * ```\n   * @twfeature ERC1155Burnable\n   */\n  burnBatch = /* @__PURE__ */buildTransactionFunction(async (tokenIds, amounts) => {\n    return assertEnabled(this.burnable, FEATURE_EDITION_BURNABLE).batch.prepare(tokenIds, amounts);\n  });\n\n  /**\n   * Burn a batch of NFTs from a specific wallet\n   *\n   * @remarks Burn the batch NFTs from the specified wallet\n   *\n   * @param account - the address to burn NFTs from\n   * @param tokenIds - the tokenIds to burn\n   * @param amounts - amount of each token to burn\n   *\n   * @example\n   * ```javascript\n   * // The address of the wallet to burn NFTS from\n   * const account = \"0x...\";\n   * // The token IDs to burn NFTs of\n   * const tokenIds = [0, 1];\n   * // The amounts of each NFT you want to burn\n   * const amounts = [2, 2];\n   *\n   * const result = await contract.erc1155.burnBatchFrom(account, tokenIds, amounts);\n   * ```\n   * @twfeature ERC1155Burnable\n   */\n  burnBatchFrom = /* @__PURE__ */buildTransactionFunction(async (account, tokenIds, amounts) => {\n    return assertEnabled(this.burnable, FEATURE_EDITION_BURNABLE).batchFrom.prepare(account, tokenIds, amounts);\n  });\n\n  ////// ERC721 LazyMint Extension //////\n\n  /**\n   * Lazy mint NFTs\n   *\n   * @remarks Create batch allows you to create a batch of many NFTs in one transaction.\n   *\n   * @example\n   * ```javascript\n   * // Custom metadata of the NFTs to create\n   * const metadatas = [{\n   *   name: \"Cool NFT\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   * }, {\n   *   name: \"Cool NFT\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"),\n   * }];\n   *\n   * const results = await contract.erc1155.lazyMint(metadatas); // uploads and creates the NFTs on chain\n   * const firstTokenId = results[0].id; // token id of the first created NFT\n   * const firstNFT = await results[0].data(); // (optional) fetch details of the first created NFT\n   * ```\n   *\n   * @param metadatas - The metadata to include in the batch.\n   * @param options - optional upload progress callback\n   * @twfeature ERC1155LazyMintableV1 | ERC1155LazyMintableV2\n   */\n  lazyMint = /* @__PURE__ */buildTransactionFunction(async (metadatas, options) => {\n    return assertEnabled(this.lazyMintable, FEATURE_EDITION_LAZY_MINTABLE_V2).lazyMint.prepare(metadatas, options);\n  });\n\n  ////// ERC1155 Claimable Extension //////\n\n  /**\n   * Construct a claim transaction without executing it.\n   * This is useful for estimating the gas cost of a claim transaction, overriding transaction options and having fine grained control over the transaction execution.\n   * @param destinationAddress - Address you want to send the token to\n   * @param tokenId - Id of the token you want to claim\n   * @param quantity - Quantity of the tokens you want to claim\n   * @param options - Optional claim verification data (e.g. price, currency, etc...)\n   *\n   * @deprecated Use `contract.erc1155.claim.prepare(...args)` instead\n   */\n  async getClaimTransaction(destinationAddress, tokenId, quantity, options) {\n    const claimWithConditions = this.claimWithConditions;\n    const claim = this.claimCustom;\n    if (claimWithConditions) {\n      return claimWithConditions.conditions.getClaimTransaction(destinationAddress, tokenId, quantity, options);\n    }\n    if (claim) {\n      return claim.getClaimTransaction(destinationAddress, tokenId, quantity, options);\n    }\n    throw new ExtensionNotImplementedError(FEATURE_EDITION_CLAIM_CUSTOM);\n  }\n\n  /**\n   * Claim NFTs\n   *\n   * @remarks Let the connected wallet claim NFTs.\n   *\n   * @example\n   * ```javascript\n   * const tokenId = 0; // the id of the NFT you want to claim\n   * const quantity = 1; // how many NFTs you want to claim\n   *\n   * const tx = await contract.erc1155.claim(tokenId, quantity);\n   * const receipt = tx.receipt; // the transaction receipt\n   * ```\n   *\n   * @param tokenId - Id of the token you want to claim\n   * @param quantity - Quantity of the tokens you want to claim\n   * @param options - Optional claim verification data (e.g. price, currency, etc...)\n   *\n   * @returns - Receipt for the transaction\n   * @twfeature ERC1155ClaimCustom | ERC1155ClaimPhasesV2 | ERC1155ClaimPhasesV1 | ERC1155ClaimConditionsV2 | ERC1155ClaimConditionsV1\n   */\n  claim = /* @__PURE__ */buildTransactionFunction(async (tokenId, quantity, options) => {\n    return this.claimTo.prepare(await this.contractWrapper.getSignerAddress(), tokenId, quantity, options);\n  });\n\n  /**\n   * Claim NFTs to a specific Wallet\n   *\n   * @remarks Let the specified wallet claim NFTs.\n   *\n   * @example\n   * ```javascript\n   * const address = \"{{wallet_address}}\"; // address of the wallet you want to claim the NFTs\n   * const tokenId = 0; // the id of the NFT you want to claim\n   * const quantity = 1; // how many NFTs you want to claim\n   *\n   * const tx = await contract.erc1155.claimTo(address, tokenId, quantity);\n   * const receipt = tx.receipt; // the transaction receipt\n   * ```\n   *\n   * @param destinationAddress - Address you want to send the token to\n   * @param tokenId - Id of the token you want to claim\n   * @param quantity - Quantity of the tokens you want to claim\n   * @param options - Optional claim verification data (e.g. price, currency, etc...)\n   *\n   * @returns - Receipt for the transaction\n   * @twfeature ERC1155ClaimCustom | ERC1155ClaimPhasesV2 | ERC1155ClaimPhasesV1 | ERC1155ClaimConditionsV2 | ERC1155ClaimConditionsV1\n   */\n  claimTo = /* @__PURE__ */buildTransactionFunction(async (destinationAddress, tokenId, quantity, options) => {\n    const claimWithConditions = this.claimWithConditions;\n    const claim = this.claimCustom;\n    if (claimWithConditions) {\n      return claimWithConditions.to.prepare(destinationAddress, tokenId, quantity, options);\n    }\n    if (claim) {\n      return claim.to.prepare(destinationAddress, tokenId, quantity, options);\n    }\n    throw new ExtensionNotImplementedError(FEATURE_EDITION_CLAIM_CUSTOM);\n  });\n\n  /**\n   * Configure claim conditions\n   * @remarks Define who can claim NFTs in the collection, when and how many.\n   * @example\n   * ```javascript\n   * const presaleStartTime = new Date();\n   * const publicSaleStartTime = new Date(Date.now() + 60 * 60 * 24 * 1000);\n   * const claimConditions = [\n   *   {\n   *     startTime: presaleStartTime, // start the presale now\n   *     maxClaimableSupply: 2, // limit how many mints for this presale\n   *     price: 0.01, // presale price\n   *     snapshot: ['0x...', '0x...'], // limit minting to only certain addresses\n   *   },\n   *   {\n   *     startTime: publicSaleStartTime, // 24h after presale, start public sale\n   *     price: 0.08, // public sale price\n   *   }\n   * ]);\n   * await contract.erc1155.claimConditions.set(tokenId, claimConditions);\n   * ```\n   * @twfeature ERC1155ClaimPhasesV2 | ERC1155ClaimPhasesV1 | ERC1155ClaimConditionsV2 | ERC1155ClaimConditionsV1\n   */\n  get claimConditions() {\n    return assertEnabled(this.claimWithConditions, FEATURE_EDITION_CLAIM_CONDITIONS_V2).conditions;\n  }\n\n  ////// ERC1155 SignatureMintable Extension //////\n\n  /**\n   * Mint with signature\n   * @remarks Generate dynamic NFTs with your own signature, and let others mint them using that signature.\n   * @example\n   * ```javascript\n   * // see how to craft a payload to sign in the `contract.erc1155.signature.generate()` documentation\n   * const signedPayload = contract.erc1155.signature().generate(payload);\n   *\n   * // now anyone can mint the NFT\n   * const tx = contract.erc1155.signature.mint(signedPayload);\n   * const receipt = tx.receipt; // the mint transaction receipt\n   * const mintedId = tx.id; // the id of the NFT minted\n   * ```\n   * @twfeature ERC1155SignatureMintable\n   */\n  get signature() {\n    return assertEnabled(this.signatureMintable, FEATURE_EDITION_SIGNATURE_MINTABLE);\n  }\n\n  ////// ERC1155 DelayedReveal Extension //////\n\n  /**\n   * Mint delayed reveal NFTs\n   * @remarks Create a batch of encrypted NFTs that can be revealed at a later time.\n   * @example\n   * ```javascript\n   * // the real NFTs, these will be encrypted until you reveal them\n   * const realNFTs = [{\n   *   name: \"Common NFT #1\",\n   *   description: \"Common NFT, one of many.\",\n   *   image: fs.readFileSync(\"path/to/image.png\"),\n   * }, {\n   *   name: \"Super Rare NFT #2\",\n   *   description: \"You got a Super Rare NFT!\",\n   *   image: fs.readFileSync(\"path/to/image.png\"),\n   * }];\n   * // A placeholder NFT that people will get immediately in their wallet, and will be converted to the real NFT at reveal time\n   * const placeholderNFT = {\n   *   name: \"Hidden NFT\",\n   *   description: \"Will be revealed next week!\"\n   * };\n   * // Create and encrypt the NFTs\n   * await contract.erc1155.drop.revealer.createDelayedRevealBatch(\n   *   placeholderNFT,\n   *   realNFTs,\n   *   \"my secret password\",\n   * );\n   * // Whenever you're ready, reveal your NFTs at any time\n   * const batchId = 0; // the batch to reveal\n   * await contract.erc1155.revealer.reveal(batchId, \"my secret password\");\n   * ```\n   * @twfeature ERC1155Revealable\n   */\n  get revealer() {\n    return assertEnabled(this.lazyMintable?.revealer, FEATURE_EDITION_REVEALABLE);\n  }\n\n  /** ******************************\n   * PRIVATE FUNCTIONS\n   *******************************/\n\n  /**\n   * @internal\n   * @param tokenId - the token Id to fetch\n   */\n  async getTokenMetadata(tokenId) {\n    const tokenUri = await this.contractWrapper.read(\"uri\", [tokenId]);\n    if (!tokenUri) {\n      throw new NotFoundError();\n    }\n    return fetchTokenMetadata(tokenId, tokenUri, this.storage);\n  }\n  detectErc1155Enumerable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC1155Enumerable\")) {\n      return new Erc1155Enumerable(this, this.contractWrapper);\n    }\n  }\n  detectErc1155Mintable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC1155Mintable\")) {\n      return new Erc1155Mintable(this, this.contractWrapper, this.storage);\n    }\n    return undefined;\n  }\n  detectErc1155Burnable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC1155Burnable\")) {\n      return new Erc1155Burnable(this.contractWrapper);\n    }\n    return undefined;\n  }\n  detectErc1155LazyMintable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC1155LazyMintableV1\") || detectContractFeature(this.contractWrapper, \"ERC1155LazyMintableV2\")) {\n      return new Erc1155LazyMintable(this, this.contractWrapper, this.storage);\n    }\n    return undefined;\n  }\n  detectErc1155SignatureMintable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC1155SignatureMintable\")) {\n      return new Erc1155SignatureMintable(this.contractWrapper, this.storage);\n    }\n    return undefined;\n  }\n  detectErc1155Claimable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC1155ClaimCustom\")) {\n      return new ERC1155Claimable(this.contractWrapper);\n    }\n    return undefined;\n  }\n  detectErc1155ClaimableWithConditions() {\n    if (detectContractFeature(this.contractWrapper, \"ERC1155ClaimConditionsV1\") || detectContractFeature(this.contractWrapper, \"ERC1155ClaimConditionsV2\") || detectContractFeature(this.contractWrapper, \"ERC1155ClaimPhasesV1\") || detectContractFeature(this.contractWrapper, \"ERC1155ClaimPhasesV2\")) {\n      return new Erc1155ClaimableWithConditions(this.contractWrapper, this.storage);\n    }\n    return undefined;\n  }\n}\nfunction cleanCurrencyAddress(currencyAddress) {\n  if (isNativeToken(currencyAddress)) {\n    return NATIVE_TOKEN_ADDRESS;\n  }\n  return currencyAddress;\n}\n\n/**\n * This method checks if the given token is approved for the transferrerContractAddress contract.\n * This is particularly useful for contracts that need to transfer NFTs on the users' behalf\n *\n * @internal\n * @param provider - The connected provider\n * @param transferrerContractAddress - The address of the marketplace contract\n * @param assetContract - The address of the asset contract.\n * @param tokenId - The token id of the token.\n * @param owner - The address of the account that owns the token.\n * @returns - True if the transferrerContractAddress is approved on the token, false otherwise.\n */\nasync function isTokenApprovedForTransfer(provider, transferrerContractAddress, assetContract, tokenId, owner) {\n  try {\n    const erc165 = new Contract(assetContract, ERC165Abi, provider);\n    const isERC721 = await erc165.supportsInterface(InterfaceId_IERC721);\n    const isERC1155 = await erc165.supportsInterface(InterfaceId_IERC1155);\n    if (isERC721) {\n      const asset = new Contract(assetContract, Erc721Abi, provider);\n      const approved = await asset.isApprovedForAll(owner, transferrerContractAddress);\n      if (approved) {\n        return true;\n      }\n\n      // Handle reverts in case of non-existent tokens\n      let approvedAddress;\n      try {\n        approvedAddress = await asset.getApproved(tokenId);\n      } catch (e) {}\n      return approvedAddress?.toLowerCase() === transferrerContractAddress.toLowerCase();\n    } else if (isERC1155) {\n      const asset = new Contract(assetContract, Erc1155Abi, provider);\n      return await asset.isApprovedForAll(owner, transferrerContractAddress);\n    } else {\n      console.error(\"Contract does not implement ERC 1155 or ERC 721.\");\n      return false;\n    }\n  } catch (err) {\n    console.error(\"Failed to check if token is approved\", err);\n    return false;\n  }\n}\n\n/**\n * Checks if the marketplace is approved to make transfers on the assetContract\n * If not, it tries to set the approval.\n * @param contractWrapper\n * @param marketplaceAddress\n * @param assetContract\n * @param tokenId\n * @param from\n */\nasync function handleTokenApproval(contractWrapper, marketplaceAddress, assetContract, tokenId, from) {\n  const erc165 = new ContractWrapper(contractWrapper.getSignerOrProvider(), assetContract, ERC165Abi, contractWrapper.options, contractWrapper.storage);\n  const isERC721 = await erc165.read(\"supportsInterface\", [InterfaceId_IERC721]);\n  const isERC1155 = await erc165.read(\"supportsInterface\", [InterfaceId_IERC1155]);\n  // check for token approval\n  if (isERC721) {\n    const asset = new ContractWrapper(contractWrapper.getSignerOrProvider(), assetContract, Erc721Abi, contractWrapper.options, contractWrapper.storage);\n    const approved = await asset.read(\"isApprovedForAll\", [from, marketplaceAddress]);\n    if (!approved) {\n      const isTokenApproved = (await asset.read(\"getApproved\", [tokenId])).toLowerCase() === marketplaceAddress.toLowerCase();\n      if (!isTokenApproved) {\n        await asset.sendTransaction(\"setApprovalForAll\", [marketplaceAddress, true]);\n      }\n    }\n  } else if (isERC1155) {\n    const asset = new ContractWrapper(contractWrapper.getSignerOrProvider(), assetContract, Erc1155Abi, contractWrapper.options, contractWrapper.storage);\n    const approved = await asset.read(\"isApprovedForAll\", [from, marketplaceAddress]);\n    if (!approved) {\n      await asset.sendTransaction(\"setApprovalForAll\", [marketplaceAddress, true]);\n    }\n  } else {\n    throw Error(\"Contract must implement ERC 1155 or ERC 721.\");\n  }\n}\n\n/**\n * Used to verify fields in new listing.\n * @internal\n */\n// TODO this should be done in zod\nfunction validateNewListingParam(param) {\n  invariant(param.assetContractAddress !== undefined && param.assetContractAddress !== null, \"Asset contract address is required\");\n  invariant(param.buyoutPricePerToken !== undefined && param.buyoutPricePerToken !== null, \"Buyout price is required\");\n  invariant(param.listingDurationInSeconds !== undefined && param.listingDurationInSeconds !== null, \"Listing duration is required\");\n  invariant(param.startTimestamp !== undefined && param.startTimestamp !== null, \"Start time is required\");\n  invariant(param.tokenId !== undefined && param.tokenId !== null, \"Token ID is required\");\n  invariant(param.quantity !== undefined && param.quantity !== null, \"Quantity is required\");\n  switch (param.type) {\n    case \"NewAuctionListing\":\n      {\n        invariant(param.reservePricePerToken !== undefined && param.reservePricePerToken !== null, \"Reserve price is required\");\n      }\n  }\n}\n\n/**\n * Maps a contract offer to the strict interface\n *\n * @internal\n * @param offer\n * @returns - An `Offer` object\n */\nasync function mapOffer(provider, listingId, offer) {\n  return {\n    quantity: offer.quantityDesired,\n    pricePerToken: offer.pricePerToken,\n    currencyContractAddress: offer.currency,\n    buyerAddress: offer.offeror,\n    quantityDesired: offer.quantityWanted,\n    currencyValue: await fetchCurrencyValue(provider, offer.currency, offer.quantityWanted.mul(offer.pricePerToken)),\n    listingId\n  };\n}\nfunction isWinningBid(winningPrice, newBidPrice, bidBuffer) {\n  bidBuffer = BigNumber.from(bidBuffer);\n  winningPrice = BigNumber.from(winningPrice);\n  newBidPrice = BigNumber.from(newBidPrice);\n  if (winningPrice.eq(BigNumber.from(0))) {\n    return false;\n  }\n  const buffer = newBidPrice.sub(winningPrice).mul(MAX_BPS).div(winningPrice);\n  return buffer.gte(bidBuffer);\n}\nasync function getAllInBatches(start, end, fn) {\n  const batches = [];\n  while (end - start > DEFAULT_QUERY_ALL_COUNT) {\n    batches.push(fn(start, start + DEFAULT_QUERY_ALL_COUNT - 1));\n    start += DEFAULT_QUERY_ALL_COUNT;\n  }\n  batches.push(fn(start, end - 1));\n  return await Promise.all(batches);\n}\n\n/**\n * Listen to Contract events in real time\n * @public\n */\nclass ContractEvents {\n  constructor(contractWrapper) {\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * Subscribe to transactions in this contract.\n   * @remarks Will emit an \"event\" object containing the transaction status ('submitted' and 'completed') and hash\n   * @example\n   * ```javascript\n   * contract.events.addTransactionListener((event) => {\n   *   console.log(event);\n   * }\n   * ```\n   * @param listener - the callback function that will be called on every transaction\n   * @public\n   */\n  addTransactionListener(listener) {\n    this.contractWrapper.addListener(EventType.Transaction, listener);\n  }\n\n  /**\n   * Remove a transaction listener\n   * @remarks Remove a listener that was added with addTransactionListener\n   * @example\n   * ```javascript\n   * contract.events.removeTransactionListener((event) => {\n   *  console.log(event);\n   * }\n   * ```\n   * @param listener - the callback function to remove\n   * @public\n   */\n  removeTransactionListener(listener) {\n    this.contractWrapper.off(EventType.Transaction, listener);\n  }\n\n  /**\n   * Subscribe to contract events\n   * @remarks You can add a listener for any contract event to run a function when\n   * the event is emitted. For example, if you wanted to listen for a \"TokensMinted\" event,\n   * you could do the following:\n   * @example\n   * ```javascript\n   * contract.events.addEventListener(\"TokensMinted\", (event) => {\n   *   console.log(event);\n   * });\n   * ```\n   * @public\n   * @param eventName - the event name as defined in the contract\n   * @param listener - the callback function that will be called on every new event\n   * @returns a function to un-subscribe from the event\n   */\n  addEventListener(\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  eventName, listener) {\n    // validates event, throws error if not found\n    const event = this.contractWrapper.readContract.interface.getEvent(eventName);\n    const address = this.contractWrapper.address;\n    const filter = {\n      address,\n      topics: [this.contractWrapper.readContract.interface.getEventTopic(event)]\n    };\n    const wrappedListener = log => {\n      const parsedLog = this.contractWrapper.readContract.interface.parseLog(log);\n      listener(this.toContractEvent(parsedLog.eventFragment, parsedLog.args, log));\n    };\n    this.contractWrapper.getProvider().on(filter, wrappedListener);\n    return () => {\n      this.contractWrapper.getProvider().off(filter, wrappedListener);\n    };\n  }\n\n  /**\n   * Listen to all events emitted from this contract\n   *\n   * @example\n   * ```javascript\n   * contract.events.listenToAllEvents((event) => {\n   *   console.log(event.eventName) // the name of the emitted event\n   *   console.log(event.data) // event payload\n   * }\n   * ```\n   * @public\n   * @param listener - the callback function that will be called on every new event\n   * @returns A function that can be called to stop listening to events\n   */\n  listenToAllEvents(listener) {\n    const address = this.contractWrapper.address;\n    const filter = {\n      address\n    };\n    const wrappedListener = log => {\n      try {\n        const parsedLog = this.contractWrapper.readContract.interface.parseLog(log);\n        listener(this.toContractEvent(parsedLog.eventFragment, parsedLog.args, log));\n      } catch (e) {\n        console.error(\"Could not parse event:\", log, e);\n      }\n    };\n    this.contractWrapper.getProvider().on(filter, wrappedListener);\n    return () => {\n      this.contractWrapper.getProvider().off(filter, wrappedListener);\n    };\n  }\n\n  /**\n   * Remove an event listener from this contract\n   * @remarks Remove a listener that was added with addEventListener\n   * @example\n   * ```javascript\n   * contract.events.removeEventListener(\"TokensMinted\", (event) => {\n   *   console.log(event);\n   * });\n   * ```\n   * @public\n   * @param eventName - the event name as defined in the contract\n   * @param listener - the listener to unregister\n   */\n  removeEventListener(\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  eventName, listener) {\n    // validates event, throws error if not found\n    const event = this.contractWrapper.readContract.interface.getEvent(eventName);\n    this.contractWrapper.readContract.off(event.name, listener);\n  }\n\n  /**\n   * Remove all listeners on this contract\n   * @remarks Remove all listeners from a contract\n   * @example\n   * ```javascript\n   * contract.events.removeAllListeners();\n   * ```\n   * @public\n   */\n  removeAllListeners() {\n    this.contractWrapper.readContract.removeAllListeners();\n    const address = this.contractWrapper.address;\n    const filter = {\n      address\n    };\n    this.contractWrapper.getProvider().removeAllListeners(filter);\n  }\n\n  /**\n   * Get All Events\n   * @remarks Get a list of all the events emitted from this contract during the specified time period\n   * @example\n   * ```javascript\n   * // Optionally pass in filters to limit the blocks from which events are retrieved\n   * const filters = {\n   *   fromBlock: 0,\n   *   toBlock: 1000000,\n   * }\n   * const events = await contract.events.getAllEvents(filters);\n   * console.log(events[0].eventName);\n   * console.log(events[0].data);\n   * ```\n   *\n   * @param filters - Specify the from and to block numbers to get events for, defaults to all blocks\n   * @returns The event objects of the events emitted with event names and data for each event\n   */\n  async getAllEvents() {\n    let filters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      fromBlock: 0,\n      toBlock: \"latest\",\n      order: \"desc\"\n    };\n    const events = await this.contractWrapper.readContract.queryFilter({}, filters.fromBlock, filters.toBlock);\n    const orderedEvents = events.sort((a, b) => {\n      return filters.order === \"desc\" ? b.blockNumber - a.blockNumber : a.blockNumber - b.blockNumber;\n    });\n    return this.parseEvents(orderedEvents);\n  }\n\n  /**\n   * Get Events\n   * @remarks Get a list of the events of a specific type emitted from this contract during the specified time period\n   * @example\n   * ```javascript\n   * // The name of the event to get logs for\n   * const eventName = \"Transfer\";\n   *\n   * // Optionally pass in options to limit the blocks from which events are retrieved\n   * const options = {\n   *   fromBlock: 0,\n   *   toBlock: 1000000, // can also pass \"latest\"\n   *   order: \"desc\",\n   *   // Configure event filters (filter on indexed event parameters)\n   *   filters: {\n   *     from: \"0x...\",\n   *     to: \"0x...\"\n   *   }\n   * };\n   *\n   * const events = await contract.events.getEvents(eventName, options);\n   * console.log(events[0].eventName);\n   * console.log(events[0].data);\n   * ```\n   *\n   * @param eventName - The name of the event to get logs for\n   * @param options - Specify the from and to block numbers to get events for, defaults to all blocks. @see EventQueryOptions\n   * @returns The requested event objects with event data\n   */\n  async getEvents(eventName) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      fromBlock: 0,\n      toBlock: \"latest\",\n      order: \"desc\"\n    };\n    const eventInterface = this.contractWrapper.readContract.interface.getEvent(eventName);\n    const args = options.filters ? eventInterface.inputs.map(e => options.filters[e.name]) : [];\n    const filter = this.contractWrapper.readContract.filters[eventInterface.name](...args);\n    const events = await this.contractWrapper.readContract.queryFilter(filter, options.fromBlock, options.toBlock);\n    const orderedEvents = events.sort((a, b) => {\n      return options.order === \"desc\" ? b.blockNumber - a.blockNumber : a.blockNumber - b.blockNumber;\n    });\n    return this.parseEvents(orderedEvents);\n  }\n  parseEvents(events) {\n    return events.map(e => {\n      const transaction = Object.fromEntries(Object.entries(e).filter(a => typeof a[1] !== \"function\" && a[0] !== \"args\"));\n      if (e.args) {\n        const entries = Object.entries(e.args);\n        const args = entries.slice(entries.length / 2, entries.length);\n        const data = {};\n        for (const [key, value] of args) {\n          data[key] = value;\n        }\n        return {\n          eventName: e.event || \"\",\n          data: data,\n          transaction\n        };\n      }\n      return {\n        eventName: e.event || \"\",\n        data: {},\n        transaction\n      };\n    });\n  }\n  toContractEvent(event, args, rawLog) {\n    const transaction = Object.fromEntries(Object.entries(rawLog).filter(a => typeof a[1] !== \"function\" && a[0] !== \"args\"));\n    const results = {};\n    event.inputs.forEach((param, index) => {\n      if (Array.isArray(args[index])) {\n        const components = param.components;\n        if (components) {\n          const arr = args[index];\n          if (param.type === \"tuple[]\") {\n            // tuple[]\n            const objArray = [];\n            for (let i = 0; i < arr.length; i++) {\n              const tuple = arr[i];\n              const obj = {};\n              for (let j = 0; j < components.length; j++) {\n                const name = components[j].name;\n                obj[name] = tuple[j];\n              }\n              objArray.push(obj);\n            }\n            results[param.name] = objArray;\n          } else {\n            // simple tuple\n            const obj = {};\n            for (let i = 0; i < components.length; i++) {\n              const name = components[i].name;\n              obj[name] = arr[i];\n            }\n            results[param.name] = obj;\n          }\n        }\n      } else {\n        results[param.name] = args[index];\n      }\n    });\n    return {\n      eventName: event.name,\n      data: results,\n      transaction\n    };\n  }\n}\n\n/**\n * @internal\n */\nconst DirectListingInputParamsSchema = /* @__PURE__ */(() => z.object({\n  /**\n   * The address of the asset being listed.\n   */\n  assetContractAddress: AddressOrEnsSchema,\n  /**\n   * The ID of the token to list.\n   */\n  tokenId: BigNumberishSchema,\n  /**\n   * The quantity of tokens to include in the listing.\n   *\n   * For ERC721s, this value should always be 1 (and will be forced internally regardless of what is passed here).\n   */\n  quantity: BigNumberishSchema.default(1),\n  /**\n   * The address of the currency to accept for the listing.\n   */\n  currencyContractAddress: AddressOrEnsSchema.default(NATIVE_TOKEN_ADDRESS),\n  /**\n   * The price to pay per unit of NFTs listed.\n   */\n  pricePerToken: AmountSchema,\n  /**\n   * The start time of the listing.\n   */\n  startTimestamp: RawDateSchema.default(new Date()),\n  /**\n   * The end time of the listing.\n   */\n  endTimestamp: EndDateSchema,\n  /**\n   * Whether the listing is reserved to be bought from a specific set of buyers.\n   */\n  isReservedListing: z.boolean().default(false)\n}))();\n\n/**\n * @public\n */\n\n/**\n * Allows overriding transaction behavior for this contract\n * @public\n */\nclass ContractInterceptor {\n  constructor(contractWrapper) {\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * The next transaction executed will add/replace any overrides passed via the passed in hook.\n   * @remarks Overridden values will be applied to the next transaction executed.\n   * @example\n   * ```javascript\n   * contract.interceptor.overrideNextTransaction(() => ({\n   *   gasLimit: 3000000,\n   * }));\n   * ```\n   * @param hook - the hook to add or replace any CallOverrides (gas limit, gas price, nonce, from, value, etc...)\n   * @public\n   */\n  overrideNextTransaction(hook) {\n    this.contractWrapper.withTransactionOverride(hook);\n  }\n}\n\n/**\n * Estimates the gas cost of Contract calls\n * @public\n */\nclass GasCostEstimator {\n  constructor(contractWrapper) {\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * Estimates the cost of gas in native token of the current chain\n   * Pass in the same parameters as the contract's function.\n   * @remarks Estimate the cost of gas in native token of the current chain\n   * @example\n   * ```javascript\n   * const costOfClaim = await nftDrop?.estimator.gasCostOf(\"claim\", [\n   *   \"0x...\", // receiver\n   *   1, // quantity\n   *   \"0x...\", // currency\n   *   1, // price per token\n   *   [], // proofs\n   *   1, // proof max quantity per transaction\n   * ]);\n   * ```\n   * @returns the estimated price in native currency (ETH, MATIC, etc) of calling this function\n   * @public\n   */\n  async gasCostOf(\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  fn, args) {\n    const [price, gasUnits] = await Promise.all([this.contractWrapper.getProvider().getGasPrice(), this.contractWrapper.estimateGas(fn, args)]);\n    return utils.formatEther(gasUnits.mul(price));\n  }\n\n  /**\n   * Estimates the gas limit of a transaction\n   * Pass in the same parameters as the contract's function.\n   * @remarks Estimates the gas limit of a transaction\n   * @example\n   * ```javascript\n   * const gasLimitOfClaim = await nftDrop?.estimator.gasLimitOf(\"claim\", [\n   *   \"0x...\", // receiver\n   *   1, // quantity\n   *   \"0x...\", // currency\n   *   1, // price per token\n   *   [], // proofs\n   *   1, // proof max quantity per transaction\n   * ]);\n   * ```\n   * @returns the estimated gas limit of the transaction\n   * @public\n   */\n  async gasLimitOf(\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  fn, args) {\n    return this.contractWrapper.estimateGas(fn, args);\n  }\n\n  /**\n   * Returns the current gas price in gwei\n   * @remarks Get the current gas price in gwei\n   * @example\n   * ```javascript\n   * const gasCostInGwei = await contract.estimator.currentGasPriceInGwei();\n   * ```\n   * @returns the current gas price in gwei\n   * @public\n   */\n  async currentGasPriceInGwei() {\n    const price = await this.contractWrapper.getProvider().getGasPrice();\n    return utils.formatUnits(price, \"gwei\");\n  }\n}\n\n/**\n * Handles direct listings\n * @public\n */\nclass MarketplaceV3DirectListings {\n  featureName = FEATURE_DIRECT_LISTINGS.name;\n\n  // utilities\n\n  constructor(contractWrapper, storage) {\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n    this.events = new ContractEvents(this.contractWrapper);\n    this.encoder = new ContractEncoder(this.contractWrapper);\n    this.interceptor = new ContractInterceptor(this.contractWrapper);\n    this.estimator = new GasCostEstimator(this.contractWrapper);\n  }\n  getAddress() {\n    return this.contractWrapper.address;\n  }\n\n  /** ******************************\n   * READ FUNCTIONS\n   *******************************/\n\n  /**\n   * Get the total number of direct listings\n   *\n   * @returns Returns the total number of direct listings created.\n   * @public\n   *\n   * @example\n   * ```javascript\n   * const totalListings = await contract.directListings.getTotalCount();\n   * ```\n   * @twfeature DirectListings\n   */\n  async getTotalCount() {\n    return await this.contractWrapper.read(\"totalListings\", []);\n  }\n\n  /**\n   * Get all direct listings\n   *\n   * @example\n   * ```javascript\n   * const listings = await contract.directListings.getAll();\n   * ```\n   *\n   * @param filter - optional filter parameters\n   * @returns the Direct listing object array\n   * @twfeature DirectListings\n   */\n  async getAll(filter) {\n    const totalListings = await this.getTotalCount();\n    const start = BigNumber.from(filter?.start || 0).toNumber();\n    const end = totalListings.toNumber();\n    if (end === 0) {\n      throw new Error(`No listings exist on the contract.`);\n    }\n    let rawListings = [];\n    const batches = await getAllInBatches(start, end, (startId, endId) => this.contractWrapper.read(\"getAllListings\", [startId, endId]));\n    rawListings = batches.flat();\n    const filteredListings = await this.applyFilter(rawListings, filter);\n    return await Promise.all(filteredListings.map(listing => this.mapListing(listing)));\n  }\n\n  /**\n   * Get all valid direct listings\n   *\n   * @remarks A valid listing is where the listing is active, and the creator still owns & has approved Marketplace to transfer the listed NFTs.\n   *\n   * @example\n   * ```javascript\n   * const listings = await contract.directListings.getAllValid();\n   * ```\n   *\n   * @param filter - optional filter parameters\n   * @returns the Direct listing object array\n   * @twfeature DirectListings\n   */\n  async getAllValid(filter) {\n    const totalListings = await this.getTotalCount();\n    const start = BigNumber.from(filter?.start || 0).toNumber();\n    const end = totalListings.toNumber();\n    if (end === 0) {\n      throw new Error(`No listings exist on the contract.`);\n    }\n    let rawListings = [];\n    const batches = await getAllInBatches(start, end, (startId, endId) => this.contractWrapper.read(\"getAllValidListings\", [startId, endId]));\n    rawListings = batches.flat();\n    const filteredListings = await this.applyFilter(rawListings, filter);\n    return await Promise.all(filteredListings.map(listing => this.mapListing(listing)));\n  }\n\n  /**\n   * Get a single direct listing\n   *\n   * @example\n   * ```javascript\n   * const listingId = 0;\n   * const listing = await contract.directListings.getListing(listingId);\n   * ```\n   *\n   * @param listingId - the listing id\n   * @returns the Direct listing object\n   *\n   * @example\n   * ```javascript\n   * const listingId = 0;\n   * const listing = await contract.directListings.getListing(listingId);\n   * ```\n   * @twfeature DirectListings\n   */\n  async getListing(listingId) {\n    const listing = await this.contractWrapper.read(\"getListing\", [listingId]);\n    return await this.mapListing(listing);\n  }\n\n  /**\n   * Check if a buyer is approved for a specific direct listing\n   *\n   * @example\n   * ```javascript\n   * const listingId = 0;\n   * const isBuyerApproved = await contract.directListings.isBuyerApprovedForListing(listingId, \"{{wallet_address}}\");\n   *\n   * @param listingId - the listing id\n   * @param buyer - buyer address\n   * @twfeature DirectListings\n   */\n  async isBuyerApprovedForListing(listingId, buyer) {\n    const listing = await this.validateListing(BigNumber.from(listingId));\n    if (!listing.isReservedListing) {\n      throw new Error(`Listing ${listingId} is not a reserved listing.`);\n    }\n    return await this.contractWrapper.read(\"isBuyerApprovedForListing\", [listingId, await resolveAddress(buyer)]);\n  }\n\n  /**\n   * Check if a currency is approved for a specific direct listing\n   *\n   * @example\n   * ```javascript\n   * const listingId = 0;\n   * const currencyContractAddress = '0x1234';\n   * const isApproved = await contract.directListings.isCurrencyApprovedForListing(listingId, currencyContractAddress);\n   * ```\n   *\n   * @param listingId - the listing id\n   * @param currency - currency address\n   * @twfeature DirectListings\n   */\n  async isCurrencyApprovedForListing(listingId, currency) {\n    await this.validateListing(BigNumber.from(listingId));\n    return await this.contractWrapper.read(\"isCurrencyApprovedForListing\", [listingId, await resolveAddress(currency)]);\n  }\n\n  /**\n   * Check price per token for an approved currency\n   *\n   * @example\n   * ```javascript\n   * const listingId = 0;\n   * const currencyContractAddress = '0x1234';\n   * const price = await contract.directListings.currencyPriceForListing(listingId, currencyContractAddress);\n   * ```\n   *\n   * @param listingId - the listing id\n   * @param currencyContractAddress - currency contract address\n   * @twfeature DirectListings\n   */\n  async currencyPriceForListing(listingId, currencyContractAddress) {\n    const listing = await this.validateListing(BigNumber.from(listingId));\n    const resolvedCurrencyAddress = await resolveAddress(currencyContractAddress);\n    if (resolvedCurrencyAddress === listing.currencyContractAddress) {\n      return listing.pricePerToken;\n    }\n    const isApprovedCurrency = await this.isCurrencyApprovedForListing(listingId, resolvedCurrencyAddress);\n    if (!isApprovedCurrency) {\n      throw new Error(`Currency ${resolvedCurrencyAddress} is not approved for Listing ${listingId}.`);\n    }\n    return await this.contractWrapper.read(\"currencyPriceForListing\", [listingId, resolvedCurrencyAddress]);\n  }\n\n  /** ******************************\n   * WRITE FUNCTIONS\n   *******************************/\n\n  /**\n   * Create new direct listing\n   *\n   * @remarks Create a new listing on the marketplace where people can buy an asset directly.\n   *\n   * @example\n   * ```javascript\n   * // Data of the listing you want to create\n   * const listing = {\n   *   // address of the contract the asset you want to list is on\n   *   assetContractAddress: \"0x...\",\n   *   // token ID of the asset you want to list\n   *   tokenId: \"0\",\n   *   // how many of the asset you want to list\n   *   quantity: 1,\n   *   // address of the currency contract that will be used to pay for the listing\n   *   currencyContractAddress: NATIVE_TOKEN_ADDRESS,\n   *   // The price to pay per unit of NFTs listed.\n   *   pricePerToken: 1.5,\n   *   // when should the listing open up for offers\n   *   startTimestamp: new Date(Date.now()),\n   *   // how long the listing will be open for\n   *   endTimestamp: new Date(Date.now() + 5 * 24 * 60 * 60 * 1000),\n   *   // Whether the listing is reserved for a specific set of buyers.\n   *   isReservedListing: false\n   * }\n   *\n   * const tx = await contract.directListings.createListing(listing);\n   * const receipt = tx.receipt; // the transaction receipt\n   * const id = tx.id; // the id of the newly created listing\n   * ```\n   * @twfeature DirectListings\n   */\n  createListing = /* @__PURE__ */buildTransactionFunction(async listing => {\n    const parsedListing = await DirectListingInputParamsSchema.parseAsync(listing);\n    await handleTokenApproval(this.contractWrapper, this.getAddress(), parsedListing.assetContractAddress, parsedListing.tokenId, await this.contractWrapper.getSignerAddress());\n    const normalizedPricePerToken = await normalizePriceValue(this.contractWrapper.getProvider(), parsedListing.pricePerToken, parsedListing.currencyContractAddress);\n    const block = await this.contractWrapper.getProvider().getBlock(\"latest\");\n    const blockTime = block.timestamp;\n    if (parsedListing.startTimestamp.lt(blockTime)) {\n      parsedListing.startTimestamp = BigNumber.from(blockTime);\n    }\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"createListing\",\n      args: [{\n        assetContract: parsedListing.assetContractAddress,\n        tokenId: parsedListing.tokenId,\n        quantity: parsedListing.quantity,\n        currency: cleanCurrencyAddress(parsedListing.currencyContractAddress),\n        pricePerToken: normalizedPricePerToken,\n        startTimestamp: parsedListing.startTimestamp,\n        endTimestamp: parsedListing.endTimestamp,\n        reserved: parsedListing.isReservedListing\n      }],\n      parse: receipt => {\n        const event = this.contractWrapper.parseLogs(\"NewListing\", receipt?.logs);\n        return {\n          id: event[0].args.listingId,\n          receipt\n        };\n      }\n    });\n  });\n\n  /**\n   * Create a batch of new listings\n   *\n   * @remarks Create a batch of new listings on the marketplace\n   *\n   * @example\n   * ```javascript\n   * const listings = [...];\n   * const tx = await contract.directListings.createListingsBatch(listings);\n   * ```\n   */\n  createListingsBatch = /* @__PURE__ */buildTransactionFunction(async listings => {\n    const data = await Promise.all(listings.map(async listing => {\n      const tx = await this.createListing.prepare(listing);\n      return tx.encode();\n    }));\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"multicall\",\n      args: [data],\n      parse: receipt => {\n        const events = this.contractWrapper.parseLogs(\"NewListing\", receipt?.logs);\n        return events.map(event => {\n          return {\n            id: event.args.listingId,\n            receipt\n          };\n        });\n      }\n    });\n  });\n\n  /**\n   * Update a direct listing\n   *\n   * @param listing - the new listing information\n   *\n   * @example\n   * ```javascript\n   * // Data of the listing you want to update\n   *\n   * const listingId = 0; // ID of the listing you want to update\n   *\n   * const listing = {\n   *   // address of the contract the asset you want to list is on\n   *   assetContractAddress: \"0x...\", // should be same as original listing\n   *   // token ID of the asset you want to list\n   *   tokenId: \"0\", // should be same as original listing\n   *   // how many of the asset you want to list\n   *   quantity: 1,\n   *   // address of the currency contract that will be used to pay for the listing\n   *   currencyContractAddress: NATIVE_TOKEN_ADDRESS,\n   *   // The price to pay per unit of NFTs listed.\n   *   pricePerToken: 1.5,\n   *   // when should the listing open up for offers\n   *   startTimestamp: new Date(Date.now()), // can't change this if listing already active\n   *   // how long the listing will be open for\n   *   endTimestamp: new Date(Date.now() + 5 * 24 * 60 * 60 * 1000),\n   *   // Whether the listing is reserved for a specific set of buyers.\n   *   isReservedListing: false\n   * }\n   *\n   * const tx = await contract.directListings.updateListing(listingId, listing);\n   * const receipt = tx.receipt; // the transaction receipt\n   * const id = tx.id; // the id of the newly created listing\n   * ```\n   * @twfeature DirectListings\n   */\n  updateListing = /* @__PURE__ */buildTransactionFunction(async (listingId, listing) => {\n    const parsedListing = await DirectListingInputParamsSchema.parseAsync(listing);\n    await handleTokenApproval(this.contractWrapper, this.getAddress(), parsedListing.assetContractAddress, parsedListing.tokenId, await this.contractWrapper.getSignerAddress());\n    const normalizedPricePerToken = await normalizePriceValue(this.contractWrapper.getProvider(), parsedListing.pricePerToken, parsedListing.currencyContractAddress);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"updateListing\",\n      args: [listingId, {\n        assetContract: parsedListing.assetContractAddress,\n        tokenId: parsedListing.tokenId,\n        quantity: parsedListing.quantity,\n        currency: cleanCurrencyAddress(parsedListing.currencyContractAddress),\n        pricePerToken: normalizedPricePerToken,\n        startTimestamp: parsedListing.startTimestamp,\n        endTimestamp: parsedListing.endTimestamp,\n        reserved: parsedListing.isReservedListing\n      }],\n      parse: receipt => {\n        const event = this.contractWrapper.parseLogs(\"UpdatedListing\", receipt?.logs);\n        return {\n          id: event[0].args.listingId,\n          receipt\n        };\n      }\n    });\n  });\n\n  /**\n   * Cancel Direct Listing\n   *\n   * @remarks Cancel a direct listing on the marketplace\n   *\n   * @example\n   * ```javascript\n   * // The listing ID of the direct listing you want to cancel\n   * const listingId = 0;\n   *\n   * await contract.directListings.cancelListing(listingId);\n   * ```\n   * @twfeature DirectListings\n   */\n  cancelListing = /* @__PURE__ */buildTransactionFunction(async listingId => {\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"cancelListing\",\n      args: [listingId]\n    });\n  });\n\n  /**\n   * Buy direct listing for a specific wallet\n   *\n   * @remarks Buy from a specific direct listing from the marketplace.\n   *\n   * @example\n   * ```javascript\n   * // The ID of the listing you want to buy from\n   * const listingId = 0;\n   * // Quantity of the asset you want to buy\n   * const quantityDesired = 1;\n   *\n   * await contract.directListings.buyFromListing(listingId, quantityDesired, \"{{wallet_address}}\");\n   * ```\n   *\n   * @param listingId - The listing id to buy\n   * @param quantityDesired - the quantity to buy\n   * @param receiver - optional receiver of the bought listing if different from the connected wallet\n   * @twfeature DirectListings\n   */\n  buyFromListing = /* @__PURE__ */buildTransactionFunction(async (listingId, quantityDesired, receiver) => {\n    if (receiver) {\n      receiver = await resolveAddress(receiver);\n    }\n    const listing = await this.validateListing(BigNumber.from(listingId));\n    const {\n      valid,\n      error\n    } = await this.isStillValidListing(listing, quantityDesired);\n    if (!valid) {\n      throw new Error(`Listing ${listingId} is no longer valid. ${error}`);\n    }\n    const buyFor = receiver ? receiver : await this.contractWrapper.getSignerAddress();\n    const quantity = BigNumber.from(quantityDesired);\n    const value = BigNumber.from(listing.pricePerToken).mul(quantity);\n    const overrides = (await this.contractWrapper.getCallOverrides()) || {};\n    await setErc20Allowance(this.contractWrapper, value, listing.currencyContractAddress, overrides);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"buyFromListing\",\n      args: [listingId, buyFor, quantity, listing.currencyContractAddress, value],\n      overrides\n    });\n  });\n\n  /**\n   * Approve buyer for a reserved direct listing\n   *\n   * @remarks Approve a buyer to buy from a reserved listing.\n   *\n   * @example\n   * ```javascript\n   * // The listing ID of the direct listing you want to approve buyer for\n   * const listingId = \"0\";\n   *\n   * await contract.directListings.approveBuyerForReservedListing(listingId, \"{{wallet_address}}\");\n   * ```\n   *\n   * @param listingId - The listing id to buy\n   * @param buyer - Address of buyer being approved\n   * @twfeature DirectListings\n   */\n  approveBuyerForReservedListing = /* @__PURE__ */buildTransactionFunction(async (listingId, buyer) => {\n    const isApproved = await this.isBuyerApprovedForListing(listingId, buyer);\n    if (!isApproved) {\n      return Transaction.fromContractWrapper({\n        contractWrapper: this.contractWrapper,\n        method: \"approveBuyerForListing\",\n        args: [listingId, buyer, true]\n      });\n    } else {\n      throw new Error(`Buyer ${buyer} already approved for listing ${listingId}.`);\n    }\n  });\n\n  /**\n   * Revoke approval of a buyer for a reserved direct listing\n   *\n   * @example\n   * ```javascript\n   * // The listing ID of the direct listing you want to approve buyer for\n   * const listingId = \"0\";\n   *\n   * await contract.directListings.revokeBuyerApprovalForReservedListing(listingId, \"{{wallet_address}}\");\n   * ```\n   *\n   * @param listingId - The listing id to buy\n   * @param buyer - Address of buyer being approved\n   */\n  revokeBuyerApprovalForReservedListing = /* @__PURE__ */buildTransactionFunction(async (listingId, buyer) => {\n    const isApproved = await this.isBuyerApprovedForListing(listingId, buyer);\n    if (isApproved) {\n      return Transaction.fromContractWrapper({\n        contractWrapper: this.contractWrapper,\n        method: \"approveBuyerForListing\",\n        args: [listingId, buyer, false]\n      });\n    } else {\n      throw new Error(`Buyer ${buyer} not approved for listing ${listingId}.`);\n    }\n  });\n\n  /**\n   * Approve a currency for a direct listing\n   *\n   *\n   * @example\n   * ```javascript\n   * // The listing ID of the direct listing you want to approve currency for\n   * const listingId = \"0\";\n   *\n   * await contract.directListings.approveCurrencyForListing(listingId, currencyContractAddress, pricePerTokenInCurrency);\n   * ```\n   *\n   * @param listingId - The listing id to buy\n   * @param currencyContractAddress - Address of currency being approved\n   * @param pricePerTokenInCurrency - Price per token in the currency\n   * @twfeature DirectListings\n   */\n  approveCurrencyForListing = /* @__PURE__ */buildTransactionFunction(async (listingId, currencyContractAddress, pricePerTokenInCurrency) => {\n    const listing = await this.validateListing(BigNumber.from(listingId));\n    const resolvedCurrencyAddress = await resolveAddress(currencyContractAddress);\n    if (resolvedCurrencyAddress === listing.currencyContractAddress) {\n      invariant(pricePerTokenInCurrency === listing.pricePerToken, \"Approving listing currency with a different price.\");\n    }\n    const currencyPrice = await this.contractWrapper.read(\"currencyPriceForListing\", [listingId, resolvedCurrencyAddress]);\n    invariant(pricePerTokenInCurrency === currencyPrice, \"Currency already approved with this price.\");\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"approveCurrencyForListing\",\n      args: [listingId, resolvedCurrencyAddress, pricePerTokenInCurrency]\n    });\n  });\n\n  /**\n   * Revoke approval of a currency for a direct listing\n   *\n   *\n   * @example\n   * ```javascript\n   * // The listing ID of the direct listing you want to revoke currency for\n   * const listingId = \"0\";\n   *\n   * await contract.directListings.revokeCurrencyApprovalForListing(listingId, currencyContractAddress);\n   * ```\n   *\n   * @param listingId - The listing id to buy\n   * @param currencyContractAddress - Address of currency\n   * @twfeature DirectListings\n   */\n  revokeCurrencyApprovalForListing = /* @__PURE__ */buildTransactionFunction(async (listingId, currencyContractAddress) => {\n    const listing = await this.validateListing(BigNumber.from(listingId));\n    const resolvedCurrencyAddress = await resolveAddress(currencyContractAddress);\n    if (resolvedCurrencyAddress === listing.currencyContractAddress) {\n      throw new Error(`Can't revoke approval for main listing currency.`);\n    }\n    const currencyPrice = await this.contractWrapper.read(\"currencyPriceForListing\", [listingId, resolvedCurrencyAddress]);\n    invariant(!currencyPrice.isZero(), \"Currency not approved.\");\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"approveCurrencyForListing\",\n      args: [listingId, resolvedCurrencyAddress, BigNumber.from(0)]\n    });\n  });\n\n  /** ******************************\n   * PRIVATE FUNCTIONS\n   *******************************/\n\n  /**\n   * Throws error if listing could not be found\n   *\n   * @param listingId - Listing to check for\n   */\n  async validateListing(listingId) {\n    try {\n      return await this.getListing(listingId);\n    } catch (err) {\n      console.error(`Error getting the listing with id ${listingId}`);\n      throw err;\n    }\n  }\n\n  /**\n   * Helper method maps the auction listing to the direct listing interface.\n   *\n   * @internal\n   * @param listing - The listing to map, as returned from the contract.\n   * @returns - The mapped interface.\n   */\n  async mapListing(listing) {\n    let status = Status.UNSET;\n    const block = await this.contractWrapper.getProvider().getBlock(\"latest\");\n    const blockTime = block.timestamp;\n    switch (listing.status) {\n      case 1:\n        status = BigNumber.from(listing.startTimestamp).gt(blockTime) ? Status.Created : BigNumber.from(listing.endTimestamp).lt(blockTime) ? Status.Expired : Status.Active;\n        break;\n      case 2:\n        status = Status.Completed;\n        break;\n      case 3:\n        status = Status.Cancelled;\n        break;\n    }\n    return {\n      assetContractAddress: listing.assetContract,\n      currencyContractAddress: listing.currency,\n      pricePerToken: listing.pricePerToken.toString(),\n      currencyValuePerToken: await fetchCurrencyValue(this.contractWrapper.getProvider(), listing.currency, listing.pricePerToken),\n      id: listing.listingId.toString(),\n      tokenId: listing.tokenId.toString(),\n      quantity: listing.quantity.toString(),\n      startTimeInSeconds: BigNumber.from(listing.startTimestamp).toNumber(),\n      asset: await fetchTokenMetadataForContract(listing.assetContract, this.contractWrapper.getProvider(), listing.tokenId, this.storage),\n      endTimeInSeconds: BigNumber.from(listing.endTimestamp).toNumber(),\n      creatorAddress: listing.listingCreator,\n      isReservedListing: listing.reserved,\n      status: status\n    };\n  }\n\n  /**\n   * Use this method to check if a direct listing is still valid.\n   *\n   * Ways a direct listing can become invalid:\n   * 1. The asset holder transferred the asset to another wallet\n   * 2. The asset holder burned the asset\n   * 3. The asset holder removed the approval on the marketplace\n   *\n   * @internal\n   * @param listing - The listing to check.\n   * @returns - True if the listing is valid, false otherwise.\n   */\n  async isStillValidListing(listing, quantity) {\n    const approved = await isTokenApprovedForTransfer(this.contractWrapper.getProvider(), this.getAddress(), listing.assetContractAddress, listing.tokenId, listing.creatorAddress);\n    if (!approved) {\n      return {\n        valid: false,\n        error: `Token '${listing.tokenId}' from contract '${listing.assetContractAddress}' is not approved for transfer`\n      };\n    }\n    const provider = this.contractWrapper.getProvider();\n    const erc165 = new Contract(listing.assetContractAddress, ERC165Abi, provider);\n    const isERC721 = await erc165.supportsInterface(InterfaceId_IERC721);\n    const isERC1155 = await erc165.supportsInterface(InterfaceId_IERC1155);\n    if (isERC721) {\n      const asset = new Contract(listing.assetContractAddress, Erc721Abi, provider);\n\n      // Handle reverts in case of non-existent tokens\n      let owner;\n      try {\n        owner = await asset.ownerOf(listing.tokenId);\n      } catch (e) {}\n      const valid = owner?.toLowerCase() === listing.creatorAddress.toLowerCase();\n      return {\n        valid,\n        error: valid ? undefined : `Seller is not the owner of Token '${listing.tokenId}' from contract '${listing.assetContractAddress} anymore'`\n      };\n    } else if (isERC1155) {\n      const asset = new Contract(listing.assetContractAddress, Erc1155Abi, provider);\n      const balance = await asset.balanceOf(listing.creatorAddress, listing.tokenId);\n      const valid = balance.gte(quantity || listing.quantity);\n      return {\n        valid,\n        error: valid ? undefined : `Seller does not have enough balance of Token '${listing.tokenId}' from contract '${listing.assetContractAddress} to fulfill the listing`\n      };\n    } else {\n      return {\n        valid: false,\n        error: \"Contract does not implement ERC 1155 or ERC 721.\"\n      };\n    }\n  }\n  async applyFilter(listings, filter) {\n    let rawListings = [...listings];\n    if (filter) {\n      if (filter.seller) {\n        const resolvedSeller = await resolveAddress(filter.seller);\n        rawListings = rawListings.filter(seller => seller.listingCreator.toString().toLowerCase() === resolvedSeller?.toString().toLowerCase());\n      }\n      if (filter.tokenContract) {\n        const resolvedToken = await resolveAddress(filter.tokenContract);\n        rawListings = rawListings.filter(tokenContract => tokenContract.assetContract.toString().toLowerCase() === resolvedToken?.toString().toLowerCase());\n      }\n      if (filter.tokenId !== undefined) {\n        rawListings = rawListings.filter(tokenContract => tokenContract.tokenId.toString() === filter?.tokenId?.toString());\n      }\n    }\n    return filter?.count && filter.count < rawListings.length ? rawListings.slice(0, filter.count) : rawListings;\n  }\n}\n\n/**\n * @internal\n */\nconst EnglishAuctionInputParamsSchema = /* @__PURE__ */(() => z.object({\n  /**\n   * The address of the asset being auctioned.\n   */\n  assetContractAddress: AddressOrEnsSchema,\n  /**\n   * The ID of the token to auction.\n   */\n  tokenId: BigNumberishSchema,\n  /**\n   * The quantity of tokens to include in the listing.\n   *\n   * For ERC721s, this value should always be 1 (and will be forced internally regardless of what is passed here).\n   */\n  quantity: BigNumberishSchema.default(1),\n  /**\n   * The address of the currency to accept for the listing.\n   */\n  currencyContractAddress: AddressOrEnsSchema.default(NATIVE_TOKEN_ADDRESS),\n  /**\n   * The minimum price that a bid must be in order to be accepted.\n   */\n  minimumBidAmount: AmountSchema,\n  /**\n   * The buyout price of the auction.\n   */\n  buyoutBidAmount: AmountSchema,\n  /**\n   * This is a buffer e.g. x seconds.\n   *\n   * If a new winning bid is made less than x seconds before expirationTimestamp, the\n   * expirationTimestamp is increased by x seconds.\n   */\n  timeBufferInSeconds: BigNumberishSchema.default(900),\n  // 15 minutes by default\n\n  /**\n   * This is a buffer in basis points e.g. x%.\n   *\n   * To be considered as a new winning bid, a bid must be at least x% greater than\n   * the current winning bid.\n   */\n  bidBufferBps: BigNumberishSchema.default(500),\n  // 5% by default\n\n  /**\n   * The start time of the auction.\n   */\n  startTimestamp: RawDateSchema.default(new Date()),\n  /**\n   * The end time of the auction.\n   */\n  endTimestamp: EndDateSchema\n}))();\n\n/**\n * @public\n */\n\n/**\n * Handles auctions\n * @public\n */\nclass MarketplaceV3EnglishAuctions {\n  featureName = FEATURE_ENGLISH_AUCTIONS.name;\n\n  // utilities\n\n  constructor(contractWrapper, storage) {\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n    this.events = new ContractEvents(this.contractWrapper);\n    this.encoder = new ContractEncoder(this.contractWrapper);\n    this.interceptor = new ContractInterceptor(this.contractWrapper);\n    this.estimator = new GasCostEstimator(this.contractWrapper);\n  }\n  getAddress() {\n    return this.contractWrapper.address;\n  }\n\n  /** ******************************\n   * READ FUNCTIONS\n   *******************************/\n\n  /**\n   * Get the total number of english auctions\n   *\n   * @returns Returns the total number of auctions created.\n   * @public\n   *\n   * @example\n   * ```javascript\n   * const totalAuctions = await contract.englishAuctions.getTotalCount();\n   * ```\n   * @twfeature EnglishAuctions\n   */\n  async getTotalCount() {\n    return await this.contractWrapper.read(\"totalAuctions\", []);\n  }\n\n  /**\n   * Get all english auctions\n   *\n   * @example\n   * ```javascript\n   * const auctions = await contract.englishAuctions.getAll();\n   * ```\n   *\n   * @param filter - optional filter parameters\n   * @returns the Auction object array\n   * @twfeature EnglishAuctions\n   */\n  async getAll(filter) {\n    const totalAuctions = await this.getTotalCount();\n    const start = BigNumber.from(filter?.start || 0).toNumber();\n    const end = totalAuctions.toNumber();\n    if (end === 0) {\n      throw new Error(`No auctions exist on the contract.`);\n    }\n    let rawAuctions = [];\n    const batches = await getAllInBatches(start, end, (startId, endId) => this.contractWrapper.read(\"getAllAuctions\", [startId, endId]));\n    rawAuctions = batches.flat();\n    const filteredAuctions = await this.applyFilter(rawAuctions, filter);\n    return await Promise.all(filteredAuctions.map(auction => this.mapAuction(auction)));\n  }\n\n  /**\n   * Get all valid english auctions\n   *\n   * @example\n   * ```javascript\n   * const auctions = await contract.englishAuctions.getAllValid();\n   * ```\n   *\n   * @param filter - optional filter parameters\n   * @returns the Auction object array\n   * @twfeature EnglishAuctions\n   */\n  async getAllValid(filter) {\n    const totalAuctions = await this.getTotalCount();\n    const start = BigNumber.from(filter?.start || 0).toNumber();\n    const end = totalAuctions.toNumber();\n    if (end === 0) {\n      throw new Error(`No auctions exist on the contract.`);\n    }\n    let rawAuctions = [];\n    const batches = await getAllInBatches(start, end, (startId, endId) => this.contractWrapper.read(\"getAllValidAuctions\", [startId, endId]));\n    rawAuctions = batches.flat();\n    const filteredAuctions = await this.applyFilter(rawAuctions, filter);\n    return await Promise.all(filteredAuctions.map(auction => this.mapAuction(auction)));\n  }\n\n  /**\n   * Get a single english auction\n   *\n   * @example\n   * ```javascript\n   * const auctionId = 0;\n   * const auction = await contract.englishAuctions.getAuction(auctionId);\n   * ```\n   *\n   * @param auctionId - the auction Id\n   * @returns the Auction object\n   * @twfeature EnglishAuctions\n   */\n  async getAuction(auctionId) {\n    const auction = await this.contractWrapper.read(\"getAuction\", [auctionId]);\n    return await this.mapAuction(auction);\n  }\n\n  /**\n   * Get winning bid of an english auction\n   *\n   * @remarks Get the current highest bid of an active auction.\n   *\n   * @example\n   * ```javascript\n   * // The ID of the auction\n   * const auctionId = 0;\n   * const winningBid = await contract.englishAuctions.getWinningBid(auctionId);\n   * ```\n   * @param auctionId - the auction Id\n   * @twfeature EnglishAuctions\n   */\n  async getWinningBid(auctionId) {\n    await this.validateAuction(BigNumber.from(auctionId));\n    const bid = await this.contractWrapper.read(\"getWinningBid\", [auctionId]);\n    if (bid._bidder === constants.AddressZero) {\n      return undefined;\n    }\n    return await this.mapBid(auctionId.toString(), bid._bidder, bid._currency, bid._bidAmount.toString());\n  }\n\n  /**\n   * Check if a bid is or will be a winning bid\n   *\n   * @example\n   * ```javascript\n   * const auctionId = 0;\n   * const bidAmount = 100;\n   * const isWinningBid = await contract.englishAuctions.isWinningBid(auctionId, bidAmount);\n   * ```\n   *\n   * @param auctionId - Auction Id\n   * @param bidAmount - Amount to bid\n   * @returns true if the bid is or will be a winning bid\n   * @twfeature EnglishAuctions\n   */\n  async isWinningBid(auctionId, bidAmount) {\n    return await this.contractWrapper.read(\"isNewWinningBid\", [auctionId, bidAmount]);\n  }\n\n  /**\n   * Get the winner for a specific english auction\n   *\n   * @remarks Get the winner of the auction after an auction ends.\n   *\n   * @example\n   * ```javascript\n   * // The auction ID of a closed english auction\n   * const auctionId = 0;\n   * const auctionWinner = await contract.englishAuctions.getWinner(auctionId);\n   * ```\n   * @param auctionId - the auction Id\n   * @returns the address of the auction winner\n   * @twfeature EnglishAuctions\n   */\n  async getWinner(auctionId) {\n    const auction = await this.validateAuction(BigNumber.from(auctionId));\n    const bid = await this.contractWrapper.read(\"getWinningBid\", [auctionId]);\n    const now = BigNumber.from(Math.floor(Date.now() / 1000));\n    const endTime = BigNumber.from(auction.endTimeInSeconds);\n\n    // if we have a winner in the map and the current time is past the endtime of the auction return the address of the winner\n    if (now.gt(endTime) && bid._bidder !== constants.AddressZero) {\n      return bid._bidder;\n    }\n    // otherwise fall back to query filter things\n\n    // TODO this should be via indexer or direct contract call\n    const contractEvent = new ContractEvents(this.contractWrapper);\n    const closedAuctions = await contractEvent.getEvents(\"AuctionClosed\");\n    const closed = closedAuctions.find(a => a.data.auctionId.eq(BigNumber.from(auctionId)));\n    if (!closed) {\n      throw new Error(`Could not find auction with ID ${auctionId} in closed auctions`);\n    }\n    return closed.data.winningBidder;\n  }\n\n  /** ******************************\n   * WRITE FUNCTIONS\n   *******************************/\n\n  /**\n   * Create an english auction\n   *\n   * @remarks Create a new auction where people can bid on an asset.\n   *\n   * @example\n   * ```javascript\n   * // Data of the auction you want to create\n   * const auction = {\n   *   // address of the contract of the asset you want to auction\n   *   assetContractAddress: \"0x...\",\n   *   // token ID of the asset you want to auction\n   *   tokenId: \"0\",\n   *   // how many of the asset you want to auction\n   *   quantity: 1,\n   *   // address of the currency contract that will be used to pay for the auctioned tokens\n   *   currencyContractAddress: NATIVE_TOKEN_ADDRESS,\n   *   // the minimum bid that will be accepted for the token\n   *   minimumBidAmount: \"1.5\",\n   *   // how much people would have to bid to instantly buy the asset\n   *   buyoutBidAmount: \"10\",\n   *   // If a bid is made less than these many seconds before expiration, the expiration time is increased by this.\n   *   timeBufferInSeconds: \"900\", // 15 minutes by default\n   *   // A bid must be at least this much bps greater than the current winning bid\n   *   bidBufferBps: \"500\", // 5% by default\n   *   // when should the auction open up for bidding\n   *   startTimestamp: new Date(Date.now()),\n   *   // end time of auction\n   *   endTimestamp: new Date(Date.now() + 5 * 24 * 60 * 60 * 1000),\n   * }\n   *\n   * const tx = await contract.englishAuctions.createAuction(auction);\n   * const receipt = tx.receipt; // the transaction receipt\n   * const id = tx.id; // the id of the newly created auction\n   * ```\n   * @param auction - the auction data\n   * @returns the transaction hash and the auction id\n   * @twfeature EnglishAuctions\n   */\n  createAuction = /* @__PURE__ */buildTransactionFunction(async auction => {\n    const parsedAuction = EnglishAuctionInputParamsSchema.parse(auction);\n    await handleTokenApproval(this.contractWrapper, this.getAddress(), parsedAuction.assetContractAddress, parsedAuction.tokenId, await this.contractWrapper.getSignerAddress());\n    const normalizedBuyoutAmount = await normalizePriceValue(this.contractWrapper.getProvider(), parsedAuction.buyoutBidAmount, parsedAuction.currencyContractAddress);\n    const normalizedMinBidAmount = await normalizePriceValue(this.contractWrapper.getProvider(), parsedAuction.minimumBidAmount, parsedAuction.currencyContractAddress);\n    const block = await this.contractWrapper.getProvider().getBlock(\"latest\");\n    const blockTime = block.timestamp;\n    if (parsedAuction.startTimestamp.lt(blockTime)) {\n      parsedAuction.startTimestamp = BigNumber.from(blockTime);\n    }\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"createAuction\",\n      args: [{\n        assetContract: parsedAuction.assetContractAddress,\n        tokenId: parsedAuction.tokenId,\n        quantity: parsedAuction.quantity,\n        currency: cleanCurrencyAddress(parsedAuction.currencyContractAddress),\n        minimumBidAmount: normalizedMinBidAmount,\n        buyoutBidAmount: normalizedBuyoutAmount,\n        timeBufferInSeconds: parsedAuction.timeBufferInSeconds,\n        bidBufferBps: parsedAuction.bidBufferBps,\n        startTimestamp: parsedAuction.startTimestamp,\n        endTimestamp: parsedAuction.endTimestamp\n      }],\n      parse: receipt => {\n        const event = this.contractWrapper.parseLogs(\"NewAuction\", receipt.logs)[0];\n        return {\n          id: event.args.auctionId,\n          receipt\n        };\n      }\n    });\n  });\n\n  /**\n   * Create a batch of new auctions\n   *\n   * @remarks Create a batch of new auctions on the marketplace\n   *\n   * @example\n   * ```javascript\n   * const auctions = [...];\n   * const tx = await contract.englishAuctions.createAuctionsBatch(auctions);\n   * ```\n   */\n  createAuctionsBatch = /* @__PURE__ */buildTransactionFunction(async listings => {\n    const data = await Promise.all(listings.map(async listing => {\n      const tx = await this.createAuction.prepare(listing);\n      return tx.encode();\n    }));\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"multicall\",\n      args: [data],\n      parse: receipt => {\n        const events = this.contractWrapper.parseLogs(\"NewAuction\", receipt?.logs);\n        return events.map(event => {\n          return {\n            id: event.args.auctionId,\n            receipt\n          };\n        });\n      }\n    });\n  });\n\n  /**\n   * Buyout an english auction\n   *\n   * @remarks Buy a specific auction from the marketplace.\n   *\n   * @example\n   * ```javascript\n   * // The auction ID you want to buy\n   * const auctionId = 0;\n   *\n   * await contract.englishAuctions.buyoutAuction(auctionId);\n   * ```\n   * @param auctionId - the auction id\n   * @returns the transaction result\n   * @twfeature EnglishAuctions\n   */\n  buyoutAuction = /* @__PURE__ */buildTransactionFunction(async auctionId => {\n    const auction = await this.validateAuction(BigNumber.from(auctionId));\n    const currencyMetadata = await fetchCurrencyMetadata(this.contractWrapper.getProvider(), auction.currencyContractAddress);\n    return this.makeBid.prepare(auctionId, utils.formatUnits(auction.buyoutBidAmount, currencyMetadata.decimals));\n  });\n\n  /**\n   * Bid on an english auction\n   *\n   * @remarks Make a bid on an auction\n   *\n   * @example\n   * ```javascript\n   * // The auction ID of the asset you want to bid on\n   * const auctionId = 0;\n   * // The total amount you are willing to bid for auctioned tokens\n   * const bidAmount = 1;\n   *\n   * await contract.englishAuctions.makeBid(auctionId, bidAmount);\n   * ```\n   * @param auctionId - the auction id\n   * @param bidAmount - the amount you are willing to bid\n   * @returns the transaction result\n   * @twfeature EnglishAuctions\n   */\n  makeBid = /* @__PURE__ */buildTransactionFunction(async (auctionId, bidAmount) => {\n    const auction = await this.validateAuction(BigNumber.from(auctionId));\n    const normalizedBidAmount = await normalizePriceValue(this.contractWrapper.getProvider(), bidAmount, auction.currencyContractAddress);\n    if (normalizedBidAmount.eq(BigNumber.from(0))) {\n      throw new Error(\"Cannot make a bid with 0 value\");\n    }\n    if (BigNumber.from(auction.buyoutBidAmount).gt(0) && normalizedBidAmount.gt(auction.buyoutBidAmount)) {\n      throw new Error(\"Bid amount must be less than or equal to buyoutBidAmount\");\n    }\n    const winningBid = await this.getWinningBid(auctionId);\n    if (winningBid) {\n      const isWinnner = await this.isWinningBid(auctionId, normalizedBidAmount);\n      invariant(isWinnner, \"Bid price is too low based on the current winning bid and the bid buffer\");\n    } else {\n      const tokenPrice = normalizedBidAmount;\n      const minimumBidAmount = BigNumber.from(auction.minimumBidAmount);\n      invariant(tokenPrice.gte(minimumBidAmount), \"Bid price is too low based on minimum bid amount\");\n    }\n    const overrides = (await this.contractWrapper.getCallOverrides()) || {};\n    await setErc20Allowance(this.contractWrapper, normalizedBidAmount, auction.currencyContractAddress, overrides);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"bidInAuction\",\n      args: [auctionId, normalizedBidAmount],\n      overrides\n    });\n  });\n\n  /**\n   * Cancel an english auction\n   *\n   * @remarks Cancel an auction on the marketplace\n   *\n   * @example\n   * ```javascript\n   * // The ID of the auction you want to cancel\n   * const auctionId = \"0\";\n   *\n   * await contract.englishAuctions.cancelAuction(auctionId);\n   * ```\n   * @param auctionId - the auction id\n   * @returns the transaction result\n   * @twfeature EnglishAuctions\n   */\n  cancelAuction = /* @__PURE__ */buildTransactionFunction(async auctionId => {\n    const winningBid = await this.getWinningBid(auctionId);\n    if (winningBid) {\n      throw new Error(`Bids already made.`);\n    }\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"cancelAuction\",\n      args: [auctionId]\n    });\n  });\n\n  /**\n   * Close the english auction for the bidder\n   *\n   * @remarks Closes the Auction and executes the sale for the buyer.\n   *\n   * @example\n   * ```javascript\n   * // The ID of the auction you want to close\n   * const auction = \"0\";\n   * await contract.englishAuctions.closeAuctionForBidder(auctionId);\n   * ```\n   *\n   * @param auctionId - the auction id to close\n   * @param closeFor - optionally pass the winning bid offeror address to close the auction on their behalf\n   * @returns the transaction result\n   * @twfeature EnglishAuctions\n   */\n  closeAuctionForBidder = /* @__PURE__ */buildTransactionFunction(async (auctionId, closeFor) => {\n    if (!closeFor) {\n      closeFor = await this.contractWrapper.getSignerAddress();\n    }\n    const auction = await this.validateAuction(BigNumber.from(auctionId));\n    try {\n      return Transaction.fromContractWrapper({\n        contractWrapper: this.contractWrapper,\n        method: \"collectAuctionTokens\",\n        args: [BigNumber.from(auctionId)]\n      });\n    } catch (err) {\n      if (err.message.includes(\"Marketplace: auction still active.\")) {\n        throw new AuctionHasNotEndedError(auctionId.toString(), auction.endTimeInSeconds.toString());\n      } else {\n        throw err;\n      }\n    }\n  });\n\n  /**\n   * Close the english auction for the seller\n   *\n   * @remarks Closes the Auction and executes the sale for the seller.\n   *\n   * @example\n   * ```javascript\n   * // The ID of the auction you want to close\n   * const auctionId = \"0\";\n   * await contract.englishAuctions.closeAuctionForSeller(auctionId);\n   * ```\n   *\n   * @param auctionId - the auction id to close\n   * @returns the transaction result\n   * @twfeature EnglishAuctions\n   */\n  closeAuctionForSeller = /* @__PURE__ */buildTransactionFunction(async auctionId => {\n    const auction = await this.validateAuction(BigNumber.from(auctionId));\n    try {\n      return Transaction.fromContractWrapper({\n        contractWrapper: this.contractWrapper,\n        method: \"collectAuctionPayout\",\n        args: [BigNumber.from(auctionId)]\n      });\n    } catch (err) {\n      if (err.message.includes(\"Marketplace: auction still active.\")) {\n        throw new AuctionHasNotEndedError(auctionId.toString(), auction.endTimeInSeconds.toString());\n      } else {\n        throw err;\n      }\n    }\n  });\n\n  /**\n   * Close the english auction for both the seller and the bidder\n   *\n   * @remarks Closes the Auction and executes the sale for both parties.\n   *\n   * @example\n   * ```javascript\n   * // The ID of the auction you want to close\n   * const auction = \"0\";\n   * await contract.englishAuctions.executeSale(auctionId);\n   * ```\n   *\n   * @param auctionId - the auction to close\n   * @returns the transaction result\n   * @twfeature EnglishAuctions\n   */\n  executeSale = /* @__PURE__ */buildTransactionFunction(async auctionId => {\n    const auction = await this.validateAuction(BigNumber.from(auctionId));\n    try {\n      const winningBid = await this.getWinningBid(auctionId);\n      invariant(winningBid, \"No winning bid found\");\n      const closeForSeller = this.encoder.encode(\"collectAuctionPayout\", [auctionId]);\n      const closeForBuyer = this.encoder.encode(\"collectAuctionTokens\", [auctionId]);\n      return Transaction.fromContractWrapper({\n        contractWrapper: this.contractWrapper,\n        method: \"multicall\",\n        args: [[closeForSeller, closeForBuyer]]\n      });\n    } catch (err) {\n      if (err.message.includes(\"Marketplace: auction still active.\")) {\n        throw new AuctionHasNotEndedError(auctionId.toString(), auction.endTimeInSeconds.toString());\n      } else {\n        throw err;\n      }\n    }\n  });\n\n  /**\n   * Get the buffer for an english auction\n   *\n   * @example\n   * ```javascript\n   * // The ID of the auction you want to get the buffer for\n   * const auctionId = \"0\";\n   * const buffer = await contract.englishAuctions.getBidBufferBps(auctionId);\n   * ```\n   *\n   * @param auctionId - id of the auction\n   * @returns the buffer in basis points\n   * @twfeature EnglishAuctions\n   */\n  async getBidBufferBps(auctionId) {\n    return (await this.getAuction(auctionId)).bidBufferBps;\n  }\n\n  /**\n   * Get the minimum next bid for an english auction\n   *\n   * @example\n   * ```javascript\n   * // The ID of the auction you want to get the minimum next bid for\n   * const auctionId = \"0\";\n   * const minimumNextBid = await contract.englishAuctions.getMinimumNextBid(auctionId);\n   * ```\n   *\n   * @returns the minimum bid a user can place to outbid the previous highest bid\n   * @param auctionId - id of the auction\n   * @twfeature EnglishAuctions\n   */\n  async getMinimumNextBid(auctionId) {\n    // we can fetch all of these at the same time using promise.all\n    const [currentBidBufferBps, winningBid, auction] = await Promise.all([this.getBidBufferBps(auctionId), this.getWinningBid(auctionId), this.validateAuction(BigNumber.from(auctionId))]);\n    const currentBidOrReservePrice = winningBid ?\n    // if there is a winning bid use the value of it\n    BigNumber.from(winningBid.bidAmount) :\n    // if there is no winning bid use the reserve price\n    BigNumber.from(auction.minimumBidAmount);\n    const minimumNextBid = currentBidOrReservePrice.add(\n    // the addition of the current bid and the buffer\n    // (have to divide by 10000 to get the fraction of the buffer (since it's in basis points))\n    currentBidOrReservePrice.mul(currentBidBufferBps).div(10000));\n\n    // it's more useful to return a currency value here\n    return fetchCurrencyValue(this.contractWrapper.getProvider(), auction.currencyContractAddress, minimumNextBid);\n  }\n\n  /** ******************************\n   * PRIVATE FUNCTIONS\n   *******************************/\n\n  /**\n   * Throws error if auction could not be found\n   *\n   * @param auctionId - Auction to check for\n   */\n  async validateAuction(auctionId) {\n    try {\n      return await this.getAuction(auctionId);\n    } catch (err) {\n      console.error(`Error getting the auction with id ${auctionId}`);\n      throw err;\n    }\n  }\n\n  /**\n   * Helper method maps the auction to the auction interface.\n   *\n   * @internal\n   * @param auction - The auction to map, as returned from the contract.\n   * @returns - The mapped interface.\n   */\n  async mapAuction(auction) {\n    let status = Status.UNSET;\n    const block = await this.contractWrapper.getProvider().getBlock(\"latest\");\n    const blockTime = block.timestamp;\n    switch (auction.status) {\n      case 1:\n        status = BigNumber.from(auction.startTimestamp).gt(blockTime) ? Status.Created : BigNumber.from(auction.endTimestamp).lt(blockTime) ? Status.Expired : Status.Active;\n        break;\n      case 2:\n        status = Status.Completed;\n        break;\n      case 3:\n        status = Status.Cancelled;\n        break;\n    }\n    return {\n      id: auction.auctionId.toString(),\n      creatorAddress: auction.auctionCreator,\n      assetContractAddress: auction.assetContract,\n      tokenId: auction.tokenId.toString(),\n      quantity: auction.quantity.toString(),\n      currencyContractAddress: auction.currency,\n      minimumBidAmount: auction.minimumBidAmount.toString(),\n      minimumBidCurrencyValue: await fetchCurrencyValue(this.contractWrapper.getProvider(), auction.currency, auction.minimumBidAmount),\n      buyoutBidAmount: auction.buyoutBidAmount.toString(),\n      buyoutCurrencyValue: await fetchCurrencyValue(this.contractWrapper.getProvider(), auction.currency, auction.buyoutBidAmount),\n      timeBufferInSeconds: BigNumber.from(auction.timeBufferInSeconds).toNumber(),\n      bidBufferBps: BigNumber.from(auction.bidBufferBps).toNumber(),\n      startTimeInSeconds: BigNumber.from(auction.startTimestamp).toNumber(),\n      endTimeInSeconds: BigNumber.from(auction.endTimestamp).toNumber(),\n      asset: await fetchTokenMetadataForContract(auction.assetContract, this.contractWrapper.getProvider(), auction.tokenId, this.storage),\n      status: status\n    };\n  }\n\n  /**\n   * Maps an auction-bid to the strict interface\n   *\n   * @internal\n   * @param bid\n   * @returns - A `Bid` object\n   */\n  async mapBid(auctionId, bidderAddress, currencyContractAddress, bidAmount) {\n    const resolvedBidderAddress = await resolveAddress(bidderAddress);\n    const resolvedCurrencyAddress = await resolveAddress(currencyContractAddress);\n    return {\n      auctionId,\n      bidderAddress: resolvedBidderAddress,\n      currencyContractAddress: resolvedCurrencyAddress,\n      bidAmount,\n      bidAmountCurrencyValue: await fetchCurrencyValue(this.contractWrapper.getProvider(), resolvedCurrencyAddress, bidAmount)\n    };\n  }\n  async applyFilter(auctions, filter) {\n    let rawAuctions = [...auctions];\n    if (filter) {\n      if (filter.seller) {\n        const resolvedSeller = await resolveAddress(filter.seller);\n        rawAuctions = rawAuctions.filter(seller => seller.auctionCreator.toString().toLowerCase() === resolvedSeller?.toString().toLowerCase());\n      }\n      if (filter.tokenContract) {\n        const resolvedToken = await resolveAddress(filter.tokenContract);\n        rawAuctions = rawAuctions.filter(tokenContract => tokenContract.assetContract.toString().toLowerCase() === resolvedToken?.toString().toLowerCase());\n      }\n      if (filter.tokenId !== undefined) {\n        rawAuctions = rawAuctions.filter(tokenContract => tokenContract.tokenId.toString() === filter?.tokenId?.toString());\n      }\n    }\n    return filter?.count && filter.count < rawAuctions.length ? rawAuctions.slice(0, filter.count) : rawAuctions;\n  }\n}\n\n/**\n * @internal\n */\nconst OfferInputParamsSchema = /* @__PURE__ */(() => z.object({\n  /**\n   * The address of the asset being sought.\n   */\n  assetContractAddress: AddressOrEnsSchema,\n  /**\n   * The ID of the token.\n   */\n  tokenId: BigNumberishSchema,\n  /**\n   * The quantity of tokens to buy.\n   *\n   * For ERC721s, this value should always be 1 (and will be forced internally regardless of what is passed here).\n   */\n  quantity: BigNumberishSchema.default(1),\n  /**\n   * The address of the currency offered for the NFTs.\n   */\n  currencyContractAddress: AddressOrEnsSchema.default(NATIVE_TOKEN_ADDRESS),\n  /**\n   * The total offer amount for the NFTs.\n   */\n  totalPrice: AmountSchema,\n  /**\n   * The end time of the offer.\n   */\n  endTimestamp: EndDateSchema\n}))();\n\n/**\n * @public\n */\n\n/**\n * Handles marketplace offers\n * @public\n */\nclass MarketplaceV3Offers {\n  featureName = FEATURE_OFFERS.name;\n\n  // utilities\n\n  constructor(contractWrapper, storage) {\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n    this.events = new ContractEvents(this.contractWrapper);\n    this.encoder = new ContractEncoder(this.contractWrapper);\n    this.interceptor = new ContractInterceptor(this.contractWrapper);\n    this.estimator = new GasCostEstimator(this.contractWrapper);\n  }\n  getAddress() {\n    return this.contractWrapper.address;\n  }\n\n  /** ******************************\n   * READ FUNCTIONS\n   *******************************/\n\n  /**\n   * Get the total number of offers\n   *\n   * @returns Returns the total number of offers created.\n   * @public\n   *\n   * @example\n   * ```javascript\n   * const totalOffers = await contract.offers.getTotalCount();\n   * ```\n   * @twfeature Offers\n   */\n  async getTotalCount() {\n    return await this.contractWrapper.read(\"totalOffers\", []);\n  }\n\n  /**\n   * Get all offers\n   *\n   * @example\n   * ```javascript\n   * const offers = await contract.offers.getAll();\n   * ```\n   *\n   * @param filter - optional filter parameters\n   * @returns the Offer object array\n   * @twfeature Offers\n   */\n  async getAll(filter) {\n    const totalOffers = await this.getTotalCount();\n    const start = BigNumber.from(filter?.start || 0).toNumber();\n    const end = totalOffers.toNumber();\n    if (end === 0) {\n      throw new Error(`No offers exist on the contract.`);\n    }\n    let rawOffers = [];\n    const batches = await getAllInBatches(start, end, (startId, endId) => this.contractWrapper.read(\"getAllOffers\", [startId, endId]));\n    rawOffers = batches.flat();\n    const filteredOffers = await this.applyFilter(rawOffers, filter);\n    return await Promise.all(filteredOffers.map(offer => this.mapOffer(offer)));\n  }\n\n  /**\n   * Get all valid offers\n   *\n   * @example\n   * ```javascript\n   * const offers = await contract.offers.getAllValid();\n   * ```\n   *\n   * @param filter - optional filter parameters\n   * @returns the Offer object array\n   * @twfeature Offers\n   */\n  async getAllValid(filter) {\n    const totalOffers = await this.getTotalCount();\n    const start = BigNumber.from(filter?.start || 0).toNumber();\n    const end = totalOffers.toNumber();\n    if (end === 0) {\n      throw new Error(`No offers exist on the contract.`);\n    }\n    let rawOffers = [];\n    const batches = await getAllInBatches(start, end, (startId, endId) => this.contractWrapper.read(\"getAllValidOffers\", [startId, endId]));\n    rawOffers = batches.flat();\n    const filteredOffers = await this.applyFilter(rawOffers, filter);\n    return await Promise.all(filteredOffers.map(offer => this.mapOffer(offer)));\n  }\n\n  /**\n   * Get a single offer\n   *\n   * @example\n   * ```javascript\n   * const offerId = 0;\n   * const offer = await contract.offers.getOffer(offerId);\n   * ```\n   *\n   * @param offerId - the listing id\n   * @returns the Direct listing object\n   * @twfeature Offers\n   */\n  async getOffer(offerId) {\n    const offer = await this.contractWrapper.read(\"getOffer\", [offerId]);\n    return await this.mapOffer(offer);\n  }\n\n  /** ******************************\n   * WRITE FUNCTIONS\n   *******************************/\n\n  /**\n   * Make an offer\n   *\n   * @remarks Make an offer on the marketplace for an asset.\n   *\n   * @example\n   * ```javascript\n   * // Data of the offer you want to make\n   * const offer = {\n   *   // address of the contract the asset you want to make an offer for\n   *   assetContractAddress: \"0x...\",\n   *   // token ID of the asset you want to buy\n   *   tokenId: \"0\",\n   *   // how many of the asset you want to buy\n   *   quantity: 1,\n   *   // address of the currency contract that you offer to pay in\n   *   currencyContractAddress: NATIVE_TOKEN_ADDRESS,\n   *   // Total price you offer to pay for the mentioned token(s)\n   *   totalPrice: \"1.5\",\n   *   // Offer valid until\n   *   endTimestamp: new Date(),\n   * }\n   *\n   * const tx = await contract.offers.makeOffer(offer);\n   * const receipt = tx.receipt; // the transaction receipt\n   * const id = tx.id; // the id of the newly created offer\n   * ```\n   * @param offer - the offer data\n   * @returns the transaction receipt and the id of the newly created offer\n   * @twfeature Offers\n   */\n  makeOffer = /* @__PURE__ */buildTransactionFunction(async offer => {\n    const parsedOffer = await OfferInputParamsSchema.parseAsync(offer);\n    const chainId = await this.contractWrapper.getChainID();\n    const currency = isNativeToken(parsedOffer.currencyContractAddress) ? NATIVE_TOKENS[chainId].wrapped.address : parsedOffer.currencyContractAddress;\n    const normalizedTotalPrice = await normalizePriceValue(this.contractWrapper.getProvider(), parsedOffer.totalPrice, currency);\n    const overrides = await this.contractWrapper.getCallOverrides();\n    await setErc20Allowance(this.contractWrapper, normalizedTotalPrice, currency, overrides);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"makeOffer\",\n      args: [{\n        assetContract: parsedOffer.assetContractAddress,\n        tokenId: parsedOffer.tokenId,\n        quantity: parsedOffer.quantity,\n        currency: currency,\n        totalPrice: normalizedTotalPrice,\n        expirationTimestamp: parsedOffer.endTimestamp\n      }],\n      parse: receipt => {\n        const event = this.contractWrapper.parseLogs(\"NewOffer\", receipt?.logs);\n        return {\n          id: event[0].args.offerId,\n          receipt\n        };\n      }\n    });\n  });\n\n  /**\n   * Cancel an offer\n   *\n   * @remarks Cancel an offer on the marketplace\n   *\n   * @example\n   * ```javascript\n   * // The ID of the offer you want to cancel\n   * const offerId = \"0\";\n   *\n   * await contract.offers.cancelOffer(offerId);\n   * ```\n   * @param offerId - the offer id\n   * @returns the transaction receipt\n   * @twfeature Offers\n   */\n  cancelOffer = /* @__PURE__ */buildTransactionFunction(async offerId => {\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"cancelOffer\",\n      args: [offerId]\n    });\n  });\n\n  /**\n   * Accept an offer\n   *\n   * @example\n   * ```javascript\n   * // The ID of the offer you want to accept\n   * const offerId = 0;\n   *\n   * await contract.offers.acceptOffer(offerId);\n   * ```\n   *\n   * @param offerId - The offer id\n   * @returns the transaction receipt\n   * @twfeature Offers\n   */\n  acceptOffer = /* @__PURE__ */buildTransactionFunction(async offerId => {\n    const offer = await this.validateOffer(BigNumber.from(offerId));\n    const {\n      valid,\n      error\n    } = await this.isStillValidOffer(offer);\n    if (!valid) {\n      throw new Error(`Offer ${offerId} is no longer valid. ${error}`);\n    }\n    const overrides = (await this.contractWrapper.getCallOverrides()) || {};\n    await handleTokenApproval(this.contractWrapper, this.getAddress(), offer.assetContractAddress, offer.tokenId, await this.contractWrapper.getSignerAddress());\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"acceptOffer\",\n      args: [offerId],\n      overrides\n    });\n  });\n\n  /** ******************************\n   * PRIVATE FUNCTIONS\n   *******************************/\n\n  /**\n   * Throws error if offer could not be found\n   *\n   * @param offerId - offer to check for\n   */\n  async validateOffer(offerId) {\n    try {\n      return await this.getOffer(offerId);\n    } catch (err) {\n      console.error(`Error getting the offer with id ${offerId}`);\n      throw err;\n    }\n  }\n\n  /**\n   * Helper method maps the offer to the offer interface.\n   *\n   * @internal\n   * @param offer - The offer to map, as returned from the contract.\n   * @returns - The mapped interface.\n   */\n  async mapOffer(offer) {\n    let status = Status.UNSET;\n    const block = await this.contractWrapper.getProvider().getBlock(\"latest\");\n    const blockTime = block.timestamp;\n    switch (offer.status) {\n      case 1:\n        status = BigNumber.from(offer.expirationTimestamp).lt(blockTime) ? Status.Expired : Status.Active;\n        break;\n      case 2:\n        status = Status.Completed;\n        break;\n      case 3:\n        status = Status.Cancelled;\n        break;\n    }\n    return {\n      id: offer.offerId.toString(),\n      offerorAddress: offer.offeror,\n      assetContractAddress: offer.assetContract,\n      currencyContractAddress: offer.currency,\n      tokenId: offer.tokenId.toString(),\n      quantity: offer.quantity.toString(),\n      totalPrice: offer.totalPrice.toString(),\n      currencyValue: await fetchCurrencyValue(this.contractWrapper.getProvider(), offer.currency, offer.totalPrice),\n      asset: await fetchTokenMetadataForContract(offer.assetContract, this.contractWrapper.getProvider(), offer.tokenId, this.storage),\n      endTimeInSeconds: BigNumber.from(offer.expirationTimestamp).toNumber(),\n      status: status\n    };\n  }\n\n  /**\n   * Use this method to check if an offer is still valid.\n   *\n   * Ways an offer can become invalid:\n   * 1. The offer has expired\n   * 2. The offeror doesn't have enough balance of currency tokens\n   * 3. The offeror removed the approval of currency tokens on the marketplace\n   *\n   * @internal\n   * @param offer - The offer to check.\n   * @returns - True if the offer is valid, false otherwise.\n   */\n  async isStillValidOffer(offer) {\n    const now = BigNumber.from(Math.floor(Date.now() / 1000));\n    if (now.gt(offer.endTimeInSeconds)) {\n      return {\n        valid: false,\n        error: `Offer with ID ${offer.id} has expired`\n      };\n    }\n    const chainId = await this.contractWrapper.getChainID();\n    const currency = isNativeToken(offer.currencyContractAddress) ? NATIVE_TOKENS[chainId].wrapped.address : offer.currencyContractAddress;\n    const provider = this.contractWrapper.getProvider();\n    const erc20 = new ContractWrapper(provider, currency, ERC20Abi, {}, this.storage);\n    const offerorBalance = await erc20.read(\"balanceOf\", [offer.offerorAddress]);\n    if (offerorBalance.lt(offer.totalPrice)) {\n      return {\n        valid: false,\n        error: `Offeror ${offer.offerorAddress} doesn't have enough balance of token ${currency}`\n      };\n    }\n    const offerorAllowance = await erc20.read(\"allowance\", [offer.offerorAddress, this.getAddress()]);\n    if (offerorAllowance.lt(offer.totalPrice)) {\n      return {\n        valid: false,\n        error: `Offeror ${offer.offerorAddress} hasn't approved enough amount of token ${currency}`\n      };\n    }\n    return {\n      valid: true,\n      error: \"\"\n    };\n  }\n  async applyFilter(offers, filter) {\n    let rawOffers = [...offers];\n    if (filter) {\n      if (filter.offeror) {\n        const resolvedOfferor = await resolveAddress(filter.offeror);\n        rawOffers = rawOffers.filter(offeror => offeror.offeror.toString().toLowerCase() === resolvedOfferor?.toString().toLowerCase());\n      }\n      if (filter.tokenContract) {\n        const resolvedToken = await resolveAddress(filter.tokenContract);\n        rawOffers = rawOffers.filter(tokenContract => tokenContract.assetContract.toString().toLowerCase() === resolvedToken?.toString().toLowerCase());\n      }\n      if (filter.tokenId !== undefined) {\n        rawOffers = rawOffers.filter(tokenContract => tokenContract.tokenId.toString() === filter?.tokenId?.toString());\n      }\n    }\n    return filter?.count && filter.count < rawOffers.length ? rawOffers.slice(0, filter.count) : rawOffers;\n  }\n}\n\n/**\n * Handle platform fees and recipients\n * @remarks Configure platform fees for a contract, which can be applied on certain paid transactions\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * const feeInfo = await contract.platformFees.get();\n * await contract.platformFees.set({\n *   platform_fee_basis_points: 100, // 1% fee\n *   platform_fee_recipient: \"0x...\" // the fee recipient\n * })\n * ```\n * @public\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars -- TO BE REMOVED IN V4\nclass ContractPlatformFee {\n  featureName = FEATURE_PLATFORM_FEE.name;\n  constructor(contractWrapper) {\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * Get the platform fee recipient and basis points\n   *\n   * @example\n   * ```javascript\n   * const feeInfo = await contract.platformFees.get();\n   * console.log(feeInfo.platform_fee_recipient);\n   * console.log(feeInfo.platform_fee_basis_points);\n   * ```\n   * @twfeature PlatformFee\n   */\n  async get() {\n    const [platformFeeRecipient, platformFeeBps] = await this.contractWrapper.read(\"getPlatformFeeInfo\", []);\n    return CommonPlatformFeeSchema.parseAsync({\n      platform_fee_recipient: platformFeeRecipient,\n      platform_fee_basis_points: platformFeeBps\n    });\n  }\n\n  /**\n   * Set the platform fee recipient and basis points\n   *\n   * @example\n   * ```javascript\n   * await contract.platformFees.set({\n   *   platform_fee_basis_points: 100, // 1% fee\n   *   platform_fee_recipient: \"0x...\" // the fee recipient\n   * })\n   * ```\n   *\n   * @param platformFeeInfo - the platform fee information\n   * @twfeature PlatformFee\n   */\n  set = /* @__PURE__ */buildTransactionFunction(async platformFeeInfo => {\n    const parsed = await CommonPlatformFeeSchema.parseAsync(platformFeeInfo);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"setPlatformFeeInfo\",\n      args: [parsed.platform_fee_recipient, parsed.platform_fee_basis_points]\n    });\n  });\n}\n\n/**\n * @internal\n * @param abi\n * @param metadata\n */\nfunction extractEventsFromAbi(abi, metadata) {\n  const parsedAbi = AbiSchema.parse(abi || []);\n  const events = parsedAbi.filter(el => el.type === \"event\");\n  const parsed = [];\n  for (const e of events) {\n    const doc = extractCommentFromMetadata(e.name, metadata, \"events\");\n    parsed.push({\n      inputs: e.inputs || [],\n      outputs: e.outputs || [],\n      name: e.name || \"unknown\",\n      comment: doc\n    });\n  }\n  return parsed;\n}\n\n/**\n * Handles publish metadata for a contract\n * @internal\n */ // eslint-disable-next-line @typescript-eslint/no-unused-vars -- TO BE REMOVED IN V4\nclass ContractPublishedMetadata {\n  constructor(contractWrapper, storage) {\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n  }\n\n  /**\n   * Get the published metadata for this contract\n   * @public\n   */\n  async get() {\n    if (this._cachedMetadata) {\n      return this._cachedMetadata;\n    }\n    this._cachedMetadata = await fetchContractMetadataFromAddress(this.contractWrapper.address, this.contractWrapper.getProvider(), this.storage, this.contractWrapper.options);\n    return this._cachedMetadata;\n  }\n\n  /**\n   * @public\n   */\n  async extractFunctions() {\n    let publishedMetadata;\n    try {\n      publishedMetadata = await this.get();\n    } catch (e) {\n      // ignore for built-in contracts\n    }\n    // to construct a contract we already **have** to have the abi on the contract wrapper, so there is no reason to look fetch it again (means this function can become synchronous as well!)\n    return extractFunctionsFromAbi(AbiSchema.parse(this.contractWrapper.abi), publishedMetadata?.metadata);\n  }\n\n  /**\n   * @public\n   */\n  async extractEvents() {\n    let publishedMetadata;\n    try {\n      publishedMetadata = await this.get();\n    } catch (e) {\n      // ignore for built-in contracts\n    }\n    // to construct a contract we already **have** to have the abi on the contract wrapper, so there is no reason to look fetch it again (means this function can become synchronous as well!)\n    return extractEventsFromAbi(AbiSchema.parse(this.contractWrapper.abi), publishedMetadata?.metadata);\n  }\n}\n\n/**\n * Encodes and decodes Contract functions\n * @public\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars -- TO BE REMOVED IN V4\nclass ContractOwner {\n  featureName = FEATURE_OWNER.name;\n  constructor(contractWrapper) {\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * Get the current owner of the contract\n   * @example\n   * ```javascript\n   * await contract.owner.get();\n   * console.log(\"Owner address: \", ownerAddress);\n   * ```\n   * @returns the owner address\n   * @twfeature Ownable\n   */\n  async get() {\n    return this.contractWrapper.read(\"owner\", []);\n  }\n\n  /**\n   * Set the new owner of the contract\n   * @remarks Can only be called by the current owner.\n   *\n   * @param address - the address of the new owner\n   *\n   * @example\n   * ```javascript\n   * const newOwnerAddress = \"{{wallet_address}}\";\n   * await contract.owner.set(newOwnerAddress);\n   * ```\n   * @twfeature Ownable\n   */\n  set = /* @__PURE__ */buildTransactionFunction(async address => {\n    const resolvedAddress = await resolveAddress(address);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"setOwner\",\n      args: [resolvedAddress]\n    });\n  });\n}\n\n/**\n * Have an official Application URI for this contract.\n * @remarks Configure an official Application URI for this contract.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * const appURI = await contract.app.get();\n * appURI = \"ipfs://some_ipfs_hash\";\n *\n * await contract.app.set(appURI)\n * ```\n * @public\n */\nclass ContractAppURI {\n  featureName = FEATURE_APPURI.name;\n  constructor(contractWrapper, metadata, storage) {\n    this.contractWrapper = contractWrapper;\n    this.metadata = metadata;\n    this.storage = storage;\n  }\n\n  /**\n   * Get App URI\n   * @returns the appURI (typically an IPFS hash)\n   * @example\n   * ```javascript\n   * const appURI = await contract.app.get();\n   * console.log(appURI) // \"ipfs://some_ipfs_hash\";\n   * ```\n   * @twfeature AppURI\n   */\n  async get() {\n    if (detectContractFeature(this.contractWrapper, \"AppURI\")) {\n      return await this.contractWrapper.read(\"appURI\", []);\n    }\n    return replaceGatewayUrlWithScheme((await this.metadata.get()).app_uri || \"\", this.storage.getGatewayUrls());\n  }\n\n  /**\n   * Set App URI\n   * @param appURI - the uri to set (typically an IPFS hash)\n   * @example\n   * ```javascript\n   * const appURI = \"ipfs://some_ipfs_hash\";\n   * await contract.app.set(appURI);\n   * ```\n   * @twfeature AppURI\n   */\n  set = /* @__PURE__ */buildTransactionFunction(async appURI => {\n    if (detectContractFeature(this.contractWrapper, \"AppURI\")) {\n      return Transaction.fromContractWrapper({\n        contractWrapper: this.contractWrapper,\n        method: \"setAppURI\",\n        args: [appURI]\n      });\n    }\n    return await this.metadata.update.prepare({\n      app_uri: appURI\n    });\n  });\n}\n\n/**\n * @internal\n */\nasync function extractConstructorParams(predeployMetadataUri, storage) {\n  const meta = await fetchPreDeployMetadata(predeployMetadataUri, storage);\n  return extractConstructorParamsFromAbi(meta.abi);\n}\n\n/**\n * @internal\n * @param predeployMetadataUri\n * @param storage\n */\nasync function extractFunctions(predeployMetadataUri, storage) {\n  const metadata = await fetchPreDeployMetadata(predeployMetadataUri, storage);\n  return extractFunctionsFromAbi(metadata.abi, metadata.metadata);\n}\nfunction getFunctionSignature(fnInputs) {\n  return \"(\" + fnInputs.map(i => {\n    return i.type === \"tuple\" ? getFunctionSignature(i.components) : i.type === \"tuple[]\" ? getFunctionSignature(i.components) + `[]` : i.type;\n  }).join(\",\") + \")\";\n}\nfunction generatePluginFunctions(pluginAddress, pluginAbi) {\n  const pluginInterface = new utils.Interface(pluginAbi);\n  const pluginFunctions = [];\n  // TODO - filter out common functions like _msgSender(), contractType(), etc.\n  for (const fnFragment of Object.values(pluginInterface.functions)) {\n    const fn = pluginInterface.getFunction(pluginInterface.getSighash(fnFragment));\n    if (fn.name.includes(\"_\")) {\n      continue;\n    }\n    pluginFunctions.push({\n      functionSelector: pluginInterface.getSighash(fn),\n      functionSignature: fn.name + getFunctionSignature(fn.inputs),\n      pluginAddress: pluginAddress\n    });\n  }\n  return pluginFunctions;\n}\nfunction generateExtensionFunctions(extensionAbi) {\n  const extensionInterface = new utils.Interface(extensionAbi);\n  const extensionFunctions = [];\n  // TODO - filter out common functions like _msgSender(), contractType(), etc.\n\n  for (const fnFragment of Object.values(extensionInterface.functions)) {\n    const fn = extensionInterface.getFunction(extensionInterface.getSighash(fnFragment));\n    if (fn.name.startsWith(\"_\")) {\n      continue;\n    }\n    extensionFunctions.push({\n      functionSelector: extensionInterface.getSighash(fn),\n      functionSignature: fn.name + getFunctionSignature(fn.inputs)\n    });\n  }\n  return extensionFunctions;\n}\n\n/**\n *\n * Returns txn data for keyless deploys as well as signer deploys.\n * Also provides a list of infra contracts to deploy.\n *\n * @internal\n *\n * @param metadataUri\n * @param storage\n * @param provider\n * @param create2Factory\n */\nasync function getDeploymentInfo(metadataUri, storage, provider, create2Factory, clientId, secretKey) {\n  caches.deploymentPresets = {};\n  const create2FactoryAddress = create2Factory ? create2Factory : await getCreate2FactoryAddress(provider);\n  const customParams = {};\n  const finalDeploymentInfo = [];\n  const {\n    compilerMetadata,\n    extendedMetadata\n  } = await fetchAndCacheDeployMetadata(metadataUri, storage);\n  const defaultExtensions = extendedMetadata?.defaultExtensions;\n  if (extendedMetadata?.routerType === \"plugin\" && defaultExtensions) {\n    invariant(clientId || secretKey, \"Require Client Id / Secret Key\");\n    const publishedExtensions = await Promise.all(defaultExtensions.map(e => {\n      return fetchPublishedContractFromPolygon(e.publisherAddress, e.extensionName, e.extensionVersion, storage, clientId, secretKey);\n    }));\n    const pluginMetadata = (await Promise.all(publishedExtensions.map(async c => {\n      return fetchAndCacheDeployMetadata(c.metadataUri, storage);\n    }))).map(fetchedMetadata => fetchedMetadata.compilerMetadata);\n\n    // get deployment info for all plugins\n    const pluginDeploymentInfo = await Promise.all(pluginMetadata.map(async metadata => {\n      const info = await computeDeploymentInfo(\"plugin\", provider, storage, create2FactoryAddress, {\n        metadata: metadata\n      }, clientId, secretKey);\n      return info;\n    }));\n\n    // create constructor param input for PluginMap\n    const mapInput = [];\n    pluginMetadata.forEach((metadata, index) => {\n      const input = generatePluginFunctions(pluginDeploymentInfo[index].transaction.predictedAddress, metadata.abi);\n      mapInput.push(...input);\n    });\n\n    // get PluginMap deployment transaction\n    const pluginMapTransaction = await computeDeploymentInfo(\"plugin\", provider, storage, create2FactoryAddress, {\n      contractName: \"PluginMap\",\n      constructorParams: {\n        _pluginsToAdd: {\n          value: mapInput\n        }\n      }\n    }, clientId, secretKey);\n\n    // address of PluginMap is input for MarketplaceV3's constructor\n    customParams[\"_pluginMap\"] = {\n      value: pluginMapTransaction.transaction.predictedAddress\n    };\n    finalDeploymentInfo.push(...pluginDeploymentInfo, pluginMapTransaction);\n  } else if (extendedMetadata?.routerType === \"dynamic\" && defaultExtensions) {\n    invariant(clientId || secretKey, \"Require Client Id / Secret Key\");\n    const publishedExtensions = await Promise.all(defaultExtensions.map(e => {\n      return fetchPublishedContractFromPolygon(e.publisherAddress, e.extensionName, e.extensionVersion, storage, clientId, secretKey);\n    }));\n    const extensionMetadata = (await Promise.all(publishedExtensions.map(async c => {\n      return fetchAndCacheDeployMetadata(c.metadataUri, storage);\n    }))).map(fetchedMetadata => fetchedMetadata.compilerMetadata);\n\n    // get deployment info for all extensions\n    const extensionDeploymentInfo = await Promise.all(extensionMetadata.map(async metadata => {\n      const info = await computeDeploymentInfo(\"extension\", provider, storage, create2FactoryAddress, {\n        metadata: metadata\n      }, clientId, secretKey);\n      return info;\n    }));\n\n    // create constructor param input for BaseRouter\n    const routerInput = [];\n    extensionMetadata.forEach((metadata, index) => {\n      const extensionFunctions = generateExtensionFunctions(metadata.abi);\n      routerInput.push({\n        metadata: {\n          name: metadata.name,\n          metadataURI: \"\",\n          implementation: extensionDeploymentInfo[index].transaction.predictedAddress\n        },\n        functions: extensionFunctions\n      });\n    });\n\n    // routerInput as constructor param for BaseRouter\n    customParams[\"_extensions\"] = {\n      value: routerInput\n    };\n    finalDeploymentInfo.push(...extensionDeploymentInfo);\n  }\n  const implementationDeployInfo = await computeDeploymentInfo(\"implementation\", provider, storage, create2FactoryAddress, {\n    metadata: compilerMetadata,\n    constructorParams: customParams\n  }, clientId, secretKey);\n\n  // get clone factory\n  const factoryInfo = await computeDeploymentInfo(\"infra\", provider, storage, create2FactoryAddress, {\n    contractName: \"TWCloneFactory\"\n  }, clientId, secretKey);\n  finalDeploymentInfo.push(factoryInfo);\n  finalDeploymentInfo.push(...Object.values(caches.deploymentPresets));\n  finalDeploymentInfo.push(implementationDeployInfo);\n  return finalDeploymentInfo;\n}\n\n/**\n * Deploy a contract at a deterministic address, using Create2 method\n * Address depends on the Create2 factory address.\n *\n * @public\n *\n * @param signer\n * @param bytecode\n * @param encodedArgs\n * @param create2FactoryAddress\n */\nasync function deployContractDeterministic(signer, transaction, options) {\n  let gasLimit = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 7000000;\n  // Check if the implementation contract is already deployed\n  invariant(signer.provider, \"Provider required\");\n  const contractDeployed = await isContractDeployed(transaction.predictedAddress, signer.provider);\n  if (!contractDeployed) {\n    console.debug(`deploying contract via create2 factory at: ${transaction.predictedAddress}`);\n    const tx = {\n      to: transaction.to,\n      data: transaction.data\n    };\n    try {\n      await signer.estimateGas(tx);\n    } catch (e) {\n      console.debug(\"error estimating gas while deploying prebuilt: \", e);\n      tx.gasLimit = BigNumber.from(gasLimit);\n    }\n    options?.notifier?.(\"deploying\", \"preset\");\n    await (await signer.sendTransaction(tx)).wait();\n    options?.notifier?.(\"deployed\", \"preset\");\n  }\n}\nfunction estimateGasForDeploy(initCode) {\n  let gasLimit = utils.arrayify(initCode).map(x => x === 0 ? 4 : 16).reduce((sum, x) => sum + x) + 200 * initCode.length / 2 + 6 * Math.ceil(initCode.length / 64) + 32000 + 21000;\n  gasLimit = Math.floor(gasLimit * 64 / 63);\n  return gasLimit;\n}\nfunction createTransactionBatches(transactions) {\n  let upperGasLimit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : GAS_LIMIT_FOR_DEPLOYER;\n  transactions = transactions.filter(tx => {\n    return tx.data.length > 0;\n  });\n  if (transactions.length === 0) {\n    return [];\n  }\n  const transactionBatches = [];\n  let sum = 0;\n  let batch = [];\n  transactions.forEach(tx => {\n    const gas = estimateGasForDeploy(tx.data);\n    if (sum + gas > upperGasLimit) {\n      if (batch.length === 0) {\n        transactionBatches.push([tx]);\n      } else {\n        transactionBatches.push(batch);\n        sum = gas;\n        batch = [tx];\n      }\n    } else {\n      sum += gas;\n      batch.push(tx);\n    }\n  });\n  if (batch.length > 0) {\n    transactionBatches.push(batch);\n  }\n  return transactionBatches;\n}\nasync function deployWithThrowawayDeployer(signer, transactions, options) {\n  const transactionBatches = createTransactionBatches(transactions);\n  if (transactionBatches.length === 0) {\n    return;\n  }\n  options?.notifier?.(\"deploying\", \"infra\");\n  const deployTxns = await Promise.all(transactionBatches.map(txBatch => {\n    // Using the deployer contract, send the deploy transactions to common factory with a signer\n    const deployer = new ContractFactory(DEPLOYER_ABI, DEPLOYER_BYTECODE).connect(signer).deploy(txBatch);\n    return deployer;\n  }));\n  await Promise.all(deployTxns.map(tx => {\n    return tx.deployed();\n  }));\n  options?.notifier?.(\"deployed\", \"infra\");\n}\nasync function getCompositeABIfromRelease(publishMetadataUri, storage) {\n  const {\n    extendedMetadata\n  } = await fetchAndCacheDeployMetadata(publishMetadataUri, storage);\n  const compositeAbi = extendedMetadata?.compositeAbi || [];\n  return compositeAbi;\n}\n\n/**\n * @internal\n */\nasync function getPluginABI(addresses, provider, storage) {\n  return (await Promise.all(addresses.map(address => fetchContractMetadataFromAddress(address, provider, storage).catch(err => {\n    console.error(`Failed to fetch plug-in for ${address}`, err);\n    return {\n      abi: []\n    };\n  })))).map(metadata => metadata.abi);\n}\n\n/**\n * @internal\n */\nasync function getCompositePluginABI(address, abi, provider, options, storage) {\n  let pluginABIs = [];\n  try {\n    // check if contract is plugin-pattern\n    const isPluginRouter = isFeatureEnabled(AbiSchema.parse(abi), \"PluginRouter\");\n    const isbaseRouter = isFeatureEnabled(AbiSchema.parse(abi), \"DynamicContract\");\n    if (isbaseRouter) {\n      const contract = new ContractWrapper(provider, address, getAllExtensionsAbi, options, storage);\n      const plugins = await contract.call(\"getAllExtensions\");\n\n      // get extension addresses\n      const pluginAddresses = plugins.map(item => item.metadata.implementation);\n\n      // get ABIs of extension contracts --\n      pluginABIs = await getPluginABI(pluginAddresses, provider, storage);\n    } else if (isPluginRouter) {\n      const contract = new ContractWrapper(provider, address, getAllPluginsAbi, options, storage);\n      const pluginMap = await contract.call(\"getAllPlugins\");\n\n      // get extension addresses\n      const allPlugins = pluginMap.map(item => item.pluginAddress);\n      const plugins = Array.from(new Set(allPlugins));\n\n      // get ABIs of extension contracts\n      pluginABIs = await getPluginABI(plugins, provider, storage);\n    }\n  } catch (err) {}\n  return pluginABIs.length > 0 ? joinABIs([abi, ...pluginABIs]) : abi;\n}\nconst DropErc20ContractInput = /* @__PURE__ */CommonContractSchema.merge(MerkleSchema).merge(CommonSymbolSchema);\nconst DropErc20ContractOutput = /* @__PURE__ */CommonContractOutputSchema.merge(MerkleSchema).merge(CommonSymbolSchema);\nconst DropErc20ContractDeploy = /* @__PURE__ */DropErc20ContractInput.merge(CommonPlatformFeeSchema).merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema);\nconst DropErc20ContractSchema = {\n  deploy: DropErc20ContractDeploy,\n  output: DropErc20ContractOutput,\n  input: DropErc20ContractInput\n};\nconst MultiwrapContractInput = /* @__PURE__ */CommonContractSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema);\nconst MultiwrapContractOutput = /* @__PURE__ */CommonContractOutputSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema);\nconst MultiwrapContractDeploy = /* @__PURE__ */MultiwrapContractInput.merge(CommonTrustedForwarderSchema);\nconst MultiwrapContractSchema = {\n  deploy: MultiwrapContractDeploy,\n  output: MultiwrapContractOutput,\n  input: MultiwrapContractInput\n};\nconst ADMIN_ROLE = [\"admin\"];\nconst NFT_BASE_CONTRACT_ROLES = [\"admin\", \"minter\", \"transfer\"];\nconst MARKETPLACE_CONTRACT_ROLES = [\"admin\", \"lister\", \"asset\"];\nconst PACK_CONTRACT_ROLES = [\"admin\", \"minter\", \"asset\", \"transfer\"];\nconst TOKEN_DROP_CONTRACT_ROLES = [\"admin\", \"transfer\"];\nconst MULTIWRAP_CONTRACT_ROLES = [\"admin\", \"transfer\", \"minter\", \"unwrap\", \"asset\"];\nconst prebuiltContractTypes = {\n  vote: \"vote\",\n  token: \"token\",\n  \"edition-drop\": \"edition-drop\",\n  edition: \"edition\",\n  marketplace: \"marketplace\",\n  \"marketplace-v3\": \"marketplace-v3\",\n  multiwrap: \"multiwrap\",\n  \"nft-collection\": \"nft-collection\",\n  \"nft-drop\": \"nft-drop\",\n  pack: \"pack\",\n  \"signature-drop\": \"signature-drop\",\n  split: \"split\",\n  \"token-drop\": \"token-drop\"\n};\nconst EditionDropInitializer = {\n  name: \"DropERC1155\",\n  contractType: prebuiltContractTypes[\"edition-drop\"],\n  schema: DropErc1155ContractSchema,\n  roles: NFT_BASE_CONTRACT_ROLES,\n  initialize: async function () {\n    for (var _len = arguments.length, _ref = new Array(_len), _key = 0; _key < _len; _key++) {\n      _ref[_key] = arguments[_key];\n    }\n    let [network, address, storage, options] = _ref;\n    const [, provider] = getSignerAndProvider(network, options);\n    const [abi, contract, _network] = await Promise.all([EditionDropInitializer.getAbi(address, provider, storage), import('./edition-drop-24708d00.browser.esm.js'), provider.getNetwork()]);\n    return new contract.EditionDrop(network, address, storage, options, abi, _network.chainId);\n  },\n  getAbi: async (address, provider, storage) => {\n    const abi = await fetchAbiFromAddress(address, provider, storage);\n    if (abi) {\n      return abi;\n    }\n    // Deprecated - only needed for backwards compatibility with non-published contracts - should remove in v4\n    const contractInfo = await getContractInfo(address, provider);\n    return !contractInfo || contractInfo.version > 2 ? (await import('@thirdweb-dev/contracts-js/dist/abis/DropERC1155.json')).default : (await import('@thirdweb-dev/contracts-js/dist/abis/DropERC1155_V2.json')).default;\n  }\n};\nconst EditionInitializer = {\n  name: \"TokenERC1155\",\n  contractType: prebuiltContractTypes[\"edition\"],\n  schema: TokenErc1155ContractSchema,\n  roles: NFT_BASE_CONTRACT_ROLES,\n  initialize: async function () {\n    for (var _len2 = arguments.length, _ref2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      _ref2[_key2] = arguments[_key2];\n    }\n    let [network, address, storage, options] = _ref2;\n    const [, provider] = getSignerAndProvider(network, options);\n    const [abi, contract, _network] = await Promise.all([EditionInitializer.getAbi(address, provider, storage), import('./edition-b3122b64.browser.esm.js'), provider.getNetwork()]);\n    return new contract.Edition(network, address, storage, options, abi, _network.chainId);\n  },\n  getAbi: async (address, provider, storage) => {\n    const abi = await fetchAbiFromAddress(address, provider, storage);\n    if (abi) {\n      return abi;\n    }\n    // Deprecated - only needed for backwards compatibility with non-published contracts - should remove in v4\n    return (await import('@thirdweb-dev/contracts-js/dist/abis/TokenERC1155.json')).default;\n  }\n};\nconst MarketplaceInitializer = {\n  name: \"Marketplace\",\n  contractType: prebuiltContractTypes.marketplace,\n  schema: MarketplaceContractSchema,\n  roles: MARKETPLACE_CONTRACT_ROLES,\n  initialize: async function () {\n    for (var _len3 = arguments.length, _ref3 = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      _ref3[_key3] = arguments[_key3];\n    }\n    let [network, address, storage, options] = _ref3;\n    const [, provider] = getSignerAndProvider(network, options);\n    const [abi, contract, _network] = await Promise.all([MarketplaceInitializer.getAbi(address, provider, storage), import('./marketplace-5b738c1b.browser.esm.js'), provider.getNetwork()]);\n    return new contract.Marketplace(network, address, storage, options, abi, _network.chainId);\n  },\n  getAbi: async (address, provider, storage) => {\n    const abi = await fetchAbiFromAddress(address, provider, storage);\n    if (abi) {\n      return abi;\n    }\n\n    // Deprecated - only needed for backwards compatibility with non-published contracts - should remove in v4\n    return (await import('@thirdweb-dev/contracts-js/dist/abis/Marketplace.json')).default;\n  }\n};\nconst MarketplaceV3Initializer = {\n  name: \"MarketplaceV3\",\n  contractType: prebuiltContractTypes[\"marketplace-v3\"],\n  schema: MarketplaceContractSchema,\n  roles: MARKETPLACE_CONTRACT_ROLES,\n  initialize: async function () {\n    for (var _len4 = arguments.length, _ref4 = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      _ref4[_key4] = arguments[_key4];\n    }\n    let [network, address, storage, options] = _ref4;\n    const [, provider] = getSignerAndProvider(network, options);\n    const [abi, contract, _network] = await Promise.all([MarketplaceV3Initializer.getAbi(address, provider, storage, options), import('./marketplacev3-e02b24ac.browser.esm.js'), provider.getNetwork()]);\n    return new contract.MarketplaceV3(network, address, storage, options, abi, _network.chainId);\n  },\n  getAbi: async (address, provider, storage, options) => {\n    const chainId = (await provider.getNetwork()).chainId;\n    const isZkSync = chainId === 280 || chainId === 324;\n\n    // Can't resolve IPFS hash from plugin bytecode on ZkSync\n    // Thus, pull the composite ABI from the release page\n    if (isZkSync) {\n      const publishedContract = await fetchPublishedContractFromPolygon(THIRDWEB_DEPLOYER, \"MarketplaceV3\", \"latest\", storage, options?.clientId, options?.secretKey);\n      const uri = publishedContract.metadataUri;\n      const compositeAbi = await getCompositeABIfromRelease(uri, storage);\n      return compositeAbi;\n    }\n    const abi = await fetchAbiFromAddress(address, provider, storage);\n    if (abi) {\n      return await getCompositePluginABI(address, abi, provider, {}, storage);\n    }\n\n    // Deprecated - only needed for backwards compatibility with non-published contracts - should remove in v4\n    const localAbi = (await import('@thirdweb-dev/contracts-js/dist/abis/MarketplaceV3.json')).default;\n    return await getCompositePluginABI(address, AbiSchema.parse(localAbi || []), provider, {}, storage);\n  }\n};\nconst MultiwrapInitializer = {\n  name: \"Multiwrap\",\n  contractType: prebuiltContractTypes.multiwrap,\n  schema: MultiwrapContractSchema,\n  roles: MULTIWRAP_CONTRACT_ROLES,\n  initialize: async function () {\n    for (var _len5 = arguments.length, _ref5 = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      _ref5[_key5] = arguments[_key5];\n    }\n    let [network, address, storage, options] = _ref5;\n    const [, provider] = getSignerAndProvider(network, options);\n    const [abi, contract, _network] = await Promise.all([MultiwrapInitializer.getAbi(address, provider, storage), import('./multiwrap-18fab528.browser.esm.js'), provider.getNetwork()]);\n    return new contract.Multiwrap(network, address, storage, options, abi, _network.chainId);\n  },\n  getAbi: async (address, provider, storage) => {\n    const abi = await fetchAbiFromAddress(address, provider, storage);\n    if (abi) {\n      return abi;\n    }\n    // Deprecated - only needed for backwards compatibility with non-published contracts - should remove in v4\n    return (await import('@thirdweb-dev/contracts-js/dist/abis/Multiwrap.json')).default;\n  }\n};\nconst NFTCollectionInitializer = {\n  name: \"TokenERC721\",\n  contractType: prebuiltContractTypes[\"nft-collection\"],\n  schema: TokenErc721ContractSchema,\n  roles: NFT_BASE_CONTRACT_ROLES,\n  initialize: async function () {\n    for (var _len6 = arguments.length, _ref6 = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n      _ref6[_key6] = arguments[_key6];\n    }\n    let [network, address, storage, options] = _ref6;\n    const [, provider] = getSignerAndProvider(network, options);\n    const [abi, contract, _network] = await Promise.all([NFTCollectionInitializer.getAbi(address, provider, storage), import('./nft-collection-0cf43f4d.browser.esm.js'), provider.getNetwork()]);\n    return new contract.NFTCollection(network, address, storage, options, abi, _network.chainId);\n  },\n  getAbi: async (address, provider, storage) => {\n    const abi = await fetchAbiFromAddress(address, provider, storage);\n    if (abi) {\n      return abi;\n    }\n    // Deprecated - only needed for backwards compatibility with non-published contracts - should remove in v4\n    return (await import('@thirdweb-dev/contracts-js/dist/abis/TokenERC721.json')).default;\n  }\n};\nconst NFTDropInitializer = {\n  name: \"DropERC721\",\n  contractType: prebuiltContractTypes[\"nft-drop\"],\n  schema: DropErc721ContractSchema,\n  roles: NFT_BASE_CONTRACT_ROLES,\n  initialize: async function () {\n    for (var _len7 = arguments.length, _ref7 = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n      _ref7[_key7] = arguments[_key7];\n    }\n    let [network, address, storage, options] = _ref7;\n    const [, provider] = getSignerAndProvider(network, options);\n    const [abi, contract, _network] = await Promise.all([NFTDropInitializer.getAbi(address, provider, storage), import('./nft-drop-399edfe0.browser.esm.js'), provider.getNetwork()]);\n    return new contract.NFTDrop(network, address, storage, options, abi, _network.chainId);\n  },\n  getAbi: async (address, provider, storage) => {\n    const abi = await fetchAbiFromAddress(address, provider, storage);\n    if (abi) {\n      return abi;\n    }\n    // Deprecated - only needed for backwards compatibility with non-published contracts - should remove in v4\n    const contractInfo = await getContractInfo(address, provider);\n    return !contractInfo || contractInfo.version > 3 ? (await import('@thirdweb-dev/contracts-js/dist/abis/DropERC721.json')).default : (await import('@thirdweb-dev/contracts-js/dist/abis/DropERC721_V3.json')).default;\n  }\n};\nconst PackInitializer = {\n  name: \"Pack\",\n  contractType: prebuiltContractTypes[\"pack\"],\n  schema: PackContractSchema,\n  roles: PACK_CONTRACT_ROLES,\n  initialize: async function () {\n    for (var _len8 = arguments.length, _ref8 = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n      _ref8[_key8] = arguments[_key8];\n    }\n    let [network, address, storage, options] = _ref8;\n    const [, provider] = getSignerAndProvider(network, options);\n    const [abi, contract, _network] = await Promise.all([PackInitializer.getAbi(address, provider, storage), import('./pack-bd61f578.browser.esm.js'), provider.getNetwork()]);\n    return new contract.Pack(network, address, storage, options, abi, _network.chainId);\n  },\n  getAbi: async (address, provider, storage) => {\n    const abi = await fetchAbiFromAddress(address, provider, storage);\n    if (abi) {\n      return abi;\n    }\n    // Deprecated - only needed for backwards compatibility with non-published contracts - should remove in v4\n    return AbiSchema.parse((await import('@thirdweb-dev/contracts-js/dist/abis/Pack.json')).default || []);\n  }\n};\nconst SignatureDropInitializer = {\n  name: \"SignatureDrop\",\n  contractType: prebuiltContractTypes[\"signature-drop\"],\n  schema: DropErc721ContractSchema,\n  roles: NFT_BASE_CONTRACT_ROLES,\n  initialize: async function () {\n    for (var _len9 = arguments.length, _ref9 = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n      _ref9[_key9] = arguments[_key9];\n    }\n    let [network, address, storage, options] = _ref9;\n    const [, provider] = getSignerAndProvider(network, options);\n    const [abi, contract, _network] = await Promise.all([SignatureDropInitializer.getAbi(address, provider, storage), import('./signature-drop-224b723c.browser.esm.js'), provider.getNetwork()]);\n    return new contract.SignatureDrop(network, address, storage, options, abi, _network.chainId);\n  },\n  getAbi: async (address, provider, storage) => {\n    const abi = await fetchAbiFromAddress(address, provider, storage);\n    if (abi) {\n      return abi;\n    }\n    // Deprecated - only needed for backwards compatibility with non-published contracts - should remove in v4\n    const contractInfo = await getContractInfo(address, provider);\n    return !contractInfo || contractInfo.version > 4 ? (await import('@thirdweb-dev/contracts-js/dist/abis/SignatureDrop.json')).default : (await import('@thirdweb-dev/contracts-js/dist/abis/SignatureDrop_V4.json')).default;\n  }\n};\nconst SplitInitializer = {\n  name: \"Split\",\n  contractType: prebuiltContractTypes[\"split\"],\n  schema: SplitsContractSchema,\n  roles: ADMIN_ROLE,\n  initialize: async function () {\n    for (var _len10 = arguments.length, _ref10 = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n      _ref10[_key10] = arguments[_key10];\n    }\n    let [network, address, storage, options] = _ref10;\n    const [, provider] = getSignerAndProvider(network, options);\n    const [abi, contract, _network] = await Promise.all([SplitInitializer.getAbi(address, provider, storage), import('./split-8c412664.browser.esm.js'), provider.getNetwork()]);\n    return new contract.Split(network, address, storage, options, abi, _network.chainId);\n  },\n  getAbi: async (address, provider, storage) => {\n    const abi = await fetchAbiFromAddress(address, provider, storage);\n    if (abi) {\n      return abi;\n    }\n    // Deprecated - only needed for backwards compatibility with non-published contracts - should remove in v4\n    return (await import('@thirdweb-dev/contracts-js/dist/abis/Split.json')).default;\n  }\n};\nconst TokenDropInitializer = {\n  name: \"DropERC20\",\n  contractType: prebuiltContractTypes[\"token-drop\"],\n  schema: DropErc20ContractSchema,\n  roles: TOKEN_DROP_CONTRACT_ROLES,\n  initialize: async function () {\n    for (var _len11 = arguments.length, _ref11 = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {\n      _ref11[_key11] = arguments[_key11];\n    }\n    let [network, address, storage, options] = _ref11;\n    const [, provider] = getSignerAndProvider(network, options);\n    const [abi, contract, _network] = await Promise.all([TokenDropInitializer.getAbi(address, provider, storage), import('./token-drop-90cb00e6.browser.esm.js'), provider.getNetwork()]);\n    return new contract.TokenDrop(network, address, storage, options, abi, _network.chainId);\n  },\n  getAbi: async (address, provider, storage) => {\n    const abi = await fetchAbiFromAddress(address, provider, storage);\n    if (abi) {\n      return abi;\n    }\n    // Deprecated - only needed for backwards compatibility with non-published contracts - should remove in v4\n    const contractInfo = await getContractInfo(address, provider);\n    return !contractInfo || contractInfo.version > 2 ? (await import('@thirdweb-dev/contracts-js/dist/abis/DropERC20.json')).default : (await import('@thirdweb-dev/contracts-js/dist/abis/DropERC20_V2.json')).default;\n  }\n};\nconst TokenInitializer = {\n  name: \"TokenERC20\",\n  contractType: prebuiltContractTypes.token,\n  schema: TokenErc20ContractSchema,\n  roles: NFT_BASE_CONTRACT_ROLES,\n  initialize: async function () {\n    for (var _len12 = arguments.length, _ref12 = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {\n      _ref12[_key12] = arguments[_key12];\n    }\n    let [network, address, storage, options] = _ref12;\n    const [, provider] = getSignerAndProvider(network, options);\n    const [abi, contract, _network] = await Promise.all([TokenInitializer.getAbi(address, provider, storage), import('./token-1023bf9c.browser.esm.js'), provider.getNetwork()]);\n    return new contract.Token(network, address, storage, options, abi, _network.chainId);\n  },\n  getAbi: async (address, provider, storage) => {\n    const abi = await fetchAbiFromAddress(address, provider, storage);\n    if (abi) {\n      return abi;\n    }\n    // Deprecated - only needed for backwards compatibility with non-published contracts - should remove in v4\n    return (await import('@thirdweb-dev/contracts-js/dist/abis/TokenERC20.json')).default;\n  }\n};\nconst VoteInitializer = {\n  name: \"VoteERC20\",\n  contractType: prebuiltContractTypes.vote,\n  schema: VoteContractSchema,\n  roles: [],\n  initialize: async function () {\n    for (var _len13 = arguments.length, _ref13 = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {\n      _ref13[_key13] = arguments[_key13];\n    }\n    let [network, address, storage, options] = _ref13;\n    const [, provider] = getSignerAndProvider(network, options);\n    const [abi, contract, _network] = await Promise.all([VoteInitializer.getAbi(address, provider, storage), import('./vote-8af4ac9b.browser.esm.js'), provider.getNetwork()]);\n    return new contract.Vote(network, address, storage, options, abi, _network.chainId);\n  },\n  getAbi: async (address, provider, storage) => {\n    const abi = await fetchAbiFromAddress(address, provider, storage);\n    if (abi) {\n      return abi;\n    }\n    // Deprecated - only needed for backwards compatibility with non-published contracts - should remove in v4\n    return (await import('@thirdweb-dev/contracts-js/dist/abis/VoteERC20.json')).default;\n  }\n};\nasync function getContractInfo(address, provider) {\n  try {\n    return await getPrebuiltInfo(address, provider);\n  } catch (e) {\n    return undefined;\n  }\n}\n\n/**\n * a map from contractType -> contract metadata\n * @internal\n */\nconst PREBUILT_CONTRACTS_MAP = {\n  [prebuiltContractTypes[\"edition-drop\"]]: EditionDropInitializer,\n  [prebuiltContractTypes.edition]: EditionInitializer,\n  [prebuiltContractTypes.marketplace]: MarketplaceInitializer,\n  [prebuiltContractTypes[\"marketplace-v3\"]]: MarketplaceV3Initializer,\n  [prebuiltContractTypes.multiwrap]: MultiwrapInitializer,\n  [prebuiltContractTypes[\"nft-collection\"]]: NFTCollectionInitializer,\n  [prebuiltContractTypes[\"nft-drop\"]]: NFTDropInitializer,\n  [prebuiltContractTypes.pack]: PackInitializer,\n  [prebuiltContractTypes[\"signature-drop\"]]: SignatureDropInitializer,\n  [prebuiltContractTypes.split]: SplitInitializer,\n  [prebuiltContractTypes[\"token-drop\"]]: TokenDropInitializer,\n  [prebuiltContractTypes.token]: TokenInitializer,\n  [prebuiltContractTypes.vote]: VoteInitializer\n};\nconst PREBUILT_CONTRACTS_APPURI_MAP = {\n  [prebuiltContractTypes[\"edition-drop\"]]: \"ipfs://QmNm3wRzpKYWo1SRtJfgfxtvudp5p2nXD6EttcsQJHwTmk\",\n  [prebuiltContractTypes.edition]: \"\",\n  [prebuiltContractTypes.marketplace]: \"ipfs://QmbAgC8YwY36n8H2kuvSWsRisxDZ15QZw3xGZyk9aDvcv7/marketplace.html\",\n  [prebuiltContractTypes[\"marketplace-v3\"]]: \"ipfs://QmbAgC8YwY36n8H2kuvSWsRisxDZ15QZw3xGZyk9aDvcv7/marketplace-v3.html\",\n  [prebuiltContractTypes.multiwrap]: \"\",\n  [prebuiltContractTypes[\"nft-collection\"]]: \"\",\n  [prebuiltContractTypes[\"nft-drop\"]]: \"ipfs://QmZptmVipc6SGFbKAyXcxGgohzTwYRXZ9LauRX5ite1xDK\",\n  [prebuiltContractTypes.pack]: \"\",\n  [prebuiltContractTypes[\"signature-drop\"]]: \"ipfs://QmZptmVipc6SGFbKAyXcxGgohzTwYRXZ9LauRX5ite1xDK\",\n  [prebuiltContractTypes.split]: \"\",\n  [prebuiltContractTypes[\"token-drop\"]]: \"ipfs://QmbAgC8YwY36n8H2kuvSWsRisxDZ15QZw3xGZyk9aDvcv7/erc20.html\",\n  [prebuiltContractTypes.token]: \"\",\n  [prebuiltContractTypes.vote]: \"\"\n};\nconst SmartContract$1 = {\n  name: \"SmartContract\",\n  contractType: \"custom\",\n  schema: {},\n  roles: ALL_ROLES\n};\nconst CONTRACTS_MAP = {\n  ...PREBUILT_CONTRACTS_MAP,\n  [SmartContract$1.contractType]: SmartContract$1\n};\n\n/**\n * @internal\n */\nfunction getContractTypeForRemoteName(name) {\n  return Object.values(CONTRACTS_MAP).find(contract => contract.name === name)?.contractType || \"custom\";\n}\nfunction getContractName(type) {\n  return Object.values(CONTRACTS_MAP).find(contract => contract.contractType === type)?.name;\n}\nconst SignerPermissionsSchema = /* @__PURE__ */z.object({\n  startDate: StartDateSchema,\n  expirationDate: EndDateSchema,\n  nativeTokenLimitPerTransaction: /* @__PURE__ */AmountSchema.default(0),\n  approvedCallTargets: /* @__PURE__ */z.array(AddressOrEnsSchema)\n});\nconst PermissionSnapshotSchema = /* @__PURE__ */z.array( /* @__PURE__ */z.object({\n  signer: AddressOrEnsSchema,\n  makeAdmin: /* @__PURE__ */z.boolean(),\n  permissions: SignerPermissionsSchema\n}));\nconst SignerPermissionRequest = [{\n  name: \"signer\",\n  type: \"address\"\n}, {\n  name: \"approvedTargets\",\n  type: \"address[]\"\n}, {\n  name: \"nativeTokenLimitPerTransaction\",\n  type: \"uint256\"\n}, {\n  name: \"permissionStartTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"permissionEndTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"reqValidityStartTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"reqValidityEndTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"uid\",\n  type: \"bytes32\"\n}];\nclass AccountPermissions {\n  featureName = FEATURE_ACCOUNT_PERMISSIONS.name;\n  constructor(contractWrapper) {\n    this.contractWrapper = contractWrapper;\n  }\n  getAddress() {\n    return this.contractWrapper.address;\n  }\n\n  /*********************************\n   * HELPER FUNCTIONS\n   ********************************/\n\n  hasDuplicateSigners(snapshot) {\n    const checkedSigner = {};\n    const signers = snapshot.map(item => item.signer);\n    for (const signer of signers) {\n      if (!checkedSigner[signer]) {\n        checkedSigner[signer] = true;\n      } else {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Format the access restrictions for a given role\n   *\n   * @param restrictions - The access restrictions for a given role\n   * @returns formatted role restrictions\n   *\n   */\n  parseSignerPermissionsStruct(permissions) {\n    return {\n      startDate: new Date(parseInt(permissions.startTimestamp.toString()) * 1000),\n      expirationDate: new Date(parseInt(permissions.endTimestamp.toString()) * 1000),\n      nativeTokenLimitPerTransaction: BigNumber.from(permissions.nativeTokenLimitPerTransaction),\n      approvedCallTargets: permissions.approvedTargets\n    };\n  }\n  async sendSignerPermissionRequest(signerAddress, permissions) {\n    const {\n      payload,\n      signature\n    } = await this.generatePayload(signerAddress, permissions);\n    const [success] = await this.contractWrapper.read(\"verifySignerPermissionRequest\", [payload, signature]);\n    if (!success) {\n      throw new Error(`Invalid signature.`);\n    }\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"setPermissionsForSigner\",\n      args: [payload, signature]\n    });\n  }\n  async buildSignerPermissionRequest(signerAddress, permissions) {\n    const {\n      payload,\n      signature\n    } = await this.generatePayload(signerAddress, permissions);\n    const isValidSigner = await this.contractWrapper.read(\"verifySignerPermissionRequest\", [payload, signature]);\n    if (!isValidSigner) {\n      throw new Error(`Invalid signature.`);\n    }\n    return this.contractWrapper.writeContract.interface.encodeFunctionData(\"setPermissionsForSigner\", [payload, signature]);\n  }\n\n  /**\n   * Generate and sign a payload to grant or revoke a signer's access to the account.\n   *\n   * @param signer - The address of the signer\n   * @param roleAction - The address of the signer\n   * @returns The generated payload and signature produced on signing that payload.\n   *\n   */\n  async generatePayload(signerAddress, permissions) {\n    // Get payload struct.\n    const payload = {\n      signer: signerAddress,\n      approvedTargets: permissions.approvedCallTargets,\n      nativeTokenLimitPerTransaction: utils.parseEther(permissions.nativeTokenLimitPerTransaction),\n      permissionStartTimestamp: permissions.startDate,\n      permissionEndTimestamp: permissions.expirationDate,\n      reqValidityStartTimestamp: 0,\n      // Req validity ends 10 years from now.\n      reqValidityEndTimestamp: BigNumber.from(Math.floor(new Date(Date.now() + 1000 * 60 * 60 * 24 * 365 * 10).getTime() / 1000)),\n      uid: resolveOrGenerateId(undefined)\n    };\n\n    // Generate signature\n    const chainId = await this.contractWrapper.getChainID();\n    const connectedSigner = this.contractWrapper.getSigner();\n    invariant(connectedSigner, \"No signer available\");\n    const signature = await this.contractWrapper.signTypedData(connectedSigner, {\n      name: \"Account\",\n      version: \"1\",\n      chainId,\n      verifyingContract: this.getAddress()\n    }, {\n      SignerPermissionRequest\n    }, payload);\n    return {\n      payload,\n      signature\n    };\n  }\n\n  /*********************************\n   * READ FUNCTIONS\n   ********************************/\n\n  /**\n   * Get whether a signer is an admin on the account.\n   *\n   * @example\n   * ```javascript\n   * const isAdmin = await contract.account.isAdmin(signer);\n   * ```\n   * @param signer - The address of a signer of the account.\n   * @returns whether a signer is an admin on the account.\n   *\n   * @twfeature AccountPermissions\n   */\n  async isAdmin(signerAddress) {\n    const resolvedSignerAddress = await resolveAddress(signerAddress);\n    return await this.contractWrapper.read(\"isAdmin\", [resolvedSignerAddress]);\n  }\n\n  /**\n   * Get whether a signer has permissions to use the account.\n   *\n   * @example\n   * ```javascript\n   * const isAdmin = await contract.account.isSigner(signer);\n   * ```\n   * @param signer - The address of a signer of the account.\n   * @returns whether a signer has permissions to use the account.\n   *\n   * @twfeature AccountPermissions\n   */\n  async isSigner(signerAddress) {\n    const resolvedSignerAddress = await resolveAddress(signerAddress);\n    return await this.contractWrapper.read(\"isActiveSigner\", [resolvedSignerAddress]);\n  }\n\n  /**\n   * Get all admins of the account.\n   *\n   * @example\n   * ```javascript\n   * const allAdmins = await contract.account.getAllAdmins();\n   * ```\n   *\n   * @returns all admins of the account.\n   *\n   * @twfeature AccountPermissions\n   */\n  async getAllAdmins() {\n    return await this.contractWrapper.read(\"getAllAdmins\", []);\n  }\n\n  /**\n   * Get all (non-admin) signers with permissions to use the account.\n   *\n   * @example\n   * ```javascript\n   * const allSigners = await contract.account.getAllSigners();\n   * ```\n   *\n   * @returns all (non-admin) signers with permissions to use the account.\n   *\n   * @twfeature AccountPermissions\n   */\n  async getAllSigners() {\n    const activeSignersWithPerms = await this.contractWrapper.read(\"getAllActiveSigners\", []);\n    return await Promise.all(activeSignersWithPerms.map(async signerWithPermissions => {\n      const signer = signerWithPermissions.signer;\n      const permissions = this.parseSignerPermissionsStruct(signerWithPermissions);\n      return {\n        signer,\n        permissions\n      };\n    }));\n  }\n\n  /**\n   * Get all admins and non-admin signers with permissions to use the account.\n   *\n   * @example\n   * ```javascript\n   * const allAdminsAndSigners = await contract.account.getAllAdminsAndSigners();\n   * ```\n   *\n   * @returns all admins and non-admin signers with permissions to use the account.\n   *\n   * @twfeature AccountPermissions\n   */\n  async getAllAdminsAndSigners() {\n    const allAdmins = await this.getAllAdmins();\n    const transformedAdmins = allAdmins.map(admin => {\n      return {\n        isAdmin: true,\n        signer: admin,\n        permissions: {\n          startDate: new Date(0),\n          expirationDate: new Date(0),\n          nativeTokenLimitPerTransaction: BigNumber.from(0),\n          approvedCallTargets: []\n        }\n      };\n    });\n    const allSigners = await this.getAllSigners();\n    return [...transformedAdmins, ...allSigners];\n  }\n\n  /*********************************\n   * WRITE FUNCTIONS\n   ********************************/\n\n  /**\n   * Grant an address admin access to the account.\n   *\n   * @remarks Grants an address admin access to the account. The admin will have complete authority over the account.\n   *\n   * @param signer - The address to be granted admin access to the account.\n   *\n   * @example\n   * ```javascript\n   * const tx = await contract.account.grantAdminAccess(signer);\n   * const receipt = tx.receipt();\n   * ```\n   *\n   * @twfeature AccountPermissions\n   */\n  grantAdminPermissions = /* @__PURE__ */buildTransactionFunction(async signerAddress => {\n    const resolvedSignerAddress = await resolveAddress(signerAddress);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"setAdmin\",\n      args: [resolvedSignerAddress, true]\n    });\n  });\n\n  /**\n   * Revoke an address' admin access to the account.\n   *\n   * @remarks Revokes an address' admin access to the account.\n   *\n   * @param signer - The address of an admin of the account.\n   *\n   * @example\n   * ```javascript\n   * const tx = await contract.account.revokeAdminAccess(signer);\n   * const receipt = tx.receipt();\n   * ```\n   *\n   * @twfeature AccountPermissions\n   */\n  revokeAdminPermissions = /* @__PURE__ */buildTransactionFunction(async signerAddress => {\n    const resolvedSignerAddress = await resolveAddress(signerAddress);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"setAdmin\",\n      args: [resolvedSignerAddress, false]\n    });\n  });\n\n  /**\n   * Grant a signer permissions to use the account.\n   *\n   * @remarks Grants a signer permissions to use the account.\n   *\n   * @param signer - The signer to be granted permissions to use the account.\n   * @param permissions - The permissions to be applied to the signer's use of the account.\n   *\n   * @example\n   * ```javascript\n   * const tx = await contract.account.grantPermissions(signer, permissions);\n   * const receipt = tx.receipt();\n   * ```\n   *\n   * @twfeature AccountPermissions\n   */\n  grantPermissions = /* @__PURE__ */buildTransactionFunction(async (signerAddress, permissions) => {\n    const resolvedSignerAddress = await resolveAddress(signerAddress);\n    const resolvedPermissions = await SignerPermissionsSchema.parseAsync(permissions);\n    if (await this.isAdmin(resolvedSignerAddress)) {\n      throw new Error(\"Signer is already an admin. Cannot grant permissions to an existing admin.\");\n    }\n    if (await this.isSigner(resolvedSignerAddress)) {\n      throw new Error(\"Signer already has permissions. Cannot grant permissions to an existing signer. You can update permissions using `updatePermissions`.\");\n    }\n    return await this.sendSignerPermissionRequest(resolvedSignerAddress, resolvedPermissions);\n  });\n\n  /**\n   * Update the permissions of a signer for using the account.\n   *\n   * @remarks Updates the permissions of a signer for using the account.\n   *\n   * @param signer - The signer whose permissions to use the account are to be updated.\n   * @param permissions - The permissions to be applied to the signer's use of the account.\n   *\n   * @example\n   * ```javascript\n   * const tx = await contract.account.updatePermissions(signer, permissions);\n   * const receipt = tx.receipt();\n   * ```\n   *\n   * @twfeature AccountPermissions\n   */\n  updatePermissions = /* @__PURE__ */buildTransactionFunction(async (signerAddress, permissions) => {\n    const resolvedSignerAddress = await resolveAddress(signerAddress);\n    const resolvedPermissions = await SignerPermissionsSchema.parseAsync(permissions);\n    if (await this.isAdmin(resolvedSignerAddress)) {\n      throw new Error(\"Signer is already an admin. Cannot update permissions of an existing admin.\");\n    }\n    if (!(await this.isSigner(resolvedSignerAddress))) {\n      throw new Error(\"Signer does not already have permissions. You can grant permissions using `grantPermissions`.\");\n    }\n    return await this.sendSignerPermissionRequest(resolvedSignerAddress, resolvedPermissions);\n  });\n\n  /**\n   * Revoke a scoped access address to the account\n   *\n   * @remarks Revokes an address' access to the account.\n   *\n   * @param signer - The address whose access to the account is to be revoked.\n   *\n   * @example\n   * ```javascript\n   * const tx = await contract.account.revokeAccess(signer);\n   * const receipt = tx.receipt();\n   * ```\n   *\n   * @twfeature AccountPermissions\n   */\n  revokeAccess = /* @__PURE__ */buildTransactionFunction(async signerAddress => {\n    const resolvedSignerAddress = await resolveAddress(signerAddress);\n    if (await this.isAdmin(resolvedSignerAddress)) {\n      throw new Error(\"Signer is already an admin. Cannot revoke permissions of an admin.\");\n    }\n    if (!(await this.isSigner(resolvedSignerAddress))) {\n      throw new Error(\"Signer does not already have permissions. You can grant permissions using `grantPermissions`.\");\n    }\n    return await this.sendSignerPermissionRequest(resolvedSignerAddress, {\n      startDate: BigNumber.from(0),\n      expirationDate: BigNumber.from(0),\n      approvedCallTargets: [],\n      nativeTokenLimitPerTransaction: \"0\"\n    });\n  });\n\n  /**\n   * Approve an address as a call target for a given signer on the account\n   *\n   * @remarks Approves an address as a call target for a given signer on the account.\n   *\n   * @param signer - A signer with restricted access to the account.\n   * @param target - The address to approve as a call target for the signer.\n   *\n   * @example\n   * ```javascript\n   * const tx = await contract.account.approveTargetForSigner(signer, target);\n   * const receipt = tx.receipt();\n   * ```\n   *\n   * @twfeature AccountPermissions\n   */\n  approveTargetForSigner = /* @__PURE__ */buildTransactionFunction(async (signerAddress, target) => {\n    const resolvedSignerAddress = await resolveAddress(signerAddress);\n    const resolvedTarget = await resolveAddress(target);\n    if (await this.isAdmin(resolvedSignerAddress)) {\n      throw new Error(\"Signer is already an admin. Cannot approve targets for an admin.\");\n    }\n    if (!(await this.isSigner(resolvedSignerAddress))) {\n      throw new Error(\"Signer does not already have permissions. You can grant permissions using `grantPermissions`.\");\n    }\n    const permissions = await this.contractWrapper.read(\"getPermissionsForSigner\", [resolvedSignerAddress]);\n    if (permissions.approvedTargets.includes(target)) {\n      throw new Error(\"Target is already approved\");\n    }\n    const newTargets = [...permissions.approvedTargets, resolvedTarget];\n    return await this.sendSignerPermissionRequest(resolvedSignerAddress, {\n      startDate: BigNumber.from(permissions.startTimestamp),\n      expirationDate: BigNumber.from(permissions.endTimestamp),\n      approvedCallTargets: newTargets,\n      nativeTokenLimitPerTransaction: permissions.nativeTokenLimitPerTransaction.toString()\n    });\n  });\n\n  /**\n   * Disapprove an address as a call target for a given signer on the account\n   *\n   * @remarks Disapprove an address as a call target for a given signer on the account.\n   *\n   * @param signer - A signer with restricted access to the account.\n   * @param target - The address to disapprove as a call target for the signer.\n   *\n   * @example\n   * ```javascript\n   * const tx = await contract.account.disapproveTargetForSigner(signer, target);\n   * const receipt = tx.receipt();\n   * ```\n   *\n   * @twfeature AccountPermissions\n   */\n  disapproveTargetForSigner = /* @__PURE__ */buildTransactionFunction(async (signerAddress, target) => {\n    const resolvedSignerAddress = await resolveAddress(signerAddress);\n    const resolvedTarget = await resolveAddress(target);\n    if (await this.isAdmin(resolvedSignerAddress)) {\n      throw new Error(\"Signer is already an admin. Cannot approve targets for an admin.\");\n    }\n    if (!(await this.isSigner(resolvedSignerAddress))) {\n      throw new Error(\"Signer does not already have permissions. You can grant permissions using `grantPermissions`.\");\n    }\n    const permissions = await this.contractWrapper.read(\"getPermissionsForSigner\", [resolvedSignerAddress]);\n    if (!permissions.approvedTargets.includes(resolvedTarget)) {\n      throw new Error(\"Target is currently not approved\");\n    }\n    const newTargets = permissions.approvedTargets.filter(approvedTarget => utils.getAddress(approvedTarget) !== utils.getAddress(resolvedTarget));\n    return await this.sendSignerPermissionRequest(resolvedSignerAddress, {\n      startDate: BigNumber.from(permissions.startTimestamp),\n      expirationDate: BigNumber.from(permissions.endTimestamp),\n      approvedCallTargets: newTargets,\n      nativeTokenLimitPerTransaction: permissions.nativeTokenLimitPerTransaction.toString()\n    });\n  });\n\n  /**\n   * Set the account's entire snapshot of permissions.\n   *\n   * @remarks Sets the account's entire snapshot of permissions.\n   *\n   * @param permissionSnapshot - the snapshot to set as the account's entire permission snapshot.\n   *\n   * @example\n   * ```javascript\n   * const tx = await contract.account.setAccess(permissionSnapshot);\n   * const receipt = tx.receipt();\n   * ```\n   *\n   * @twfeature AccountPermissions\n   */\n  resetAllPermissions = /* @__PURE__ */buildTransactionFunction(async permissionSnapshot => {\n    const resolvedSnapshot = await PermissionSnapshotSchema.parseAsync(permissionSnapshot);\n\n    /**\n     * All cases\n     *\n     * - Add new admin :check:\n     * - Remove current admin :check:\n     * - Add new scoped :check:\n     * - Remove current scoped :check:\n     * - Update current scoped :check:\n     * - Current admin -> new scoped :check:\n     * - Current scoped -> new admin :check:\n     **/\n\n    // No duplicate signers in input!\n    if (this.hasDuplicateSigners(resolvedSnapshot)) {\n      throw new Error(\"Duplicate signers found in input.\");\n    }\n    const addAdminData = [];\n    const removeAdminData = [];\n    const addOrUpdateSignerData = [];\n    const removeSignerData = [];\n\n    // Remove all existing admins not included in the passed snapshot.\n    const allAdmins = await this.getAllAdmins();\n    const allToMakeAdmin = resolvedSnapshot.filter(item => item.makeAdmin).map(item => item.signer);\n    allAdmins.forEach(admin => {\n      if (!allToMakeAdmin.includes(admin)) {\n        removeAdminData.push(this.contractWrapper.writeContract.interface.encodeFunctionData(\"setAdmin\", [admin, false]));\n      }\n    });\n\n    // Remove all existing signers not included in the passed snapshot.\n    const allSigners = await this.getAllSigners();\n    const allToMakeSigners = resolvedSnapshot.filter(item => {\n      return !item.makeAdmin;\n    }).map(item => item.signer);\n    await Promise.all(allSigners.map(async item => {\n      if (!allToMakeSigners.includes(item.signer)) {\n        const data = await this.buildSignerPermissionRequest(item.signer, {\n          startDate: BigNumber.from(0),\n          expirationDate: BigNumber.from(0),\n          approvedCallTargets: [],\n          nativeTokenLimitPerTransaction: \"0\"\n        });\n        removeSignerData.push(data);\n      }\n    }));\n    for (const member of resolvedSnapshot) {\n      // Add new admin\n      if (member.makeAdmin) {\n        addAdminData.push(this.contractWrapper.writeContract.interface.encodeFunctionData(\"setAdmin\", [member.signer, true]));\n      } else {\n        // Add new scoped\n        const data = await this.buildSignerPermissionRequest(member.signer, member.permissions);\n        addOrUpdateSignerData.push(data);\n      }\n    }\n    const data = [];\n    removeAdminData.forEach(item => {\n      data.push(item);\n    });\n    removeSignerData.forEach(item => {\n      data.push(item);\n    });\n    addOrUpdateSignerData.forEach(item => {\n      data.push(item);\n    });\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"multicall\",\n      args: [data]\n    });\n  });\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars -- TO BE REMOVED IN V4\nclass Account {\n  featureName = FEATURE_ACCOUNT.name;\n  constructor(contractWrapper) {\n    this.contractWrapper = contractWrapper;\n    this.accountPermissions = this.detectAccountPermissions();\n  }\n  detectAccountPermissions() {\n    if (detectContractFeature(this.contractWrapper, \"AccountPermissions\")) {\n      return new AccountPermissions(this.contractWrapper);\n    }\n    return undefined;\n  }\n  getAddress() {\n    return this.contractWrapper.address;\n  }\n\n  /*********************************\n   * READ FUNCTIONS\n   ********************************/\n\n  /**\n   * Get whether a signer is an admin on the account.\n   *\n   * @example\n   * ```javascript\n   * const isAdmin = await contract.account.isAdmin(signer);\n   * ```\n   * @param signer - The address of a signer of the account.\n   * @returns whether a signer is an admin on the account.\n   *\n   * @twfeature AccountPermissions\n   */\n  async isAdmin(signerAddress) {\n    return assertEnabled(this.accountPermissions, FEATURE_ACCOUNT_PERMISSIONS).isAdmin(signerAddress);\n  }\n\n  /**\n   * Get whether a signer has permissions to use the account.\n   *\n   * @example\n   * ```javascript\n   * const isAdmin = await contract.account.isSigner(signer);\n   * ```\n   * @param signer - The address of a signer of the account.\n   * @returns whether a signer has permissions to use the account.\n   *\n   * @twfeature AccountPermissions\n   */\n  async isSigner(signerAddress) {\n    return assertEnabled(this.accountPermissions, FEATURE_ACCOUNT_PERMISSIONS).isSigner(signerAddress);\n  }\n\n  /**\n   * Get all admins of the account.\n   *\n   * @example\n   * ```javascript\n   * const allAdmins = await contract.account.getAllAdmins();\n   * ```\n   *\n   * @returns all admins of the account.\n   *\n   * @twfeature AccountPermissions\n   */\n  async getAllAdmins() {\n    return assertEnabled(this.accountPermissions, FEATURE_ACCOUNT_PERMISSIONS).getAllAdmins();\n  }\n\n  /**\n   * Get all (non-admin) signers with permissions to use the account.\n   *\n   * @example\n   * ```javascript\n   * const allSigners = await contract.account.getAllSigners();\n   * ```\n   *\n   * @returns all (non-admin) signers with permissions to use the account.\n   *\n   * @twfeature AccountPermissions\n   */\n  async getAllSigners() {\n    return assertEnabled(this.accountPermissions, FEATURE_ACCOUNT_PERMISSIONS).getAllSigners();\n  }\n\n  /**\n   * Get all admins and non-admin signers with permissions to use the account.\n   *\n   * @example\n   * ```javascript\n   * const allAdminsAndSigners = await contract.account.getAllAdminsAndSigners();\n   * ```\n   *\n   * @returns all admins and non-admin signers with permissions to use the account.\n   *\n   * @twfeature AccountPermissions\n   */\n  async getAllAdminsAndSigners() {\n    return assertEnabled(this.accountPermissions, FEATURE_ACCOUNT_PERMISSIONS).getAllAdminsAndSigners();\n  }\n\n  /*********************************\n   * WRITE FUNCTIONS\n   ********************************/\n\n  /**\n   * Grant an address admin access to the account.\n   *\n   * @remarks Grants an address admin access to the account. The admin will have complete authority over the account.\n   *\n   * @param signer - The address to be granted admin access to the account.\n   *\n   * @example\n   * ```javascript\n   * const tx = await contract.account.grantAdminAccess(signer);\n   * const receipt = tx.receipt();\n   * ```\n   *\n   * @twfeature AccountPermissions\n   */\n  grantAdminPermissions = /* @__PURE__ */buildTransactionFunction(async signerAddress => {\n    return assertEnabled(this.accountPermissions, FEATURE_ACCOUNT_PERMISSIONS).grantAdminPermissions.prepare(signerAddress);\n  });\n\n  /**\n   * Revoke an address' admin access to the account.\n   *\n   * @remarks Revokes an address' admin access to the account.\n   *\n   * @param signer - The address of an admin of the account.\n   *\n   * @example\n   * ```javascript\n   * const tx = await contract.account.revokeAdminAccess(signer);\n   * const receipt = tx.receipt();\n   * ```\n   *\n   * @twfeature AccountPermissions\n   */\n  revokeAdminPermissions = /* @__PURE__ */buildTransactionFunction(async signerAddress => {\n    return assertEnabled(this.accountPermissions, FEATURE_ACCOUNT_PERMISSIONS).revokeAdminPermissions.prepare(signerAddress);\n  });\n\n  /**\n   * Grant a signer permissions to use the account.\n   *\n   * @remarks Grants a signer permissions to use the account.\n   *\n   * @param signer - The signer to be granted permissions to use the account.\n   * @param permissions - The permissions to be applied to the signer's use of the account.\n   *\n   * @example\n   * ```javascript\n   * const tx = await contract.account.grantPermissions(signer, permissions);\n   * const receipt = tx.receipt();\n   * ```\n   *\n   * @twfeature AccountPermissions\n   */\n  grantPermissions = /* @__PURE__ */buildTransactionFunction(async (signerAddress, permissions) => {\n    return assertEnabled(this.accountPermissions, FEATURE_ACCOUNT_PERMISSIONS).grantPermissions.prepare(signerAddress, permissions);\n  });\n\n  /**\n   * Update the permissions of a signer for using the account.\n   *\n   * @remarks Updates the permissions of a signer for using the account.\n   *\n   * @param signer - The signer whose permissions to use the account are to be updated.\n   * @param permissions - The permissions to be applied to the signer's use of the account.\n   *\n   * @example\n   * ```javascript\n   * const tx = await contract.account.updateAccess(signer, restrictions);\n   * const receipt = tx.receipt();\n   * ```\n   *\n   * @twfeature AccountPermissions\n   */\n  updatePermissions = /* @__PURE__ */buildTransactionFunction(async (signerAddress, permissions) => {\n    return assertEnabled(this.accountPermissions, FEATURE_ACCOUNT_PERMISSIONS).updatePermissions.prepare(signerAddress, permissions);\n  });\n\n  /**\n   * Revoke a scoped access address to the account\n   *\n   * @remarks Revokes an address' access to the account.\n   *\n   * @param signer - The address whose access to the account is to be revoked.\n   *\n   * @example\n   * ```javascript\n   * const tx = await contract.account.revokeAccess(signer);\n   * const receipt = tx.receipt();\n   * ```\n   *\n   * @twfeature AccountPermissions\n   */\n  revokeAccess = /* @__PURE__ */buildTransactionFunction(async signerAddress => {\n    return assertEnabled(this.accountPermissions, FEATURE_ACCOUNT_PERMISSIONS).revokeAccess.prepare(signerAddress);\n  });\n\n  /**\n   * Approve an address as a call target for a given signer on the account\n   *\n   * @remarks Approves an address as a call target for a given signer on the account.\n   *\n   * @param signer - A signer with restricted access to the account.\n   * @param target - The address to approve as a call target for the signer.\n   *\n   * @example\n   * ```javascript\n   * const tx = await contract.account.approveTargetForSigner(signer, target);\n   * const receipt = tx.receipt();\n   * ```\n   *\n   * @twfeature AccountPermissions\n   */\n  approveTargetForSigner = /* @__PURE__ */buildTransactionFunction(async (signerAddress, target) => {\n    return assertEnabled(this.accountPermissions, FEATURE_ACCOUNT_PERMISSIONS).approveTargetForSigner.prepare(signerAddress, target);\n  });\n\n  /**\n   * Disapprove an address as a call target for a given signer on the account\n   *\n   * @remarks Disapprove an address as a call target for a given signer on the account.\n   *\n   * @param signer - A signer with restricted access to the account.\n   * @param target - The address to disapprove as a call target for the signer.\n   *\n   * @example\n   * ```javascript\n   * const tx = await contract.account.disapproveTargetForSigner(signer, target);\n   * const receipt = tx.receipt();\n   * ```\n   *\n   * @twfeature AccountPermissions\n   */\n  disapproveTargetForSigner = /* @__PURE__ */buildTransactionFunction(async (signerAddress, target) => {\n    return assertEnabled(this.accountPermissions, FEATURE_ACCOUNT_PERMISSIONS).disapproveTargetForSigner.prepare(signerAddress, target);\n  });\n\n  /**\n   * Set the account's entire snapshot of permissions.\n   *\n   * @remarks Sets the account's entire snapshot of permissions.\n   *\n   * @param permissionSnapshot - the snapshot to set as the account's entire permission snapshot.\n   *\n   * @example\n   * ```javascript\n   * const tx = await contract.account.setAccess(permissionSnapshot);\n   * const receipt = tx.receipt();\n   * ```\n   *\n   * @twfeature AccountPermissions\n   */\n  resetAllPermissions = /* @__PURE__ */buildTransactionFunction(async permissionSnapshot => {\n    return assertEnabled(this.accountPermissions, FEATURE_ACCOUNT_PERMISSIONS).resetAllPermissions.prepare(permissionSnapshot);\n  });\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars -- TO BE REMOVED IN V4\nclass AccountFactory {\n  featureName = FEATURE_ACCOUNT_FACTORY.name;\n\n  // utilities\n\n  constructor(contractWrapper) {\n    this.contractWrapper = contractWrapper;\n    this.events = new ContractEvents(this.contractWrapper);\n  }\n  getAddress() {\n    return this.contractWrapper.address;\n  }\n\n  /*********************************\n   * READ FUNCTIONS\n   *******************************/\n\n  /**\n   * Get the deterministic address of the account that will be created\n   *\n   * @example\n   * ```javascript\n   * const accountAddress = await contract.accountFactory.predictAccountAddress(admin);\n   * ```\n   * @param admin - The admin of the account.\n   * @param extraData - (Optional) Extra data to be passed to the account on creation.\n   * @returns the deterministic address of the account that will be created for the given admin.\n   *\n   * @twfeature AccountFactory\n   */\n  async predictAccountAddress(admin, extraData) {\n    let data = utils.toUtf8Bytes(\"\");\n    if (extraData) {\n      data = extraData;\n    }\n    return this.contractWrapper.read(\"getAddress\", [admin, data]);\n  }\n\n  /**\n   * Get all accounts on which the given signer has authority\n   *\n   * @example\n   * ```javascript\n   * const allAccounts = await contract.accountFactory.getAssociatedAccounts(admin);\n   * ```\n   * @param signer - The account address.\n   * @returns all accounts on which the given signer has authority.\n   *\n   * @twfeature AccountFactory\n   */\n  async getAssociatedAccounts(signer) {\n    return this.contractWrapper.read(\"getAccountsOfSigner\", [signer]);\n  }\n\n  /**\n   * Get all accounts\n   *\n   * @example\n   * ```javascript\n   * const allAccounts = await contract.accountFactory.getAllAccounts();\n   * ```\n   *\n   * @returns all accounts created via the account factory.\n   *\n   * @twfeature AccountFactory\n   */\n  async getAllAccounts() {\n    return await this.contractWrapper.read(\"getAllAccounts\", []);\n  }\n\n  /**\n   * Check if a account has been deployed for the given admin\n   *\n   * @param admin - The admin of the account.\n   * @param extraData - (Optional) Extra data to be passed to the account on creation.\n   * @returns whether the account has been deployed for the given admin.\n   */\n  async isAccountDeployed(admin, extraData) {\n    const addr = await this.predictAccountAddress(admin, extraData);\n    return isContractDeployed(addr, this.contractWrapper.getProvider());\n  }\n\n  /*********************************\n   * WRITE FUNCTIONS\n   *******************************/\n\n  /**\n   * Create a account\n   *\n   * @remarks Create a account for an admin. The admin will have complete authority over the account.\n   *\n   * @param admin - The admin of the account.\n   * @param extraData - (Optional) Extra data to be passed to the account on creation.\n   *\n   * @example\n   *  ```javascript\n   * const tx = await contract.accountFactory.createAccount(admin, extraData);\n   * const receipt = tx.receipt();\n   * const accountAddress = tx.address;\n   * ```\n   *\n   * @twfeature AccountFactory\n   */\n  createAccount = /* @__PURE__ */buildTransactionFunction(async (accountAdmin, extraData) => {\n    if (await this.isAccountDeployed(accountAdmin, extraData)) {\n      throw new Error(`Account already deployed for admin: ${accountAdmin}`);\n    }\n    let data = utils.toUtf8Bytes(\"\");\n    if (extraData) {\n      data = extraData;\n    }\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"createAccount\",\n      args: [accountAdmin, data],\n      parse: receipt => {\n        const event = this.contractWrapper.parseLogs(\"AccountCreated\", receipt?.logs);\n        return {\n          address: event[0].args.account,\n          receipt\n        };\n      }\n    });\n  });\n}\n\n/**\n * @public\n */\nclass Airdrop1155 {\n  featureName = FEATURE_AIRDROP_ERC1155.name;\n  constructor(contractWrapper) {\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * @internal\n   */\n  getAddress() {\n    return this.contractWrapper.address;\n  }\n\n  /** ******************************\n   * WRITE FUNCTIONS\n   *******************************/\n\n  /**\n   * Perform airdrop of ERC1155 tokens\n   *\n   * @example\n   * ```javascript\n   * // Airdrop content array, with recipients and tokenIds\n   * const contents = [\n   *      {\n   *        recipient: \"0xabc...\", // first recipient address\n   *        tokenId: 0,\n   *        amount: \"10\" // number of tokens\n   *      },\n   *      {\n   *        recipient: \"0x123...\", // second recipient address\n   *        tokenId: 0\n   *        amount: \"20\" // number of tokens\n   *      }\n   *   ]\n   *\n   * const tokenAddress = \"0x...\" // Address of the ERC1155 token being airdropped\n   * const tokenOwner = \"0x...\" // Address of the owner of the tokens being airdropped\n   *\n   * const output = await contract.airdrop1155.drop(tokenAddress, tokenOwner, contents);\n   *\n   * // the `output` return value above contains:\n   * //     - count of successful and failed drops\n   * //     - array containing failed drops, if any\n   *\n   * ```\n   * @param tokenAddress\n   * @param tokenOwner\n   * @param contents\n   *\n   * @returns an array of recipients for who the airdrop failed (empty means all transfers were successful)\n   * @twfeature AirdropERC1155\n   */\n  drop = /* @__PURE__ */buildTransactionFunction(async (tokenAddress, tokenOwner, contents) => {\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"airdropERC1155\",\n      args: [tokenAddress, tokenOwner, contents],\n      parse: receipt => {\n        const events = this.contractWrapper.parseLogs(\"AirdropFailed\", receipt.logs);\n        const failedDrops = events.map(e => {\n          return {\n            recipient: e.args.recipient,\n            tokenId: e.args.tokenId.toNumber(),\n            amount: e.args.amount.toString()\n          };\n        });\n        return {\n          successfulDropCount: contents.length - failedDrops.length,\n          failedDropCount: failedDrops.length,\n          failedDrops\n        };\n      }\n    });\n  });\n}\n\n/**\n * @public\n */\nclass Airdrop20 {\n  featureName = FEATURE_AIRDROP_ERC20.name;\n  constructor(contractWrapper) {\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * @internal\n   */\n  getAddress() {\n    return this.contractWrapper.address;\n  }\n\n  /** ******************************\n   * WRITE FUNCTIONS\n   *******************************/\n\n  /**\n   * Perform airdrop of ERC20 tokens\n   *\n   * @example\n   * ```javascript\n   * // Airdrop content array, with recipients and token amounts\n   * const contents = [\n   *      {\n   *        recipient: \"0xabc...\", // first recipient address\n   *        amount: \"10\" // number of tokens in wei units\n   *      },\n   *      {\n   *        recipient: \"0x123...\", // second recipient address\n   *        amount: \"20\" // number of tokens in wei units\n   *      }\n   *   ]\n   *\n   * const tokenAddress = \"0x...\" // Address of the ERC20 token being airdropped\n   * const tokenOwner = \"0x...\" // Address of the owner of the tokens being airdropped\n   *\n   * const output = await contract.airdrop20.drop(tokenAddress, tokenOwner, contents);\n   *\n   * // the `output` return value above contains:\n   * //     - count of successful and failed drops\n   * //     - array containing failed drops, if any\n   *\n   * ```\n   * @param tokenAddress\n   * @param tokenOwner\n   * @param contents\n   *\n   * @returns an array of recipients for who the airdrop failed (empty means all transfers were successful)\n   * @twfeature AirdropERC20\n   */\n  drop = /* @__PURE__ */buildTransactionFunction(async (tokenAddress, tokenOwner, contents) => {\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"airdropERC20\",\n      args: [tokenAddress, tokenOwner, contents],\n      parse: receipt => {\n        const events = this.contractWrapper.parseLogs(\"AirdropFailed\", receipt.logs);\n        const failedDrops = events.map(e => {\n          return {\n            recipient: e.args.recipient,\n            amount: e.args.amount.toString()\n          };\n        });\n        return {\n          successfulDropCount: contents.length - failedDrops.length,\n          failedDropCount: failedDrops.length,\n          failedDrops\n        };\n      }\n    });\n  });\n}\n\n/**\n * @public\n */\nclass Airdrop721 {\n  featureName = FEATURE_AIRDROP_ERC721.name;\n  constructor(contractWrapper) {\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * @internal\n   */\n  getAddress() {\n    return this.contractWrapper.address;\n  }\n\n  /** ******************************\n   * WRITE FUNCTIONS\n   *******************************/\n\n  /**\n   * Perform airdrop of ERC721 tokens\n   *\n   * @example\n   * ```javascript\n   * // Airdrop content array, with recipients and tokenIds\n   * const contents = [\n   *      {\n   *        recipient: \"0xabc...\", // first recipient address\n   *        tokenId: 0\n   *      },\n   *      {\n   *        recipient: \"0x123...\", // second recipient address\n   *        tokenId: 2\n   *      }\n   *   ]\n   *\n   * const tokenAddress = \"0x...\" // Address of the ERC721 token being airdropped\n   * const tokenOwner = \"0x...\" // Address of the owner of the tokens being airdropped\n   *\n   * const output = await contract.airdrop721.drop(tokenAddress, tokenOwner, contents);\n   *\n   * // the `output` return value above contains:\n   * //     - count of successful and failed drops\n   * //     - array containing failed drops, if any\n   *\n   * ```\n   * @param tokenAddress\n   * @param tokenOwner\n   * @param contents\n   *\n   * @returns an array of recipients for who the airdrop failed (empty means all transfers were successful)\n   * @twfeature AirdropERC721\n   */\n  drop = /* @__PURE__ */buildTransactionFunction(async (tokenAddress, tokenOwner, contents) => {\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"airdropERC721\",\n      args: [tokenAddress, tokenOwner, contents],\n      parse: receipt => {\n        const events = this.contractWrapper.parseLogs(\"AirdropFailed\", receipt.logs);\n        const failedDrops = events.map(e => {\n          return {\n            recipient: e.args.recipient,\n            tokenId: e.args.tokenId.toNumber()\n          };\n        });\n        return {\n          successfulDropCount: contents.length - failedDrops.length,\n          failedDropCount: failedDrops.length,\n          failedDrops\n        };\n      }\n    });\n  });\n}\nclass ExtensionManager {\n  featureName = FEATURE_DYNAMIC_CONTRACT.name;\n  constructor(contractWrapper) {\n    this.contractWrapper = contractWrapper;\n  }\n  getAddress() {\n    return this.contractWrapper.readContract.address;\n  }\n\n  /** ******************************\n   * READ FUNCTIONS\n   *******************************/\n\n  async getAll() {\n    const extensions = await this.contractWrapper.readContract.getAllExtensions();\n    return extensions;\n  }\n  async get(extensionName) {\n    const extension = await this.contractWrapper.readContract.getExtension(extensionName);\n    return extension;\n  }\n  async getExtensionAddress(extensionName) {\n    const extension = await this.get(extensionName);\n    return extension.metadata.implementation;\n  }\n  async getAllFunctions(extensionName) {\n    const extension = await this.get(extensionName);\n    return extension.functions;\n  }\n  async getExtensionForFunction(functionInput) {\n    let selector = functionInput.functionSelector;\n    if (!selector) {\n      invariant(functionInput.functionSignature, \"Atleast one of function selector and signature must be provided\");\n      selector = utils.id(functionInput.functionSignature).substring(0, 10);\n    }\n    const extensionMetadata = await this.contractWrapper.readContract.getMetadataForFunction(selector);\n    return extensionMetadata;\n  }\n  async getExtensionAddressForFunction(functionInput) {\n    const extensionMetadata = await this.getExtensionForFunction(functionInput);\n    return extensionMetadata.implementation;\n  }\n\n  /** ******************************\n   * WRITE FUNCTIONS\n   *******************************/\n\n  /**\n   * Adds an extension to the contract\n   */\n  add = /* @__PURE__ */buildTransactionFunction(async inputArgs => {\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"addExtension\",\n      args: [inputArgs.extension],\n      parse: async receipt => {\n        const events = this.contractWrapper.parseLogs(\"ExtensionAdded\", receipt.logs);\n        if (events.length < 1) {\n          throw new Error(\"No ExtensionAdded event found\");\n        }\n        const extensionAbi = inputArgs.extensionAbi ? AbiSchema.parse(inputArgs.extensionAbi) : (await fetchContractMetadataFromAddress(inputArgs.extension.metadata.implementation, this.contractWrapper.getProvider(), this.contractWrapper.storage)).abi;\n        const abiToAdd = this.filterAbiForAdd(extensionAbi, inputArgs.extension);\n        const updatedAbi = joinABIs([AbiSchema.parse(this.contractWrapper.abi), abiToAdd]);\n        this.contractWrapper.updateAbi(updatedAbi);\n        return receipt;\n      }\n    });\n  });\n\n  /**\n   * Adds a deployed extension to the contract\n   */\n  addDeployed = /* @__PURE__ */buildTransactionFunction(async inputArgs => {\n    let extensionAbi = inputArgs.extensionAbi;\n    if (!extensionAbi) {\n      const metadata = await fetchContractMetadataFromAddress(inputArgs.extensionAddress, this.contractWrapper.getProvider(), this.contractWrapper.storage, this.contractWrapper.options);\n      extensionAbi = metadata.abi;\n    }\n    invariant(extensionAbi, \"Require extension ABI\");\n    let extensionMetadataUri = \"\";\n    if (inputArgs.extensionMetadata) {\n      if (typeof inputArgs.extensionMetadata === \"string\") {\n        extensionMetadataUri = inputArgs.extensionMetadata;\n      } else {\n        const parsedMetadata = await CommonContractSchema.parseAsync(inputArgs.extensionMetadata);\n        extensionMetadataUri = await this.contractWrapper.storage.upload(parsedMetadata);\n      }\n    }\n    const extensionFunctions = generateExtensionFunctions(AbiSchema.parse(extensionAbi));\n    const extension = {\n      metadata: {\n        name: inputArgs.extensionName,\n        metadataURI: extensionMetadataUri,\n        implementation: inputArgs.extensionAddress\n      },\n      functions: extensionFunctions\n    };\n    return this.add.prepare({\n      extension,\n      extensionAbi\n    });\n  });\n\n  /**\n   * Adds a published extension to the contract, and deploys it deterministically if necessary\n   */\n  addPublished = /* @__PURE__ */buildTransactionFunction(async inputArgs => {\n    const version = inputArgs.version || \"latest\";\n    const {\n      deployedExtensionAddress,\n      extensionMetadata\n    } = await this.deployExtension(inputArgs.extensionName, inputArgs.publisherAddress || THIRDWEB_DEPLOYER, version);\n    return this.addDeployed.prepare({\n      extensionName: inputArgs.extensionName,\n      extensionAddress: deployedExtensionAddress,\n      extensionMetadata: inputArgs.extensionMetadataOverride || extensionMetadata\n    });\n  });\n  replace = /* @__PURE__ */buildTransactionFunction(async inputArgs => {\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"replaceExtension\",\n      args: [inputArgs.extension],\n      parse: async receipt => {\n        const events = this.contractWrapper.parseLogs(\"ExtensionReplaced\", receipt.logs);\n        if (events.length < 1) {\n          throw new Error(\"No ExtensionReplaced event found\");\n        }\n        const extensionAbi = inputArgs.extensionAbi ? AbiSchema.parse(inputArgs.extensionAbi) : (await fetchContractMetadataFromAddress(inputArgs.extension.metadata.implementation, this.contractWrapper.getProvider(), this.contractWrapper.storage)).abi;\n        const contractAbi = this.filterAbiForRemove(AbiSchema.parse(this.contractWrapper.abi), extensionAbi);\n        const abiToAdd = this.filterAbiForAdd(extensionAbi, inputArgs.extension);\n        const updatedAbi = joinABIs([contractAbi, abiToAdd]);\n        this.contractWrapper.updateAbi(updatedAbi);\n        return receipt;\n      }\n    });\n  });\n  replaceDeployed = /* @__PURE__ */buildTransactionFunction(async inputArgs => {\n    let extensionAbi = inputArgs.extensionAbi;\n    if (!extensionAbi) {\n      const metadata = await fetchContractMetadataFromAddress(inputArgs.extensionAddress, this.contractWrapper.getProvider(), this.contractWrapper.storage, this.contractWrapper.options);\n      extensionAbi = metadata.abi;\n    }\n    invariant(extensionAbi, \"Require extension ABI\");\n    let extensionMetadataUri = \"\";\n    if (inputArgs.extensionMetadata) {\n      if (typeof inputArgs.extensionMetadata === \"string\") {\n        extensionMetadataUri = inputArgs.extensionMetadata;\n      } else {\n        const parsedMetadata = await CommonContractSchema.parseAsync(inputArgs.extensionMetadata);\n        extensionMetadataUri = await this.contractWrapper.storage.upload(parsedMetadata);\n      }\n    }\n    const extensionFunctions = generateExtensionFunctions(AbiSchema.parse(extensionAbi));\n    const extension = {\n      metadata: {\n        name: inputArgs.extensionName,\n        metadataURI: extensionMetadataUri,\n        implementation: inputArgs.extensionAddress\n      },\n      functions: extensionFunctions\n    };\n    return this.replace.prepare({\n      extension,\n      extensionAbi\n    });\n  });\n  replacePublished = /* @__PURE__ */buildTransactionFunction(async inputArgs => {\n    const version = inputArgs.version || \"latest\";\n    const {\n      deployedExtensionAddress,\n      extensionMetadata\n    } = await this.deployExtension(inputArgs.extensionName, inputArgs.publisherAddress || THIRDWEB_DEPLOYER, version);\n    return this.replaceDeployed.prepare({\n      extensionName: inputArgs.extensionName,\n      extensionAddress: deployedExtensionAddress,\n      extensionMetadata: inputArgs.extensionMetadataOverride || extensionMetadata\n    });\n  });\n  remove = /* @__PURE__ */buildTransactionFunction(async inputArgs => {\n    const extensionAddress = await this.getExtensionAddress(inputArgs.extensionName);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"removeExtension\",\n      args: [inputArgs.extensionName],\n      parse: async receipt => {\n        const events = this.contractWrapper.parseLogs(\"ExtensionRemoved\", receipt.logs);\n        if (events.length < 1) {\n          throw new Error(\"No ExtensionRemoved event found\");\n        }\n        const extensionAbi = (await fetchContractMetadataFromAddress(extensionAddress, this.contractWrapper.getProvider(), this.contractWrapper.storage)).abi;\n        const updatedAbi = this.filterAbiForRemove(AbiSchema.parse(this.contractWrapper.abi), extensionAbi);\n        this.contractWrapper.updateAbi(updatedAbi);\n        return receipt;\n      }\n    });\n  });\n\n  /** ******************************\n   * Internal / private\n   *******************************/\n\n  filterAbiForAdd(extensionAbi, extension) {\n    const extensionAbiInterface = new utils.Interface(extensionAbi);\n    const extensionFunctionSelectors = extension.functions.map(fn => fn.functionSelector);\n    const filtered = extensionAbi.filter(item => {\n      const fnFragment = Object.values(new utils.Interface([item]).functions);\n      if (fnFragment.length === 0) {\n        return false;\n      }\n      const fnSigHash = extensionAbiInterface.getSighash(fnFragment[0]);\n      return extensionFunctionSelectors.includes(fnSigHash);\n    });\n    return filtered;\n  }\n  filterAbiForRemove(fullAbi, abiToRemove) {\n    const fullAbiInterface = new utils.Interface(fullAbi);\n    const interfaceToRemove = new utils.Interface(abiToRemove);\n    const functionsToRemove = Object.values(interfaceToRemove.functions).map(fn => interfaceToRemove.getSighash(fn));\n    const filtered = fullAbi.filter(item => {\n      const fnFragment = Object.values(new utils.Interface([item]).functions);\n      if (fnFragment.length === 0) {\n        return false;\n      }\n      const fnSigHash = fullAbiInterface.getSighash(fnFragment[0]);\n      return !functionsToRemove.includes(fnSigHash);\n    });\n    return filtered;\n  }\n  async deployExtension(extensionName, publisherAddress) {\n    let version = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"latest\";\n    const published = await fetchPublishedContractFromPolygon(publisherAddress, extensionName, version, this.contractWrapper.storage, this.contractWrapper.options.clientId, this.contractWrapper.options.secretKey);\n    const deploymentInfo = await getDeploymentInfo(published.metadataUri, this.contractWrapper.storage, this.contractWrapper.getProvider(), \"\", this.contractWrapper.options.clientId, this.contractWrapper.options.secretKey);\n    const implementationAddress = deploymentInfo.find(i => i.type === \"implementation\")?.transaction.predictedAddress;\n\n    // deploy infra + plugins + implementation using a throwaway Deployer contract\n\n    // filter out already deployed contracts (data is empty)\n    const transactionsToSend = deploymentInfo.filter(i => i.transaction.data && i.transaction.data.length > 0);\n    const transactionsforDirectDeploy = transactionsToSend.filter(i => {\n      return i.type !== \"infra\";\n    }).map(i => i.transaction);\n    const transactionsForThrowawayDeployer = transactionsToSend.filter(i => {\n      return i.type === \"infra\";\n    }).map(i => i.transaction);\n    const signer = this.contractWrapper.getSigner();\n    invariant(signer, \"Signer is required\");\n\n    // deploy via throwaway deployer, multiple infra contracts in one transaction\n    await deployWithThrowawayDeployer(signer, transactionsForThrowawayDeployer, {});\n\n    // send each transaction directly to Create2 factory\n    // process txns one at a time\n    for (const tx of transactionsforDirectDeploy) {\n      try {\n        await deployContractDeterministic(signer, tx);\n      } catch (e) {\n        console.debug(`Error deploying contract at ${tx.predictedAddress}`, e?.message);\n      }\n    }\n    return {\n      deployedExtensionAddress: implementationAddress,\n      extensionMetadata: published.metadataUri\n    };\n  }\n}\n\n/**\n * Custom contract dynamic class with feature detection\n *\n * @example\n *\n * ```javascript\n * import { ThirdwebSDK } from \"@thirdweb-dev/sdk\";\n *\n * const sdk = new ThirdwebSDK(provider);\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n *\n * // call any function in your contract\n * await contract.call(\"myCustomFunction\", [param1, param2]);\n *\n * // if your contract follows the ERC721 standard, contract.nft will be present\n * const allNFTs = await contract.erc721.query.all()\n *\n * // if your contract extends IMintableERC721, contract.nft.mint() will be available\n * const tx = await contract.erc721.mint({\n *     name: \"Cool NFT\",\n *     image: readFileSync(\"some_image.png\"),\n *   });\n * ```\n *\n * @beta\n */\nclass SmartContract {\n  // utilities\n\n  get abi() {\n    return AbiSchema.parse(this.contractWrapper.abi || []);\n  }\n\n  /**\n   * Handle royalties\n   */\n  get royalties() {\n    return assertEnabled(this.detectRoyalties(), FEATURE_ROYALTY);\n  }\n\n  /**\n   * Handle permissions\n   */\n  get roles() {\n    return assertEnabled(this.detectRoles(), FEATURE_PERMISSIONS);\n  }\n\n  /**\n   * Handle primary sales\n   */\n  get sales() {\n    return assertEnabled(this.detectPrimarySales(), FEATURE_PRIMARY_SALE);\n  }\n\n  /**\n   * Handle platform fees\n   */\n  get platformFees() {\n    return assertEnabled(this.detectPlatformFees(), FEATURE_PLATFORM_FEE);\n  }\n\n  /**\n   * Set and get the owner of the contract\n   */\n  get owner() {\n    return assertEnabled(this.detectOwnable(), FEATURE_OWNER);\n  }\n\n  /**\n   * Auto-detects ERC20 standard functions.\n   */\n  get erc20() {\n    return assertEnabled(this.detectErc20(), FEATURE_TOKEN);\n  }\n\n  /**\n   * Auto-detects ERC721 standard functions.\n   */\n  get erc721() {\n    return assertEnabled(this.detectErc721(), FEATURE_NFT);\n  }\n\n  /**\n   * Auto-detects ERC1155 standard functions.\n   */\n  get erc1155() {\n    return assertEnabled(this.detectErc1155(), FEATURE_EDITION);\n  }\n\n  /**\n   * Auto-detects AppURI standard functions.\n   */\n  get app() {\n    return assertEnabled(this.detectApp(), FEATURE_APPURI);\n  }\n\n  /**\n   * Direct listings\n   * @remarks Create and manage direct listings in your marketplace.\n   * ```javascript\n   * // Data of the listing you want to create\n   * const listing = {\n   *   // address of the contract the asset you want to list is on\n   *   assetContractAddress: \"0x...\",\n   *   // token ID of the asset you want to list\n   *   tokenId: \"0\",\n   *   // how many of the asset you want to list\n   *   quantity: 1,\n   *   // address of the currency contract that will be used to pay for the listing\n   *   currencyContractAddress: NATIVE_TOKEN_ADDRESS,\n   *   // The price to pay per unit of NFTs listed.\n   *   pricePerToken: 1.5,\n   *   // when should the listing open up for offers\n   *   startTimestamp: new Date(Date.now()),\n   *   // how long the listing will be open for\n   *   endTimestamp: new Date(Date.now() + 5 * 24 * 60 * 60 * 1000),\n   *   // Whether the listing is reserved for a specific set of buyers.\n   *   isReservedListing: false\n   * }\n   *\n   * const tx = await contract.directListings.createListing(listing);\n   * const receipt = tx.receipt; // the transaction receipt\n   * const id = tx.id; // the id of the newly created listing\n   *\n   * // And on the buyers side:\n   * // The ID of the listing you want to buy from\n   * const listingId = 0;\n   * // Quantity of the asset you want to buy\n   * const quantityDesired = 1;\n   *\n   * await contract.directListings.buyFromListing(listingId, quantityDesired);\n   * ```\n   */\n  get directListings() {\n    return assertEnabled(this.detectDirectListings(), FEATURE_DIRECT_LISTINGS);\n  }\n  /**\n   * Auctions\n   * @remarks Create and manage auctions in your marketplace.\n   * @example\n   * ```javascript\n   * // Data of the auction you want to create\n   * const auction = {\n   *   // address of the contract of the asset you want to auction\n   *   assetContractAddress: \"0x...\",\n   *   // token ID of the asset you want to auction\n   *   tokenId: \"0\",\n   *   // how many of the asset you want to auction\n   *   quantity: 1,\n   *   // address of the currency contract that will be used to pay for the auctioned tokens\n   *   currencyContractAddress: NATIVE_TOKEN_ADDRESS,\n   *   // the minimum bid that will be accepted for the token\n   *   minimumBidAmount: \"1.5\",\n   *   // how much people would have to bid to instantly buy the asset\n   *   buyoutBidAmount: \"10\",\n   *   // If a bid is made less than these many seconds before expiration, the expiration time is increased by this.\n   *   timeBufferInSeconds: \"1000\",\n   *   // A bid must be at least this much bps greater than the current winning bid\n   *   bidBufferBps: \"100\", // 100 bps stands for 1%\n   *   // when should the auction open up for bidding\n   *   startTimestamp: new Date(Date.now()),\n   *   // end time of auction\n   *   endTimestamp: new Date(Date.now() + 5 * 24 * 60 * 60 * 1000),\n   * }\n   *\n   * const tx = await contract.englishAuctions.createAuction(auction);\n   * const receipt = tx.receipt; // the transaction receipt\n   * const id = tx.id; // the id of the newly created auction\n   *\n   * // And on the buyers side:\n   * // The auction ID of the asset you want to bid on\n   * const auctionId = 0;\n   * // The total amount you are willing to bid for auctioned tokens\n   * const bidAmount = 1;\n   *\n   * await contract.englishAuctions.makeBid(auctionId, bidAmount);\n   * ```\n   */\n  get englishAuctions() {\n    return assertEnabled(this.detectEnglishAuctions(), FEATURE_ENGLISH_AUCTIONS);\n  }\n\n  /**\n   * Offers\n   * @remarks Make and manage offers.\n   * @example\n   * ```javascript\n   * // Data of the offer you want to make\n   * const offer = {\n   *   // address of the contract the asset you want to make an offer for\n   *   assetContractAddress: \"0x...\",\n   *   // token ID of the asset you want to buy\n   *   tokenId: \"0\",\n   *   // how many of the asset you want to buy\n   *   quantity: 1,\n   *   // address of the currency contract that you offer to pay in\n   *   currencyContractAddress: NATIVE_TOKEN_ADDRESS,\n   *   // Total price you offer to pay for the mentioned token(s)\n   *   totalPrice: \"1.5\",\n   *   // Offer valid until\n   *   endTimestamp: new Date(),\n   * }\n   *\n   * const tx = await contract.offers.makeOffer(offer);\n   * const receipt = tx.receipt; // the transaction receipt\n   * const id = tx.id; // the id of the newly created offer\n   *\n   * // And on the seller's side:\n   * // The ID of the offer you want to accept\n   * const offerId = 0;\n   * await contract.offers.acceptOffer(offerId);\n   * ```\n   */\n  get offers() {\n    return assertEnabled(this.detectOffers(), FEATURE_OFFERS);\n  }\n  get airdrop20() {\n    return assertEnabled(this.detectAirdrop20(), FEATURE_AIRDROP_ERC20);\n  }\n  get airdrop721() {\n    return assertEnabled(this.detectAirdrop721(), FEATURE_AIRDROP_ERC721);\n  }\n  get airdrop1155() {\n    return assertEnabled(this.detectAirdrop1155(), FEATURE_AIRDROP_ERC1155);\n  }\n\n  /**\n   * Account Factory\n   *\n   * @remarks Create accounts and fetch data about them.\n   * @example\n   * ```javascript\n   *\n   * // Predict the address of the account that will be created for an admin.\n   * const deterministicAddress = await contract.accountFactory.predictAccountAddress(admin, extraData);\n   *\n   * // Create accounts\n   * const tx = await contract.accountFactory.createAccount(admin, extraData);\n   * // the same as `deterministicAddress`\n   * const accountAddress = tx.address;\n   *\n   * // Get all accounts created by the factory\n   * const allAccounts = await contract.accountFactory.getAllAccounts();\n   *\n   * // Get all accounts on which a signer has been given authority.\n   * const associatedAccounts = await contract.accountFactory.getAssociatedAccounts(signer);\n   *\n   * // Get all signers who have been given authority on a account.\n   * const associatedSigners = await contract.accountFactory.getAssociatedSigners(accountAddress);\n   *\n   * // Check whether a account has already been created for a given admin.\n   * const isAccountDeployed = await contract.accountFactory.isAccountDeployed(admin, extraData);\n   * ```\n   */\n  get accountFactory() {\n    return assertEnabled(this.detectAccountFactory(), FEATURE_ACCOUNT_FACTORY);\n  }\n\n  // TODO documentation\n  get account() {\n    return assertEnabled(this.detectAccount(), FEATURE_ACCOUNT);\n  }\n  get extensions() {\n    return assertEnabled(this.detectBaseRouter(), FEATURE_DYNAMIC_CONTRACT);\n  }\n  get chainId() {\n    return this._chainId;\n  }\n  constructor(network, address, abi, storage) {\n    let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    let chainId = arguments.length > 5 ? arguments[5] : undefined;\n    let contractWrapper = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : new ContractWrapper(network, address, abi, options, storage);\n    this._chainId = chainId;\n    this.storage = storage;\n    this.contractWrapper = contractWrapper;\n    this.events = new ContractEvents(this.contractWrapper);\n    this.encoder = new ContractEncoder(this.contractWrapper);\n    this.interceptor = new ContractInterceptor(this.contractWrapper);\n    this.estimator = new GasCostEstimator(this.contractWrapper);\n    this.publishedMetadata = new ContractPublishedMetadata(this.contractWrapper, this.storage);\n    this.metadata = new ContractMetadata(this.contractWrapper, CustomContractSchema, this.storage);\n  }\n  onNetworkUpdated(network) {\n    this.contractWrapper.updateSignerOrProvider(network);\n  }\n  getAddress() {\n    return this.contractWrapper.address;\n  }\n\n  /**\n   * Prepare a transaction for sending\n   */\n  prepare(method, args, overrides) {\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method,\n      args,\n      overrides\n    });\n  }\n\n  /**\n   * Call any function on this contract\n   * @example\n   * ```javascript\n   * // read functions will return the data from the contract\n   * const myValue = await contract.call(\"myReadFunction\");\n   * console.log(myValue);\n   *\n   * // write functions will return the transaction receipt\n   * const tx = await contract.call(\"myWriteFunction\", [arg1, arg2]);\n   * const receipt = tx.receipt;\n   *\n   * // Optionally override transaction options\n   * await contract.call(\"myWriteFunction\", [arg1, arg2], {\n   *  gasLimit: 1000000, // override default gas limit\n   *  value: ethers.utils.parseEther(\"0.1\"), // send 0.1 ether with the contract call\n   * };\n   * ```\n   * @param functionName - the name of the function to call\n   * @param args - the arguments of the function\n   */\n  async call(functionName, args, overrides) {\n    return this.contractWrapper.call(functionName, args, overrides);\n  }\n\n  /** ********************\n   * FEATURE DETECTION\n   * ********************/\n\n  detectRoyalties() {\n    if (detectContractFeature(this.contractWrapper, \"Royalty\")) {\n      // ContractMetadata is stateless, it's fine to create a new one here\n      // This also makes it not order dependent in the feature detection process\n      const metadata = new ContractMetadata(this.contractWrapper, CustomContractSchema, this.storage);\n      return new ContractRoyalty(this.contractWrapper, metadata);\n    }\n    return undefined;\n  }\n  detectRoles() {\n    if (detectContractFeature(this.contractWrapper, \"Permissions\")) {\n      return new ContractRoles(this.contractWrapper, ALL_ROLES);\n    }\n    return undefined;\n  }\n  detectPrimarySales() {\n    if (detectContractFeature(this.contractWrapper, \"PrimarySale\")) {\n      return new ContractPrimarySale(this.contractWrapper);\n    }\n    return undefined;\n  }\n  detectPlatformFees() {\n    if (detectContractFeature(this.contractWrapper, \"PlatformFee\")) {\n      return new ContractPlatformFee(this.contractWrapper);\n    }\n    return undefined;\n  }\n  detectErc20() {\n    if (detectContractFeature(this.contractWrapper, \"ERC20\")) {\n      return new Erc20(this.contractWrapper, this.storage, this.chainId);\n    }\n    return undefined;\n  }\n  detectErc721() {\n    if (detectContractFeature(this.contractWrapper, \"ERC721\")) {\n      return new Erc721(this.contractWrapper, this.storage, this.chainId);\n    }\n    return undefined;\n  }\n  detectErc1155() {\n    if (detectContractFeature(this.contractWrapper, \"ERC1155\")) {\n      return new Erc1155(this.contractWrapper, this.storage, this.chainId);\n    }\n    return undefined;\n  }\n  detectOwnable() {\n    if (detectContractFeature(this.contractWrapper, \"Ownable\")) {\n      return new ContractOwner(this.contractWrapper);\n    }\n    return undefined;\n  }\n  detectApp() {\n    const metadata = new ContractMetadata(this.contractWrapper, CustomContractSchema, this.storage);\n    if (detectContractFeature(this.contractWrapper, \"AppURI\")) {\n      return new ContractAppURI(this.contractWrapper, metadata, this.storage);\n    } else if (detectContractFeature(this.contractWrapper, \"ContractMetadata\")) {\n      return new ContractAppURI(this.contractWrapper, metadata, this.storage);\n    }\n    return undefined;\n  }\n  detectDirectListings() {\n    if (detectContractFeature(this.contractWrapper, \"DirectListings\")) {\n      return new MarketplaceV3DirectListings(this.contractWrapper, this.storage);\n    }\n    return undefined;\n  }\n  detectEnglishAuctions() {\n    if (detectContractFeature(this.contractWrapper, \"EnglishAuctions\")) {\n      return new MarketplaceV3EnglishAuctions(this.contractWrapper, this.storage);\n    }\n    return undefined;\n  }\n  detectOffers() {\n    if (detectContractFeature(this.contractWrapper, \"Offers\")) {\n      return new MarketplaceV3Offers(this.contractWrapper, this.storage);\n    }\n    return undefined;\n  }\n  detectBaseRouter() {\n    if (detectContractFeature(this.contractWrapper, FEATURE_DYNAMIC_CONTRACT.name)) {\n      return new ExtensionManager(this.contractWrapper);\n    }\n    return undefined;\n  }\n  detectAirdrop20() {\n    if (detectContractFeature(this.contractWrapper, \"AirdropERC20\")) {\n      return new Airdrop20(this.contractWrapper);\n    }\n    return undefined;\n  }\n  detectAirdrop721() {\n    if (detectContractFeature(this.contractWrapper, \"AirdropERC721\")) {\n      return new Airdrop721(this.contractWrapper);\n    }\n    return undefined;\n  }\n  detectAirdrop1155() {\n    if (detectContractFeature(this.contractWrapper, \"AirdropERC1155\")) {\n      return new Airdrop1155(this.contractWrapper);\n    }\n    return undefined;\n  }\n\n  // ========== Account features ==========\n\n  detectAccountFactory() {\n    if (detectContractFeature(this.contractWrapper, FEATURE_ACCOUNT_FACTORY.name)) {\n      return new AccountFactory(this.contractWrapper);\n    }\n    return undefined;\n  }\n  detectAccount() {\n    if (detectContractFeature(this.contractWrapper, FEATURE_ACCOUNT.name)) {\n      return new Account(this.contractWrapper);\n    }\n    return undefined;\n  }\n}\n\n/**\n * Handles publishing contracts (EXPERIMENTAL)\n * @internal\n */\nclass ContractPublisher extends RPCConnectionHandler {\n  constructor(network, options, storage) {\n    super(network, options);\n    this.storage = storage;\n    this.publisher = new ContractWrapper(network, getContractPublisherAddress(), ContractPublisherAbi, options, storage);\n  }\n  updateSignerOrProvider(network) {\n    super.updateSignerOrProvider(network);\n    this.publisher.updateSignerOrProvider(network);\n  }\n\n  /**\n   * @internal\n   * @param metadataUri\n   */\n  async extractConstructorParams(metadataUri) {\n    return extractConstructorParams(metadataUri, this.storage);\n  }\n\n  /**\n   * @internal\n   * @param predeployMetadataUri\n   */\n  async extractFunctions(predeployMetadataUri) {\n    return extractFunctions(predeployMetadataUri, this.storage);\n  }\n\n  /**\n   * @internal\n   * @param predeployUri\n   */\n  async fetchCompilerMetadataFromPredeployURI(predeployUri) {\n    return fetchPreDeployMetadata(predeployUri, this.storage);\n  }\n\n  /**\n   * @internal\n   * @param prepublishUri\n   * @param publisherAddress\n   */\n  async fetchPrePublishMetadata(prepublishUri, publisherAddress) {\n    const preDeployMetadataFetched = await fetchPreDeployMetadata(prepublishUri, this.storage);\n    const latestPublishedContract = publisherAddress ? await this.getLatest(publisherAddress, preDeployMetadataFetched.name) : undefined;\n    const latestPublishedContractMetadata = latestPublishedContract ? await this.fetchPublishedContractInfo(latestPublishedContract) : undefined;\n    return {\n      preDeployMetadata: preDeployMetadataFetched,\n      latestPublishedContractMetadata\n    };\n  }\n\n  /**\n   * @internal\n   * @param address\n   */\n  async fetchCompilerMetadataFromAddress(address) {\n    const resolvedAddress = await resolveAddress(address);\n    return fetchContractMetadataFromAddress(resolvedAddress, this.getProvider(), this.storage, this.options);\n  }\n\n  /**\n   * @internal\n   * Get the full information about a published contract\n   * @param contract\n   */\n  async fetchPublishedContractInfo(contract) {\n    return {\n      name: contract.id,\n      publishedTimestamp: contract.timestamp,\n      publishedMetadata: await this.fetchFullPublishMetadata(contract.metadataUri)\n    };\n  }\n\n  /**\n   * @internal\n   * @param publishedMetadataUri\n   */\n  async fetchFullPublishMetadata(publishedMetadataUri) {\n    return fetchExtendedReleaseMetadata(publishedMetadataUri, this.storage);\n  }\n\n  /**\n   * @internal\n   * // TODO expose a resolvePublishMetadata(contractAddress, chainId) that handles the dual chain case\n   * // TODO will be easy to do with the multichain pattern of 3.0\n   * @param compilerMetadataUri\n   */\n  async resolvePublishMetadataFromCompilerMetadata(compilerMetadataUri) {\n    const publishedMetadataUri = await this.publisher.read(\"getPublishedUriFromCompilerUri\", [compilerMetadataUri]);\n    if (publishedMetadataUri.length === 0) {\n      throw Error(`Could not resolve published metadata URI from ${compilerMetadataUri}`);\n    }\n    return await Promise.all(publishedMetadataUri.filter(uri => uri.length > 0).map(uri => this.fetchFullPublishMetadata(uri)));\n  }\n\n  /**\n   * @internal\n   * TODO clean this up (see method above, too)\n   */\n  async resolveContractUriFromAddress(address) {\n    const resolvedAddress = await resolveAddress(address);\n    const contractUri = await resolveContractUriFromAddress(resolvedAddress, this.getProvider());\n    invariant(contractUri, \"Could not resolve contract URI from address\");\n    return contractUri;\n  }\n\n  /**\n   * @internal\n   * @param address\n   */\n  async fetchContractSourcesFromAddress(address) {\n    const resolvedAddress = await resolveAddress(address);\n    const metadata = await this.fetchCompilerMetadataFromAddress(resolvedAddress);\n    return await fetchSourceFilesFromMetadata(metadata, this.storage);\n  }\n\n  /**\n   * @internal\n   * @param profileMetadata\n   */\n  updatePublisherProfile = /* @__PURE__ */buildTransactionFunction(async profileMetadata => {\n    const signer = this.getSigner();\n    invariant(signer, \"A signer is required\");\n    const publisher = await signer.getAddress();\n    const profileUri = await this.storage.upload(profileMetadata);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.publisher,\n      method: \"setPublisherProfileUri\",\n      args: [publisher, profileUri]\n    });\n  });\n\n  /**\n   * @internal\n   * @param publisherAddress\n   */\n  async getPublisherProfile(publisherAddress) {\n    const resolvedPublisherAddress = await resolveAddress(publisherAddress);\n    const profileUri = await this.publisher.read(\"getPublisherProfileUri\", [resolvedPublisherAddress]);\n    if (!profileUri || profileUri.length === 0) {\n      return {};\n    }\n    return ProfileSchemaOutput.parse(await this.storage.downloadJSON(profileUri));\n  }\n\n  /**\n   * @internal\n   * @param publisherAddress\n   */\n  async getAll(publisherAddress) {\n    const resolvedPublisherAddress = await resolveAddress(publisherAddress);\n    const data = await this.publisher.read(\"getAllPublishedContracts\", [resolvedPublisherAddress]);\n    // since we can fetch from multiple publisher contracts, just keep the latest one in the list\n    const map = data.reduce((acc, curr) => {\n      // replaces the previous contract with the latest one\n      acc[curr.contractId] = curr;\n      return acc;\n    }, {});\n    return Object.entries(map).map(_ref => {\n      let [, struct] = _ref;\n      return this.toPublishedContract(struct);\n    });\n  }\n\n  /**\n   * @internal\n   * @param publisherAddress\n   * @param contractId\n   */\n  async getAllVersions(publisherAddress, contractId) {\n    const resolvedPublisherAddress = await resolveAddress(publisherAddress);\n    const contractStructs = await this.publisher.read(\"getPublishedContractVersions\", [resolvedPublisherAddress, contractId]);\n    if (contractStructs.length === 0) {\n      throw Error(\"Not found\");\n    }\n    return contractStructs.map(d => this.toPublishedContract(d));\n  }\n  async getVersion(publisherAddress, contractId) {\n    let version = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"latest\";\n    const resolvedPublisherAddress = await resolveAddress(publisherAddress);\n    if (version === \"latest\") {\n      return this.getLatest(resolvedPublisherAddress, contractId);\n    }\n    const allVersions = await this.getAllVersions(resolvedPublisherAddress, contractId);\n    // get the metadata for each version\n    const versionMetadata = await Promise.all(allVersions.map(contract => this.fetchPublishedContractInfo(contract)));\n    // find the version that matches the version string\n    const versionMatch = versionMetadata.find(metadata => metadata.publishedMetadata.version === version);\n    invariant(versionMatch, \"Contract version not found\");\n    // match the version back to the contract based on the published timestamp\n    return allVersions.find(contract => contract.timestamp === versionMatch.publishedTimestamp);\n  }\n  async getLatest(publisherAddress, contractId) {\n    const resolvedPublisherAddress = await resolveAddress(publisherAddress);\n    const model = await this.publisher.read(\"getPublishedContract\", [resolvedPublisherAddress, contractId]);\n    if (model && model.publishMetadataUri) {\n      return this.toPublishedContract(model);\n    }\n    return undefined;\n  }\n  publish = /* @__PURE__ */buildTransactionFunction(async (predeployUri, extraMetadata) => {\n    const signer = this.getSigner();\n    invariant(signer, \"A signer is required\");\n    const publisher = await signer.getAddress();\n    const predeployMetadata = await fetchRawPredeployMetadata(predeployUri, this.storage);\n    const compilerMetadata = await fetchContractMetadata(predeployMetadata.metadataUri, this.storage);\n    const isPlugin = isFeatureEnabled(AbiSchema.parse(compilerMetadata.abi), \"PluginRouter\");\n    const isDynamic = isFeatureEnabled(AbiSchema.parse(compilerMetadata.abi), \"DynamicContract\");\n    extraMetadata.routerType = isPlugin ? \"plugin\" : isDynamic ? \"dynamic\" : \"none\";\n\n    // For a dynamic contract Router, try to fetch plugin/extension metadata\n    if (isDynamic || isPlugin) {\n      const defaultExtensions = extraMetadata.defaultExtensions;\n      if (defaultExtensions && defaultExtensions.length > 0) {\n        try {\n          const publishedExtensions = await Promise.all(defaultExtensions.map(e => {\n            return fetchPublishedContractFromPolygon(e.publisherAddress, e.extensionName, e.extensionVersion, this.storage, this.options.clientId, this.options.secretKey);\n          }));\n          const publishedExtensionUris = publishedExtensions.map(ext => ext.metadataUri);\n          const extensionABIs = (await Promise.all(publishedExtensionUris.map(async uri => {\n            return fetchAndCacheDeployMetadata(uri, this.storage);\n          }))).map(fetchedMetadata => fetchedMetadata.compilerMetadata.abi);\n          const composite = joinABIs([compilerMetadata.abi, ...extensionABIs]);\n          extraMetadata.compositeAbi = AbiSchema.parse(composite);\n        } catch {}\n      }\n    }\n\n    // ensure version is incremental\n    const latestContract = await this.getLatest(publisher, predeployMetadata.name);\n    if (latestContract && latestContract.metadataUri) {\n      const latestMetadata = await this.fetchPublishedContractInfo(latestContract);\n      const latestVersion = latestMetadata.publishedMetadata.version;\n      if (!isIncrementalVersion(latestVersion, extraMetadata.version)) {\n        throw Error(`Version ${extraMetadata.version} is not greater than ${latestVersion}`);\n      }\n    }\n    const fetchedBytecode = await (await this.storage.download(predeployMetadata.bytecodeUri)).text();\n    const bytecode = fetchedBytecode.startsWith(\"0x\") ? fetchedBytecode : `0x${fetchedBytecode}`;\n    const bytecodeHash = utils.solidityKeccak256([\"bytes\"], [bytecode]);\n    const contractId = predeployMetadata.name;\n    const fullMetadata = await FullPublishMetadataSchemaInput.parseAsync({\n      ...extraMetadata,\n      metadataUri: predeployMetadata.metadataUri,\n      bytecodeUri: predeployMetadata.bytecodeUri,\n      name: predeployMetadata.name,\n      analytics: predeployMetadata.analytics,\n      publisher\n    });\n    const fullMetadataUri = await this.storage.upload(fullMetadata);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.publisher,\n      method: \"publishContract\",\n      args: [publisher, contractId, fullMetadataUri, predeployMetadata.metadataUri, bytecodeHash, constants.AddressZero],\n      parse: receipt => {\n        const events = this.publisher.parseLogs(\"ContractPublished\", receipt.logs);\n        if (events.length < 1) {\n          throw new Error(\"No ContractPublished event found\");\n        }\n        const contract = events[0].args.publishedContract;\n        return {\n          receipt,\n          data: async () => this.toPublishedContract(contract)\n        };\n      }\n    });\n  });\n  unpublish = /* @__PURE__ */buildTransactionFunction(async (publisher, contractId) => {\n    const resolvedPublisher = await resolveAddress(publisher);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.publisher,\n      method: \"unpublishContract\",\n      args: [resolvedPublisher, contractId]\n    });\n  });\n  toPublishedContract(contractModel) {\n    return PublishedContractSchema.parse({\n      id: contractModel.contractId,\n      timestamp: contractModel.publishTimestamp,\n      metadataUri: contractModel.publishMetadataUri\n    });\n  }\n}\nexport { MintRequest721withQuantity as $, AbiTypeSchema as A, BYOCContractMetadataSchema as B, CustomContractInput as C, DeployTypeInput as D, ExtraPublishMetadataSchemaInput as E, FactoryDeploymentSchema as F, CommonPlatformFeeSchema as G, CommonTrustedForwarderSchema as H, CommonSymbolSchema as I, CurrencySchema as J, CurrencyValueSchema as K, BaseSignaturePayloadInput as L, Signature20PayloadInput as M, Signature20PayloadOutput as N, Signature721PayloadInput as O, PreDeployMetadata as P, Signature721PayloadOutput as Q, RouterTypeInput as R, StaticJsonRpcBatchProvider as S, Signature1155PayloadInput as T, Signature1155PayloadInputWithTokenId as U, Signature1155PayloadOutput as V, Signature721WithQuantityInput as W, Signature721WithQuantityOutput as X, MintRequest20 as Y, MintRequest721 as Z, MintRequest1155 as _, CustomContractOutput as a, prepareGaslessRequest as a$, GenericRequest as a0, MerkleSchema as a1, SnapshotEntryInput as a2, SnapshotInputSchema as a3, SnapshotEntryWithProofSchema as a4, SnapshotSchema as a5, SnapshotInfoSchema as a6, BigNumberSchema as a7, BigNumberishSchema as a8, BigNumberTransformSchema as a9, Erc721Supply as aA, Erc721Enumerable as aB, Erc721TieredDrop as aC, Erc721 as aD, Erc721WithQuantitySignatureMintable as aE, Erc721Burnable as aF, Erc1155BatchMintable as aG, Erc1155Burnable as aH, Erc1155Enumerable as aI, Erc1155LazyMintable as aJ, Erc1155Mintable as aK, Erc1155 as aL, Erc1155SignatureMintable as aM, MarketplaceV3DirectListings as aN, MarketplaceV3EnglishAuctions as aO, MarketplaceV3Offers as aP, GasCostEstimator as aQ, ContractEvents as aR, ContractInterceptor as aS, ContractPlatformFee as aT, ContractPublishedMetadata as aU, ContractOwner as aV, Transaction as aW, DeployTransaction as aX, defaultGaslessSendFunction as aY, biconomySendFunction as aZ, defenderSendFunction as a_, AddressSchema as aa, AddressOrEnsSchema as ab, RawDateSchema as ac, StartDateSchema as ad, EndDateSchema as ae, CallOverrideSchema as af, ContractEncoder as ag, ContractMetadata as ah, ContractRoles as ai, ContractRoyalty as aj, ContractPrimarySale as ak, DelayedReveal as al, DropClaimConditions as am, DropErc1155ClaimConditions as an, Erc20BatchMintable as ao, Erc20Burnable as ap, Erc20ClaimableWithConditions as aq, Erc20Droppable as ar, Erc20Mintable as as, Erc20SignatureMintable as at, Erc20 as au, Erc721BatchMintable as av, Erc721ClaimableWithConditions as aw, Erc721Claimable as ax, Erc721LazyMintable as ay, Erc721Mintable as az, CustomContractDeploy as b, resolveImplementation as b$, ContractAppURI as b0, Account as b1, AccountFactory as b2, SignerPermissionsSchema as b3, PermissionSnapshotSchema as b4, SignerPermissionRequest as b5, Status as b6, ClaimEligibility as b7, isNativeToken as b8, cleanCurrencyAddress as b9, AdminRoleMissingError as bA, AuctionHasNotEndedError as bB, ExtensionNotImplementedError as bC, TransactionError as bD, parseRevertReason as bE, includesErrorMessage as bF, createSnapshot as bG, ALL_ROLES as bH, getRoleHash as bI, fetchContractMetadataFromAddress as bJ, fetchAbiFromAddress as bK, getDefaultGasOverrides as bL, getDynamicFeeData as bM, getGasPrice as bN, getPolygonGasPriorityFee as bO, fetchContractMetadata as bP, hasMatchingAbi as bQ, matchesAbiFromBytecode as bR, extractConstructorParams as bS, extractFunctions as bT, extractCommentFromMetadata as bU, extractConstructorParamsFromAbi as bV, extractFunctionsFromAbi as bW, extractEventsFromAbi as bX, extractMinimalProxyImplementationAddress as bY, resolveContractUriFromAddress as bZ, resolveContractUriAndBytecode as b_, normalizePriceValue as ba, fetchCurrencyMetadata as bb, fetchCurrencyValue as bc, setErc20Allowance as bd, approveErc20Allowance as be, normalizeAmount as bf, toWei as bg, convertToReadableQuantity as bh, fetchSnapshotEntryForAddress as bi, NotFoundError as bj, InvalidAddressError as bk, MissingRoleError as bl, AssetNotFoundError as bm, UploadError as bn, FileNameMissingError as bo, DuplicateFileNameError as bp, NotEnoughTokensError as bq, MissingOwnerRoleError as br, QuantityAboveLimitError as bs, FetchError as bt, DuplicateLeafsError as bu, AuctionAlreadyStartedError as bv, FunctionDeprecatedError as bw, ListingNotFoundError as bx, WrongListingTypeError as by, RestrictedTransferError as bz, CustomContractSchema as c, getChainProvider as c$, extractIPFSHashFromBytecode as c0, fetchRawPredeployMetadata as c1, fetchPreDeployMetadata as c2, fetchExtendedReleaseMetadata as c3, detectFeatures as c4, detectFeaturesFromBytecode as c5, getAllDetectedFeatures as c6, getAllDetectedExtensionsFromBytecode as c7, constructAbiFromBytecode as c8, getAllDetectedExtensions as c9, getDeploymentInfo as cA, deployWithThrowawayDeployer as cB, computeDeploymentInfo as cC, encodeConstructorParamsForImplementation as cD, getCreate2FactoryDeploymentInfo as cE, THIRDWEB_DEPLOYER as cF, fetchPublishedContractFromPolygon as cG, fetchAndCacheDeployMetadata as cH, estimateGasForDeploy as cI, createTransactionBatches as cJ, resolveEns as cK, resolveAddress as cL, OZ_DEFENDER_FORWARDER_ADDRESS as cM, CONTRACT_ADDRESSES as cN, getContractAddressByChainId as cO, getContractPublisherAddress as cP, getMultichainRegistryAddress as cQ, ChainId as cR, setSupportedChains as cS, getSupportedChains as cT, InterfaceId_IERC721 as cU, InterfaceId_IERC1155 as cV, NATIVE_TOKEN_ADDRESS as cW, NATIVE_TOKENS as cX, getNativeTokenByChainId as cY, LINK_TOKEN_ADDRESS as cZ, EventType as c_, isFeatureEnabled as ca, isExtensionEnabled as cb, assertEnabled as cc, detectContractFeature as cd, hasFunction as ce, joinABIs as cf, toSemver as cg, isIncrementalVersion as ch, isDowngradeVersion as ci, fetchSourceFilesFromMetadata as cj, CREATE2_FACTORY_BYTECODE as ck, SIGNATURE as cl, COMMON_FACTORY as cm, GAS_LIMIT_FOR_DEPLOYER as cn, DEPLOYER_BYTECODE as co, DEPLOYER_ABI as cp, isContractDeployed as cq, isEIP155Enforced as cr, getCreate2FactoryAddress as cs, getSaltHash as ct, getInitBytecodeWithSalt as cu, computeDeploymentAddress as cv, computeEOAForwarderAddress as cw, computeForwarderAddress as cx, getKeylessTxn as cy, deployContractDeterministic as cz, AbiObjectSchema as d, SplitsContractSchema as d$, getChainIdFromNetwork as d0, getChainIdOrName as d1, isChainConfig as d2, getProviderFromRpcUrl as d3, getSignerAndProvider as d4, SUPPORTED_FEATURES as d5, EditionDropInitializer as d6, EditionInitializer as d7, MarketplaceInitializer as d8, MarketplaceV3Initializer as d9, getCompositePluginABI as dA, buildDeployTransactionFunction as dB, getProcessEnv as dC, DropErc721ContractSchema as dD, mapOffer as dE, fetchTokenMetadataForContract as dF, isTokenApprovedForTransfer as dG, validateNewListingParam as dH, handleTokenApproval as dI, isWinningBid as dJ, NFT_BASE_CONTRACT_ROLES as dK, DropErc1155ContractSchema as dL, TokenErc1155ContractSchema as dM, MARKETPLACE_CONTRACT_ROLES as dN, MarketplaceContractSchema as dO, FEATURE_DIRECT_LISTINGS as dP, FEATURE_ENGLISH_AUCTIONS as dQ, FEATURE_OFFERS as dR, MULTIWRAP_CONTRACT_ROLES as dS, MultiwrapContractSchema as dT, uploadOrExtractURI as dU, TokenErc721ContractSchema as dV, FEATURE_NFT_REVEALABLE as dW, FEATURE_PACK_VRF as dX, PACK_CONTRACT_ROLES as dY, PackContractSchema as dZ, ADMIN_ROLE as d_, MultiwrapInitializer as da, NFTCollectionInitializer as db, NFTDropInitializer as dc, PackInitializer as dd, SignatureDropInitializer as de, SplitInitializer as df, TokenDropInitializer as dg, TokenInitializer as dh, VoteInitializer as di, PREBUILT_CONTRACTS_MAP as dj, PREBUILT_CONTRACTS_APPURI_MAP as dk, CONTRACTS_MAP as dl, getContractTypeForRemoteName as dm, getContractName as dn, isProvider as dp, isSigner as dq, AddressZero as dr, extractFeatures as ds, CUSTOM_GAS_FOR_CHAIN as dt, RPCConnectionHandler as du, signTypedDataInternal as dv, ContractWrapper as dw, buildTransactionFunction as dx, ContractPublisher as dy, SmartContract as dz, AbiSchema as e, TOKEN_DROP_CONTRACT_ROLES as e0, DropErc20ContractSchema as e1, TokenErc20ContractSchema as e2, VoteContractSchema as e3, ChainIdToAddressSchema as f, CustomFactoryInput as g, DeploymentNetworkInput as h, ExtraPublishMetadataSchemaOutput as i, FullPublishMetadataSchemaInput as j, FullPublishMetadataSchemaOutput as k, ProfileSchemaInput as l, ProfileSchemaOutput as m, PublishedContractSchema as n, ContractInfoSchema as o, CompilerMetadataFetchedSchema as p, PreDeployMetadataFetchedSchema as q, ClaimConditionMetadataSchema as r, ClaimConditionInputSchema as s, ClaimConditionInputArray as t, PartialClaimConditionInputSchema as u, ClaimConditionOutputSchema as v, CommonContractSchema as w, CommonContractOutputSchema as x, CommonRoyaltySchema as y, CommonPrimarySaleSchema as z };","map":{"version":3,"names":["Q","QuantitySchema","A","AmountSchema","B","BytesLikeSchema","N","NFTInputOrUriSchema","a","BasisPointsSchema","F","FileOrBufferOrStringSchema","P","PercentSchema","C","CommonNFTOutput","b","CommonNFTInput","D","DEFAULT_QUERY_ALL_COUNT","c","BasicNFTInput","M","MAX_BPS","z","BigNumber","providers","utils","constants","Contract","ContractFactory","invariant","v4","isBrowser","isBrowser$1","isFileOrBuffer","replaceGatewayUrlWithScheme","ERC165Abi","IERC721MetadataAbi","Erc1155MetadataAbi","ERC20Abi","IERC20MetadataAbi","deepEqual","MerkleTree","IThirdwebContractABI","DeprecatedAbi","Erc1155Abi","Erc721Abi","ContractPublisherAbi","defaultChains","getValidChainRPCs","Polygon","Mumbai","bs58","TWRegistryABI","IBurnableERC20Abi","IDrop","DropERC20_V2Abi","IDropSinglePhase","IDropSinglePhaseV1","IERC20PermitAbi","IMintableERC20Abi","MulticallAbi","ISignatureMintERC20Abi","IBurnableERC721Abi","IClaimableERC721","DelayedRevealAbi","DropERC721_V3Abi","Erc721EnumerableAbi","Erc721AQueryableAbi","Erc721SupplyAbi","ILazyMintAbi","IMintableERC721Abi","SignatureMintERC721Abi","SignatureMintERC721_V1Abi","TieredDropAbi","SharedMetadataAbi","zora_IDropERC721","ILoyaltyCardAbi","INFTMetadataAbi","IBurnableERC1155Abi","IClaimableERC1155","IDropMultiPhase1155","DropERC1155_V2Abi","IDropSinglePhase1155","IDropSinglePhase1155_V1","Erc1155SupplyAbi","Erc1155EnumerableAbi","IMintableERC1155Abi","ISignatureMintERC1155Abi","IERC2771ContextAbi","IAppURI","IContractMetadataAbi","IDirectListingsAbi","IEnglishAuctionsAbi","IOffersAbi","IPackVRFAbi","IPermissionsAbi","IPermissionsEnumerableAbi","IThirdwebPlatformFeeAbi","IThirdwebPrimarySaleAbi","IThirdwebRoyaltyAbi","IOwnableAbi","IAirdropERC20","IAirdropERC721","IAirdropERC1155","IAccountFactoryCore","IAccountPermissions","IAccount","Interface","ForwarderABI","fetch","EventEmitter","MAX_LENGTH","NUMERIC_IDENTIFIER","MAIN_VERSION_IDENTIFIER","REGEX_MAIN_VERSION","RegExp","toSemver","version","length","Error","matches","trim","match","major","Number","minor","patch","versionString","join","isIncrementalVersion","current","next","currentSemver","nextSemver","eqMajor","eqMinor","isDowngradeVersion","BigNumberSchema","union","string","number","bigint","custom","data","isBigNumber","transform","arg","from","BigNumberishSchema","toString","BigNumberTransformSchema","isSigner","value","_isSigner","isProvider","_isProvider","DEFAULT_BATCH_TIME_LIMIT_MS","DEFAULT_BATCH_SIZE_LIMIT","DEFAULT_BATCH_OPTIONS","timeLimitMs","sizeLimit","StaticJsonRpcBatchProvider","StaticJsonRpcProvider","constructor","url","network","batchOptions","arguments","undefined","_timeLimitMs","_sizeLimit","_pendingBatchAggregator","_pendingBatch","sendCurrentBatch","request","clearTimeout","batch","request_","map","inflight","emit","action","deepCopy","provider","fetchJson","connection","JSON","stringify","then","result","response","forEach","inflightRequest_","index","payload","error","message","code","reject","resolve","send","method","params","id","_nextId","jsonrpc","inflightRequest","promise","Promise","push","setTimeout","ChainInfoInputSchema","object","rpc","array","chainId","nativeCurrency","name","symbol","decimals","slug","SDKOptionsSchema","supportedChains","default","clientId","optional","secretKey","readonlySettings","rpcUrl","gasSettings","maxPriceInGwei","min","speed","enum","gasless","openzeppelin","relayerUrl","relayerForwarderAddress","useEOAForwarder","boolean","domainName","domainVersion","experimentalChainlessSupport","biconomy","apiId","apiKey","deadlineSeconds","gatewayUrls","pkg","description","repository","license","main","module","browser","exports","files","preconstruct","entrypoints","envConditions","sideEffects","scripts","format","lint","fix","clean","build","devDependencies","chai","eslint","ethers","hardhat","mocha","nyc","prettier","typescript","peerDependencies","peerDependenciesMeta","dependencies","abitype","buffer","eventemitter3","merkletreejs","tweetnacl","uuid","yaml","zod","bugs","author","buildDefaultMap","options","reduce","previousValue","currentValue","getChainProvider","sdkOptions","isRpcUrl","getProviderFromRpcUrl","parse","isChainConfig","filter","rpcMap","getChainIdFromNetwork","e","chainNameToId","acc","curr","getChainIdOrName","getNetwork","n","toLowerCase","RPC_PROVIDER_MAP","Map","headers","authStrategy","isTwUrl","pto","crypto","require","hashedSecretKey","createHash","update","digest","derivedClientId","slice","utilizedRpcUrl","URL","pathname","globalThis","TW_AUTH_TOKEN","TW_CLI_AUTH_TOKEN","bundleId","APP_BUNDLE_ID","includes","window","bridge","seralizedOpts","existingProvider","get","newProvider","JsonRpcBatchProvider","set","WebSocketProvider","getDefaultProvider","hostname","endsWith","getSignerAndProvider","signer","ENS_CACHE","resolveEns","ens","depth","ensPromise","has","resolveName","address","expirationTime","Date","now","resolvedPromise","delete","EnsSchema","refine","isAddress","AddressSchema","out","AddressOrEnsSchema","invalid_type_error","ChainId","setSupportedChains","chains","getSupportedChains","NATIVE_TOKEN_ADDRESS","NATIVE_TOKENS","Mainnet","wrapped","Goerli","Avalanche","AvalancheFujiTestnet","Fantom","FantomTestnet","Arbitrum","ArbitrumGoerli","Optimism","OptimismGoerli","BinanceSmartChainMainnet","BinanceSmartChainTestnet","Hardhat","Localhost","getNativeTokenByChainId","chain","find","AddressZero","LINK_TOKEN_ADDRESS","RawDateSchema","date","i","Math","floor","getTime","StartDateSchema","EndDateSchema","CurrencySchema","CurrencyValueSchema","extend","displayValue","MerkleSchema","merkle","record","SnapshotEntryInput","maxClaimable","price","currencyAddress","SnapshotInputSchema","strings","all","parseAsync","SnapshotEntryWithProofSchema","proof","SnapshotSchema","merkleRoot","claims","SnapshotInfoSchema","snapshotUri","ClaimConditionMetadataSchema","catchall","unknown","ClaimConditionInputSchema","startTime","maxClaimableSupply","maxClaimablePerWallet","waitInSeconds","merkleRootHash","hexZeroPad","snapshot","nullable","metadata","ClaimConditionInputArray","PartialClaimConditionInputSchema","partial","ClaimConditionOutputSchema","availableSupply","currentMintSupply","currencyMetadata","toNumber","resolveOrGenerateId","requestUId","Buffer","alloc","hexlify","toUtf8Bytes","BaseSignaturePayloadInput","to","mintStartTime","mintEndTime","uid","primarySaleRecipient","Signature20PayloadInput","quantity","Signature20PayloadOutput","Signature721PayloadInput","royaltyRecipient","royaltyBps","Signature721PayloadOutput","uri","Signature1155PayloadInput","Signature1155PayloadInputWithTokenId","tokenId","Signature1155PayloadOutput","Signature721WithQuantityInput","Signature721WithQuantityOutput","MintRequest20","type","MintRequest721","MintRequest1155","MintRequest721withQuantity","GenericRequest","CommonContractSchema","image","external_link","app_uri","social_urls","CommonContractOutputSchema","CommonRoyaltySchema","seller_fee_basis_points","fee_recipient","CommonPrimarySaleSchema","primary_sale_recipient","CommonPlatformFeeSchema","platform_fee_basis_points","platform_fee_recipient","CommonTrustedForwarderSchema","trusted_forwarders","CommonSymbolSchema","BYOCContractMetadataSchema","CustomContractInput","merge","any","CustomContractOutput","CustomContractDeploy","CustomContractSchema","deploy","output","input","AbiTypeBaseSchema","AbiTypeSchema","stateMutability","components","AbiObjectSchema","inputs","outputs","AbiSchema","PreDeployMetadata","metadataUri","bytecodeUri","analytics","ChainIdToAddressSchema","CustomFactoryInput","factoryFunction","customFactoryAddresses","FactoryDeploymentSchema","implementationAddresses","implementationInitializerFunction","customFactoryInput","factoryAddresses","DeployTypeInput","literal","RouterTypeInput","DeploymentNetworkInput","allNetworks","networksEnabled","ExtraPublishMetadataSchemaInput","v","displayName","readme","changelog","tags","audit","logo","isDeployableViaFactory","isDeployableViaProxy","factoryDeploymentData","deployType","routerType","defaultExtensions","extensionName","extensionVersion","publisherAddress","networksForDeployment","constructorParams","defaultValue","hidden","compositeAbi","ExtraPublishMetadataSchemaOutput","FullPublishMetadataSchemaInput","publisher","FullPublishMetadataSchemaOutput","ProfileSchemaInput","bio","avatar","website","twitter","telegram","facebook","github","medium","linkedin","reddit","discord","ProfileSchemaOutput","PublishedContractSchema","timestamp","ContractInfoSchema","title","details","notice","CompilerMetadataFetchedSchema","abi","info","licenses","isPartialAbi","PreDeployMetadataFetchedSchema","bytecode","CallOverrideSchema","gasLimit","gasPrice","maxFeePerGas","maxPriorityFeePerGas","nonce","blockTag","strict","ContractEncoder","contractWrapper","encode","fn","args","readContract","interface","encodeFunctionData","decode","encodedArgs","decodeFunctionData","NotFoundError","identifier","InvalidAddressError","MissingRoleError","role","AssetNotFoundError","UploadError","FileNameMissingError","DuplicateFileNameError","fileName","NotEnoughTokensError","contractAddress","available","MissingOwnerRoleError","QuantityAboveLimitError","FetchError","innerError","DuplicateLeafsError","AuctionAlreadyStartedError","FunctionDeprecatedError","ListingNotFoundError","marketplaceContractAddress","listingId","WrongListingTypeError","actualType","expectedType","RestrictedTransferError","assetAddress","AdminRoleMissingError","AuctionHasNotEndedError","endTime","ExtensionNotImplementedError","feature","TransactionError","reason","raw","errorMessage","withSpaces","contractName","e2","hash","gt","formatEther","sources","revertFile","file","source","lines","split","line","revertLine","findIndex","errorLines","filename","replace","parseRevertReason","errorString","parseMessageParts","label","content","spaces","Array","fill","regex","msgMatches","extracted","includesErrorMessage","err","FEATURE_TOKEN_CLAIM_CONDITIONS_V1","namespace","docLinks","sdk","contracts","abis","features","FEATURE_TOKEN_CLAIM_CONDITIONS_V2","FEATURE_TOKEN_CLAIM_PHASES_V2","FEATURE_TOKEN_CLAIM_PHASES_V1","FEATURE_TOKEN_BURNABLE","FEATURE_TOKEN_SIGNATURE_MINTABLE","FEATURE_TOKEN_BATCH_MINTABLE","FEATURE_TOKEN_MINTABLE","FEATURE_TOKEN_PERMIT","FEATURE_TOKEN","FEATURE_NFT_BURNABLE","FEATURE_NFT_REVEALABLE","FEATURE_NFT_TIERED_DROP","FEATURE_NFT_CLAIM_CONDITIONS_V1","FEATURE_NFT_CLAIM_CONDITIONS_V2","FEATURE_NFT_CLAIM_PHASES_V1","FEATURE_NFT_CLAIM_PHASES_V2","FEATURE_NFT_CLAIM_CUSTOM","FEATURE_NFT_CLAIM_ZORA","FEATURE_NFT_LAZY_MINTABLE","FEATURE_NFT_BATCH_MINTABLE","FEATURE_NFT_MINTABLE","FEATURE_NFT_SIGNATURE_MINTABLE_V2","FEATURE_NFT_SIGNATURE_MINTABLE_V1","FEATURE_NFT_ENUMERABLE","FEATURE_NFT_QUERYABLE","FEATURE_NFT_SUPPLY","FEATURE_NFT_SHARED_METADATA","FEATURE_NFT_LOYALTY_CARD","FEATURE_NFT_UPDATABLE_METADATA","FEATURE_NFT","NAME_SYMBOL_ABI","internalType","FEATURE_EDITION_BURNABLE","FEATURE_EDITION_CLAIM_CONDITIONS_V1","FEATURE_EDITION_CLAIM_CONDITIONS_V2","FEATURE_EDITION_CLAIM_PHASES_V2","FEATURE_EDITION_CLAIM_PHASES_V1","FEATURE_EDITION_CLAIM_CUSTOM","FEATURE_EDITION_REVEALABLE","FEATURE_EDITION_LAZY_MINTABLE_V2","FEATURE_EDITION_LAZY_MINTABLE_V1","FEATURE_EDITION_SIGNATURE_MINTABLE","FEATURE_EDITION_BATCH_MINTABLE","FEATURE_EDITION_MINTABLE","FEATURE_EDITION_ENUMERABLE","FEATURE_EDITION_UPDATABLE_METADATA","FEATURE_EDITION_SUPPLY","FEATURE_EDITION","getAllPluginsAbi","getAllExtensionsAbi","FEATURE_ROYALTY","FEATURE_PRIMARY_SALE","FEATURE_PLATFORM_FEE","FEATURE_PERMISSIONS_ENUMERABLE","FEATURE_PERMISSIONS","FEATURE_METADATA","FEATURE_APPURI","FEATURE_OWNER","FEATURE_GASLESS","FEATURE_PACK_VRF","FEATURE_PLUGIN_ROUTER","FEATURE_DYNAMIC_CONTRACT","FEATURE_DIRECT_LISTINGS","FEATURE_ENGLISH_AUCTIONS","FEATURE_OFFERS","FEATURE_ACCOUNT_FACTORY","FEATURE_ACCOUNT_PERMISSIONS","FEATURE_ACCOUNT","FEATURE_AIRDROP_ERC20","FEATURE_AIRDROP_ERC721","FEATURE_AIRDROP_ERC1155","SUPPORTED_FEATURES","toJSType","contractType","isReturnType","withName","jsType","isArray","startsWith","extractCommentFromMetadata","userdoc","Object","keys","devdoc","extractFunctionsFromAbi","functions","el","parsed","f","doc","fargs","o","signature","comment","hasMatchingAbi","contractAbi","featureAbis","contractFn","interfaceFn","flatMap","intersection","iFn","every","cIndex","matchesAbiFromBytecode","contractBytecode","interfaces","selectors","values","getSighash","uniqueSelectors","Set","selector","detectFeatures","results","featureKey","enabled","matchesAbiInterface","childResults","detectFeaturesFromBytecode","isFeatureEnabled","featureName","_featureEnabled","isExtensionEnabled","found","key","detectContractFeature","hasFunction","functionName","decoder","TextDecoder","src","srcEnd","position","LEGACY_RECORD_INLINE_ID","RECORD_DEFINITIONS_ID","RECORD_INLINE_ID","BUNDLED_STRINGS_ID","PACKED_REFERENCE_TAG_ID","STOP_CODE","currentDecoder","currentStructures","srcString","srcStringStart","srcStringEnd","bundledStrings","referenceMap","currentExtensions","currentExtensionRanges","packedValues","dataView","restoreMapsAsObject","defaultOptions","useRecords","mapsAsObjects","sequentialMode","Decoder","keyMap","_keyMap","getStructures","getShared","structures","uninitialized","mapKey","k","entries","assign","decodeKey","end","saveState","clearSource","prototype","call","DataView","byteOffset","byteLength","Uint8Array","sharedValues","pack","maxPrivatePackedValues","concat","checkedRead","read","postBundlePosition","incomplete","RangeError","token","majorType","getFloat16","getUint16","getFloat32","useFloat32","multiplier","mult10","getUint32","getFloat64","int64AsNumber","getBigUint64","safeKey","readBin","shortStringInJS","longStringInJS","readFixedString","structure","createStructureReader","recordDefinition","readJustLength","readBundleExt","loadShared","extension","handlesRead","Tag","packedValue","getPackedValues","isNaN","validName","readObject","compiledReader","propertyCount","slowReads","Function","test","readStringJS","subarray","units","byte1","byte2","byte3","byte4","unit","fromCharCode","apply","String","start","bytes","byte","d","g","h","j","l","m","copyBuffers","f32Array","Float32Array","u8Array","byte0","exponent","NaN","Infinity","abs","tag","dateString","epochSec","round","BigInt","fraction","exp","log","definition","existingStructure","isShared","restoreStructures","position0","position1","glbl","packedTable","_read","newPackedValues","prefixes","suffixes","stringRefs","target","refEntry","targetProperties","used","combine","SHARED_DATA_TAG_ID","isLittleEndianMachine","Uint16Array","typedArrays","typedArrayTags","registerTypedArray","TypedArray","dvMethod","bytesPerElement","BYTES_PER_ELEMENT","littleEndian","sizeShift","dv","elements","ta","bundlePosition","bundleLength","dataPosition","sharedData","updatedStructures","sharedVersion","splice","callback","savedSrcEnd","savedPosition","savedSrcStringStart","savedSrcStringEnd","savedSrcString","savedReferenceMap","savedBundledStrings","savedSrc","savedStructures","savedDecoder","savedSequentialMode","defaultDecoder","hexToBytes","hex","isHexStrict","parseInt","extractIPFSHashFromBytecode","numericBytecode","cborLength","bytecodeBuffer","cborData","console","warn","extractMinimalProxyImplementationAddress","implementationAddress","resolveContractUriFromAddress","resolveImplementation","resolveContractUriAndBytecode","getCode","proxyStorage","getStorageAt","CONTRACT_METADATA_TIMEOUT_SEC","fetchContractMetadata","compilerMetadataUri","storage","downloadJSON","timeoutInSeconds","compilationTarget","settings","targets","detail","_ref","getProcessEnv","process","env","MultichainRegistry_address","getMultichainRegistryAddress","isNode","unique","joinABIs","parsedABIs","flat","filteredABIs","finalABIs","item","extractFeatures","enabledExtensions","extensionKey","getAllDetectedFeatures","getAllDetectedExtensionsFromBytecode","constructAbiFromBytecode","extensions","getAllDetectedExtensions","metadataCache","multichainRegistry","getCacheKey","putInCache","getFromCache","fetchContractMetadataFromAddress","cached","ipfsData","registryData","catch","getMetadataUriFromMultichainRegistry","polygonChain","importedUri","getMetadataUri","fetchAbiFromAddress","buildDeployTransactionFunction","executeFn","tx","execute","prepare","buildTransactionFunction","getDefaultGasOverrides","originalProvider","feeData","getDynamicFeeData","getGasPrice","block","eth_maxPriorityFeePerGas","getBlock","baseBlockFee","baseFeePerGas","parseUnits","getPolygonGasPriorityFee","getFeeData","mul","add","getPreferredPriorityFee","defaultPriorityFeePerGas","percentMultiplier","extraTip","div","txGasPrice","maxGasPrice","getGasStationUrl","MIN_POLYGON_GAS_PRICE","MIN_MUMBAI_GAS_PRICE","getDefaultGasFee","gasStationUrl","json","priorityFee","fixedFee","parseFloat","toFixed","fetchSourceFilesFromMetadata","publishedMetadata","path","urls","ipfsLink","ipfsHash","timeout","_r","rej","race","download","text","isRouterContract","isPluginRouter","isBaseRouter","ERROR_SUBSTRINGS","ERROR_SUBSTRINGS_COMPOSITE","CUSTOM_GAS_FOR_CHAIN","matchError","errorIndex","substring","compositeErrorIndex","arr","foundError","CREATE2_FACTORY_BYTECODE","SIGNATURE","r","s","COMMON_FACTORY","GAS_LIMIT_FOR_DEPLOYER","DEPLOYER_BYTECODE","DEPLOYER_ABI","isContractDeployed","isEIP155Enforced","sendTransaction","errorMsg","errorJson","getKeylessTxn","transaction","arrayify","keccak256","serializeTransaction","recoverAddress","signedSerializedTx","getCreate2FactoryDeploymentInfo","joinSignature","deploymentTransaction","create2FactoryAddress","getContractAddress","deployment","getCreate2FactoryAddress","commonFactoryExists","enforceEip155","networkId","deploymentInfo","ContractPublisher_address","getContractPublisherAddress","DropErc721ContractInput","DropErc721ContractOutput","DropErc721ContractDeploy","DropErc721ContractSchema","DropErc1155ContractInput","DropErc1155ContractOutput","DropErc1155ContractDeploy","DropErc1155ContractSchema","MarketplaceContractInput","MarketplaceContractOutput","MarketplaceContractDeploy","MarketplaceContractSchema","PackContractInput","PackContractOutput","PackContractDeploy","PackContractSchema","SplitRecipientInputSchema","sharesBps","SplitRecipientOuputSchema","SplitsContractInput","recipients","superRefine","val","context","addressMap","totalShares","entry","addIssue","ZodIssueCode","SplitsContractOutput","SplitsContractDeploy","SplitsContractSchema","TokenErc20ContractInput","TokenErc20ContractOutput","TokenErc20ContractDeploy","TokenErc20ContractSchema","TokenErc721ContractInput","TokenErc721ContractOutput","TokenErc721ContractDeploy","TokenErc721ContractSchema","TokenErc1155ContractInput","TokenErc1155ContractOutput","TokenErc1155ContractDeploy","TokenErc1155ContractSchema","VoteSettingsInputSchema","voting_delay_in_blocks","voting_period_in_blocks","voting_token_address","voting_quorum_fraction","proposal_token_threshold","VoteSettingsOuputSchema","VoteContractInput","VoteContractOutput","VoteContractDeploy","VoteContractSchema","resolveAddress","addressOrEns","fetchExtendedReleaseMetadata","publishMetadataUri","meta","fetchRawPredeployMetadata","fetchPreDeployMetadata","rawMeta","deployBytecode","parsedMeta","deployMetadataCache","fetchAndCacheDeployMetadata","compilerMetadata","extendedMetadata","TWRegistry_address","TWFactory_address","OZ_DEFENDER_FORWARDER_ADDRESS","CONTRACT_ADDRESSES","openzeppelinForwarder","openzeppelinForwarderEOA","biconomyForwarder","twFactory","twRegistry","twBYOCRegistry","getContractAddressByChainId","InterfaceId_IERC721","InterfaceId_IERC1155","EventType","THIRDWEB_DEPLOYER","fetchPublishedContractFromPolygon","contract","publishedContract","model","getPublishedContract","contractId","publishTimestamp","allVersions","getPublishedContractVersions","versionMetadata","publishedTimestamp","versionMatch","getSaltHash","bytecodePrefixed","bytecodeHash","salt","saltHash","getInitBytecodeWithSalt","initBytecodeWithSalt","solidityPack","computeDeploymentAddress","initBytecode","deployInfoPacked","solidityKeccak256","hashedDeployInfo","extractConstructorParamsFromAbi","parsedAbi","caches","deploymentPresets","getRoyaltyEngineV1ByChainId","ROYALTY_ENGINE_V1_ADDRESS","computeDeploymentInfo","create2Factory","contractOptions","contractDeployed","predictedAddress","encodeConstructorParamsForImplementation","constructorParamMap","constructorParamTypes","p","ParamType","constructorParamValues","nativeTokenWrapperAddress","defaultAbiCoder","computeEOAForwarderAddress","computeForwarderAddress","ForwardRequest","ChainAwareForwardRequest","BiconomyForwarderAbi","_nonces","_noncesSyncTimestamp","getAndIncrementNonce","forwarder","forwarderFunction","forwarderArgs","shouldSync","nonceResult","signTypedDataInternal","signerInput","domain","types","originalSigner","_TypedDataEncoder","getPayload","signerAddress","getAddress","isWalletConnect","_signTypedData","finalErr","splitSignature","NAME_ABI","DOMAIN_SEPARATOR_ABI","constant","payable","NONCES_ABI","getSignerNonce","nonces","getNonce","getDomainSeperator","DOMAIN_SEPARATOR","err2","getTokenName","getChainDomainSeperator","contractDomainSeparator","verifyingContract","polygonDomain","toHexString","hashDomain","signEIP2612Permit","owner","spender","deadline","getChainId","MaxUint256","Permit","TransactionContext","overrides","connect","getSigner","getProvider","getStorage","getArgs","getOverrides","getValue","setArgs","setOverrides","updateOverrides","setValue","setGasLimit","setGasPrice","setNonce","setMaxFeePerGas","setMaxPriorityFeePerGas","setType","setAccessList","accessList","setCustomData","customData","setCcipReadEnabled","ccipReadEnabled","setGasLimitMultiple","factor","gasMultiple","estimateGasCost","estimateGasLimit","gasCost","ether","wei","getSignerAddress","getGasOverrides","Transaction","fromContractWrapper","optionsWithContract","writeContract","fromContractInfo","gaslessOptions","getTarget","getMethod","getGaslessOptions","setGaslessOptions","setParse","sign","populatedTx","populateTransaction","signedTx","signTransaction","gasOverrides","simulate","callStatic","functionError","transactionError","estimateGas","gasEstimate","sendGasless","receipt","wait","prepareGasless","txHash","defaultGaslessSendFunction","sentTx","iteration","getTransaction","gas","lt","functionArgs","callOverrides","functionSignature","getFunction","methodArgs","joinedArgs","transactionHash","DeployTransaction","factory","events","encodeDeploy","getDeployTransaction","deployError","status","biconomySendFunction","defenderSendFunction","biconomyPrepareRequest","ok","resp","statusText","defenderPrepareRequest","forwarderAddress","chainid","amount","permit","sig","messageType","body","prepareGaslessRequest","gaslessTx","batchId","batchNonce","txGas","tokenGasPrice","hashToSign","signMessage","ContractMetadata","schema","parseOutputMetadata","parseInputMetadata","supportsContractMetadata","contractSymbol","_parseAndUploadMetadata","wrapper","parsedMetadata","upload","roleMap","admin","transfer","minter","pauser","lister","asset","unwrap","ALL_ROLES","getRoleHash","ContractRoles","roles","getAll","roleHash","count","setAll","rolesWithAddresses","contractEncoder","currentRoles","encoded","sortedRoles","sort","addresses","currentAddresses","toAdd","toRemove","revokeFunctionName","getRevokeRoleFunctionName","verify","members","resolvedAddress","grant","revoke","ContractRoyalty","getDefaultRoyaltyInfo","getTokenRoyaltyInfo","setDefaultRoyaltyInfo","royaltyData","oldMetadata","mergedMetadata","contractURI","setTokenRoyaltyInfo","parsedRoyaltyData","ContractPrimarySale","getRecipient","setRecipient","recipient","FALLBACK_METADATA","fetchTokenMetadata","tokenUri","base64","jsonMetadata","parsedUri","unparsedTokenIdUri","fetchTokenMetadataForContract","erc165","isERC721","isERC1155","supportsInterface","erc721","tokenURI","erc1155","uploadOrExtractURI","uploadOrExtractURIs","metadatas","startNumber","isUriList","isMetadataList","uris","uploadBatch","rewriteFileNames","fileStartNumber","onProgress","getBaseUriFromBatch","baseUri","lastIndexOf","DelayedReveal","nextTokenIdToMintFn","createDelayedRevealBatch","placeholder","password","placeholderUris","placeholderUri","startFileNumber","baseUriId","hashedPassword","hashDelayRevealPassword","encryptedBaseUri","legacyContract","isLegacyContract","getChainID","provenanceHash","parseLogs","logs","startingIndex","startTokenId","endingIndex","endTokenId","lte","reveal","decryptedUri","getBatchesToReveal","isZero","countRangeArray","uriIndices","uriIndicesWithZeroStart","tokenMetadatas","getNftMetadata","encryptedUriData","getLegacyEncryptedData","encryptedBaseUris","hexDataLength","batchUri","placeholderMetadata","_","batchTokenIndex","legacy","abstractContractModelToLegacy","startTimestamp","supplyClaimed","pricePerToken","currency","quantityLimitPerTransaction","waitTimeInSecondsBetweenClaims","abstractContractModelToNew","quantityLimitPerWallet","convertQuantityToBigNumber","tokenDecimals","isNativeToken","tokenAddress","fetchCurrencyMetadata","nativeToken","erc20","parseSnapshotInputs","chunkSize","chunks","ceil","chunk","SHARD_NYBBLES","SnapshotFormatVersion","ShardedMerkleTree","originalEntriesUri","shardNybbles","shards","trees","fromUri","shardedMerkleTreeInfo","isShardedMerkleTree","fromShardedMerkleTreeInfo","hashEntry","currencyDecimals","snapshotFormatVersion","V1","V2","fetchAndCacheDecimals","cache","buildAndUpload","snapshotInput","snapshotEntry","shard","currencyDecimalMap","subTrees","getHexRoot","roots","fromEntries","tree","shardsToUpload","shardId","proofs","getProof","shardedMerkleInfo","masterUri","hashedEntries","leaf","getAllEntries","fetchSnapshotEntryForAddress","merkleMetadata","merkleTree","snapshotData","legacyContractModelToAbstract","newContractModelToAbstract","RPCConnectionHandler","optionParseError","updateSignerOrProvider","isReadOnly","getSignerOrProvider","ContractWrapper","isValidContract","customOverrides","updateAbi","updatedAbi","getCallOverrides","emitTransactionEvent","multiCall","withTransactionOverride","hook","ethersFnName","fnName","txOptions","sendGaslessTransaction","waitForTransaction","sendTransactionByFunction","staticErr","formatError","func","signTypedData","Signature","eventName","topic","getEventTopic","parsedLogs","x","topics","indexOf","parseLog","approveErc20Allowance","contractToApprove","allowance","totalPrice","normalizePriceValue","inputPrice","prepareClaim","addressToClaim","activeClaimCondition","merkleMetadataFetcher","checkERC20Allowance","priceInProof","currencyAddressInProof","createSnapshot","hasDuplicates","size","compare","left","right","eq","processSnapshotData","claimConditionInputs","snapshotInfos","inputsWithSnapshots","conditionInput","snapshotInfo","convertToContractModel","metadataOrUri","processClaimConditionInputs","parsedInputs","sortedConditions","fetchCurrencyValue","providerOrSigner","formatUnits","fetchSnapshot","smt","claim","convertToReadableQuantity","bn","transformResultToClaimCondition","pm","shouldDownloadSnapshot","cv","sub","resolvedMetadata","updateExistingClaimConditions","claimConditionInput","existingConditions","priceDecimals","priceInWei","priceInTokens","newConditionParsed","mergedConditionOutput","existingOutput","newConditionAtIndex","formattedPrice","Status","ClaimEligibility","DropClaimConditions","getActive","cc","getTokenDecimals","withAllowList","conditionId","isLegacySinglePhaseDrop","contractModel","isLegacyMultiPhaseDrop","isNewSinglePhaseDrop","isNewMultiphaseDrop","currentStartId","countBn","startId","conditions","fetchedConditions","canClaim","addressToCheck","getClaimIneligibilityReasons","reasons","activeConditionIndex","claimCondition","quantityWithDecimals","NoWallet","NoClaimConditionSet","Unknown","supplyWithDecimals","NotEnoughSupply","merkleRootArray","stripZeros","hasAllowList","allowListEntry","getClaimerProofs","AddressNotAllowed","claimVerification","validMerkleProof","maxQuantityInAllowlist","OverMaxClaimablePerWallet","WrongPriceOrCurrency","ClaimPhaseNotStarted","claimedSupply","getSupplyClaimedByWallet","lastClaimedTimestamp","timestampForNextClaim","AlreadyClaimed","WaitBeforeNextClaimTransaction","balance","getBalance","NotEnoughTokens","claimerAddress","claimConditionId","getSnapshotFormatVersion","walletAddress","activeClaimConditionId","_this","resetClaimEligibilityForAll","claimConditionsProcessed","merkleInfo","cw","baseContractEncoder","contractEncoderLegacy","newConditionInputs","getClaimArguments","destinationAddress","getClaimTransaction","DropErc1155ClaimConditions","mc","setBatch","claimConditions","_this2","claimConditionsForToken","processedClaimConditions","_ref2","legacyContractEncoder","Erc20BatchMintable","toAddress","normalizeAmount","Erc20Burnable","tokens","holder","Erc20ClaimableWithConditions","Erc20Droppable","Erc20Mintable","detectErc20BatchMintable","getMintTransaction","setErc20Allowance","Erc20SignatureMintable","mint","signedPayload","mintRequest","mapPayloadToContractStruct","mintBatch","signedPayloads","contractPayloads","verification","generate","generateBatch","payloadsToSign","parsedRequests","finalPayload","MintRequest","normalizedPrice","amountWithDecimals","validityEndTimestamp","validityStartTimestamp","assertEnabled","Erc20","_chainId","mintable","detectErc20Mintable","burnable","detectErc20Burnable","droppable","detectErc20Droppable","signatureMintable","detectErc20SignatureMintable","onNetworkUpdated","balanceOf","totalSupply","spenderAddress","allowanceOf","transferFrom","setAllowance","transferBatch","mintTo","receiver","mintBatchTo","burn","burnFrom","claimTo","Erc721BatchMintable","tokenIdMinted","Erc721ClaimableWithConditions","event","calculateClaimCost","totalCost","Erc721Claimable","Erc721LazyMintable","revealer","detectErc721Revealable","lazyMint","nextTokenIdToMint","getTokenMetadata","Erc721Mintable","detectErc721BatchMintable","Erc721Enumerable","tokenIds","indices","Erc721AQueryable","Erc721Supply","owned","detectErc721Owned","queryParams","maxSupply","maxId","allOwners","totalCount","totalClaimedSupply","owners","ownerOf","totalCirculatingSupply","TieredDropPayloadSchema","tierPriority","Erc721TieredDrop","getMetadataInTier","tier","tiers","batches","t","nfts","ranges","range","nftsInRange","baseURIs","startIdInclusive","endIdNonInclusive","getTokensInTier","endIndex","createBatchWithTier","createDelayedRevealBatchWithTier","payloadToSign","parsedPayloads","claimWithSignature","normalizedTotalPrice","quantityClaimed","Erc721Burnable","toWei","parseEther","Erc721ClaimableZora","saleDetails","getSaleDetails","publicSalePrice","zoraFee","firstPurchasedTokenId","Erc721LoyaltyCard","cancel","Erc721UpdatableMetadata","Erc721SharedMetadata","imageURI","animation_url","animationURI","sanitizeJSONString","imageUri","animationUri","sanitized","Erc721WithQuantitySignatureMintable","isLegacyNFTContract","mapLegacyPayloadToContractStruct","normalizedPricePerToken","Erc721","query","detectErc721Enumerable","detectErc721Mintable","detectErc721Burnable","lazyMintable","detectErc721LazyMintable","tieredDropable","detectErc721TieredDrop","detectErc721SignatureMintable","claimWithConditions","detectErc721ClaimableWithConditions","claimCustom","detectErc721Claimable","claimZora","detectErc721ClaimableZora","erc721SharedMetadata","detectErc721SharedMetadata","loyaltyCard","detectErc721LoyaltyCard","updatableMetadata","detectErc721UpdatableMetadata","supply","isApproved","operator","_address","_operator","_to","fromAddress","setApprovalForAll","approved","setApprovalForToken","getAllOwners","getOwned","getOwnedTokenIds","totalUnclaimedSupply","tieredDrop","sharedMetadata","Erc1155BatchMintable","metadataWithSupply","supplies","Erc1155Burnable","account","amounts","batchFrom","Erc1155Enumerable","balances","ownedBalances","editionMetadata","quantityOwned","getPrebuiltInfo","toUtf8String","contractVersion","Erc1155LazyMintable","detectErc1155Revealable","prebuiltInfo","isLegacyEditionDropContract","Erc1155Mintable","detectErc1155BatchMintable","additionalSupplyTo","additionalSupply","AirdropAddressInput","AirdropInputSchema","ERC1155Claimable","Erc1155ClaimableWithConditions","Erc1155SignatureMintable","generateFromTokenId","payloads","generateBatchFromTokenIds","contractInfo","Erc1155","detectErc1155Enumerable","detectErc1155Mintable","detectErc1155Burnable","detectErc1155LazyMintable","detectErc1155SignatureMintable","detectErc1155Claimable","detectErc1155ClaimableWithConditions","airdrop","_this3","totalToAirdrop","prev","mintAdditionalSupply","mintAdditionalSupplyTo","burnBatch","burnBatchFrom","cleanCurrencyAddress","isTokenApprovedForTransfer","transferrerContractAddress","assetContract","isApprovedForAll","approvedAddress","getApproved","handleTokenApproval","marketplaceAddress","isTokenApproved","validateNewListingParam","param","assetContractAddress","buyoutPricePerToken","listingDurationInSeconds","reservePricePerToken","mapOffer","offer","quantityDesired","currencyContractAddress","buyerAddress","offeror","quantityWanted","currencyValue","isWinningBid","winningPrice","newBidPrice","bidBuffer","gte","getAllInBatches","ContractEvents","addTransactionListener","listener","addListener","removeTransactionListener","off","addEventListener","getEvent","wrappedListener","parsedLog","toContractEvent","eventFragment","on","listenToAllEvents","removeEventListener","removeAllListeners","getAllEvents","filters","fromBlock","toBlock","order","queryFilter","orderedEvents","blockNumber","parseEvents","getEvents","eventInterface","rawLog","objArray","tuple","obj","DirectListingInputParamsSchema","endTimestamp","isReservedListing","ContractInterceptor","overrideNextTransaction","GasCostEstimator","gasCostOf","gasUnits","gasLimitOf","currentGasPriceInGwei","MarketplaceV3DirectListings","encoder","interceptor","estimator","getTotalCount","totalListings","rawListings","endId","filteredListings","applyFilter","listing","mapListing","getAllValid","getListing","isBuyerApprovedForListing","buyer","validateListing","isCurrencyApprovedForListing","currencyPriceForListing","resolvedCurrencyAddress","isApprovedCurrency","createListing","parsedListing","blockTime","reserved","createListingsBatch","listings","updateListing","cancelListing","buyFromListing","valid","isStillValidListing","buyFor","approveBuyerForReservedListing","revokeBuyerApprovalForReservedListing","approveCurrencyForListing","pricePerTokenInCurrency","currencyPrice","revokeCurrencyApprovalForListing","UNSET","Created","Expired","Active","Completed","Cancelled","currencyValuePerToken","startTimeInSeconds","endTimeInSeconds","creatorAddress","listingCreator","seller","resolvedSeller","tokenContract","resolvedToken","EnglishAuctionInputParamsSchema","minimumBidAmount","buyoutBidAmount","timeBufferInSeconds","bidBufferBps","MarketplaceV3EnglishAuctions","totalAuctions","rawAuctions","filteredAuctions","auction","mapAuction","getAuction","auctionId","getWinningBid","validateAuction","bid","_bidder","mapBid","_currency","_bidAmount","bidAmount","getWinner","contractEvent","closedAuctions","closed","winningBidder","createAuction","parsedAuction","normalizedBuyoutAmount","normalizedMinBidAmount","createAuctionsBatch","buyoutAuction","makeBid","normalizedBidAmount","winningBid","isWinnner","tokenPrice","cancelAuction","closeAuctionForBidder","closeFor","closeAuctionForSeller","executeSale","closeForSeller","closeForBuyer","getBidBufferBps","getMinimumNextBid","currentBidBufferBps","currentBidOrReservePrice","minimumNextBid","auctionCreator","minimumBidCurrencyValue","buyoutCurrencyValue","bidderAddress","resolvedBidderAddress","bidAmountCurrencyValue","auctions","OfferInputParamsSchema","MarketplaceV3Offers","totalOffers","rawOffers","filteredOffers","getOffer","offerId","makeOffer","parsedOffer","expirationTimestamp","cancelOffer","acceptOffer","validateOffer","isStillValidOffer","offerorAddress","offerorBalance","offerorAllowance","offers","resolvedOfferor","ContractPlatformFee","platformFeeRecipient","platformFeeBps","platformFeeInfo","extractEventsFromAbi","ContractPublishedMetadata","_cachedMetadata","extractFunctions","extractEvents","ContractOwner","ContractAppURI","getGatewayUrls","appURI","extractConstructorParams","predeployMetadataUri","getFunctionSignature","fnInputs","generatePluginFunctions","pluginAddress","pluginAbi","pluginInterface","pluginFunctions","fnFragment","functionSelector","generateExtensionFunctions","extensionAbi","extensionInterface","extensionFunctions","getDeploymentInfo","customParams","finalDeploymentInfo","publishedExtensions","pluginMetadata","fetchedMetadata","pluginDeploymentInfo","mapInput","pluginMapTransaction","_pluginsToAdd","extensionMetadata","extensionDeploymentInfo","routerInput","metadataURI","implementation","implementationDeployInfo","factoryInfo","deployContractDeterministic","debug","notifier","estimateGasForDeploy","initCode","sum","createTransactionBatches","transactions","upperGasLimit","transactionBatches","deployWithThrowawayDeployer","deployTxns","txBatch","deployer","deployed","getCompositeABIfromRelease","getPluginABI","getCompositePluginABI","pluginABIs","isbaseRouter","plugins","pluginAddresses","pluginMap","allPlugins","DropErc20ContractInput","DropErc20ContractOutput","DropErc20ContractDeploy","DropErc20ContractSchema","MultiwrapContractInput","MultiwrapContractOutput","MultiwrapContractDeploy","MultiwrapContractSchema","ADMIN_ROLE","NFT_BASE_CONTRACT_ROLES","MARKETPLACE_CONTRACT_ROLES","PACK_CONTRACT_ROLES","TOKEN_DROP_CONTRACT_ROLES","MULTIWRAP_CONTRACT_ROLES","prebuiltContractTypes","vote","edition","marketplace","multiwrap","EditionDropInitializer","initialize","_len","_key","_network","getAbi","EditionDrop","getContractInfo","EditionInitializer","_len2","_key2","Edition","MarketplaceInitializer","_len3","_ref3","_key3","Marketplace","MarketplaceV3Initializer","_len4","_ref4","_key4","MarketplaceV3","isZkSync","localAbi","MultiwrapInitializer","_len5","_ref5","_key5","Multiwrap","NFTCollectionInitializer","_len6","_ref6","_key6","NFTCollection","NFTDropInitializer","_len7","_ref7","_key7","NFTDrop","PackInitializer","_len8","_ref8","_key8","Pack","SignatureDropInitializer","_len9","_ref9","_key9","SignatureDrop","SplitInitializer","_len10","_ref10","_key10","Split","TokenDropInitializer","_len11","_ref11","_key11","TokenDrop","TokenInitializer","_len12","_ref12","_key12","Token","VoteInitializer","_len13","_ref13","_key13","Vote","PREBUILT_CONTRACTS_MAP","PREBUILT_CONTRACTS_APPURI_MAP","SmartContract$1","CONTRACTS_MAP","getContractTypeForRemoteName","getContractName","SignerPermissionsSchema","startDate","expirationDate","nativeTokenLimitPerTransaction","approvedCallTargets","PermissionSnapshotSchema","makeAdmin","permissions","SignerPermissionRequest","AccountPermissions","hasDuplicateSigners","checkedSigner","signers","parseSignerPermissionsStruct","approvedTargets","sendSignerPermissionRequest","generatePayload","success","buildSignerPermissionRequest","isValidSigner","permissionStartTimestamp","permissionEndTimestamp","reqValidityStartTimestamp","reqValidityEndTimestamp","connectedSigner","isAdmin","resolvedSignerAddress","getAllAdmins","getAllSigners","activeSignersWithPerms","signerWithPermissions","getAllAdminsAndSigners","allAdmins","transformedAdmins","allSigners","grantAdminPermissions","revokeAdminPermissions","grantPermissions","resolvedPermissions","updatePermissions","revokeAccess","approveTargetForSigner","resolvedTarget","newTargets","disapproveTargetForSigner","approvedTarget","resetAllPermissions","permissionSnapshot","resolvedSnapshot","addAdminData","removeAdminData","addOrUpdateSignerData","removeSignerData","allToMakeAdmin","allToMakeSigners","member","Account","accountPermissions","detectAccountPermissions","AccountFactory","predictAccountAddress","extraData","getAssociatedAccounts","getAllAccounts","isAccountDeployed","addr","createAccount","accountAdmin","Airdrop1155","drop","tokenOwner","contents","failedDrops","successfulDropCount","failedDropCount","Airdrop20","Airdrop721","ExtensionManager","getAllExtensions","getExtension","getExtensionAddress","getAllFunctions","getExtensionForFunction","functionInput","getMetadataForFunction","getExtensionAddressForFunction","inputArgs","abiToAdd","filterAbiForAdd","addDeployed","extensionAddress","extensionMetadataUri","addPublished","deployedExtensionAddress","deployExtension","extensionMetadataOverride","filterAbiForRemove","replaceDeployed","replacePublished","remove","extensionAbiInterface","extensionFunctionSelectors","filtered","fnSigHash","fullAbi","abiToRemove","fullAbiInterface","interfaceToRemove","functionsToRemove","published","transactionsToSend","transactionsforDirectDeploy","transactionsForThrowawayDeployer","SmartContract","royalties","detectRoyalties","detectRoles","sales","detectPrimarySales","platformFees","detectPlatformFees","detectOwnable","detectErc20","detectErc721","detectErc1155","app","detectApp","directListings","detectDirectListings","englishAuctions","detectEnglishAuctions","detectOffers","airdrop20","detectAirdrop20","airdrop721","detectAirdrop721","airdrop1155","detectAirdrop1155","accountFactory","detectAccountFactory","detectAccount","detectBaseRouter","ContractPublisher","fetchCompilerMetadataFromPredeployURI","predeployUri","fetchPrePublishMetadata","prepublishUri","preDeployMetadataFetched","latestPublishedContract","getLatest","latestPublishedContractMetadata","fetchPublishedContractInfo","preDeployMetadata","fetchCompilerMetadataFromAddress","fetchFullPublishMetadata","publishedMetadataUri","resolvePublishMetadataFromCompilerMetadata","contractUri","fetchContractSourcesFromAddress","updatePublisherProfile","profileMetadata","profileUri","getPublisherProfile","resolvedPublisherAddress","struct","toPublishedContract","getAllVersions","contractStructs","getVersion","publish","extraMetadata","predeployMetadata","isPlugin","isDynamic","publishedExtensionUris","ext","extensionABIs","composite","latestContract","latestMetadata","latestVersion","fetchedBytecode","fullMetadata","fullMetadataUri","unpublish","resolvedPublisher","$","E","G","H","I","J","K","L","O","R","S","T","U","V","W","X","Y","Z","a$","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aA","aB","aC","aD","aE","aF","aG","aH","aI","aJ","aK","aL","aM","aN","aO","aP","aQ","aR","aS","aT","aU","aV","aW","aX","aY","aZ","a_","aa","ab","ac","ad","ae","af","ag","ah","ai","aj","ak","al","am","an","ao","ap","aq","ar","as","at","au","av","aw","ax","ay","az","b$","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","bA","bB","bC","bD","bE","bF","bG","bH","bI","bJ","bK","bL","bM","bN","bO","bP","bQ","bR","bS","bT","bU","bV","bW","bX","bY","bZ","b_","ba","bb","bc","bd","be","bf","bg","bh","bi","bj","bk","bl","bm","bo","bp","bq","br","bs","bt","bu","bv","bw","bx","by","bz","c$","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","cA","cB","cC","cD","cE","cF","cG","cH","cI","cJ","cK","cL","cM","cN","cO","cP","cQ","cR","cS","cT","cU","cV","cW","cX","cY","cZ","c_","ca","cb","cd","ce","cf","cg","ch","ci","cj","ck","cl","cm","cn","co","cp","cq","cr","cs","ct","cu","cx","cy","cz","d$","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","dA","dB","dC","dD","dE","dF","dG","dH","dI","dJ","dK","dL","dM","dN","dO","dP","dQ","dR","dS","dT","dU","dV","dW","dX","dY","dZ","d_","da","db","dc","dd","de","df","dg","dh","di","dj","dk","dl","dm","dn","dp","dq","dr","ds","dt","du","dw","dx","dy","dz","e0","e1","e3","q","u","w","y"],"sources":["C:/Misc/Documents/Career/FinTech/BlockChain/FrontEnd/buildspace-dao-starter/node_modules/@thirdweb-dev/sdk/dist/contract-publisher-1ff1fe07.browser.esm.js"],"sourcesContent":["import { Q as QuantitySchema, A as AmountSchema, B as BytesLikeSchema, N as NFTInputOrUriSchema, a as BasisPointsSchema, F as FileOrBufferOrStringSchema, P as PercentSchema, C as CommonNFTOutput, b as CommonNFTInput, D as DEFAULT_QUERY_ALL_COUNT, c as BasicNFTInput, M as MAX_BPS } from './QueryParams-39bcad7a.browser.esm.js';\nimport { z } from 'zod';\nimport { BigNumber, providers, utils, constants, Contract, ContractFactory } from 'ethers';\nimport invariant from 'tiny-invariant';\nimport { v4 } from 'uuid';\nimport { isBrowser as isBrowser$1, isFileOrBuffer, replaceGatewayUrlWithScheme } from '@thirdweb-dev/storage';\nimport ERC165Abi from '@thirdweb-dev/contracts-js/dist/abis/IERC165.json';\nimport IERC721MetadataAbi from '@thirdweb-dev/contracts-js/dist/abis/IERC721Metadata.json';\nimport Erc1155MetadataAbi from '@thirdweb-dev/contracts-js/dist/abis/IERC1155Metadata.json';\nimport ERC20Abi from '@thirdweb-dev/contracts-js/dist/abis/IERC20.json';\nimport IERC20MetadataAbi from '@thirdweb-dev/contracts-js/dist/abis/IERC20Metadata.json';\nimport deepEqual from 'fast-deep-equal';\nimport { MerkleTree } from 'merkletreejs';\nimport IThirdwebContractABI from '@thirdweb-dev/contracts-js/dist/abis/IThirdwebContract.json';\nimport DeprecatedAbi from '@thirdweb-dev/contracts-js/dist/abis/IDelayedRevealDeprecated.json';\nimport Erc1155Abi from '@thirdweb-dev/contracts-js/dist/abis/IERC1155.json';\nimport Erc721Abi from '@thirdweb-dev/contracts-js/dist/abis/IERC721.json';\nimport ContractPublisherAbi from '@thirdweb-dev/contracts-js/dist/abis/ContractPublisher.json';\nimport { defaultChains, getValidChainRPCs, Polygon, Mumbai } from '@thirdweb-dev/chains';\nimport bs58 from 'bs58';\nimport TWRegistryABI from '@thirdweb-dev/contracts-js/dist/abis/TWMultichainRegistryLogic.json';\nimport IBurnableERC20Abi from '@thirdweb-dev/contracts-js/dist/abis/IBurnableERC20.json';\nimport IDrop from '@thirdweb-dev/contracts-js/dist/abis/IDrop.json';\nimport DropERC20_V2Abi from '@thirdweb-dev/contracts-js/dist/abis/IDropERC20_V2.json';\nimport IDropSinglePhase from '@thirdweb-dev/contracts-js/dist/abis/IDropSinglePhase.json';\nimport IDropSinglePhaseV1 from '@thirdweb-dev/contracts-js/dist/abis/IDropSinglePhase_V1.json';\nimport IERC20PermitAbi from '@thirdweb-dev/contracts-js/dist/abis/IERC20Permit.json';\nimport IMintableERC20Abi from '@thirdweb-dev/contracts-js/dist/abis/IMintableERC20.json';\nimport MulticallAbi from '@thirdweb-dev/contracts-js/dist/abis/IMulticall.json';\nimport ISignatureMintERC20Abi from '@thirdweb-dev/contracts-js/dist/abis/ISignatureMintERC20.json';\nimport IBurnableERC721Abi from '@thirdweb-dev/contracts-js/dist/abis/IBurnableERC721.json';\nimport IClaimableERC721 from '@thirdweb-dev/contracts-js/dist/abis/IClaimableERC721.json';\nimport DelayedRevealAbi from '@thirdweb-dev/contracts-js/dist/abis/IDelayedReveal.json';\nimport DropERC721_V3Abi from '@thirdweb-dev/contracts-js/dist/abis/IDropERC721_V3.json';\nimport Erc721EnumerableAbi from '@thirdweb-dev/contracts-js/dist/abis/IERC721Enumerable.json';\nimport Erc721AQueryableAbi from '@thirdweb-dev/contracts-js/dist/abis/IERC721AQueryableUpgradeable.json';\nimport Erc721SupplyAbi from '@thirdweb-dev/contracts-js/dist/abis/IERC721Supply.json';\nimport ILazyMintAbi from '@thirdweb-dev/contracts-js/dist/abis/ILazyMint.json';\nimport IMintableERC721Abi from '@thirdweb-dev/contracts-js/dist/abis/IMintableERC721.json';\nimport SignatureMintERC721Abi from '@thirdweb-dev/contracts-js/dist/abis/ISignatureMintERC721.json';\nimport SignatureMintERC721_V1Abi from '@thirdweb-dev/contracts-js/dist/abis/ISignatureMintERC721_V1.json';\nimport TieredDropAbi from '@thirdweb-dev/contracts-js/dist/abis/LazyMintWithTier.json';\nimport SharedMetadataAbi from '@thirdweb-dev/contracts-js/dist/abis/SharedMetadata.json';\nimport zora_IDropERC721 from '@thirdweb-dev/contracts-js/dist/abis/zora_IERC721Drop.json';\nimport ILoyaltyCardAbi from '@thirdweb-dev/contracts-js/dist/abis/ILoyaltyCard.json';\nimport INFTMetadataAbi from '@thirdweb-dev/contracts-js/dist/abis/INFTMetadata.json';\nimport IBurnableERC1155Abi from '@thirdweb-dev/contracts-js/dist/abis/IBurnableERC1155.json';\nimport IClaimableERC1155 from '@thirdweb-dev/contracts-js/dist/abis/IClaimableERC1155.json';\nimport IDropMultiPhase1155 from '@thirdweb-dev/contracts-js/dist/abis/IDrop1155.json';\nimport DropERC1155_V2Abi from '@thirdweb-dev/contracts-js/dist/abis/IDropERC1155_V2.json';\nimport IDropSinglePhase1155 from '@thirdweb-dev/contracts-js/dist/abis/IDropSinglePhase1155.json';\nimport IDropSinglePhase1155_V1 from '@thirdweb-dev/contracts-js/dist/abis/IDropSinglePhase1155_V1.json';\nimport Erc1155SupplyAbi from '@thirdweb-dev/contracts-js/dist/abis/IERC1155Supply.json';\nimport Erc1155EnumerableAbi from '@thirdweb-dev/contracts-js/dist/abis/IERC1155Enumerable.json';\nimport IMintableERC1155Abi from '@thirdweb-dev/contracts-js/dist/abis/IMintableERC1155.json';\nimport ISignatureMintERC1155Abi from '@thirdweb-dev/contracts-js/dist/abis/ISignatureMintERC1155.json';\nimport IERC2771ContextAbi from '@thirdweb-dev/contracts-js/dist/abis/IERC2771Context.json';\nimport IAppURI from '@thirdweb-dev/contracts-js/dist/abis/IAppURI.json';\nimport IContractMetadataAbi from '@thirdweb-dev/contracts-js/dist/abis/IContractMetadata.json';\nimport IDirectListingsAbi from '@thirdweb-dev/contracts-js/dist/abis/IDirectListings.json';\nimport IEnglishAuctionsAbi from '@thirdweb-dev/contracts-js/dist/abis/IEnglishAuctions.json';\nimport IOffersAbi from '@thirdweb-dev/contracts-js/dist/abis/IOffers.json';\nimport IPackVRFAbi from '@thirdweb-dev/contracts-js/dist/abis/IPackVRFDirect.json';\nimport IPermissionsAbi from '@thirdweb-dev/contracts-js/dist/abis/IPermissions.json';\nimport IPermissionsEnumerableAbi from '@thirdweb-dev/contracts-js/dist/abis/IPermissionsEnumerable.json';\nimport IThirdwebPlatformFeeAbi from '@thirdweb-dev/contracts-js/dist/abis/IPlatformFee.json';\nimport IThirdwebPrimarySaleAbi from '@thirdweb-dev/contracts-js/dist/abis/IPrimarySale.json';\nimport IThirdwebRoyaltyAbi from '@thirdweb-dev/contracts-js/dist/abis/IRoyalty.json';\nimport IOwnableAbi from '@thirdweb-dev/contracts-js/dist/abis/Ownable.json';\nimport IAirdropERC20 from '@thirdweb-dev/contracts-js/dist/abis/IAirdropERC20.json';\nimport IAirdropERC721 from '@thirdweb-dev/contracts-js/dist/abis/IAirdropERC721.json';\nimport IAirdropERC1155 from '@thirdweb-dev/contracts-js/dist/abis/IAirdropERC1155.json';\nimport IAccountFactoryCore from '@thirdweb-dev/contracts-js/dist/abis/IAccountFactoryCore.json';\nimport IAccountPermissions from '@thirdweb-dev/contracts-js/dist/abis/IAccountPermissions.json';\nimport IAccount from '@thirdweb-dev/contracts-js/dist/abis/IAccount.json';\nimport { Interface } from 'ethers/lib/utils';\nimport ForwarderABI from '@thirdweb-dev/contracts-js/dist/abis/Forwarder.json';\nimport fetch from 'cross-fetch';\nimport EventEmitter from 'eventemitter3';\n\nconst MAX_LENGTH = 256;\nconst NUMERIC_IDENTIFIER = \"0|[1-9]\\\\d*\";\nconst MAIN_VERSION_IDENTIFIER = `(${NUMERIC_IDENTIFIER})\\\\.(${NUMERIC_IDENTIFIER})\\\\.(${NUMERIC_IDENTIFIER})`;\nconst REGEX_MAIN_VERSION = new RegExp(MAIN_VERSION_IDENTIFIER);\n\n/**\n * @internal\n */\n\n/**\n * @internal\n * @param version\n */\nfunction toSemver(version) {\n  if (version.length > MAX_LENGTH) {\n    throw new Error(`version is longer than ${MAX_LENGTH} characters`);\n  }\n  const matches = version.trim().match(REGEX_MAIN_VERSION);\n  if (!matches || matches?.length !== 4) {\n    throw new Error(`${version} is not a valid semantic version. Should be in the format of major.minor.patch. Ex: 0.4.1`);\n  }\n  const major = Number(matches[1]);\n  const minor = Number(matches[2]);\n  const patch = Number(matches[3]);\n  const versionString = [major, minor, patch].join(\".\");\n  return {\n    major,\n    minor,\n    patch,\n    versionString\n  };\n}\n\n/**\n * @internal\n * @param current\n * @param next\n */\nfunction isIncrementalVersion(current, next) {\n  const currentSemver = toSemver(current);\n  const nextSemver = toSemver(next);\n  if (nextSemver.major > currentSemver.major) {\n    return true;\n  }\n  const eqMajor = nextSemver.major === currentSemver.major;\n  if (eqMajor && nextSemver.minor > currentSemver.minor) {\n    return true;\n  }\n  const eqMinor = nextSemver.minor === currentSemver.minor;\n  return eqMajor && eqMinor && nextSemver.patch > currentSemver.patch;\n}\nfunction isDowngradeVersion(current, next) {\n  const currentSemver = toSemver(current);\n  const nextSemver = toSemver(next);\n  if (nextSemver.major < currentSemver.major) {\n    return true;\n  }\n  const eqMajor = nextSemver.major === currentSemver.major;\n  if (eqMajor && nextSemver.minor < currentSemver.minor) {\n    return true;\n  }\n  const eqMinor = nextSemver.minor === currentSemver.minor;\n  return eqMajor && eqMinor && nextSemver.patch < currentSemver.patch;\n}\n\nconst BigNumberSchema = /* @__PURE__ */(() => z.union([z.string(), z.number(), z.bigint(), z.custom(data => {\n  return BigNumber.isBigNumber(data);\n})]).transform(arg => BigNumber.from(arg)))();\nconst BigNumberishSchema = /* @__PURE__ */BigNumberSchema.transform(arg => arg.toString());\nconst BigNumberTransformSchema = /* @__PURE__ */(() => z.union([z.bigint(), z.custom(data => {\n  return BigNumber.isBigNumber(data);\n})]).transform(arg => {\n  return BigNumber.from(arg).toString();\n}))();\n\n/**\n * util function to check for signer, ripped out of ethers Signer.isProvider\n *\n * @param value possible signer\n * @returns boolean if value is a signer\n * @internal\n */\nfunction isSigner(value) {\n  return !!(value && value._isSigner);\n}\n\n/**\n * util function to check for provider, ripped out of ethers providers.Provider.isProvider\n *\n * @param value possible provider\n * @returns boolean if value is a provider\n * @internal\n */\nfunction isProvider(value) {\n  return !!(value && value._isProvider);\n}\n\nconst DEFAULT_BATCH_TIME_LIMIT_MS = 50;\nconst DEFAULT_BATCH_SIZE_LIMIT = 250;\nconst DEFAULT_BATCH_OPTIONS = {\n  timeLimitMs: DEFAULT_BATCH_TIME_LIMIT_MS,\n  sizeLimit: DEFAULT_BATCH_SIZE_LIMIT\n};\n// mostly copied from ethers.js directly but make it a StaticJsonRpcProvider\nclass StaticJsonRpcBatchProvider extends providers.StaticJsonRpcProvider {\n  constructor(url, network) {\n    let batchOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_BATCH_OPTIONS;\n    super(url, network);\n    this._timeLimitMs = batchOptions.timeLimitMs || DEFAULT_BATCH_SIZE_LIMIT;\n    this._sizeLimit = batchOptions.sizeLimit || DEFAULT_BATCH_TIME_LIMIT_MS;\n    this._pendingBatchAggregator = null;\n    this._pendingBatch = null;\n  }\n  sendCurrentBatch(request) {\n    // if we still have a timeout clear that first\n    if (this._pendingBatchAggregator) {\n      clearTimeout(this._pendingBatchAggregator);\n    }\n    // Get the current batch and clear it, so new requests\n    // go into the next batch\n    const batch = this._pendingBatch || [];\n    this._pendingBatch = null;\n    this._pendingBatchAggregator = null;\n\n    // Get the request as an array of requests\n    const request_ = batch.map(inflight => inflight.request);\n    this.emit(\"debug\", {\n      action: \"requestBatch\",\n      request: utils.deepCopy(request),\n      provider: this\n    });\n    return utils.fetchJson(this.connection, JSON.stringify(request_)).then(result => {\n      this.emit(\"debug\", {\n        action: \"response\",\n        request: request_,\n        response: result,\n        provider: this\n      });\n\n      // For each result, feed it to the correct Promise, depending\n      // on whether it was a success or error\n      batch.forEach((inflightRequest_, index) => {\n        const payload = result[index];\n\n        // there may *not* be a payload for a given request (typically RPC error level)\n        if (payload) {\n          // if there is a payload, check for an error\n          if (payload.error) {\n            const error = new Error(payload.error.message);\n            error.code = payload.error.code;\n            error.data = payload.error.data;\n            inflightRequest_.reject(error);\n          } else {\n            // if there's no error resolve the request\n            inflightRequest_.resolve(payload.result);\n          }\n        } else {\n          // if there is no payload, reject the request\n          inflightRequest_.reject(new Error(\"No response for request\"));\n        }\n      });\n    }, error => {\n      this.emit(\"debug\", {\n        action: \"response\",\n        error: error,\n        request: request_,\n        provider: this\n      });\n\n      // If there was an error, reject all the requests\n      batch.forEach(inflightRequest_ => {\n        inflightRequest_.reject(error);\n      });\n    });\n  }\n  send(method, params) {\n    const request = {\n      method: method,\n      params: params,\n      id: this._nextId++,\n      jsonrpc: \"2.0\"\n    };\n    if (this._pendingBatch === null) {\n      this._pendingBatch = [];\n    }\n    const inflightRequest = {\n      request,\n      resolve: null,\n      reject: null\n    };\n    const promise = new Promise((resolve, reject) => {\n      inflightRequest.resolve = resolve;\n      inflightRequest.reject = reject;\n    });\n    this._pendingBatch.push(inflightRequest);\n\n    // if we would go *over* the size limit of the batch with this request, send the batch now\n    if (this._pendingBatch.length === this._sizeLimit) {\n      this.sendCurrentBatch(request);\n    }\n    if (!this._pendingBatchAggregator) {\n      // Schedule batch for next event loop + short duration\n      this._pendingBatchAggregator = setTimeout(() => {\n        this.sendCurrentBatch(request);\n      }, this._timeLimitMs);\n    }\n    return promise;\n  }\n}\n\nconst ChainInfoInputSchema = /* @__PURE__ */(() => z.object({\n  rpc: z.array(z.string().url()),\n  chainId: z.number(),\n  nativeCurrency: z.object({\n    name: z.string(),\n    symbol: z.string(),\n    decimals: z.number()\n  }),\n  slug: z.string()\n}))();\n\n/**\n * @public\n */\nconst SDKOptionsSchema = /* @__PURE__ */(() => z.object({\n  // @ts-expect-error - zod doesn't know anything about readonly\n  supportedChains: z.array(ChainInfoInputSchema).default(defaultChains),\n  clientId: z.string().optional(),\n  secretKey: z.string().optional(),\n  readonlySettings: z.object({\n    rpcUrl: z.string().url(),\n    chainId: z.number().optional()\n  }).optional(),\n  gasSettings: z.object({\n    maxPriceInGwei: z.number().min(1, \"gas price cannot be less than 1\").default(300),\n    speed: z.enum([\"standard\", \"fast\", \"fastest\"]).default(\"fastest\")\n  }).default({\n    maxPriceInGwei: 300,\n    speed: \"fastest\"\n  }),\n  gasless: z.union([z.object({\n    openzeppelin: z.object({\n      relayerUrl: z.string().url(),\n      relayerForwarderAddress: z.string().optional(),\n      useEOAForwarder: z.boolean().default(false),\n      domainName: z.string().default(\"GSNv2 Forwarder\"),\n      domainVersion: z.string().default(\"0.0.1\")\n    }),\n    experimentalChainlessSupport: z.boolean().default(false)\n  }), z.object({\n    biconomy: z.object({\n      apiId: z.string(),\n      apiKey: z.string(),\n      deadlineSeconds: z.number().min(1, \"deadlineSeconds cannot be les than 1\").default(3600)\n    })\n  })]).optional(),\n  gatewayUrls: z.array(z.string()).optional()\n}).default({\n  gasSettings: {\n    maxPriceInGwei: 300,\n    speed: \"fastest\"\n  }\n}))();\n\n/**\n * @public\n * All these configuration options are optional with sane defaults:\n * @example\n * ```javascript\n * {\n *   readonlySettings: {\n *     rpcUrl, // force read calls to go through your own RPC url\n *     chainId, // reduce RPC calls by sepcifying your chain ID\n *   },\n *   gasSettings: {\n *     maxPriceInGwei, // Maximum gas price for transactions (default 300 gwei)\n *     speed, // the tx speed setting: 'standard'|'fast|'fastest' (default: 'fastest')\n *   },\n *   gasless: {\n *     // By specifying a gasless configuration - all transactions will get forwarded to enable gasless transactions\n *     openzeppelin: {\n *       relayerUrl, // your OZ Defender relayer URL\n *       relayerForwarderAddress, // the OZ defender relayer address (defaults to the standard one)\n *     },\n *     biconomy: {\n *       apiId, // your Biconomy API Id\n *       apiKey, // your Biconomy API Key\n *       deadlineSeconds, // your Biconomy timeout preference\n *     },\n *   },\n * }\n * ```\n */\n\n/**\n * @internal\n */\n\n/**\n * @public\n */\n\nvar pkg = {\n\tname: \"@thirdweb-dev/sdk\",\n\tversion: \"3.10.67\",\n\tdescription: \"The main thirdweb SDK.\",\n\trepository: \"https://github.com/thirdweb-dev/js/tree/main/packages/sdk\",\n\tlicense: \"Apache-2.0\",\n\tmain: \"dist/thirdweb-dev-sdk.cjs.js\",\n\tmodule: \"dist/thirdweb-dev-sdk.esm.js\",\n\tbrowser: {\n\t\t\"./dist/thirdweb-dev-sdk.esm.js\": \"./dist/thirdweb-dev-sdk.browser.esm.js\"\n\t},\n\texports: {\n\t\t\".\": {\n\t\t\tmodule: {\n\t\t\t\tbrowser: \"./dist/thirdweb-dev-sdk.browser.esm.js\",\n\t\t\t\t\"default\": \"./dist/thirdweb-dev-sdk.esm.js\"\n\t\t\t},\n\t\t\t\"default\": \"./dist/thirdweb-dev-sdk.cjs.js\"\n\t\t},\n\t\t\"./evm\": {\n\t\t\tmodule: {\n\t\t\t\tbrowser: \"./evm/dist/thirdweb-dev-sdk-evm.browser.esm.js\",\n\t\t\t\t\"default\": \"./evm/dist/thirdweb-dev-sdk-evm.esm.js\"\n\t\t\t},\n\t\t\t\"default\": \"./evm/dist/thirdweb-dev-sdk-evm.cjs.js\"\n\t\t},\n\t\t\"./solana\": {\n\t\t\tmodule: {\n\t\t\t\tbrowser: \"./solana/dist/thirdweb-dev-sdk-solana.browser.esm.js\",\n\t\t\t\t\"default\": \"./solana/dist/thirdweb-dev-sdk-solana.esm.js\"\n\t\t\t},\n\t\t\t\"default\": \"./solana/dist/thirdweb-dev-sdk-solana.cjs.js\"\n\t\t},\n\t\t\"./evm/zksync\": {\n\t\t\tmodule: {\n\t\t\t\tbrowser: \"./evm/zksync/dist/thirdweb-dev-sdk-evm-zksync.browser.esm.js\",\n\t\t\t\t\"default\": \"./evm/zksync/dist/thirdweb-dev-sdk-evm-zksync.esm.js\"\n\t\t\t},\n\t\t\t\"default\": \"./evm/zksync/dist/thirdweb-dev-sdk-evm-zksync.cjs.js\"\n\t\t},\n\t\t\"./evm/functions\": {\n\t\t\tmodule: {\n\t\t\t\tbrowser: \"./evm/functions/dist/thirdweb-dev-sdk-evm-functions.browser.esm.js\",\n\t\t\t\t\"default\": \"./evm/functions/dist/thirdweb-dev-sdk-evm-functions.esm.js\"\n\t\t\t},\n\t\t\t\"default\": \"./evm/functions/dist/thirdweb-dev-sdk-evm-functions.cjs.js\"\n\t\t},\n\t\t\"./solana/server\": {\n\t\t\tmodule: {\n\t\t\t\tbrowser: \"./solana/server/dist/thirdweb-dev-sdk-solana-server.browser.esm.js\",\n\t\t\t\t\"default\": \"./solana/server/dist/thirdweb-dev-sdk-solana-server.esm.js\"\n\t\t\t},\n\t\t\t\"default\": \"./solana/server/dist/thirdweb-dev-sdk-solana-server.cjs.js\"\n\t\t},\n\t\t\"./package.json\": \"./package.json\"\n\t},\n\tfiles: [\n\t\t\"dist/\",\n\t\t\"evm/\",\n\t\t\"solana/\",\n\t\t\"server/\"\n\t],\n\tpreconstruct: {\n\t\tentrypoints: [\n\t\t\t\"index.ts\",\n\t\t\t\"evm/index.ts\",\n\t\t\t\"evm/functions/index.ts\",\n\t\t\t\"evm/zksync/index.ts\",\n\t\t\t\"solana/index.ts\",\n\t\t\t\"solana/server/index.ts\"\n\t\t],\n\t\texports: {\n\t\t\tenvConditions: [\n\t\t\t\t\"browser\"\n\t\t\t]\n\t\t}\n\t},\n\tsideEffects: false,\n\tscripts: {\n\t\tformat: \"prettier --write 'src/**/*'\",\n\t\tlint: \"eslint src/\",\n\t\tfix: \"eslint src/ --fix\",\n\t\tclean: \"rm -rf dist/\",\n\t\t\"generate-docs\": \"pnpm generate-docs:evm && pnpm generate-docs:solana && pnpm generate-snippets\",\n\t\t\"generate-docs:evm\": \"api-extractor run --local --config ./config/api-extractor-evm.json && api-documenter markdown -i ./temp -o ./docs/evm && rm -rf ./temp-evm && mv ./temp ./temp-evm\",\n\t\t\"generate-docs:solana\": \"api-extractor run --local --config ./config/api-extractor-solana.json && api-documenter markdown -i ./temp -o ./docs/solana && rm -rf ./temp-solana && mv ./temp ./temp-solana\",\n\t\t\"generate-snippets\": \"node ./scripts/generate-snippets.mjs && node ./scripts/generate-feature-snippets-evm.mjs\",\n\t\tbuild: \"tsc && preconstruct build\",\n\t\t\"test:evm:all\": \"SWC_NODE_PROJECT=./tsconfig.test.json nyc --reporter lcovonly --report-dir ./coverage/evm mocha --config './test/evm/.mocharc.json' --timeout 90000 --parallel './test/evm/**/*.test.ts'\",\n\t\t\"test:evm\": \"make test-evm\",\n\t\t\"test:evm:single\": \"SWC_NODE_PROJECT=./tsconfig.test.json mocha --config './test/evm/.mocharc.json' --timeout 90000\",\n\t\t\"node:solana:start\": \"DEBUG='amman:(info|error|debug)' amman start --forceClone\",\n\t\t\"node:solana:stop\": \"amman stop\",\n\t\t\"test:solana:all\": \"SWC_NODE_PROJECT=./tsconfig.test.json nyc --reporter lcovonly --report-dir ./coverage/solana  mocha --config './test/solana/.mocharc.json' --timeout 30000 --parallel './test/solana/**/*.test.ts'\",\n\t\t\"test:solana\": \"make test-sol\",\n\t\t\"test:solana:single\": \"SWC_NODE_PROJECT=./tsconfig.test.json mocha --config './test/solana/.mocharc.json' --timeout 30000\",\n\t\tpush: \"yalc push\"\n\t},\n\tdevDependencies: {\n\t\t\"@aws-sdk/client-secrets-manager\": \"^3.378.0\",\n\t\t\"@ethersproject/abstract-provider\": \"^5.7.0\",\n\t\t\"@metaplex-foundation/amman\": \"^0.12.1\",\n\t\t\"@metaplex-foundation/amman-client\": \"^0.2.4\",\n\t\t\"@metaplex-foundation/js\": \"^0.19.2\",\n\t\t\"@metaplex-foundation/mpl-token-metadata\": \"^2.12.0\",\n\t\t\"@microsoft/api-documenter\": \"^7.22.30\",\n\t\t\"@microsoft/api-extractor\": \"^7.36.3\",\n\t\t\"@microsoft/tsdoc\": \"^0.14.1\",\n\t\t\"@nomiclabs/hardhat-ethers\": \"^2.2.3\",\n\t\t\"@preconstruct/cli\": \"2.7.0\",\n\t\t\"@project-serum/anchor\": \"^0.25.0\",\n\t\t\"@solana/spl-token\": \"^0.3.5\",\n\t\t\"@solana/web3.js\": \"^1.62.0\",\n\t\t\"@swc-node/register\": \"^1.6.6\",\n\t\t\"@swc/core\": \"^1.3.71\",\n\t\t\"@thirdweb-dev/tsconfig\": \"workspace:*\",\n\t\t\"@types/bn.js\": \"^5.1.1\",\n\t\t\"@types/chai\": \"^4.3.5\",\n\t\t\"@types/deep-equal-in-any-order\": \"^1.0.1\",\n\t\t\"@types/mocha\": \"^10.0.0\",\n\t\t\"@types/node\": \"^18.17.1\",\n\t\t\"@types/uuid\": \"^9.0.2\",\n\t\t\"@typescript-eslint/eslint-plugin\": \"^6.2.0\",\n\t\t\"@typescript-eslint/parser\": \"^6.2.0\",\n\t\tchai: \"^4.3.6\",\n\t\t\"deep-equal-in-any-order\": \"^1.1.18\",\n\t\t\"dotenv-mono\": \"^1.3.10\",\n\t\teslint: \"^8.45.0\",\n\t\t\"eslint-config-prettier\": \"^8.9.0\",\n\t\t\"eslint-config-thirdweb\": \"workspace:*\",\n\t\t\"eslint-plugin-better-tree-shaking\": \"0.0.3\",\n\t\t\"eslint-plugin-import\": \"^2.26.0\",\n\t\t\"eslint-plugin-inclusive-language\": \"^2.2.0\",\n\t\t\"eslint-plugin-prettier\": \"^5.0.0\",\n\t\t\"eslint-plugin-tsdoc\": \"^0.2.16\",\n\t\tethers: \"^5.7.2\",\n\t\t\"ethers-aws-kms-signer\": \"^1.3.2\",\n\t\thardhat: \"^2.17.0\",\n\t\tmocha: \"^10.2.0\",\n\t\tnyc: \"^15.1.0\",\n\t\tprettier: \"^3.0.0\",\n\t\ttypescript: \"^5.1.6\",\n\t\t\"zksync-web3\": \"^0.14.3\"\n\t},\n\tpeerDependencies: {\n\t\t\"@aws-sdk/client-secrets-manager\": \"^3.215.0\",\n\t\t\"@metaplex-foundation/js\": \"^0.17.6\",\n\t\t\"@metaplex-foundation/mpl-token-metadata\": \"^2.3.3\",\n\t\t\"@project-serum/anchor\": \"^0.25.0\",\n\t\t\"@solana/spl-token\": \"^0.3.5\",\n\t\t\"@solana/web3.js\": \"^1.62.0\",\n\t\tethers: \"^5\",\n\t\t\"ethers-aws-kms-signer\": \"^1.3.2\",\n\t\t\"zksync-web3\": \"^0.14.3\"\n\t},\n\tpeerDependenciesMeta: {\n\t\t\"@aws-sdk/client-secrets-manager\": {\n\t\t\toptional: true\n\t\t},\n\t\t\"ethers-aws-kms-signer\": {\n\t\t\toptional: true\n\t\t},\n\t\t\"@solana/spl-token\": {\n\t\t\toptional: true\n\t\t},\n\t\t\"@solana/web3.js\": {\n\t\t\toptional: true\n\t\t},\n\t\t\"@project-serum/anchor\": {\n\t\t\toptional: true\n\t\t},\n\t\t\"@metaplex-foundation/mpl-token-metadata\": {\n\t\t\toptional: true\n\t\t},\n\t\t\"@metaplex-foundation/js\": {\n\t\t\toptional: true\n\t\t},\n\t\t\"zksync-web3\": {\n\t\t\toptional: true\n\t\t}\n\t},\n\tdependencies: {\n\t\t\"@thirdweb-dev/chains\": \"workspace:*\",\n\t\t\"@thirdweb-dev/contracts-js\": \"workspace:*\",\n\t\t\"@thirdweb-dev/generated-abis\": \"workspace:*\",\n\t\t\"@thirdweb-dev/storage\": \"workspace:*\",\n\t\tabitype: \"^0.2.5\",\n\t\t\"bn.js\": \"^5.2.1\",\n\t\tbs58: \"^5.0.0\",\n\t\tbuffer: \"^6.0.3\",\n\t\t\"cross-fetch\": \"^3.1.8\",\n\t\teventemitter3: \"^5.0.1\",\n\t\t\"fast-deep-equal\": \"^3.1.3\",\n\t\tmerkletreejs: \"^0.2.24\",\n\t\t\"tiny-invariant\": \"^1.2.0\",\n\t\ttweetnacl: \"^1.0.3\",\n\t\tuuid: \"^9.0.0\",\n\t\tyaml: \"^2.3.1\",\n\t\tzod: \"^3.20.2\"\n\t},\n\tbugs: {\n\t\turl: \"https://github.com/thirdweb-dev/js/issues\"\n\t},\n\tauthor: \"thirdweb eng <eng@thirdweb.com>\"\n};\n\n/**\n * @internal\n */\nfunction buildDefaultMap(options) {\n  return options.supportedChains.reduce((previousValue, currentValue) => {\n    previousValue[currentValue.chainId] = currentValue;\n    return previousValue;\n  }, {});\n}\n\n/**\n * Get an ethers provider for the specified network\n *\n * @internal\n */\nfunction getChainProvider(network, sdkOptions) {\n  // If we have an RPC URL, use that for the provider\n  if (typeof network === \"string\" && isRpcUrl(network)) {\n    return getProviderFromRpcUrl(network, sdkOptions);\n  }\n\n  // Add the chain to the supportedChains\n  const options = SDKOptionsSchema.parse(sdkOptions);\n  if (isChainConfig(network)) {\n    options.supportedChains = [\n    // @ts-expect-error - we know this is a chain and it will work to build the map\n    network, ...options.supportedChains.filter(c => c.chainId !== network.chainId)];\n  }\n\n  // Build a map of chainId -> ChainInfo based on the supportedChains\n  const rpcMap = buildDefaultMap(options);\n  let rpcUrl = \"\";\n  let chainId;\n  try {\n    // Resolve the chain id from the network, which could be a chain, chain name, or chain id\n    chainId = getChainIdFromNetwork(network, options);\n    // Attempt to get the RPC url from the map based on the chainId\n    rpcUrl = getValidChainRPCs(rpcMap[chainId], options.clientId)[0];\n  } catch (e) {\n    // no-op\n  }\n\n  // if we still don't have an url fall back to just using the chainId or slug in the rpc and try that\n  if (!rpcUrl) {\n    rpcUrl = `https://${chainId || network}.rpc.thirdweb.com/${options.clientId || \"\"}`;\n  }\n  if (!rpcUrl) {\n    throw new Error(`No rpc url found for chain ${network}. Please provide a valid rpc url via the 'supportedChains' property of the sdk options.`);\n  }\n  return getProviderFromRpcUrl(rpcUrl, sdkOptions, chainId);\n}\nfunction getChainIdFromNetwork(network, options) {\n  if (isChainConfig(network)) {\n    // If it's a chain just return the chain id\n    return network.chainId;\n  } else if (typeof network === \"number\") {\n    // If it's a number (chainId) return it directly\n    return network;\n  } else {\n    // If it's a string (chain name) return the chain id from the map\n    const chainNameToId = options.supportedChains.reduce((acc, curr) => {\n      acc[curr.slug] = curr.chainId;\n      return acc;\n    }, {});\n    if (network in chainNameToId) {\n      return chainNameToId[network];\n    }\n  }\n  throw new Error(`Cannot resolve chainId from: ${network} - please pass the chainId instead and specify it in the 'supportedChains' property of the SDK options.`);\n}\nasync function getChainIdOrName(network) {\n  if (isChainConfig(network)) {\n    // If it's a chain just return the chain id\n    return network.chainId;\n  } else if (typeof network === \"number\") {\n    // If it's a number (chainId) return it directly\n    return network;\n  } else if (typeof network === \"number\") {\n    // If it's a string (chain name) return the chain id from the map\n    return network;\n  } else if (isProvider(network)) {\n    return network.getNetwork().then(n => n.chainId);\n  } else if (isSigner(network)) {\n    if (!network.provider) {\n      throw new Error(\"Signer does not have a provider\");\n    }\n    return network.provider.getNetwork().then(n => n.chainId);\n  }\n  throw new Error(`Cannot resolve chainId from: ${network}.`);\n}\n\n/**\n * Check whether a NetworkInput value is a Chain config (naively, without parsing)\n */\nfunction isChainConfig(network) {\n  return typeof network !== \"string\" && typeof network !== \"number\" && !isSigner(network) && !isProvider(network);\n}\n\n/**\n * Returns whether the specified url is a valid RPC url, as implemented by ethers.getDefaultProvier():\n * - https://github.com/ethers-io/ethers.js/blob/ec1b9583039a14a0e0fa15d0a2a6082a2f41cf5b/packages/providers/src.ts/index.ts#L55\n *\n * @param url - The url to check\n *\n * @internal\n */\nfunction isRpcUrl(url) {\n  const match = url.match(/^(ws|http)s?:/i);\n  if (match) {\n    switch (match[1].toLowerCase()) {\n      case \"http\":\n      case \"https\":\n      case \"ws\":\n      case \"wss\":\n        return true;\n    }\n  }\n  return false;\n}\nconst RPC_PROVIDER_MAP = new Map();\n\n/**\n * Get an ethers provider based on the specified RPC URL\n *\n * @param rpcUrl - The RPC URL\n * @param chainId - The optional chain ID\n * @returns The provider for the specified RPC URL\n *\n * @internal\n */\nfunction getProviderFromRpcUrl(rpcUrl, sdkOptions, chainId) {\n  try {\n    const headers = {};\n    // will be used to make sure we don't cache providers with different auth strategies\n    let authStrategy = \"none\";\n    if (isTwUrl(rpcUrl)) {\n      // if we have a secret key passed in the SDK options we want to always use that\n      if (sdkOptions?.secretKey) {\n        // compute the clientId from the secret key\n        // should only be used on Node.js in a backend/script context\n        if (\"object\" !== \"undefined\") {\n          throw new Error(\"Cannot use secretKey in browser context\");\n        }\n        // this is on purpose because we're using the crypto module only in node\n        // try to trick webpack :)\n        const pto = \"pto\";\n        // eslint-disable-next-line @typescript-eslint/no-var-requires\n        const crypto = require(\"cry\" + pto);\n        const hashedSecretKey = crypto.createHash(\"sha256\").update(sdkOptions.secretKey).digest(\"hex\");\n        const derivedClientId = hashedSecretKey.slice(0, 32);\n        const utilizedRpcUrl = new URL(rpcUrl);\n        // always set the clientId on the path to the derived client id\n        utilizedRpcUrl.pathname = derivedClientId;\n        // set the headers\n        headers[\"x-client-id\"] = derivedClientId;\n        headers[\"x-secret-key\"] = sdkOptions.secretKey;\n        // set the final rpc url\n        rpcUrl = utilizedRpcUrl.toString();\n        authStrategy = \"secretKey\";\n      }\n      // if we do NOT have a secret key but we have a client id we want to use that\n      else if (sdkOptions?.clientId) {\n        const utilizedRpcUrl = new URL(rpcUrl);\n        // always set the clientId on the path to the client id\n        utilizedRpcUrl.pathname = sdkOptions.clientId;\n        // set the headers\n        headers[\"x-client-id\"] = sdkOptions.clientId;\n        // set the final rpc url\n        rpcUrl = utilizedRpcUrl.toString();\n        authStrategy = \"clientId\";\n      }\n\n      // if we *also* have a tw auth token on global context add it to the headers (in addition to anything else)\n      if (typeof globalThis !== \"undefined\" && \"TW_AUTH_TOKEN\" in globalThis && typeof globalThis.TW_AUTH_TOKEN === \"string\") {\n        headers[\"authorization\"] = `Bearer ${globalThis.TW_AUTH_TOKEN}`;\n        authStrategy = \"twAuthToken\";\n      }\n      if (typeof globalThis !== \"undefined\" && \"TW_CLI_AUTH_TOKEN\" in globalThis && typeof globalThis.TW_CLI_AUTH_TOKEN === \"string\") {\n        headers[\"x-authorize-wallet\"] = \"true\";\n      }\n      const bundleId = typeof globalThis !== \"undefined\" && \"APP_BUNDLE_ID\" in globalThis ? globalThis.APP_BUNDLE_ID : undefined;\n      if (!rpcUrl.includes(\"bundleId\")) {\n        rpcUrl = rpcUrl + (bundleId ? `?bundleId=${bundleId}` : \"\");\n      }\n      headers[\"x-sdk-version\"] = pkg.version;\n      headers[\"x-sdk-name\"] = pkg.name;\n      headers[\"x-sdk-platform\"] = bundleId ? \"react-native\" : isBrowser$1() ? window.bridge !== undefined ? \"webGL\" : \"browser\" : \"node\";\n    }\n    const match = rpcUrl.match(/^(ws|http)s?:/i);\n    // Try the JSON batch provider if available\n    if (match) {\n      switch (match[1].toLowerCase()) {\n        case \"http\":\n        case \"https\":\n          // Create a unique cache key for these params\n          const seralizedOpts = `${rpcUrl}-${chainId || -1}-${authStrategy}`;\n\n          // Check if we have a provider in our cache already\n          const existingProvider = RPC_PROVIDER_MAP.get(seralizedOpts);\n          if (existingProvider) {\n            return existingProvider;\n          }\n\n          // Otherwise, create a new provider on the specific network\n          const newProvider = chainId ?\n          // If we know the chainId we should use the StaticJsonRpcBatchProvider\n          new StaticJsonRpcBatchProvider({\n            url: rpcUrl,\n            headers\n          }, chainId) :\n          // Otherwise fall back to the built in json rpc batch provider\n          new providers.JsonRpcBatchProvider({\n            url: rpcUrl,\n            headers\n          });\n\n          // Save the provider in our cache\n          RPC_PROVIDER_MAP.set(seralizedOpts, newProvider);\n          return newProvider;\n        case \"ws\":\n        case \"wss\":\n          // Use the WebSocketProvider for ws:// URLs\n          // TODO: handle auth for WS at some point\n          return new providers.WebSocketProvider(rpcUrl, chainId);\n      }\n    }\n  } catch (e) {\n    // no-op\n  }\n\n  // Always fallback to the default provider if no other option worked\n  return providers.getDefaultProvider(rpcUrl);\n}\n\n// TODO move to utils package\nfunction isTwUrl(url) {\n  return new URL(url).hostname.endsWith(\".thirdweb.com\");\n}\n\n/**\n * @internal\n */\nfunction getSignerAndProvider(network, options) {\n  let signer;\n  let provider;\n  if (isSigner(network)) {\n    // Here, we have an ethers.Signer\n    signer = network;\n    if (network.provider) {\n      provider = network.provider;\n    }\n  } else if (isProvider(network)) {\n    // Here, we have an ethers.providers.Provider\n    provider = network;\n  } else {\n    // Here, we must have a ChainOrRpcUrl, which is a chain name, chain id, rpc url, or chain config\n    // All of which, getChainProvider can handle for us\n    provider = getChainProvider(network, options);\n  }\n  if (options?.readonlySettings) {\n    // If readonly settings are specified, then overwrite the provider\n    provider = getProviderFromRpcUrl(options.readonlySettings.rpcUrl, options, options.readonlySettings.chainId);\n  }\n\n  // At this point, if we don't have a provider, don't default to a random chain\n  // Instead, just throw an error\n  if (!provider) {\n    if (signer) {\n      throw new Error(\"No provider passed to the SDK! Please make sure that your signer is connected to a provider!\");\n    }\n    throw new Error(\"No provider found! Make sure to specify which network to connect to, or pass a signer or provider to the SDK!\");\n  }\n  return [signer, provider];\n}\n\n// TODO: Respect SDK RPC configuration and don't pull straight from ethers\nlet provider;\nconst ENS_CACHE = new Map();\nasync function resolveEns(ens) {\n  let depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  if (!provider) {\n    // if we don't already have a provider then get one\n    provider = getSignerAndProvider(\"ethereum\")[1];\n  }\n  let ensPromise;\n  if (ENS_CACHE.has(ens)) {\n    ensPromise = ENS_CACHE.get(ens);\n  } else {\n    ensPromise = provider.resolveName(ens).then(address => {\n      // If they don't have an ENS, only cache for 30s\n      if (!address) {\n        return {\n          address: null,\n          expirationTime: new Date(Date.now() + 1000 * 30)\n        };\n      }\n\n      // Cache ENS for 1 hour\n      return {\n        address,\n        expirationTime: new Date(Date.now() + 1000 * 60 * 5)\n      };\n    });\n  }\n  const resolvedPromise = await ensPromise;\n  if (resolvedPromise.expirationTime < new Date()) {\n    // delete the cache if it's expired\n    ENS_CACHE.delete(ens);\n    // then call ourselves again to refresh the cache, but don't block on the result\n    if (depth === 0) {\n      resolveEns(ens, depth + 1);\n    }\n  }\n  return resolvedPromise.address;\n}\n\n// Only pass through to provider call if value ends with .eth or .cb.id\nconst EnsSchema = /* @__PURE__ */(() => z.custom(ens => typeof ens === \"string\" && (ens.endsWith(\".eth\") || ens.endsWith(\".cb.id\"))).transform(async ens => resolveEns(ens)).refine(address => !!address && utils.isAddress(address), {\n  message: \"Provided value was not a valid ENS name\"\n}))();\n\nconst AddressSchema = /* @__PURE__ */z.custom(address => typeof address === \"string\" && utils.isAddress(address), out => {\n  return {\n    message: `${out} is not a valid address`\n  };\n});\n\n// Important for address check to come before ENS so network request is only made when necessary\nconst AddressOrEnsSchema = /* @__PURE__ */z.union([AddressSchema, EnsSchema], {\n  invalid_type_error: \"Provided value was not a valid address or ENS name\"\n});\n\n// Use this everywhere even though it's just string so we can optionally switch it out\n// more easily if we want to later\n\n/**\n * @public\n */\nlet ChainId = /*#__PURE__*/function (ChainId) {\n  ChainId[ChainId[\"Mainnet\"] = 1] = \"Mainnet\";\n  ChainId[ChainId[\"Goerli\"] = 5] = \"Goerli\";\n  ChainId[ChainId[\"Polygon\"] = 137] = \"Polygon\";\n  ChainId[ChainId[\"Mumbai\"] = 80001] = \"Mumbai\";\n  ChainId[ChainId[\"Localhost\"] = 1337] = \"Localhost\";\n  ChainId[ChainId[\"Hardhat\"] = 31337] = \"Hardhat\";\n  ChainId[ChainId[\"Fantom\"] = 250] = \"Fantom\";\n  ChainId[ChainId[\"FantomTestnet\"] = 4002] = \"FantomTestnet\";\n  ChainId[ChainId[\"Avalanche\"] = 43114] = \"Avalanche\";\n  ChainId[ChainId[\"AvalancheFujiTestnet\"] = 43113] = \"AvalancheFujiTestnet\";\n  ChainId[ChainId[\"Optimism\"] = 10] = \"Optimism\";\n  ChainId[ChainId[\"OptimismGoerli\"] = 420] = \"OptimismGoerli\";\n  ChainId[ChainId[\"Arbitrum\"] = 42161] = \"Arbitrum\";\n  ChainId[ChainId[\"ArbitrumGoerli\"] = 421613] = \"ArbitrumGoerli\";\n  ChainId[ChainId[\"BinanceSmartChainMainnet\"] = 56] = \"BinanceSmartChainMainnet\";\n  ChainId[ChainId[\"BinanceSmartChainTestnet\"] = 97] = \"BinanceSmartChainTestnet\";\n  return ChainId;\n}({});\n\n// @ts-expect-error - readonly vs not\nlet supportedChains = defaultChains;\n\n/**\n * @internal\n */\nfunction setSupportedChains(chains) {\n  if (chains && chains.length > 0) {\n    supportedChains = chains;\n  } else {\n    // @ts-expect-error - readonly vs not\n    supportedChains = defaultChains;\n  }\n}\n\n/**\n * @internal\n */\nfunction getSupportedChains() {\n  return supportedChains;\n}\n\n/**\n * @public\n */\nconst NATIVE_TOKEN_ADDRESS = \"0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee\";\n\n/**\n * @public\n */\nconst NATIVE_TOKENS = {\n  [ChainId.Mainnet]: {\n    name: \"Ether\",\n    symbol: \"ETH\",\n    decimals: 18,\n    wrapped: {\n      address: \"0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\",\n      name: \"Wrapped Ether\",\n      symbol: \"WETH\"\n    }\n  },\n  [ChainId.Goerli]: {\n    name: \"Görli Ether\",\n    symbol: \"GOR\",\n    decimals: 18,\n    wrapped: {\n      address: \"0xb4fbf271143f4fbf7b91a5ded31805e42b2208d6\",\n      name: \"Wrapped Ether\",\n      symbol: \"WETH\"\n    }\n  },\n  11155111: {\n    name: \"Sepolia Ether\",\n    symbol: \"SEP\",\n    decimals: 18,\n    wrapped: {\n      address: \"0x7b79995e5f793A07Bc00c21412e50Ecae098E7f9\",\n      name: \"Wrapped Ether\",\n      symbol: \"WETH\"\n    }\n  },\n  [ChainId.Polygon]: {\n    name: \"Matic\",\n    symbol: \"MATIC\",\n    decimals: 18,\n    wrapped: {\n      address: \"0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270\",\n      name: \"Wrapped Matic\",\n      symbol: \"WMATIC\"\n    }\n  },\n  [ChainId.Mumbai]: {\n    name: \"Matic\",\n    symbol: \"MATIC\",\n    decimals: 18,\n    wrapped: {\n      address: \"0x9c3C9283D3e44854697Cd22D3Faa240Cfb032889\",\n      name: \"Wrapped Matic\",\n      symbol: \"WMATIC\"\n    }\n  },\n  [ChainId.Avalanche]: {\n    name: \"Avalanche\",\n    symbol: \"AVAX\",\n    decimals: 18,\n    wrapped: {\n      address: \"0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7\",\n      name: \"Wrapped AVAX\",\n      symbol: \"WAVAX\"\n    }\n  },\n  [ChainId.AvalancheFujiTestnet]: {\n    name: \"Avalanche\",\n    symbol: \"AVAX\",\n    decimals: 18,\n    wrapped: {\n      address: \"0xd00ae08403B9bbb9124bB305C09058E32C39A48c\",\n      name: \"Wrapped AVAX\",\n      symbol: \"WAVAX\"\n    }\n  },\n  [ChainId.Fantom]: {\n    name: \"Fantom\",\n    symbol: \"FTM\",\n    decimals: 18,\n    wrapped: {\n      address: \"0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83\",\n      name: \"Wrapped Fantom\",\n      symbol: \"WFTM\"\n    }\n  },\n  [ChainId.FantomTestnet]: {\n    name: \"Fantom\",\n    symbol: \"FTM\",\n    decimals: 18,\n    wrapped: {\n      address: \"0xf1277d1Ed8AD466beddF92ef448A132661956621\",\n      name: \"Wrapped Fantom\",\n      symbol: \"WFTM\"\n    }\n  },\n  [ChainId.Arbitrum]: {\n    name: \"Ether\",\n    symbol: \"ETH\",\n    decimals: 18,\n    wrapped: {\n      address: \"0x82af49447d8a07e3bd95bd0d56f35241523fbab1\",\n      name: \"Wrapped Ether\",\n      symbol: \"WETH\"\n    }\n  },\n  [ChainId.ArbitrumGoerli]: {\n    name: \"Arbitrum Goerli Ether\",\n    symbol: \"AGOR\",\n    decimals: 18,\n    wrapped: {\n      address: \"0xe39Ab88f8A4777030A534146A9Ca3B52bd5D43A3\",\n      name: \"Wrapped Ether\",\n      symbol: \"WETH\"\n    }\n  },\n  [ChainId.Optimism]: {\n    name: \"Ether\",\n    symbol: \"ETH\",\n    decimals: 18,\n    wrapped: {\n      address: \"0x4200000000000000000000000000000000000006\",\n      name: \"Wrapped Ether\",\n      symbol: \"WETH\"\n    }\n  },\n  [ChainId.OptimismGoerli]: {\n    name: \"Goerli Ether\",\n    symbol: \"ETH\",\n    decimals: 18,\n    wrapped: {\n      address: \"0x4200000000000000000000000000000000000006\",\n      name: \"Wrapped Ether\",\n      symbol: \"WETH\"\n    }\n  },\n  [ChainId.BinanceSmartChainMainnet]: {\n    name: \"Binance Chain Native Token\",\n    symbol: \"BNB\",\n    decimals: 18,\n    wrapped: {\n      address: \"0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c\",\n      name: \"Wrapped Binance Chain Token\",\n      symbol: \"WBNB\"\n    }\n  },\n  [ChainId.BinanceSmartChainTestnet]: {\n    name: \"Binance Chain Native Token\",\n    symbol: \"TBNB\",\n    decimals: 18,\n    wrapped: {\n      address: \"0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd\",\n      name: \"Wrapped Binance Chain Testnet Token\",\n      symbol: \"WBNB\"\n    }\n  },\n  [ChainId.Hardhat]: {\n    name: \"Ether\",\n    symbol: \"ETH\",\n    decimals: 18,\n    wrapped: {\n      address: \"0x5FbDB2315678afecb367f032d93F642f64180aa3\",\n      name: \"Wrapped Ether\",\n      symbol: \"WETH\"\n    }\n  },\n  [ChainId.Localhost]: {\n    name: \"Ether\",\n    symbol: \"ETH\",\n    decimals: 18,\n    wrapped: {\n      address: \"0x5FbDB2315678afecb367f032d93F642f64180aa3\",\n      name: \"Wrapped Ether\",\n      symbol: \"WETH\"\n    }\n  },\n  84531: {\n    name: \"Base Goerli Testnet\",\n    symbol: \"ETH\",\n    decimals: 18,\n    wrapped: {\n      address: \"0x4200000000000000000000000000000000000006\",\n      name: \"Wrapped Ether\",\n      symbol: \"WETH\"\n    }\n  },\n  // eslint-disable-next-line no-useless-computed-key\n  [280]: {\n    name: \"zkSync Era Testnet\",\n    symbol: \"ETH\",\n    decimals: 18,\n    wrapped: {\n      address: \"0x5AEa5775959fBC2557Cc8789bC1bf90A239D9a91\",\n      name: \"Wrapped Ether\",\n      symbol: \"WETH\"\n    }\n  }\n};\n\n/**\n * Returns the native token for a given chain\n * @param chainId - the chain id\n * @public\n */\nfunction getNativeTokenByChainId(chainId) {\n  const chain = getSupportedChains().find(c => c.chainId === chainId);\n  if (chain && chain.nativeCurrency) {\n    return {\n      name: chain.nativeCurrency.name,\n      symbol: chain.nativeCurrency.symbol,\n      decimals: 18,\n      wrapped: {\n        address: constants.AddressZero,\n        name: `Wrapped ${chain.nativeCurrency.name}`,\n        symbol: `W${chain.nativeCurrency.symbol}`\n      }\n    };\n  }\n  return NATIVE_TOKENS[chainId] || {\n    name: \"Ether\",\n    symbol: \"ETH\",\n    decimals: 18,\n    wrapped: {\n      address: constants.AddressZero,\n      name: \"Wrapped Ether\",\n      symbol: \"WETH\"\n    }\n  };\n}\nconst LINK_TOKEN_ADDRESS = {\n  [ChainId.Mainnet]: \"0x514910771AF9Ca656af840dff83E8264EcF986CA\",\n  [ChainId.Goerli]: \"0x326C977E6efc84E512bB9C30f76E30c160eD06FB\",\n  [ChainId.BinanceSmartChainMainnet]: \"0x404460C6A5EdE2D891e8297795264fDe62ADBB75\",\n  [ChainId.Polygon]: \"0xb0897686c545045aFc77CF20eC7A532E3120E0F1\",\n  [ChainId.Mumbai]: \"0x326C977E6efc84E512bB9C30f76E30c160eD06FB\",\n  [ChainId.Avalanche]: \"0x5947BB275c521040051D82396192181b413227A3\",\n  [ChainId.AvalancheFujiTestnet]: \"0x0b9d5D9136855f6FEc3c0993feE6E9CE8a297846\",\n  [ChainId.Fantom]: \"0x6F43FF82CCA38001B6699a8AC47A2d0E66939407\",\n  [ChainId.FantomTestnet]: \"0xfaFedb041c0DD4fA2Dc0d87a6B0979Ee6FA7af5F\"\n};\n\nconst RawDateSchema = /* @__PURE__ */(() => z.union([z.date().transform(i => {\n  return BigNumber.from(Math.floor(i.getTime() / 1000));\n}), z.number().transform(i => {\n  return BigNumber.from(i);\n})]))();\n\n/**\n * Default to now\n */\nconst StartDateSchema = /* @__PURE__ */(() => RawDateSchema.default(new Date(0)))();\n\n/**\n * Default to 10 years from now\n */\nconst EndDateSchema = /* @__PURE__ */(() => RawDateSchema.default(new Date(Date.now() + 1000 * 60 * 60 * 24 * 365 * 10)))();\n\n/**\n * @internal\n */\nconst CurrencySchema = /* @__PURE__ */(() => z.object({\n  name: z.string(),\n  symbol: z.string(),\n  decimals: z.number()\n}))();\n\n/**\n * @internal\n */\nconst CurrencyValueSchema = /* @__PURE__ */(() => CurrencySchema.extend({\n  value: BigNumberSchema,\n  displayValue: z.string()\n}))();\n\n/**\n * @internal\n */\nconst MerkleSchema = /* @__PURE__ */(() => z.object({\n  merkle: z.record(z.string()).default({})\n}))();\nconst SnapshotEntryInput = /* @__PURE__ */(() => z.object({\n  address: AddressOrEnsSchema,\n  maxClaimable: QuantitySchema.default(0),\n  // defaults to 0\n  price: QuantitySchema.optional(),\n  // defaults to unlimited, but can be undefined in old snapshots\n  currencyAddress: AddressOrEnsSchema.default(constants.AddressZero).optional() // defaults to AddressZero, but can be undefined for old snapshots\n}))();\n\n/**\n * @internal\n */\nconst SnapshotInputSchema = /* @__PURE__ */(() => z.union([z.array(z.string()).transform(async strings => await Promise.all(strings.map(address => SnapshotEntryInput.parseAsync({\n  address\n})))), z.array(SnapshotEntryInput)]))();\nconst SnapshotEntryWithProofSchema = /* @__PURE__ */(() => SnapshotEntryInput.extend({\n  proof: z.array(z.string())\n}))();\n\n/**\n * @internal\n */\nconst SnapshotSchema = /* @__PURE__ */(() => z.object({\n  /**\n   * The merkle root\n   */\n  merkleRoot: z.string(),\n  claims: z.array(SnapshotEntryWithProofSchema)\n}))();\n\n/**\n * @internal\n */\n\n/**\n * @internal\n */\nconst SnapshotInfoSchema = /* @__PURE__ */(() => z.object({\n  merkleRoot: z.string(),\n  snapshotUri: z.string()\n}))();\n\n/**\n * @internal\n */\nconst ClaimConditionMetadataSchema = /* @__PURE__ */(() => z.object({\n  name: z.string().optional()\n}).catchall(z.unknown()))();\n\n/**\n * @internal\n */\nconst ClaimConditionInputSchema = /* @__PURE__ */(() => z.object({\n  startTime: StartDateSchema,\n  currencyAddress: z.string().default(NATIVE_TOKEN_ADDRESS),\n  price: AmountSchema.default(0),\n  maxClaimableSupply: QuantitySchema,\n  maxClaimablePerWallet: QuantitySchema,\n  waitInSeconds: BigNumberishSchema.default(0),\n  merkleRootHash: BytesLikeSchema.default(utils.hexZeroPad([0], 32)),\n  snapshot: z.optional(SnapshotInputSchema).nullable(),\n  metadata: ClaimConditionMetadataSchema.optional()\n}))();\n\n/**\n * @internal\n */\nconst ClaimConditionInputArray = /* @__PURE__ */z.array(ClaimConditionInputSchema);\n\n/**\n * @internal\n */\nconst PartialClaimConditionInputSchema = /* @__PURE__ */ClaimConditionInputSchema.partial();\n\n/**\n * @internal\n */\nconst ClaimConditionOutputSchema = /* @__PURE__ */(() => ClaimConditionInputSchema.extend({\n  availableSupply: QuantitySchema,\n  currentMintSupply: QuantitySchema,\n  currencyMetadata: CurrencyValueSchema.default({\n    value: BigNumber.from(\"0\"),\n    displayValue: \"0\",\n    symbol: \"\",\n    decimals: 18,\n    name: \"\"\n  }),\n  price: BigNumberSchema,\n  waitInSeconds: BigNumberSchema,\n  startTime: BigNumberSchema.transform(n => new Date(n.toNumber() * 1000)),\n  snapshot: SnapshotInputSchema.optional().nullable()\n}))();\n\nfunction resolveOrGenerateId(requestUId) {\n  if (requestUId === undefined) {\n    const buffer = Buffer.alloc(16);\n    v4({}, buffer);\n    return utils.hexlify(utils.toUtf8Bytes(buffer.toString(\"hex\")));\n  } else {\n    return utils.hexlify(requestUId);\n  }\n}\n\n/**\n * @internal\n */\nconst BaseSignaturePayloadInput = /* @__PURE__ */(() => z.object({\n  to: AddressOrEnsSchema.refine(address => address.toLowerCase() !== constants.AddressZero, {\n    message: \"Cannot create payload to mint to zero address\"\n  }),\n  price: AmountSchema.default(0),\n  currencyAddress: AddressSchema.default(NATIVE_TOKEN_ADDRESS),\n  mintStartTime: StartDateSchema,\n  mintEndTime: EndDateSchema,\n  uid: z.string().optional().transform(arg => resolveOrGenerateId(arg)),\n  primarySaleRecipient: AddressOrEnsSchema.default(constants.AddressZero)\n}))();\n\n/**\n * @internal\n */\nconst Signature20PayloadInput = /* @__PURE__ */BaseSignaturePayloadInput.extend({\n  quantity: AmountSchema\n});\n\n/**\n * @internal\n */\nconst Signature20PayloadOutput = /* @__PURE__ */Signature20PayloadInput.extend({\n  mintStartTime: BigNumberSchema,\n  mintEndTime: BigNumberSchema\n});\n\n/**\n * @internal\n */\nconst Signature721PayloadInput = /* @__PURE__ */(() => BaseSignaturePayloadInput.extend({\n  metadata: NFTInputOrUriSchema,\n  royaltyRecipient: z.string().default(constants.AddressZero),\n  royaltyBps: BasisPointsSchema.default(0)\n}))();\n\n/**\n * @internal\n */\nconst Signature721PayloadOutput = /* @__PURE__ */(() => Signature721PayloadInput.extend({\n  metadata: NFTInputOrUriSchema.default(\"\"),\n  uri: z.string(),\n  royaltyBps: BigNumberSchema,\n  mintStartTime: BigNumberSchema,\n  mintEndTime: BigNumberSchema\n}))();\n\n/**\n * @internal\n */\nconst Signature1155PayloadInput = /* @__PURE__ */(() => Signature721PayloadInput.extend({\n  metadata: NFTInputOrUriSchema.default(\"\"),\n  quantity: BigNumberishSchema\n}))();\n\n/**\n * @internal\n */\nconst Signature1155PayloadInputWithTokenId = /* @__PURE__ */Signature1155PayloadInput.extend({\n  tokenId: BigNumberishSchema\n});\n\n/**\n * @internal\n */\nconst Signature1155PayloadOutput = /* @__PURE__ */Signature721PayloadOutput.extend({\n  tokenId: BigNumberSchema,\n  quantity: BigNumberSchema\n});\n\n/**\n * @internal\n */\nconst Signature721WithQuantityInput = /* @__PURE__ */(() => Signature721PayloadInput.extend({\n  metadata: NFTInputOrUriSchema.default(\"\"),\n  quantity: BigNumberSchema.default(1)\n}))();\n\n/**\n * @internal\n */\nconst Signature721WithQuantityOutput = /* @__PURE__ */(() => Signature721PayloadOutput.extend({\n  quantity: BigNumberSchema.default(1)\n}))();\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\n/**\n * @public\n */\n\nconst MintRequest20 = [{\n  name: \"to\",\n  type: \"address\"\n}, {\n  name: \"primarySaleRecipient\",\n  type: \"address\"\n}, {\n  name: \"quantity\",\n  type: \"uint256\"\n}, {\n  name: \"price\",\n  type: \"uint256\"\n}, {\n  name: \"currency\",\n  type: \"address\"\n}, {\n  name: \"validityStartTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"validityEndTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"uid\",\n  type: \"bytes32\"\n}];\nconst MintRequest721 = [{\n  name: \"to\",\n  type: \"address\"\n}, {\n  name: \"royaltyRecipient\",\n  type: \"address\"\n}, {\n  name: \"royaltyBps\",\n  type: \"uint256\"\n}, {\n  name: \"primarySaleRecipient\",\n  type: \"address\"\n}, {\n  name: \"uri\",\n  type: \"string\"\n}, {\n  name: \"price\",\n  type: \"uint256\"\n}, {\n  name: \"currency\",\n  type: \"address\"\n}, {\n  name: \"validityStartTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"validityEndTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"uid\",\n  type: \"bytes32\"\n}];\nconst MintRequest1155 = [{\n  name: \"to\",\n  type: \"address\"\n}, {\n  name: \"royaltyRecipient\",\n  type: \"address\"\n}, {\n  name: \"royaltyBps\",\n  type: \"uint256\"\n}, {\n  name: \"primarySaleRecipient\",\n  type: \"address\"\n}, {\n  name: \"tokenId\",\n  type: \"uint256\"\n}, {\n  name: \"uri\",\n  type: \"string\"\n}, {\n  name: \"quantity\",\n  type: \"uint256\"\n}, {\n  name: \"pricePerToken\",\n  type: \"uint256\"\n}, {\n  name: \"currency\",\n  type: \"address\"\n}, {\n  name: \"validityStartTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"validityEndTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"uid\",\n  type: \"bytes32\"\n}];\nconst MintRequest721withQuantity = [{\n  name: \"to\",\n  type: \"address\"\n}, {\n  name: \"royaltyRecipient\",\n  type: \"address\"\n}, {\n  name: \"royaltyBps\",\n  type: \"uint256\"\n}, {\n  name: \"primarySaleRecipient\",\n  type: \"address\"\n}, {\n  name: \"uri\",\n  type: \"string\"\n}, {\n  name: \"quantity\",\n  type: \"uint256\"\n}, {\n  name: \"pricePerToken\",\n  type: \"uint256\"\n}, {\n  name: \"currency\",\n  type: \"address\"\n}, {\n  name: \"validityStartTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"validityEndTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"uid\",\n  type: \"bytes32\"\n}];\nconst GenericRequest = [{\n  name: \"validityStartTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"validityEndTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"uid\",\n  type: \"bytes32\"\n}, {\n  name: \"data\",\n  type: \"bytes\"\n}];\n\n/**\n * @internal\n */\nconst CommonContractSchema = /* @__PURE__ */(() => z.object({\n  name: z.string(),\n  description: z.string().optional(),\n  image: FileOrBufferOrStringSchema.optional(),\n  external_link: z.string().optional(),\n  app_uri: z.string().optional(),\n  social_urls: z.record(z.string()).optional()\n}).catchall(z.unknown()))();\n/**\n * @internal\n */\nconst CommonContractOutputSchema = /* @__PURE__ */(() => CommonContractSchema.extend({\n  image: z.string().optional()\n}).catchall(z.unknown()))();\n\n/**\n * @internal\n */\nconst CommonRoyaltySchema = /* @__PURE__ */(() => z.object({\n  /**\n   * The amount of royalty collected on all royalties represented as basis points.\n   * The default is 0 (no royalties).\n   *\n   * 1 basis point = 0.01%\n   *\n   * For example: if this value is 100, then the royalty is 1% of the total sales.\n   *\n   *  @internalremarks used by OpenSea \"seller_fee_basis_points\"\n   */\n  seller_fee_basis_points: BasisPointsSchema.default(0),\n  /**\n   * The address of the royalty recipient. All royalties will be sent\n   * to this address.\n   * @internalremarks used by OpenSea \"fee_recipient\"\n   */\n  fee_recipient: AddressOrEnsSchema.default(constants.AddressZero)\n}))();\n\n/**\n * @internal\n */\nconst CommonPrimarySaleSchema = /* @__PURE__ */z.object({\n  /**\n   * primary sale recipient address\n   */\n  primary_sale_recipient: AddressOrEnsSchema\n});\n\n/**\n * @internal\n */\nconst CommonPlatformFeeSchema = /* @__PURE__ */(() => z.object({\n  /**\n   * platform fee basis points\n   */\n  platform_fee_basis_points: BasisPointsSchema.default(0),\n  /**\n   * platform fee recipient address\n   */\n  platform_fee_recipient: AddressOrEnsSchema.default(constants.AddressZero)\n}))();\n\n/**\n * @internal\n */\nconst CommonTrustedForwarderSchema = /* @__PURE__ */(() => z.object({\n  trusted_forwarders: z.array(AddressOrEnsSchema).default([])\n}))();\n\n/**\n * @internal\n */\nconst CommonSymbolSchema = /* @__PURE__ */(() => z.object({\n  symbol: z.string().default(\"\")\n}))();\n\n/**\n * @internal\n */\nconst BYOCContractMetadataSchema = /* @__PURE__ */(() => CommonContractSchema.catchall(z.union([BigNumberTransformSchema, z.unknown()])))();\n\n/**\n * @internal\n */\n\n/**\n * @internal\n */\nconst CustomContractInput = /* @__PURE__ */(() => BYOCContractMetadataSchema.merge(CommonRoyaltySchema.merge(MerkleSchema).merge(CommonSymbolSchema).partial()).catchall(z.any()))();\n\n/**\n * @internal\n */\nconst CustomContractOutput = /* @__PURE__ */(() => CommonContractOutputSchema.merge(CommonRoyaltySchema.merge(MerkleSchema).merge(CommonSymbolSchema).partial()).catchall(z.any()))();\n\n/**\n * @internal\n */\nconst CustomContractDeploy = /* @__PURE__ */(() => CustomContractInput.merge(CommonPlatformFeeSchema.merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema).partial()))();\n\n/**\n * @internal\n */\nconst CustomContractSchema = {\n  deploy: CustomContractDeploy,\n  output: CustomContractOutput,\n  input: CustomContractInput\n};\n\n/**\n * @internal\n */\nconst AbiTypeBaseSchema = /* @__PURE__ */(() => z.object({\n  type: z.string(),\n  name: z.string().default(\"\")\n}).catchall(z.any()))();\n\n/**\n * @internal\n */\nconst AbiTypeSchema = /* @__PURE__ */(() => AbiTypeBaseSchema.extend({\n  stateMutability: z.string().optional(),\n  components: z.array(AbiTypeBaseSchema).optional()\n}).catchall(z.any()))();\n\n/**\n * @internal\n */\nconst AbiObjectSchema = /* @__PURE__ */(() => z.object({\n  type: z.string(),\n  name: z.string().default(\"\"),\n  inputs: z.array(AbiTypeSchema).default([]),\n  outputs: z.array(AbiTypeSchema).default([])\n}).catchall(z.any()))();\n\n/**\n * @internal\n */\nconst AbiSchema = /* @__PURE__ */z.array(AbiObjectSchema);\n// if we want to statically type this for external usage it has to *awlways* be the output type\n\n// input type is only used internally\n/**\n * @internal\n */\n/**\n * @internal\n */\nconst PreDeployMetadata = /* @__PURE__ */(() => z.object({\n  name: z.string(),\n  metadataUri: z.string(),\n  bytecodeUri: z.string(),\n  analytics: z.any().optional()\n}).catchall(z.any()))();\n\n/**\n * @internal\n */\nconst ChainIdToAddressSchema = /* @__PURE__ */(() => z.record(z.string(), z.string()))();\n\n/**\n * @internal\n */\nconst CustomFactoryInput = /* @__PURE__ */(() => z.object({\n  factoryFunction: z.string(),\n  params: z.array(z.object({\n    name: z.string(),\n    type: z.string()\n  })).default([]),\n  customFactoryAddresses: ChainIdToAddressSchema\n}))();\n\n/**\n * @internal\n */\nconst FactoryDeploymentSchema = /* @__PURE__ */(() => z.object({\n  implementationAddresses: ChainIdToAddressSchema,\n  implementationInitializerFunction: z.string().default(\"initialize\"),\n  customFactoryInput: CustomFactoryInput.optional(),\n  factoryAddresses: ChainIdToAddressSchema.optional()\n}))();\n\n/**\n * @internal\n */\nconst DeployTypeInput = /* @__PURE__ */(() => z.union([z.literal(\"standard\"), z.literal(\"autoFactory\"), z.literal(\"customFactory\")]))();\n\n/**\n * @internal\n */\nconst RouterTypeInput = /* @__PURE__ */(() => z.union([z.literal(\"none\"), z.literal(\"plugin\"), z.literal(\"dynamic\")]))();\n\n/**\n * @internal\n */\nconst DeploymentNetworkInput = /* @__PURE__ */(() => z.object({\n  allNetworks: z.boolean().optional(),\n  networksEnabled: z.array(z.number()).default([])\n}))();\n\n/**\n * @internal\n */\nconst ExtraPublishMetadataSchemaInput = /* @__PURE__ */(() => z.object({\n  version: z.string().refine(v => {\n    try {\n      toSemver(v);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }, out => {\n    return {\n      message: `'${out}' is not a valid semantic version. Should be in the format of major.minor.patch. Ex: 0.4.1`\n    };\n  }),\n  displayName: z.string().optional(),\n  description: z.string().optional(),\n  readme: z.string().optional(),\n  license: z.string().optional(),\n  changelog: z.string().optional(),\n  tags: z.array(z.string()).optional(),\n  audit: FileOrBufferOrStringSchema.nullable().optional(),\n  logo: FileOrBufferOrStringSchema.nullable().optional(),\n  isDeployableViaFactory: z.boolean().optional(),\n  isDeployableViaProxy: z.boolean().optional(),\n  factoryDeploymentData: FactoryDeploymentSchema.optional(),\n  deployType: DeployTypeInput.optional(),\n  routerType: RouterTypeInput.optional(),\n  defaultExtensions: z.array(z.object({\n    extensionName: z.string(),\n    extensionVersion: z.string().default(\"latest\"),\n    publisherAddress: AddressOrEnsSchema\n  })).optional(),\n  networksForDeployment: DeploymentNetworkInput.optional(),\n  constructorParams: z.record(z.string(), z.object({\n    displayName: z.string().optional(),\n    description: z.string().optional(),\n    defaultValue: z.string().optional(),\n    hidden: z.boolean().optional()\n  }).catchall(z.any())).optional(),\n  compositeAbi: AbiSchema.optional()\n}).catchall(z.any()))();\n\n/**\n * @internal\n */\nconst ExtraPublishMetadataSchemaOutput = /* @__PURE__ */(() => ExtraPublishMetadataSchemaInput.extend({\n  audit: z.string().nullable().optional(),\n  logo: z.string().nullable().optional()\n}))();\n/**\n * @internal\n */\nconst FullPublishMetadataSchemaInput = /* @__PURE__ */(() => PreDeployMetadata.merge(ExtraPublishMetadataSchemaInput).extend({\n  publisher: AddressOrEnsSchema.optional()\n}))();\n\n/**\n * @internal\n */\nconst FullPublishMetadataSchemaOutput = /* @__PURE__ */(() => PreDeployMetadata.merge(ExtraPublishMetadataSchemaOutput).extend({\n  publisher: AddressOrEnsSchema.optional()\n}))();\n/**\n * @internal\n */\nconst ProfileSchemaInput = /* @__PURE__ */(() => z.object({\n  name: z.string().optional(),\n  bio: z.string().optional(),\n  avatar: FileOrBufferOrStringSchema.nullable().optional(),\n  website: z.string().optional(),\n  twitter: z.string().optional(),\n  telegram: z.string().optional(),\n  facebook: z.string().optional(),\n  github: z.string().optional(),\n  medium: z.string().optional(),\n  linkedin: z.string().optional(),\n  reddit: z.string().optional(),\n  discord: z.string().optional()\n}))();\nconst ProfileSchemaOutput = /* @__PURE__ */(() => ProfileSchemaInput.extend({\n  avatar: z.string().nullable().optional()\n}))();\n/**\n * @internal\n */\nconst PublishedContractSchema = /* @__PURE__ */(() => z.object({\n  id: z.string(),\n  timestamp: BigNumberishSchema,\n  metadataUri: z.string()\n}))();\n\n/**\n * @internal\n * Follows https://docs.soliditylang.org/en/v0.8.15/natspec-format.html\n */\nconst ContractInfoSchema = /* @__PURE__ */(() => z.object({\n  title: z.string().optional(),\n  author: z.string().optional(),\n  details: z.string().optional(),\n  notice: z.string().optional()\n}))();\n\n/**\n * @internal\n */\nconst CompilerMetadataFetchedSchema = /* @__PURE__ */(() => z.object({\n  name: z.string(),\n  abi: AbiSchema,\n  metadata: z.record(z.string(), z.any()),\n  info: ContractInfoSchema,\n  licenses: z.array(z.string().optional()).default([]).transform(v => {\n    return v.filter(license => license !== undefined);\n  }),\n  isPartialAbi: z.boolean().optional()\n}))();\n\n/**\n * @internal\n */\nconst PreDeployMetadataFetchedSchema = /* @__PURE__ */(() => PreDeployMetadata.merge(CompilerMetadataFetchedSchema).extend({\n  bytecode: z.string()\n}))();\n\nconst CallOverrideSchema = /* @__PURE__ */(() => z.object({\n  gasLimit: BigNumberishSchema.optional(),\n  gasPrice: BigNumberishSchema.optional(),\n  maxFeePerGas: BigNumberishSchema.optional(),\n  maxPriorityFeePerGas: BigNumberishSchema.optional(),\n  nonce: BigNumberishSchema.optional(),\n  value: BigNumberishSchema.optional(),\n  blockTag: z.union([z.string(), z.number()]).optional(),\n  from: AddressOrEnsSchema.optional(),\n  type: z.number().optional()\n}).strict())();\n\n/**\n * Encodes and decodes Contract functions\n * @public\n */\nclass ContractEncoder {\n  constructor(contractWrapper) {\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * Encodes the given contract function with argument\n   * @returns the encoded data\n   */\n  encode(fn, args) {\n    return this.contractWrapper.readContract.interface.encodeFunctionData(fn, args);\n  }\n\n  /**\n   * Decode encoded call data for a given function\n   * @param fn - the function to decode\n   * @param encodedArgs - the encoded arguments\n   */\n  decode(fn, encodedArgs) {\n    return this.contractWrapper.readContract.interface.decodeFunctionData(fn, encodedArgs);\n  }\n}\n\n/**\n * Error that may get thrown if IPFS returns nothing for a given uri.\n * @internal\n */\nclass NotFoundError extends Error {\n  /** @internal */\n  constructor(identifier) {\n    super(identifier ? `Object with id ${identifier} NOT FOUND` : \"NOT_FOUND\");\n  }\n}\n\n/**\n * Error that may get thrown if an invalid address was passed\n * @internal\n */\nclass InvalidAddressError extends Error {\n  /** @internal */\n  constructor(address) {\n    super(address ? `'${address}' is an invalid address` : \"Invalid address passed\");\n  }\n}\n\n/**\n * @internal\n */\nclass MissingRoleError extends Error {\n  /** @internal */\n  /** @internal */\n  constructor(address, role) {\n    super(`MISSING ROLE: ${address} does not have the '${role}' role`);\n  }\n}\n\n/**\n * @internal\n */\nclass AssetNotFoundError extends Error {\n  /** @internal */\n  /** @internal */\n  constructor() {\n    let message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"The asset you're trying to use could not be found.\";\n    super(`message: ${message}`);\n  }\n}\n\n/**\n * @internal\n */\nclass UploadError extends Error {\n  /** @internal */\n  constructor(message) {\n    super(`UPLOAD_FAILED: ${message}`);\n  }\n}\n\n/**\n * @internal\n */\nclass FileNameMissingError extends Error {\n  /** @internal */\n  constructor() {\n    super(\"File name is required when object is not a `File` type object.\");\n  }\n}\n\n/**\n * @internal\n */\nclass DuplicateFileNameError extends Error {\n  /** @internal */\n  constructor(fileName) {\n    super(`DUPLICATE_FILE_NAME_ERROR: File name ${fileName} was passed for more than one file.`);\n  }\n}\n\n/**\n * @internal\n */\nclass NotEnoughTokensError extends Error {\n  /** @internal */\n  constructor(contractAddress, quantity, available) {\n    super(`BALANCE ERROR: you do not have enough balance on contract ${contractAddress} to use ${quantity} tokens. You have ${available} tokens available.`);\n  }\n}\n\n/**\n * @internal\n */\nclass MissingOwnerRoleError extends Error {\n  /** @internal */\n  constructor() {\n    super(`LIST ERROR: you should be the owner of the token to list it.`);\n  }\n}\n\n/**\n * @internal\n */\nclass QuantityAboveLimitError extends Error {\n  /** @internal */\n  constructor(quantity) {\n    super(`BUY ERROR: You cannot buy more than ${quantity} tokens`);\n  }\n}\n\n/**\n * Thrown when data fails to fetch from storage.\n * @internal\n */\nclass FetchError extends Error {\n  /** @internal */\n  constructor(message, innerError) {\n    super(`FETCH_FAILED: ${message}`);\n    this.innerError = innerError;\n  }\n}\n\n/**\n * Thrown when attempting to create a snapshot with duplicate leafs\n * @internal\n */\nclass DuplicateLeafsError extends Error {\n  constructor(message) {\n    super(`DUPLICATE_LEAFS${message ? ` : ${message}` : \"\"}`);\n  }\n}\n\n/**\n * Thrown when attempting to update/cancel an auction that already started\n * @internal\n */\nclass AuctionAlreadyStartedError extends Error {\n  constructor(id) {\n    super(`Auction already started with existing bid${id ? `, id: ${id}` : \"\"}`);\n  }\n}\n\n/**\n * @internal\n */\nclass FunctionDeprecatedError extends Error {\n  /** @internal */\n  constructor(message) {\n    super(`FUNCTION DEPRECATED. ${message ? `Use ${message} instead` : \"\"}`);\n  }\n}\n\n/**\n * Thrown when trying to retrieve a listing from a marketplace that doesn't exist\n * @internal\n */\nclass ListingNotFoundError extends Error {\n  constructor(marketplaceContractAddress, listingId) {\n    super(`Could not find listing.${marketplaceContractAddress ? ` marketplace address: ${marketplaceContractAddress}` : \"\"}${listingId ? ` listing id: ${listingId}` : \"\"}`);\n  }\n}\n\n/**\n * Thrown when trying to retrieve a listing of the wrong type\n * @internal\n */\nclass WrongListingTypeError extends Error {\n  constructor(marketplaceContractAddress, listingId, actualType, expectedType) {\n    super(`Incorrect listing type. Are you sure you're using the right method?.${marketplaceContractAddress ? ` marketplace address: ${marketplaceContractAddress}` : \"\"}${listingId ? ` listing id: ${listingId}` : \"\"}${expectedType ? ` expected type: ${expectedType}` : \"\"}${actualType ? ` actual type: ${actualType}` : \"\"}`);\n  }\n}\n\n/**\n * Thrown when attempting to transfer an asset that has restricted transferability\n * @internal\n */\nclass RestrictedTransferError extends Error {\n  constructor(assetAddress) {\n    super(`Failed to transfer asset, transfer is restricted.${assetAddress ? ` Address : ${assetAddress}` : \"\"}`);\n  }\n}\n\n/**\n * Thrown when attempting to execute an admin-role function.\n * @internal\n */\nclass AdminRoleMissingError extends Error {\n  constructor(address, contractAddress) {\n    let message = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"Failed to execute transaction\";\n    super(`${message}, admin role is missing${address ? ` on address: ${address}` : \"\"}${contractAddress ? ` on contract: ${contractAddress}` : \"\"}`);\n  }\n}\n\n/**\n * Thrown when attempting to close an auction that has not ended\n * @internal\n */\nclass AuctionHasNotEndedError extends Error {\n  constructor(id, endTime) {\n    super(`Auction has not ended yet${id ? `, id: ${id}` : \"\"}${endTime ? `, end time: ${endTime.toString()}` : \"\"}`);\n  }\n}\n\n/**\n * Thrown when attempting to call a contract function that is not implemented\n * @internal\n */\nclass ExtensionNotImplementedError extends Error {\n  constructor(feature) {\n    super(`This functionality is not available because the contract does not implement the '${feature.name}' Extension. Learn how to unlock this functionality at https://portal.thirdweb.com/extensions `);\n  }\n}\n\n/**\n * @internal\n */\n\n/**\n * @public\n */\nclass TransactionError extends Error {\n  #reason;\n  #info;\n  #raw;\n  constructor(info, raw) {\n    let errorMessage = `\\n\\n\\n╔═══════════════════╗\\n║ TRANSACTION ERROR ║\\n╚═══════════════════╝\\n\\n`;\n    errorMessage += `Reason: ${info.reason}`;\n    errorMessage += `\\n\\n\\n╔═════════════════════════╗\\n║ TRANSACTION INFORMATION ║\\n╚═════════════════════════╝\\n`;\n    errorMessage += withSpaces(\"from\", info.from);\n    if (info.to) {\n      errorMessage += withSpaces(\"to\", info.contractName ? `${info.to} (${info.contractName})` : info.to);\n    }\n    errorMessage += withSpaces(`chain`, `${info.network.name} (${info.network.chainId})`);\n    if (info.rpcUrl) {\n      try {\n        const url = new URL(info.rpcUrl);\n        errorMessage += withSpaces(`rpc`, url.hostname);\n      } catch (e2) {\n        // ignore if can't parse URL\n      }\n    }\n    if (info.hash) {\n      errorMessage += withSpaces(`tx hash`, info.hash);\n    }\n    if (info.value && info.value.gt(0)) {\n      errorMessage += withSpaces(\"value\", `${utils.formatEther(info.value)} ${NATIVE_TOKENS[info.network.chainId]?.symbol || \"\"}`);\n    }\n    errorMessage += withSpaces(`data`, `${info.data}`);\n    if (info.method) {\n      errorMessage += withSpaces(\"method\", info.method);\n    }\n    if (info.sources) {\n      const revertFile = info.sources.find(file => file.source.includes(info.reason));\n      if (revertFile) {\n        const lines = revertFile.source.split(\"\\n\").map((line, index) => `${index + 1}  ${line}`);\n        const revertLine = lines.findIndex(line => line.includes(info.reason));\n        lines[revertLine] += \"   <-- REVERT\";\n        const errorLines = lines.slice(revertLine - 8, revertLine + 4);\n        errorMessage += `\\n\\n\\n╔══════════════════════╗\\n║ SOLIDITY STACK TRACE ║\\n╚══════════════════════╝\\n\\n`;\n        errorMessage += `File: ${revertFile.filename.replace(\"node_modules/\", \"\")}\\n\\n`;\n        errorMessage += errorLines.join(\"\\n\");\n      }\n    }\n    errorMessage += `\\n\\n\\n╔═════════════════════╗\\n║ DEBUGGING RESOURCES ║\\n╚═════════════════════╝\\n\\n`;\n    errorMessage += `Need helping debugging? Join our Discord: https://discord.gg/thirdweb`;\n    errorMessage += `\\n\\n`;\n    super(errorMessage);\n    this.#reason = info.reason;\n    this.#info = info;\n    this.#raw = raw;\n  }\n\n  // Keep reason here for backwards compatibility\n  get reason() {\n    return this.#reason;\n  }\n  get raw() {\n    return this.#raw;\n  }\n  get info() {\n    return this.#info;\n  }\n}\n\n/**\n * @internal\n */\nfunction parseRevertReason(error) {\n  if (error.reason && !error.reason.includes(\"cannot estimate gas\")) {\n    return error.reason;\n  }\n  if (error.error) {\n    return error.error;\n  }\n\n  // I think this code path should never be hit, but just in case\n\n  let errorString = error;\n  if (typeof error === \"object\") {\n    // MetaMask errors come as objects so parse them first\n    errorString = JSON.stringify(error);\n  } else if (typeof error !== \"string\") {\n    errorString = error.toString();\n  }\n  return parseMessageParts(/.*?\"message\":\"([^\"\\\\]*).*?/, errorString) || parseMessageParts(/.*?\"reason\":\"([^\"\\\\]*).*?/, errorString) || error.message || \"\";\n}\nfunction withSpaces(label, content) {\n  if (content === \"\") {\n    return content;\n  }\n  const spaces = Array(10 - label.length).fill(\" \").join(\"\");\n  if (content.includes(\"\\n\")) {\n    content = \"\\n\\n  \" + content.split(\"\\n\").join(`\\n  `);\n  } else {\n    content = `${spaces}${content}`;\n  }\n  return `\\n${label}:${content}`;\n}\nfunction parseMessageParts(regex, raw) {\n  const msgMatches = raw.match(regex) || [];\n  let extracted = \"\";\n  if (msgMatches?.length > 0) {\n    extracted += msgMatches[1];\n  }\n  return extracted;\n}\n\n/**\n * @internal\n * @param err\n * @param message\n */\nfunction includesErrorMessage(err, message) {\n  if (!err) {\n    return false;\n  }\n  return err && err.toString().includes(message) || err && err.message && err.message.toString().includes(message) || err && err.error && err.error.toString().includes(message);\n}\n\nconst FEATURE_TOKEN_CLAIM_CONDITIONS_V1 = {\n  name: \"ERC20ClaimConditionsV1\",\n  namespace: \"token.drop.claim\",\n  docLinks: {\n    sdk: \"sdk.erc20dclaimable\",\n    contracts: \"erc20claimconditions\"\n  },\n  abis: [ERC20Abi, IDropSinglePhaseV1],\n  features: {}\n};\nconst FEATURE_TOKEN_CLAIM_CONDITIONS_V2 = {\n  name: \"ERC20ClaimConditionsV2\",\n  namespace: \"token.drop.claim\",\n  docLinks: {\n    sdk: \"sdk.erc20dclaimable\",\n    contracts: \"erc20claimconditions\"\n  },\n  abis: [ERC20Abi, IDropSinglePhase],\n  features: {}\n};\nconst FEATURE_TOKEN_CLAIM_PHASES_V2 = {\n  name: \"ERC20ClaimPhasesV2\",\n  namespace: \"token.drop.claim\",\n  docLinks: {\n    sdk: \"sdk.erc20dclaimable\",\n    contracts: \"erc20claimphases\"\n  },\n  abis: [ERC20Abi, IDrop],\n  features: {}\n};\nconst FEATURE_TOKEN_CLAIM_PHASES_V1 = {\n  name: \"ERC20ClaimPhasesV1\",\n  namespace: \"token.drop.claim\",\n  docLinks: {\n    sdk: \"sdk.erc20dclaimable\",\n    contracts: \"erc20claimphases\"\n  },\n  abis: [DropERC20_V2Abi],\n  features: {}\n};\nconst FEATURE_TOKEN_BURNABLE = {\n  name: \"ERC20Burnable\",\n  namespace: \"token.burn\",\n  docLinks: {\n    sdk: \"sdk.erc20burnable\",\n    contracts: \"erc20burnable\"\n  },\n  abis: [ERC20Abi, IBurnableERC20Abi],\n  features: {}\n};\nconst FEATURE_TOKEN_SIGNATURE_MINTABLE = {\n  name: \"ERC20SignatureMintable\",\n  namespace: \"token.signature\",\n  docLinks: {\n    sdk: \"sdk.erc20signaturemintable\",\n    contracts: \"erc20signaturemint\"\n  },\n  abis: [ERC20Abi, ISignatureMintERC20Abi],\n  features: {}\n};\nconst FEATURE_TOKEN_BATCH_MINTABLE = {\n  name: \"ERC20BatchMintable\",\n  namespace: \"token.mint.batch\",\n  docLinks: {\n    sdk: \"sdk.erc20batchmintable\",\n    contracts: \"erc20batchmintable\"\n  },\n  abis: [ERC20Abi, IMintableERC20Abi, MulticallAbi],\n  features: {}\n};\nconst FEATURE_TOKEN_MINTABLE = {\n  name: \"ERC20Mintable\",\n  namespace: \"token.mint\",\n  docLinks: {\n    sdk: \"sdk.erc20mintable\",\n    contracts: \"erc20mintable\"\n  },\n  abis: [ERC20Abi, IMintableERC20Abi],\n  features: {\n    [FEATURE_TOKEN_BATCH_MINTABLE.name]: FEATURE_TOKEN_BATCH_MINTABLE\n  }\n};\nconst FEATURE_TOKEN_PERMIT = {\n  name: \"ERC20Permit\",\n  namespace: \"token.permit\",\n  docLinks: {\n    sdk: \"sdk.erc20permit\",\n    contracts: \"erc20permit\"\n  },\n  abis: [ERC20Abi, IERC20PermitAbi],\n  features: {}\n};\nconst FEATURE_TOKEN = {\n  name: \"ERC20\",\n  namespace: \"token\",\n  docLinks: {\n    sdk: \"sdk.erc20\",\n    contracts: \"erc20\"\n  },\n  abis: [ERC20Abi, IERC20MetadataAbi],\n  features: {\n    [FEATURE_TOKEN_BURNABLE.name]: FEATURE_TOKEN_BURNABLE,\n    [FEATURE_TOKEN_MINTABLE.name]: FEATURE_TOKEN_MINTABLE,\n    [FEATURE_TOKEN_CLAIM_CONDITIONS_V1.name]: FEATURE_TOKEN_CLAIM_CONDITIONS_V1,\n    [FEATURE_TOKEN_CLAIM_CONDITIONS_V2.name]: FEATURE_TOKEN_CLAIM_CONDITIONS_V2,\n    [FEATURE_TOKEN_CLAIM_PHASES_V1.name]: FEATURE_TOKEN_CLAIM_PHASES_V1,\n    [FEATURE_TOKEN_CLAIM_PHASES_V2.name]: FEATURE_TOKEN_CLAIM_PHASES_V2,\n    [FEATURE_TOKEN_SIGNATURE_MINTABLE.name]: FEATURE_TOKEN_SIGNATURE_MINTABLE,\n    [FEATURE_TOKEN_PERMIT.name]: FEATURE_TOKEN_PERMIT\n  }\n};\n\nconst FEATURE_NFT_BURNABLE = {\n  name: \"ERC721Burnable\",\n  namespace: \"nft.burn\",\n  docLinks: {\n    sdk: \"sdk.erc721burnable\",\n    contracts: \"erc721burnable\"\n  },\n  abis: [Erc721Abi, IBurnableERC721Abi],\n  features: {}\n};\nconst FEATURE_NFT_REVEALABLE = {\n  name: \"ERC721Revealable\",\n  namespace: \"nft.drop.revealer\",\n  docLinks: {\n    sdk: \"sdk.delayedreveal\",\n    contracts: \"erc721revealable\"\n  },\n  abis: [Erc721Abi, ILazyMintAbi, DelayedRevealAbi],\n  features: {}\n};\nconst FEATURE_NFT_TIERED_DROP = {\n  name: \"ERC721TieredDrop\",\n  namespace: \"nft.tieredDrop\",\n  docLinks: {\n    sdk: \"sdk.erc721tiereddrop\",\n    //TODO\n    contracts: \"\"\n  },\n  abis: [Erc721Abi, TieredDropAbi],\n  features: {}\n};\nconst FEATURE_NFT_CLAIM_CONDITIONS_V1 = {\n  name: \"ERC721ClaimConditionsV1\",\n  namespace: \"nft.drop.claim\",\n  docLinks: {\n    sdk: \"sdk.erc721claimable\",\n    contracts: \"erc721claimconditions\"\n  },\n  abis: [Erc721Abi, IDropSinglePhaseV1],\n  features: {}\n};\nconst FEATURE_NFT_CLAIM_CONDITIONS_V2 = {\n  name: \"ERC721ClaimConditionsV2\",\n  namespace: \"nft.drop.claim\",\n  docLinks: {\n    sdk: \"sdk.erc721claimable\",\n    contracts: \"erc721claimconditions\"\n  },\n  abis: [Erc721Abi, IDropSinglePhase],\n  features: {}\n};\nconst FEATURE_NFT_CLAIM_PHASES_V1 = {\n  name: \"ERC721ClaimPhasesV1\",\n  namespace: \"nft.drop.claim\",\n  docLinks: {\n    sdk: \"sdk.erc721claimable\",\n    contracts: \"erc721claimphases\"\n  },\n  abis: [DropERC721_V3Abi],\n  features: {}\n};\nconst FEATURE_NFT_CLAIM_PHASES_V2 = {\n  name: \"ERC721ClaimPhasesV2\",\n  namespace: \"nft.drop.claim\",\n  docLinks: {\n    sdk: \"sdk.erc721claimable\",\n    contracts: \"erc721claimphases\"\n  },\n  abis: [Erc721Abi, IDrop],\n  features: {}\n};\nconst FEATURE_NFT_CLAIM_CUSTOM = {\n  name: \"ERC721ClaimCustom\",\n  namespace: \"nft.drop.claim\",\n  docLinks: {\n    sdk: \"sdk.erc721claimable\",\n    contracts: \"erc721claimcustom\"\n  },\n  abis: [Erc721Abi, IClaimableERC721],\n  features: {}\n};\nconst FEATURE_NFT_CLAIM_ZORA = {\n  name: \"ERC721ClaimZora\",\n  namespace: \"nft.drop.claim\",\n  docLinks: {\n    sdk: \"sdk.erc721claimable\",\n    contracts: \"erc721claimzora\"\n  },\n  abis: [Erc721Abi, zora_IDropERC721],\n  features: {}\n};\nconst FEATURE_NFT_LAZY_MINTABLE = {\n  name: \"ERC721LazyMintable\",\n  namespace: \"nft.drop\",\n  docLinks: {\n    sdk: \"sdk.erc721lazymintable\",\n    contracts: \"lazymint\"\n  },\n  abis: [Erc721Abi, ILazyMintAbi],\n  features: {\n    [FEATURE_NFT_REVEALABLE.name]: FEATURE_NFT_REVEALABLE\n  }\n};\nconst FEATURE_NFT_BATCH_MINTABLE = {\n  name: \"ERC721BatchMintable\",\n  namespace: \"nft.mint.batch\",\n  docLinks: {\n    sdk: \"sdk.erc721batchmintable\",\n    contracts: \"erc721batchmintable\"\n  },\n  abis: [Erc721Abi, IMintableERC721Abi, MulticallAbi],\n  features: {}\n};\nconst FEATURE_NFT_MINTABLE = {\n  name: \"ERC721Mintable\",\n  namespace: \"nft.mint\",\n  docLinks: {\n    sdk: \"sdk.erc721mintable\",\n    contracts: \"erc721mintable\"\n  },\n  abis: [Erc721Abi, IMintableERC721Abi],\n  features: {\n    [FEATURE_NFT_BATCH_MINTABLE.name]: FEATURE_NFT_BATCH_MINTABLE\n  }\n};\nconst FEATURE_NFT_SIGNATURE_MINTABLE_V2 = {\n  name: \"ERC721SignatureMintV2\",\n  namespace: \"nft.signature\",\n  docLinks: {\n    sdk: \"sdk.erc721signaturemint\",\n    contracts: \"erc721signaturemint\"\n  },\n  abis: [Erc721Abi, SignatureMintERC721Abi],\n  features: {}\n};\nconst FEATURE_NFT_SIGNATURE_MINTABLE_V1 = {\n  name: \"ERC721SignatureMintV1\",\n  namespace: \"nft.signature\",\n  docLinks: {\n    sdk: \"sdk.erc721signaturemint\",\n    contracts: \"erc721signaturemint\"\n  },\n  abis: [SignatureMintERC721_V1Abi],\n  features: {}\n};\nconst FEATURE_NFT_ENUMERABLE = {\n  name: \"ERC721Enumerable\",\n  namespace: \"nft.query.owned\",\n  docLinks: {\n    sdk: \"sdk.erc721enumerable\",\n    contracts: \"erc721enumerable\"\n  },\n  abis: [Erc721Abi, Erc721EnumerableAbi],\n  features: {}\n};\nconst FEATURE_NFT_QUERYABLE = {\n  name: \"ERC721AQueryable\",\n  namespace: \"nft.query.owned\",\n  docLinks: {\n    sdk: \"\",\n    contracts: \"\"\n  },\n  abis: [Erc721AQueryableAbi],\n  features: {}\n};\nconst FEATURE_NFT_SUPPLY = {\n  name: \"ERC721Supply\",\n  namespace: \"nft.query\",\n  docLinks: {\n    sdk: \"sdk.erc721supply\",\n    contracts: \"erc721supply\"\n  },\n  abis: [Erc721Abi, Erc721SupplyAbi],\n  features: {\n    [FEATURE_NFT_ENUMERABLE.name]: FEATURE_NFT_ENUMERABLE,\n    [FEATURE_NFT_QUERYABLE.name]: FEATURE_NFT_QUERYABLE\n  }\n};\nconst FEATURE_NFT_SHARED_METADATA = {\n  name: \"ERC721SharedMetadata\",\n  namespace: \"nft.sharedmetadata\",\n  docLinks: {\n    sdk: \"sdk.sharedmetadata\",\n    contracts: \"SharedMetadata\"\n  },\n  abis: [Erc721Abi, SharedMetadataAbi],\n  features: {}\n};\nconst FEATURE_NFT_LOYALTY_CARD = {\n  name: \"ERC721LoyaltyCard\",\n  namespace: \"nft.loyaltyCard\",\n  docLinks: {\n    // TODO\n    sdk: \"\",\n    contracts: \"\"\n  },\n  abis: [ILoyaltyCardAbi],\n  features: {}\n};\nconst FEATURE_NFT_UPDATABLE_METADATA = {\n  name: \"ERC721UpdatableMetadata\",\n  namespace: \"nft.metadata\",\n  docLinks: {\n    // TODO\n    sdk: \"\",\n    contracts: \"\"\n  },\n  abis: [Erc721Abi, INFTMetadataAbi],\n  features: {}\n};\nconst FEATURE_NFT = {\n  name: \"ERC721\",\n  namespace: \"nft\",\n  docLinks: {\n    sdk: \"sdk.erc721\",\n    contracts: \"erc721\"\n  },\n  abis: [Erc721Abi, IERC721MetadataAbi],\n  features: {\n    [FEATURE_NFT_BURNABLE.name]: FEATURE_NFT_BURNABLE,\n    [FEATURE_NFT_SUPPLY.name]: FEATURE_NFT_SUPPLY,\n    [FEATURE_NFT_MINTABLE.name]: FEATURE_NFT_MINTABLE,\n    [FEATURE_NFT_LAZY_MINTABLE.name]: FEATURE_NFT_LAZY_MINTABLE,\n    [FEATURE_NFT_SIGNATURE_MINTABLE_V1.name]: FEATURE_NFT_SIGNATURE_MINTABLE_V1,\n    [FEATURE_NFT_SIGNATURE_MINTABLE_V2.name]: FEATURE_NFT_SIGNATURE_MINTABLE_V2,\n    [FEATURE_NFT_TIERED_DROP.name]: FEATURE_NFT_TIERED_DROP,\n    [FEATURE_NFT_CLAIM_CUSTOM.name]: FEATURE_NFT_CLAIM_CUSTOM,\n    [FEATURE_NFT_CLAIM_ZORA.name]: FEATURE_NFT_CLAIM_ZORA,\n    [FEATURE_NFT_CLAIM_CONDITIONS_V1.name]: FEATURE_NFT_CLAIM_CONDITIONS_V1,\n    [FEATURE_NFT_CLAIM_CONDITIONS_V2.name]: FEATURE_NFT_CLAIM_CONDITIONS_V2,\n    [FEATURE_NFT_CLAIM_PHASES_V1.name]: FEATURE_NFT_CLAIM_PHASES_V1,\n    [FEATURE_NFT_CLAIM_PHASES_V2.name]: FEATURE_NFT_CLAIM_PHASES_V2,\n    [FEATURE_NFT_SHARED_METADATA.name]: FEATURE_NFT_SHARED_METADATA,\n    [FEATURE_NFT_LOYALTY_CARD.name]: FEATURE_NFT_LOYALTY_CARD,\n    [FEATURE_NFT_UPDATABLE_METADATA.name]: FEATURE_NFT_UPDATABLE_METADATA\n  }\n};\n\n// TODO could be part of IERC1155Metadata even though its not in the spec\nconst NAME_SYMBOL_ABI = [{\n  inputs: [],\n  name: \"name\",\n  outputs: [{\n    internalType: \"string\",\n    name: \"\",\n    type: \"string\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"symbol\",\n  outputs: [{\n    internalType: \"string\",\n    name: \"\",\n    type: \"string\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}];\nconst FEATURE_EDITION_BURNABLE = {\n  name: \"ERC1155Burnable\",\n  namespace: \"edition.burn\",\n  docLinks: {\n    sdk: \"sdk.erc1155burnable\",\n    contracts: \"erc1155burnable\"\n  },\n  abis: [Erc1155Abi, IBurnableERC1155Abi],\n  features: {}\n};\nconst FEATURE_EDITION_CLAIM_CONDITIONS_V1 = {\n  name: \"ERC1155ClaimConditionsV1\",\n  namespace: \"edition.drop.claim\",\n  docLinks: {\n    sdk: \"sdk.erc1155claimable\",\n    contracts: \"erc1155dropsinglephase\"\n  },\n  abis: [Erc1155Abi, IDropSinglePhase1155_V1],\n  features: {}\n};\nconst FEATURE_EDITION_CLAIM_CONDITIONS_V2 = {\n  name: \"ERC1155ClaimConditionsV2\",\n  namespace: \"edition.drop.claim\",\n  docLinks: {\n    sdk: \"sdk.erc1155claimable\",\n    contracts: \"erc1155claimconditions\"\n  },\n  abis: [Erc1155Abi, IDropSinglePhase1155],\n  features: {}\n};\nconst FEATURE_EDITION_CLAIM_PHASES_V2 = {\n  name: \"ERC1155ClaimPhasesV2\",\n  namespace: \"edition.drop.claim\",\n  docLinks: {\n    sdk: \"sdk.erc1155claimable\",\n    contracts: \"erc1155claimphases\"\n  },\n  abis: [Erc1155Abi, IDropMultiPhase1155],\n  features: {}\n};\nconst FEATURE_EDITION_CLAIM_PHASES_V1 = {\n  name: \"ERC1155ClaimPhasesV1\",\n  namespace: \"edition.drop.claim\",\n  docLinks: {\n    sdk: \"sdk.erc1155claimable\",\n    contracts: \"erc1155claimphases\"\n  },\n  abis: [DropERC1155_V2Abi],\n  features: {}\n};\nconst FEATURE_EDITION_CLAIM_CUSTOM = {\n  name: \"ERC1155ClaimCustom\",\n  namespace: \"edition.drop.claim\",\n  docLinks: {\n    sdk: \"sdk.erc1155claimable\",\n    contracts: \"erc1155claimcustom\"\n  },\n  abis: [Erc1155Abi, IClaimableERC1155],\n  features: {}\n};\nconst FEATURE_EDITION_REVEALABLE = {\n  name: \"ERC1155Revealable\",\n  namespace: \"edition.drop.revealer\",\n  docLinks: {\n    sdk: \"sdk.drop.delayedreveal\",\n    contracts: \"erc1155revealable\"\n  },\n  abis: [Erc1155Abi, ILazyMintAbi, DelayedRevealAbi],\n  features: {}\n};\nconst FEATURE_EDITION_LAZY_MINTABLE_V2 = {\n  name: \"ERC1155LazyMintableV2\",\n  namespace: \"edition.drop\",\n  docLinks: {\n    sdk: \"sdk.erc1155droppable\",\n    contracts: \"lazymint\"\n  },\n  abis: [Erc1155Abi, ILazyMintAbi],\n  features: {\n    [FEATURE_EDITION_REVEALABLE.name]: FEATURE_EDITION_REVEALABLE\n  }\n};\nconst FEATURE_EDITION_LAZY_MINTABLE_V1 = {\n  name: \"ERC1155LazyMintableV1\",\n  namespace: \"edition.drop\",\n  docLinks: {\n    sdk: \"sdk.erc1155droppable\",\n    contracts: \"lazymint\"\n  },\n  abis: [DropERC1155_V2Abi],\n  features: {\n    [FEATURE_EDITION_CLAIM_PHASES_V1.name]: FEATURE_EDITION_CLAIM_PHASES_V1\n  }\n};\nconst FEATURE_EDITION_SIGNATURE_MINTABLE = {\n  name: \"ERC1155SignatureMintable\",\n  namespace: \"edition.signature\",\n  docLinks: {\n    sdk: \"sdk.erc1155signaturemintable\",\n    contracts: \"erc1155signaturemint\"\n  },\n  abis: [Erc1155Abi, ISignatureMintERC1155Abi],\n  features: {}\n};\nconst FEATURE_EDITION_BATCH_MINTABLE = {\n  name: \"ERC1155BatchMintable\",\n  namespace: \"edition.mint.batch\",\n  docLinks: {\n    sdk: \"sdk.erc1155batchmintable\",\n    contracts: \"erc1155batchmintable\"\n  },\n  abis: [Erc1155Abi, IMintableERC1155Abi, MulticallAbi],\n  features: {}\n};\nconst FEATURE_EDITION_MINTABLE = {\n  name: \"ERC1155Mintable\",\n  namespace: \"edition.mint\",\n  docLinks: {\n    sdk: \"sdk.erc1155mintable\",\n    contracts: \"erc1155mintable\"\n  },\n  abis: [Erc1155Abi, IMintableERC1155Abi],\n  features: {\n    [FEATURE_EDITION_BATCH_MINTABLE.name]: FEATURE_EDITION_BATCH_MINTABLE\n  }\n};\nconst FEATURE_EDITION_ENUMERABLE = {\n  name: \"ERC1155Enumerable\",\n  namespace: \"edition.query\",\n  docLinks: {\n    sdk: \"sdk.erc1155\",\n    contracts: \"erc1155enumerable\"\n  },\n  abis: [Erc1155Abi, Erc1155EnumerableAbi],\n  features: {}\n};\nconst FEATURE_EDITION_UPDATABLE_METADATA = {\n  name: \"ERC1155UpdatableMetadata\",\n  namespace: \"edition.metadata\",\n  docLinks: {\n    // TODO\n    sdk: \"\",\n    contracts: \"\"\n  },\n  abis: [Erc1155Abi, INFTMetadataAbi],\n  features: {}\n};\nconst FEATURE_EDITION_SUPPLY = {\n  name: \"ERC1155Supply\",\n  namespace: \"edition.supply\",\n  docLinks: {\n    sdk: \"\",\n    contracts: \"\"\n  },\n  abis: [Erc1155Abi, Erc1155SupplyAbi],\n  features: {}\n};\nconst FEATURE_EDITION = {\n  name: \"ERC1155\",\n  namespace: \"edition\",\n  docLinks: {\n    sdk: \"sdk.erc1155enumerable\",\n    contracts: \"erc1155\"\n  },\n  abis: [Erc1155Abi, Erc1155MetadataAbi, NAME_SYMBOL_ABI],\n  features: {\n    [FEATURE_EDITION_SUPPLY.name]: FEATURE_EDITION_SUPPLY,\n    [FEATURE_EDITION_BURNABLE.name]: FEATURE_EDITION_BURNABLE,\n    [FEATURE_EDITION_ENUMERABLE.name]: FEATURE_EDITION_ENUMERABLE,\n    [FEATURE_EDITION_MINTABLE.name]: FEATURE_EDITION_MINTABLE,\n    [FEATURE_EDITION_LAZY_MINTABLE_V1.name]: FEATURE_EDITION_LAZY_MINTABLE_V1,\n    [FEATURE_EDITION_LAZY_MINTABLE_V2.name]: FEATURE_EDITION_LAZY_MINTABLE_V2,\n    [FEATURE_EDITION_REVEALABLE.name]: FEATURE_EDITION_REVEALABLE,\n    [FEATURE_EDITION_SIGNATURE_MINTABLE.name]: FEATURE_EDITION_SIGNATURE_MINTABLE,\n    [FEATURE_EDITION_CLAIM_CUSTOM.name]: FEATURE_EDITION_CLAIM_CUSTOM,\n    [FEATURE_EDITION_CLAIM_CONDITIONS_V1.name]: FEATURE_EDITION_CLAIM_CONDITIONS_V1,\n    [FEATURE_EDITION_CLAIM_CONDITIONS_V2.name]: FEATURE_EDITION_CLAIM_CONDITIONS_V2,\n    [FEATURE_EDITION_CLAIM_PHASES_V2.name]: FEATURE_EDITION_CLAIM_PHASES_V2,\n    [FEATURE_EDITION_UPDATABLE_METADATA.name]: FEATURE_EDITION_UPDATABLE_METADATA\n  }\n};\n\nconst getAllPluginsAbi = [{\n  inputs: [],\n  name: \"getAllPlugins\",\n  outputs: [{\n    components: [{\n      internalType: \"bytes4\",\n      name: \"functionSelector\",\n      type: \"bytes4\"\n    }, {\n      internalType: \"string\",\n      name: \"functionSignature\",\n      type: \"string\"\n    }, {\n      internalType: \"address\",\n      name: \"pluginAddress\",\n      type: \"address\"\n    }],\n    internalType: \"struct IPluginMap.Plugin[]\",\n    name: \"registered\",\n    type: \"tuple[]\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}];\nconst getAllExtensionsAbi = [{\n  inputs: [],\n  name: \"getAllExtensions\",\n  outputs: [{\n    components: [{\n      components: [{\n        internalType: \"string\",\n        name: \"name\",\n        type: \"string\"\n      }, {\n        internalType: \"string\",\n        name: \"metadataURI\",\n        type: \"string\"\n      }, {\n        internalType: \"address\",\n        name: \"implementation\",\n        type: \"address\"\n      }],\n      internalType: \"struct IExtension.ExtensionMetadata\",\n      name: \"metadata\",\n      type: \"tuple\"\n    }, {\n      components: [{\n        internalType: \"bytes4\",\n        name: \"functionSelector\",\n        type: \"bytes4\"\n      }, {\n        internalType: \"string\",\n        name: \"functionSignature\",\n        type: \"string\"\n      }],\n      internalType: \"struct IExtension.ExtensionFunction[]\",\n      name: \"functions\",\n      type: \"tuple[]\"\n    }],\n    internalType: \"struct IExtension.Extension[]\",\n    name: \"allExtensions\",\n    type: \"tuple[]\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}];\nconst FEATURE_ROYALTY = {\n  name: \"Royalty\",\n  namespace: \"royalty\",\n  docLinks: {\n    sdk: \"sdk.contractroyalty\",\n    contracts: \"royalty\"\n  },\n  abis: [IThirdwebRoyaltyAbi],\n  features: {}\n};\nconst FEATURE_PRIMARY_SALE = {\n  name: \"PrimarySale\",\n  namespace: \"sales\",\n  docLinks: {\n    sdk: \"sdk.contractprimarysale\",\n    contracts: \"primarysale\"\n  },\n  abis: [IThirdwebPrimarySaleAbi],\n  features: {}\n};\nconst FEATURE_PLATFORM_FEE = {\n  name: \"PlatformFee\",\n  namespace: \"platformFees\",\n  docLinks: {\n    sdk: \"sdk.platformfee\",\n    contracts: \"platformfee\"\n  },\n  abis: [IThirdwebPlatformFeeAbi],\n  features: {}\n};\nconst FEATURE_PERMISSIONS_ENUMERABLE = {\n  name: \"PermissionsEnumerable\",\n  namespace: \"roles\",\n  docLinks: {\n    sdk: \"sdk.contractroles\",\n    contracts: \"permissionsenumerable\"\n  },\n  abis: [IPermissionsEnumerableAbi],\n  features: {}\n};\nconst FEATURE_PERMISSIONS = {\n  name: \"Permissions\",\n  namespace: \"roles\",\n  docLinks: {\n    sdk: \"sdk.contractroles\",\n    contracts: \"permissions\"\n  },\n  abis: [IPermissionsAbi],\n  features: {\n    [FEATURE_PERMISSIONS_ENUMERABLE.name]: FEATURE_PERMISSIONS_ENUMERABLE\n  }\n};\nconst FEATURE_METADATA = {\n  name: \"ContractMetadata\",\n  namespace: \"metadata\",\n  docLinks: {\n    sdk: \"sdk.contractmetadata\",\n    contracts: \"contractmetadata\"\n  },\n  abis: [IContractMetadataAbi],\n  features: {}\n};\nconst FEATURE_APPURI = {\n  name: \"AppURI\",\n  namespace: \"appURI\",\n  docLinks: {\n    sdk: \"sdk.appURI\",\n    //TODO\n    contracts: \"\"\n  },\n  abis: [IAppURI],\n  features: {}\n};\nconst FEATURE_OWNER = {\n  name: \"Ownable\",\n  namespace: \"owner\",\n  docLinks: {\n    sdk: \"sdk.owner\",\n    contracts: \"ownable\"\n  },\n  abis: [IOwnableAbi],\n  features: {}\n};\nconst FEATURE_GASLESS = {\n  name: \"Gasless\",\n  namespace: \"gasless\",\n  docLinks: {\n    sdk: \"sdk.gaslesstransaction\",\n    // TODO add the correct name for this once it's added to portal\n    contracts: \"IERC2771Context\"\n  },\n  abis: [IERC2771ContextAbi],\n  features: {}\n};\nconst FEATURE_PACK_VRF = {\n  name: \"PackVRF\",\n  namespace: \"pack.vrf\",\n  docLinks: {\n    sdk: \"sdk.packvrf\",\n    //TODO\n    contracts: \"IPackVRF\"\n  },\n  abis: [IPackVRFAbi],\n  features: {}\n};\nconst FEATURE_PLUGIN_ROUTER = {\n  name: \"PluginRouter\",\n  namespace: \"plugin.router\",\n  docLinks: {\n    sdk: \"sdk.pluginrouter\",\n    //TODO\n    contracts: \"PluginRouter\"\n  },\n  abis: [getAllPluginsAbi],\n  features: {}\n};\nconst FEATURE_DYNAMIC_CONTRACT = {\n  name: \"DynamicContract\",\n  namespace: \"dynamic.contract\",\n  docLinks: {\n    sdk: \"\",\n    //TODO\n    contracts: \"IExtensionsManager\"\n  },\n  abis: [getAllExtensionsAbi],\n  features: {}\n};\nconst FEATURE_DIRECT_LISTINGS = {\n  name: \"DirectListings\",\n  namespace: \"direct.listings\",\n  docLinks: {\n    // TODO\n    sdk: \"\",\n    contracts: \"IDirectListings\"\n  },\n  abis: [IDirectListingsAbi],\n  features: {}\n};\nconst FEATURE_ENGLISH_AUCTIONS = {\n  name: \"EnglishAuctions\",\n  namespace: \"english.auctions\",\n  docLinks: {\n    // TODO\n    sdk: \"\",\n    contracts: \"IEnglishAuctions\"\n  },\n  abis: [IEnglishAuctionsAbi],\n  features: {}\n};\nconst FEATURE_OFFERS = {\n  name: \"Offers\",\n  namespace: \"offers\",\n  docLinks: {\n    // TODO\n    sdk: \"\",\n    contracts: \"IOffers\"\n  },\n  abis: [IOffersAbi],\n  features: {}\n};\nconst FEATURE_ACCOUNT_FACTORY = {\n  name: \"AccountFactory\",\n  namespace: \"accountFactory\",\n  docLinks: {\n    // TODO\n    sdk: \"sdk.accountFactory\",\n    contracts: \"IAccountFactory\"\n  },\n  abis: [IAccountFactoryCore],\n  features: {}\n};\nconst FEATURE_ACCOUNT_PERMISSIONS = {\n  name: \"AccountPermissions\",\n  namespace: \"accountPermissions\",\n  docLinks: {\n    // TODO\n    sdk: \"sdk.account\",\n    contracts: \"IAccountPermissions\"\n  },\n  abis: [IAccountPermissions],\n  features: {}\n};\nconst FEATURE_ACCOUNT = {\n  name: \"Account\",\n  namespace: \"account\",\n  docLinks: {\n    // TODO\n    sdk: \"sdk.account\",\n    contracts: \"IAccount\"\n  },\n  abis: [IAccount],\n  features: {\n    [FEATURE_ACCOUNT_PERMISSIONS.name]: FEATURE_ACCOUNT_PERMISSIONS\n  }\n};\nconst FEATURE_AIRDROP_ERC20 = {\n  name: \"AirdropERC20\",\n  namespace: \"airdrop20\",\n  docLinks: {\n    // TODO\n    sdk: \"\",\n    contracts: \"IAirdropERC20\"\n  },\n  abis: [IAirdropERC20],\n  features: {}\n};\nconst FEATURE_AIRDROP_ERC721 = {\n  name: \"AirdropERC721\",\n  namespace: \"airdrop721\",\n  docLinks: {\n    // TODO\n    sdk: \"\",\n    contracts: \"IAirdropERC721\"\n  },\n  abis: [IAirdropERC721],\n  features: {}\n};\nconst FEATURE_AIRDROP_ERC1155 = {\n  name: \"AirdropERC1155\",\n  namespace: \"airdrop1155\",\n  docLinks: {\n    // TODO\n    sdk: \"\",\n    contracts: \"IAirdropERC1155\"\n  },\n  abis: [IAirdropERC1155],\n  features: {}\n};\n\n/**\n * @internal\n */\n\n/**\n * @internal\n */\n\n/**\n * @internal\n */\n\n/**\n * @internal\n */\nconst SUPPORTED_FEATURES = {\n  [FEATURE_TOKEN.name]: FEATURE_TOKEN,\n  [FEATURE_NFT.name]: FEATURE_NFT,\n  [FEATURE_EDITION.name]: FEATURE_EDITION,\n  [FEATURE_ROYALTY.name]: FEATURE_ROYALTY,\n  [FEATURE_PLATFORM_FEE.name]: FEATURE_PLATFORM_FEE,\n  [FEATURE_PRIMARY_SALE.name]: FEATURE_PRIMARY_SALE,\n  [FEATURE_PERMISSIONS.name]: FEATURE_PERMISSIONS,\n  [FEATURE_METADATA.name]: FEATURE_METADATA,\n  [FEATURE_APPURI.name]: FEATURE_APPURI,\n  [FEATURE_OWNER.name]: FEATURE_OWNER,\n  [FEATURE_GASLESS.name]: FEATURE_GASLESS,\n  [FEATURE_PACK_VRF.name]: FEATURE_PACK_VRF,\n  [FEATURE_PLUGIN_ROUTER.name]: FEATURE_PLUGIN_ROUTER,\n  [FEATURE_DYNAMIC_CONTRACT.name]: FEATURE_DYNAMIC_CONTRACT,\n  [FEATURE_DIRECT_LISTINGS.name]: FEATURE_DIRECT_LISTINGS,\n  [FEATURE_ENGLISH_AUCTIONS.name]: FEATURE_ENGLISH_AUCTIONS,\n  [FEATURE_OFFERS.name]: FEATURE_OFFERS,\n  [FEATURE_AIRDROP_ERC20.name]: FEATURE_AIRDROP_ERC20,\n  [FEATURE_AIRDROP_ERC721.name]: FEATURE_AIRDROP_ERC721,\n  [FEATURE_AIRDROP_ERC1155.name]: FEATURE_AIRDROP_ERC1155,\n  [FEATURE_ACCOUNT_FACTORY.name]: FEATURE_ACCOUNT_FACTORY,\n  [FEATURE_ACCOUNT.name]: FEATURE_ACCOUNT,\n  [FEATURE_NFT_LOYALTY_CARD.name]: FEATURE_NFT_LOYALTY_CARD,\n  [FEATURE_NFT_UPDATABLE_METADATA.name]: FEATURE_NFT_UPDATABLE_METADATA\n};\n\nfunction toJSType(contractType) {\n  let isReturnType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  let withName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  let jsType = contractType.type;\n  let isArray = false;\n  if (jsType.endsWith(\"[]\")) {\n    isArray = true;\n    jsType = jsType.slice(0, -2);\n  }\n  if (jsType.startsWith(\"bytes\")) {\n    jsType = \"BytesLike\";\n  }\n  if (jsType.startsWith(\"uint\") || jsType.startsWith(\"int\")) {\n    jsType = isReturnType ? \"BigNumber\" : \"BigNumberish\";\n  }\n  if (jsType.startsWith(\"bool\")) {\n    jsType = \"boolean\";\n  }\n  if (jsType === \"address\") {\n    jsType = \"string\";\n  }\n  if (jsType === \"tuple\") {\n    if (contractType.components) {\n      jsType = `{ ${contractType.components.map(a => toJSType(a, false, true)).join(\", \")} }`;\n    }\n  }\n  if (isArray) {\n    jsType += \"[]\";\n  }\n  if (withName) {\n    jsType = `${contractType.name}: ${jsType}`;\n  }\n  return jsType;\n}\n\n/**\n * @internal\n * @param name\n * @param metadata\n * @param type\n */\nfunction extractCommentFromMetadata(name, metadata, type) {\n  return metadata?.output?.userdoc?.[type]?.[Object.keys(metadata?.output?.userdoc[type] || {}).find(fn => fn.includes(name || \"unknown\")) || \"\"]?.notice || metadata?.output?.devdoc?.[type]?.[Object.keys(metadata?.output?.devdoc[type] || {}).find(fn => fn.includes(name || \"unknown\")) || \"\"]?.details;\n}\n\n/**\n * @internal\n * @param abi\n * @param metadata\n */\nfunction extractFunctionsFromAbi(abi, metadata) {\n  const functions = (abi || []).filter(el => el.type === \"function\");\n  const parsed = [];\n  for (const f of functions) {\n    const doc = extractCommentFromMetadata(f.name, metadata, \"methods\");\n    const args = f.inputs?.map(i => `${i.name || \"key\"}: ${toJSType(i)}`)?.join(\", \") || \"\";\n    const fargs = args ? `, [${args}]` : \"\";\n    const out = f.outputs?.map(o => toJSType(o, true))?.join(\", \");\n    const promise = out ? `: Promise<${out}>` : `: Promise<TransactionResult>`;\n    const signature = `contract.call(\"${f.name}\"${fargs})${promise}`;\n    parsed.push({\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore we know AbiTypeBaseSchema.name is not going to be undefined since we're doing `.default(\"\")`\n      inputs: f.inputs || [],\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore we know the AbiTypeBaseSchema.name is not going to be undefined since we're doing `.default(\"\")`\n      outputs: f.outputs || [],\n      name: f.name || \"unknown\",\n      signature,\n      stateMutability: f.stateMutability || \"\",\n      comment: doc\n    });\n  }\n  return parsed;\n}\n\n/**\n * @internal\n * @param contractAbi\n * @param featureAbis\n * @returns\n */\nfunction hasMatchingAbi(contractAbi, featureAbis) {\n  const contractFn = extractFunctionsFromAbi(contractAbi);\n  const interfaceFn = featureAbis.flatMap(i => extractFunctionsFromAbi(i));\n  // match every function and their arguments\n  const intersection = contractFn.filter(fn => {\n    const match = interfaceFn.find(iFn => iFn.name === fn.name && iFn.inputs.length === fn.inputs.length && iFn.inputs.every((i, index) => {\n      if (i.type === \"tuple\" || i.type === \"tuple[]\") {\n        // check that all properties in the tuple are the same type\n        return i.type === fn.inputs[index].type && i.components?.every((c, cIndex) => {\n          return c.type === fn.inputs[index].components?.[cIndex]?.type;\n        });\n      }\n      return i.type === fn.inputs[index].type;\n    }));\n    return match !== undefined;\n  });\n  return intersection.length === interfaceFn.length;\n}\nfunction matchesAbiFromBytecode(contractBytecode, featureAbis) {\n  const interfaces = featureAbis.map(abi => new Interface(abi));\n  const selectors = interfaces.flatMap(i => {\n    return Object.values(i.functions).map(fn => Number(i.getSighash(fn)).toString(16));\n  });\n  const uniqueSelectors = [...new Set(selectors)];\n  // checks that all unique selectors are found in the bytecode\n  return uniqueSelectors.every(selector => contractBytecode.includes(selector));\n}\n\n/**\n * Processes ALL supported features and sets whether the passed in abi supports each individual feature\n * @internal\n * @param abi\n * @param features\n * @returns the nested struct of all features and whether they're detected in the abi\n */\nfunction detectFeatures(abi) {\n  let features = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : SUPPORTED_FEATURES;\n  const results = {};\n  for (const featureKey in features) {\n    const feature = features[featureKey];\n    const enabled = matchesAbiInterface(abi, feature);\n    const childResults = detectFeatures(abi, feature.features);\n    results[featureKey] = {\n      ...feature,\n      features: childResults,\n      enabled\n    };\n  }\n  return results;\n}\nfunction detectFeaturesFromBytecode(bytecode) {\n  let features = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : SUPPORTED_FEATURES;\n  const results = {};\n  for (const featureKey in features) {\n    const feature = features[featureKey];\n    const enabled = matchesAbiFromBytecode(bytecode, feature.abis);\n    const childResults = detectFeaturesFromBytecode(bytecode, feature.features);\n    results[featureKey] = {\n      ...feature,\n      features: childResults,\n      enabled\n    };\n  }\n  return results;\n}\n\n/**\n * @internal\n * @param abi\n * @param feature\n */\nfunction matchesAbiInterface(abi, feature) {\n  // returns true if all the functions in `interfaceToMatch` are found in `contract` (removing any duplicates)\n  return hasMatchingAbi(abi, feature.abis);\n}\n\n/**\n * Checks whether the given ABI supports a given feature\n * @deprecated use isExtensionEnabled instead\n * @param abi\n * @param featureName\n */\nfunction isFeatureEnabled(abi, featureName) {\n  const features = detectFeatures(abi);\n  return _featureEnabled(features, featureName);\n}\n\n/**\n * Checks whether the given ABI supports a given extension\n * @public\n * @param abi\n * @param featureName\n */\nfunction isExtensionEnabled(abi, featureName) {\n  return isFeatureEnabled(abi, featureName);\n}\n\n/**\n * Searches the feature map for featureName and returns whether its enabled\n * @internal\n * @param features\n * @param featureName\n */\nfunction _featureEnabled(features, featureName) {\n  const keys = Object.keys(features);\n  if (!keys.includes(featureName)) {\n    let found = false;\n    for (const key of keys) {\n      const f = features[key];\n      found = _featureEnabled(f.features, featureName);\n      if (found) {\n        break;\n      }\n    }\n    return found;\n  }\n  const feature = features[featureName];\n  return feature.enabled;\n}\n\n/**\n * Type guard for contractWrappers depending on passed feature name\n * @internal\n * @param contractWrapper\n * @param featureName\n */\nfunction detectContractFeature(contractWrapper, featureName) {\n  return isExtensionEnabled(AbiSchema.parse(contractWrapper.abi), featureName);\n}\n\n/**\n * @internal\n * @param contractWrapper\n * @param functionName\n */\nfunction hasFunction(functionName, contractWrapper) {\n  return functionName in contractWrapper.readContract.functions;\n}\n\n/* eslint-disable eqeqeq */\n/* eslint-disable better-tree-shaking/no-top-level-side-effects  */\nlet decoder;\ntry {\n  decoder = new TextDecoder();\n} catch (error) {}\nlet src;\nlet srcEnd;\nlet position = 0;\nconst LEGACY_RECORD_INLINE_ID = 105;\nconst RECORD_DEFINITIONS_ID = 0xdffe;\nconst RECORD_INLINE_ID = 0xdfff; // temporary first-come first-serve tag // proposed tag: 0x7265 // 're'\nconst BUNDLED_STRINGS_ID = 0xdff9;\nconst PACKED_REFERENCE_TAG_ID = 6;\nconst STOP_CODE = {};\nlet currentDecoder = {};\nlet currentStructures;\nlet srcString;\nlet srcStringStart = 0;\nlet srcStringEnd = 0;\nlet bundledStrings;\nlet referenceMap;\nlet currentExtensions = [];\nlet currentExtensionRanges = [];\nlet packedValues;\nlet dataView;\nlet restoreMapsAsObject;\nlet defaultOptions = {\n  useRecords: false,\n  mapsAsObjects: true\n};\nlet sequentialMode = false;\nclass Decoder {\n  constructor(options) {\n    if (options) {\n      if ((options.keyMap || options._keyMap) && !options.useRecords) {\n        options.useRecords = false;\n        options.mapsAsObjects = true;\n      }\n      if (options.useRecords === false && options.mapsAsObjects === undefined) {\n        options.mapsAsObjects = true;\n      }\n      if (options.getStructures) {\n        options.getShared = options.getStructures;\n      }\n      if (options.getShared && !options.structures) {\n        (options.structures = []).uninitialized = true;\n      } // this is what we use to denote an uninitialized structures\n      if (options.keyMap) {\n        this.mapKey = new Map();\n        for (let [k, v] of Object.entries(options.keyMap)) {\n          this.mapKey.set(v, k);\n        }\n      }\n    }\n    Object.assign(this, options);\n  }\n  decodeKey(key) {\n    return this.keyMap ? this.mapKey.get(key) || key : key;\n  }\n  decode(source, end) {\n    if (src) {\n      // re-entrant execution, save the state and restore it after we do this decode\n      return saveState(() => {\n        clearSource();\n        return this ? this.decode(source, end) : Decoder.prototype.decode.call(defaultOptions, source, end);\n      });\n    }\n    srcEnd = end > -1 ? end : source.length;\n    position = 0;\n    srcStringEnd = 0;\n    srcString = null;\n    bundledStrings = null;\n    src = source;\n    // this provides cached access to the data view for a buffer if it is getting reused, which is a recommend\n    // technique for getting data from a database where it can be copied into an existing buffer instead of creating\n    // new ones\n    try {\n      dataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength));\n    } catch (error) {\n      // if it doesn't have a buffer, maybe it is the wrong type of object\n      src = null;\n      if (source instanceof Uint8Array) {\n        throw error;\n      }\n      throw new Error(\"Source must be a Uint8Array or Buffer but was a \" + (source && typeof source === \"object\" ? source.constructor.name : typeof source));\n    }\n    if (this instanceof Decoder) {\n      // eslint-disable-next-line @typescript-eslint/no-this-alias\n      currentDecoder = this;\n      packedValues = this.sharedValues && (this.pack ? new Array(this.maxPrivatePackedValues || 16).concat(this.sharedValues) : this.sharedValues);\n      if (this.structures) {\n        currentStructures = this.structures;\n        return checkedRead();\n      } else if (!currentStructures || currentStructures.length > 0) {\n        currentStructures = [];\n      }\n    } else {\n      currentDecoder = defaultOptions;\n      if (!currentStructures || currentStructures.length > 0) {\n        currentStructures = [];\n      }\n      packedValues = null;\n    }\n    return checkedRead();\n  }\n}\nfunction checkedRead() {\n  try {\n    let result = read();\n    if (bundledStrings) {\n      if (position >= bundledStrings.postBundlePosition) {\n        let error = new Error(\"Unexpected bundle position\");\n        error.incomplete = true;\n        throw error;\n      }\n      // bundled strings to skip past\n      position = bundledStrings.postBundlePosition;\n      bundledStrings = null;\n    }\n    if (position == srcEnd) {\n      // finished reading this source, cleanup references\n      currentStructures = null;\n      src = null;\n      if (referenceMap) {\n        referenceMap = null;\n      }\n    } else if (position > srcEnd) {\n      // over read\n      let error = new Error(\"Unexpected end of CBOR data\");\n      error.incomplete = true;\n      throw error;\n    } else if (!sequentialMode) {\n      throw new Error(\"Data read, but end of buffer not reached\");\n    }\n    // else more to read, but we are reading sequentially, so don't clear source yet\n    return result;\n  } catch (error) {\n    clearSource();\n    if (error instanceof RangeError || error.message.startsWith(\"Unexpected end of buffer\")) {\n      error.incomplete = true;\n    }\n    throw error;\n  }\n}\nfunction read() {\n  let token = src[position++];\n  let majorType = token >> 5;\n  token = token & 0x1f;\n  if (token > 0x17) {\n    switch (token) {\n      case 0x18:\n        token = src[position++];\n        break;\n      case 0x19:\n        if (majorType == 7) {\n          return getFloat16();\n        }\n        token = dataView.getUint16(position);\n        position += 2;\n        break;\n      case 0x1a:\n        if (majorType == 7) {\n          let value = dataView.getFloat32(position);\n          if (currentDecoder.useFloat32 > 2) {\n            // this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n            let multiplier = mult10[(src[position] & 0x7f) << 1 | src[position + 1] >> 7];\n            position += 4;\n            return (multiplier * value + (value > 0 ? 0.5 : -0.5) >> 0) / multiplier;\n          }\n          position += 4;\n          return value;\n        }\n        token = dataView.getUint32(position);\n        position += 4;\n        break;\n      case 0x1b:\n        if (majorType == 7) {\n          let value = dataView.getFloat64(position);\n          position += 8;\n          return value;\n        }\n        if (majorType > 1) {\n          if (dataView.getUint32(position) > 0) {\n            throw new Error(\"JavaScript does not support arrays, maps, or strings with length over 4294967295\");\n          }\n          token = dataView.getUint32(position + 4);\n        } else if (currentDecoder.int64AsNumber) {\n          token = dataView.getUint32(position) * 0x100000000;\n          token += dataView.getUint32(position + 4);\n        } else {\n          token = dataView.getBigUint64(position);\n        }\n        position += 8;\n        break;\n      case 0x1f:\n        // indefinite length\n        switch (majorType) {\n          case 2: // byte string\n          case 3:\n            // text string\n            throw new Error(\"Indefinite length not supported for byte or text strings\");\n          case 4:\n            // array\n            let array = [];\n            let value,\n              i = 0;\n            while ((value = read()) != STOP_CODE) {\n              array[i++] = value;\n            }\n            return majorType == 4 ? array : majorType == 3 ? array.join(\"\") : Buffer.concat(array);\n          case 5:\n            // map\n            let key;\n            if (currentDecoder.mapsAsObjects) {\n              let object = {};\n              if (currentDecoder.keyMap) {\n                while ((key = read()) != STOP_CODE) {\n                  object[safeKey(currentDecoder.decodeKey(key))] = read();\n                }\n              } else {\n                while ((key = read()) != STOP_CODE) {\n                  object[safeKey(key)] = read();\n                }\n              }\n              return object;\n            } else {\n              if (restoreMapsAsObject) {\n                currentDecoder.mapsAsObjects = true;\n                restoreMapsAsObject = false;\n              }\n              let map = new Map();\n              if (currentDecoder.keyMap) {\n                while ((key = read()) != STOP_CODE) {\n                  map.set(currentDecoder.decodeKey(key), read());\n                }\n              } else {\n                while ((key = read()) != STOP_CODE) {\n                  map.set(key, read());\n                }\n              }\n              return map;\n            }\n          case 7:\n            return STOP_CODE;\n          default:\n            throw new Error(\"Invalid major type for indefinite length \" + majorType);\n        }\n      default:\n        throw new Error(\"Unknown token \" + token);\n    }\n  }\n  switch (majorType) {\n    case 0:\n      // positive int\n      return token;\n    case 1:\n      // negative int\n      return ~token;\n    case 2:\n      // buffer\n      return readBin(token);\n    case 3:\n      // string\n      if (srcStringEnd >= position) {\n        return srcString.slice(position - srcStringStart, (position += token) - srcStringStart);\n      }\n      if (srcStringEnd == 0 && srcEnd < 140 && token < 32) {\n        // for small blocks, avoiding the overhead of the extract call is helpful\n        let string = token < 16 ? shortStringInJS(token) : longStringInJS(token);\n        if (string != null) {\n          return string;\n        }\n      }\n      return readFixedString(token);\n    case 4:\n      // array\n      let array = new Array(token);\n      //if (currentDecoder.keyMap) for (let i = 0; i < token; i++) array[i] = currentDecoder.decodeKey(read())\n      //else\n      for (let i = 0; i < token; i++) {\n        array[i] = read();\n      }\n      return array;\n    case 5:\n      // map\n      if (currentDecoder.mapsAsObjects) {\n        let object = {};\n        if (currentDecoder.keyMap) {\n          for (let i = 0; i < token; i++) {\n            object[safeKey(currentDecoder.decodeKey(read()))] = read();\n          }\n        } else {\n          for (let i = 0; i < token; i++) {\n            object[safeKey(read())] = read();\n          }\n        }\n        return object;\n      } else {\n        if (restoreMapsAsObject) {\n          currentDecoder.mapsAsObjects = true;\n          restoreMapsAsObject = false;\n        }\n        let map = new Map();\n        if (currentDecoder.keyMap) {\n          for (let i = 0; i < token; i++) {\n            map.set(currentDecoder.decodeKey(read()), read());\n          }\n        } else {\n          for (let i = 0; i < token; i++) {\n            map.set(read(), read());\n          }\n        }\n        return map;\n      }\n    case 6:\n      // extension\n      if (token >= BUNDLED_STRINGS_ID) {\n        let structure = currentStructures[token & 0x1fff]; // check record structures first\n        // At some point we may provide an option for dynamic tag assignment with a range like token >= 8 && (token < 16 || (token > 0x80 && token < 0xc0) || (token > 0x130 && token < 0x4000))\n        if (structure) {\n          if (!structure.read) {\n            structure.read = createStructureReader(structure);\n          }\n          return structure.read();\n        }\n        if (token < 0x10000) {\n          if (token == RECORD_INLINE_ID) {\n            // we do a special check for this so that we can keep the currentExtensions as densely stored array (v8 stores arrays densely under about 3000 elements)\n            return recordDefinition(read());\n          } else if (token == RECORD_DEFINITIONS_ID) {\n            let length = readJustLength();\n            let id = read();\n            for (let i = 2; i < length; i++) {\n              recordDefinition([id++, read()]);\n            }\n            return read();\n          } else if (token == BUNDLED_STRINGS_ID) {\n            return readBundleExt();\n          }\n          if (currentDecoder.getShared) {\n            loadShared();\n            structure = currentStructures[token & 0x1fff];\n            if (structure) {\n              if (!structure.read) {\n                structure.read = createStructureReader(structure);\n              }\n              return structure.read();\n            }\n          }\n        }\n      }\n      let extension = currentExtensions[token];\n      if (extension) {\n        if (extension.handlesRead) {\n          return extension(read);\n        } else {\n          return extension(read());\n        }\n      } else {\n        let input = read();\n        for (let i = 0; i < currentExtensionRanges.length; i++) {\n          let value = currentExtensionRanges[i](token, input);\n          if (value !== undefined) {\n            return value;\n          }\n        }\n        return new Tag(input, token);\n      }\n    case 7:\n      // fixed value\n      switch (token) {\n        case 0x14:\n          return false;\n        case 0x15:\n          return true;\n        case 0x16:\n          return null;\n        case 0x17:\n          return;\n        // undefined\n        case 0x1f:\n        default:\n          let packedValue = (packedValues || getPackedValues())[token];\n          if (packedValue !== undefined) {\n            return packedValue;\n          }\n          throw new Error(\"Unknown token \" + token);\n      }\n    default:\n      // negative int\n      if (isNaN(token)) {\n        let error = new Error(\"Unexpected end of CBOR data\");\n        error.incomplete = true;\n        throw error;\n      }\n      throw new Error(\"Unknown CBOR token \" + token);\n  }\n}\nconst validName = /^[a-zA-Z_$][a-zA-Z\\d_$]*$/;\nfunction createStructureReader(structure) {\n  function readObject() {\n    // get the array size from the header\n    let length = src[position++];\n    //let majorType = token >> 5\n    length = length & 0x1f;\n    if (length > 0x17) {\n      switch (length) {\n        case 0x18:\n          length = src[position++];\n          break;\n        case 0x19:\n          length = dataView.getUint16(position);\n          position += 2;\n          break;\n        case 0x1a:\n          length = dataView.getUint32(position);\n          position += 4;\n          break;\n        default:\n          throw new Error(\"Expected array header, but got \" + src[position - 1]);\n      }\n    }\n    // This initial function is quick to instantiate, but runs slower. After several iterations pay the cost to build the faster function\n    let compiledReader = this.compiledReader; // first look to see if we have the fast compiled function\n    while (compiledReader) {\n      // we have a fast compiled object literal reader\n      if (compiledReader.propertyCount === length) {\n        return compiledReader(read);\n      } // with the right length, so we use it\n      compiledReader = compiledReader.next; // see if there is another reader with the right length\n    }\n\n    if (this.slowReads++ >= 3) {\n      // create a fast compiled reader\n      let array = this.length == length ? this : this.slice(0, length);\n      compiledReader = currentDecoder.keyMap ? new Function(\"r\", \"return {\" + array.map(k => currentDecoder.decodeKey(k)).map(k => validName.test(k) ? safeKey(k) + \":r()\" : \"[\" + JSON.stringify(k) + \"]:r()\").join(\",\") + \"}\") : new Function(\"r\", \"return {\" + array.map(key => validName.test(key) ? safeKey(key) + \":r()\" : \"[\" + JSON.stringify(key) + \"]:r()\").join(\",\") + \"}\");\n      if (this.compiledReader) {\n        compiledReader.next = this.compiledReader;\n      } // if there is an existing one, we store multiple readers as a linked list because it is usually pretty rare to have multiple readers (of different length) for the same structure\n      compiledReader.propertyCount = length;\n      this.compiledReader = compiledReader;\n      return compiledReader(read);\n    }\n    let object = {};\n    if (currentDecoder.keyMap) {\n      for (let i = 0; i < length; i++) {\n        object[safeKey(currentDecoder.decodeKey(this[i]))] = read();\n      }\n    } else {\n      for (let i = 0; i < length; i++) {\n        object[safeKey(this[i])] = read();\n      }\n    }\n    return object;\n  }\n  structure.slowReads = 0;\n  return readObject;\n}\nfunction safeKey(key) {\n  return key === \"__proto__\" ? \"__proto_\" : key;\n}\nlet readFixedString = readStringJS;\nfunction readStringJS(length) {\n  let result;\n  if (length < 16) {\n    if (result = shortStringInJS(length)) {\n      return result;\n    }\n  }\n  if (length > 64 && decoder) {\n    return decoder.decode(src.subarray(position, position += length));\n  }\n  const end = position + length;\n  const units = [];\n  result = \"\";\n  while (position < end) {\n    const byte1 = src[position++];\n    if ((byte1 & 0x80) === 0) {\n      // 1 byte\n      units.push(byte1);\n    } else if ((byte1 & 0xe0) === 0xc0) {\n      // 2 bytes\n      const byte2 = src[position++] & 0x3f;\n      units.push((byte1 & 0x1f) << 6 | byte2);\n    } else if ((byte1 & 0xf0) === 0xe0) {\n      // 3 bytes\n      const byte2 = src[position++] & 0x3f;\n      const byte3 = src[position++] & 0x3f;\n      units.push((byte1 & 0x1f) << 12 | byte2 << 6 | byte3);\n    } else if ((byte1 & 0xf8) === 0xf0) {\n      // 4 bytes\n      const byte2 = src[position++] & 0x3f;\n      const byte3 = src[position++] & 0x3f;\n      const byte4 = src[position++] & 0x3f;\n      let unit = (byte1 & 0x07) << 0x12 | byte2 << 0x0c | byte3 << 0x06 | byte4;\n      if (unit > 0xffff) {\n        unit -= 0x10000;\n        units.push(unit >>> 10 & 0x3ff | 0xd800);\n        unit = 0xdc00 | unit & 0x3ff;\n      }\n      units.push(unit);\n    } else {\n      units.push(byte1);\n    }\n    if (units.length >= 0x1000) {\n      result += fromCharCode.apply(String, units);\n      units.length = 0;\n    }\n  }\n  if (units.length > 0) {\n    result += fromCharCode.apply(String, units);\n  }\n  return result;\n}\nlet fromCharCode = String.fromCharCode;\nfunction longStringInJS(length) {\n  let start = position;\n  let bytes = new Array(length);\n  for (let i = 0; i < length; i++) {\n    const byte = src[position++];\n    if ((byte & 0x80) > 0) {\n      position = start;\n      return;\n    }\n    bytes[i] = byte;\n  }\n  return fromCharCode.apply(String, bytes);\n}\nfunction shortStringInJS(length) {\n  if (length < 4) {\n    if (length < 2) {\n      if (length === 0) {\n        return \"\";\n      } else {\n        let a = src[position++];\n        if ((a & 0x80) > 1) {\n          position -= 1;\n          return;\n        }\n        return fromCharCode(a);\n      }\n    } else {\n      let a = src[position++];\n      let b = src[position++];\n      if ((a & 0x80) > 0 || (b & 0x80) > 0) {\n        position -= 2;\n        return;\n      }\n      if (length < 3) {\n        return fromCharCode(a, b);\n      }\n      let c = src[position++];\n      if ((c & 0x80) > 0) {\n        position -= 3;\n        return;\n      }\n      return fromCharCode(a, b, c);\n    }\n  } else {\n    let a = src[position++];\n    let b = src[position++];\n    let c = src[position++];\n    let d = src[position++];\n    if ((a & 0x80) > 0 || (b & 0x80) > 0 || (c & 0x80) > 0 || (d & 0x80) > 0) {\n      position -= 4;\n      return;\n    }\n    if (length < 6) {\n      if (length === 4) {\n        return fromCharCode(a, b, c, d);\n      } else {\n        let e = src[position++];\n        if ((e & 0x80) > 0) {\n          position -= 5;\n          return;\n        }\n        return fromCharCode(a, b, c, d, e);\n      }\n    } else if (length < 8) {\n      let e = src[position++];\n      let f = src[position++];\n      if ((e & 0x80) > 0 || (f & 0x80) > 0) {\n        position -= 6;\n        return;\n      }\n      if (length < 7) {\n        return fromCharCode(a, b, c, d, e, f);\n      }\n      let g = src[position++];\n      if ((g & 0x80) > 0) {\n        position -= 7;\n        return;\n      }\n      return fromCharCode(a, b, c, d, e, f, g);\n    } else {\n      let e = src[position++];\n      let f = src[position++];\n      let g = src[position++];\n      let h = src[position++];\n      if ((e & 0x80) > 0 || (f & 0x80) > 0 || (g & 0x80) > 0 || (h & 0x80) > 0) {\n        position -= 8;\n        return;\n      }\n      if (length < 10) {\n        if (length === 8) {\n          return fromCharCode(a, b, c, d, e, f, g, h);\n        } else {\n          let i = src[position++];\n          if ((i & 0x80) > 0) {\n            position -= 9;\n            return;\n          }\n          return fromCharCode(a, b, c, d, e, f, g, h, i);\n        }\n      } else if (length < 12) {\n        let i = src[position++];\n        let j = src[position++];\n        if ((i & 0x80) > 0 || (j & 0x80) > 0) {\n          position -= 10;\n          return;\n        }\n        if (length < 11) {\n          return fromCharCode(a, b, c, d, e, f, g, h, i, j);\n        }\n        let k = src[position++];\n        if ((k & 0x80) > 0) {\n          position -= 11;\n          return;\n        }\n        return fromCharCode(a, b, c, d, e, f, g, h, i, j, k);\n      } else {\n        let i = src[position++];\n        let j = src[position++];\n        let k = src[position++];\n        let l = src[position++];\n        if ((i & 0x80) > 0 || (j & 0x80) > 0 || (k & 0x80) > 0 || (l & 0x80) > 0) {\n          position -= 12;\n          return;\n        }\n        if (length < 14) {\n          if (length === 12) {\n            return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l);\n          } else {\n            let m = src[position++];\n            if ((m & 0x80) > 0) {\n              position -= 13;\n              return;\n            }\n            return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m);\n          }\n        } else {\n          let m = src[position++];\n          let n = src[position++];\n          if ((m & 0x80) > 0 || (n & 0x80) > 0) {\n            position -= 14;\n            return;\n          }\n          if (length < 15) {\n            return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n);\n          }\n          let o = src[position++];\n          if ((o & 0x80) > 0) {\n            position -= 15;\n            return;\n          }\n          return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o);\n        }\n      }\n    }\n  }\n}\nfunction readBin(length) {\n  return currentDecoder.copyBuffers ?\n  // specifically use the copying slice (not the node one)\n  Uint8Array.prototype.slice.call(src, position, position += length) : src.subarray(position, position += length);\n}\nlet f32Array = new Float32Array(1);\nlet u8Array = new Uint8Array(f32Array.buffer, 0, 4);\nfunction getFloat16() {\n  let byte0 = src[position++];\n  let byte1 = src[position++];\n  let exponent = (byte0 & 0x7f) >> 2;\n  if (exponent === 0x1f) {\n    // specials\n    if (byte1 || byte0 & 3) {\n      return NaN;\n    }\n    return byte0 & 0x80 ? -Infinity : Infinity;\n  }\n  if (exponent === 0) {\n    // sub-normals\n    // significand with 10 fractional bits and divided by 2^14\n    let abs = ((byte0 & 3) << 8 | byte1) / (1 << 24);\n    return byte0 & 0x80 ? -abs : abs;\n  }\n  u8Array[3] = byte0 & 0x80 |\n  // sign bit\n  (exponent >> 1) + 56; // 4 of 5 of the exponent bits, re-offset-ed\n  u8Array[2] = (byte0 & 7) << 5 |\n  // last exponent bit and first two mantissa bits\n  byte1 >> 3; // next 5 bits of mantissa\n  u8Array[1] = byte1 << 5; // last three bits of mantissa\n  u8Array[0] = 0;\n  return f32Array[0];\n}\nclass Tag {\n  constructor(value, tag) {\n    this.value = value;\n    this.tag = tag;\n  }\n}\ncurrentExtensions[0] = dateString => {\n  // string date extension\n  return new Date(dateString);\n};\ncurrentExtensions[1] = epochSec => {\n  // numeric date extension\n  return new Date(Math.round(epochSec * 1000));\n};\ncurrentExtensions[2] = buffer => {\n  // bigint extension\n  let value = BigInt(0);\n  for (let i = 0, l = buffer.byteLength; i < l; i++) {\n    value = BigInt(buffer[i]) + value << BigInt(8);\n  }\n  return value;\n};\ncurrentExtensions[3] = buffer => {\n  // negative bigint extension\n  return BigInt(-1) - currentExtensions[2](buffer);\n};\ncurrentExtensions[4] = fraction => {\n  // best to reparse to maintain accuracy\n  return Number(fraction[1] + \"e\" + fraction[0]);\n};\ncurrentExtensions[5] = fraction => {\n  // probably not sufficiently accurate\n  return fraction[1] * Math.exp(fraction[0] * Math.log(2));\n};\n\n// the registration of the record definition extension\nconst recordDefinition = definition => {\n  let id = definition[0] - 0xe000;\n  let structure = definition[1];\n  let existingStructure = currentStructures[id];\n  if (existingStructure && existingStructure.isShared) {\n    (currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id] = existingStructure;\n  }\n  currentStructures[id] = structure;\n  structure.read = createStructureReader(structure);\n  let object = {};\n  if (currentDecoder.keyMap) {\n    for (let i = 2, l = definition.length; i < l; i++) {\n      let key = currentDecoder.decodeKey(structure[i - 2]);\n      object[safeKey(key)] = definition[i];\n    }\n  } else {\n    for (let i = 2, l = definition.length; i < l; i++) {\n      let key = structure[i - 2];\n      object[safeKey(key)] = definition[i];\n    }\n  }\n  return object;\n};\ncurrentExtensions[LEGACY_RECORD_INLINE_ID] = recordDefinition;\ncurrentExtensions[14] = value => {\n  if (bundledStrings) {\n    return bundledStrings[0].slice(bundledStrings.position0, bundledStrings.position0 += value);\n  }\n  return new Tag(value, 14);\n};\ncurrentExtensions[15] = value => {\n  if (bundledStrings) {\n    return bundledStrings[1].slice(bundledStrings.position1, bundledStrings.position1 += value);\n  }\n  return new Tag(value, 15);\n};\nlet glbl = {\n  Error,\n  RegExp\n};\ncurrentExtensions[27] = data => {\n  // http://cbor.schmorp.de/generic-object\n  return (glbl[data[0]] || Error)(data[1], data[2]);\n};\nconst packedTable = _read => {\n  if (src[position++] != 0x84) {\n    throw new Error(\"Packed values structure must be followed by a 4 element array\");\n  }\n  let newPackedValues = _read(); // packed values\n  packedValues = packedValues ? newPackedValues.concat(packedValues.slice(newPackedValues.length)) : newPackedValues;\n  packedValues.prefixes = _read();\n  packedValues.suffixes = _read();\n  return _read(); // read the rump\n};\n\npackedTable.handlesRead = true;\ncurrentExtensions[51] = packedTable;\ncurrentExtensions[PACKED_REFERENCE_TAG_ID] = data => {\n  // packed reference\n  if (!packedValues) {\n    if (currentDecoder.getShared) {\n      loadShared();\n    } else {\n      return new Tag(data, PACKED_REFERENCE_TAG_ID);\n    }\n  }\n  if (typeof data === \"number\") {\n    return packedValues[16 + (data >= 0 ? 2 * data : -2 * data - 1)];\n  }\n  throw new Error(\"No support for non-integer packed references yet\");\n};\ncurrentExtensions[25] = id => {\n  return stringRefs[id];\n};\ncurrentExtensions[256] = _read => {\n  stringRefs = [];\n  try {\n    return _read();\n  } finally {\n    stringRefs = null;\n  }\n};\ncurrentExtensions[256].handlesRead = true;\ncurrentExtensions[28] = _read => {\n  // shareable http://cbor.schmorp.de/value-sharing (for structured clones)\n  if (!referenceMap) {\n    referenceMap = new Map();\n    referenceMap.id = 0;\n  }\n  let id = referenceMap.id++;\n  let token = src[position];\n  let target;\n  // TODO: handle Maps, Sets, and other types that can cycle; this is complicated, because you potentially need to read\n  // ahead past references to record structure definitions\n  if (token >> 5 == 4) {\n    target = [];\n  } else {\n    target = {};\n  }\n  let refEntry = {\n    target\n  }; // a placeholder object\n  referenceMap.set(id, refEntry);\n  let targetProperties = _read(); // read the next value as the target object to id\n  if (refEntry.used) {\n    // there is a cycle, so we have to assign properties to original target\n    return Object.assign(target, targetProperties);\n  }\n  refEntry.target = targetProperties; // the placeholder wasn't used, replace with the deserialized one\n  return targetProperties; // no cycle, can just use the returned read object\n};\n\ncurrentExtensions[28].handlesRead = true;\ncurrentExtensions[29] = id => {\n  // sharedref http://cbor.schmorp.de/value-sharing (for structured clones)\n  let refEntry = referenceMap.get(id);\n  refEntry.used = true;\n  return refEntry.target;\n};\ncurrentExtensions[258] = array => new Set(array); // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md\n(currentExtensions[259] = _read => {\n  // https://github.com/shanewholloway/js-cbor-codec/blob/master/docs/CBOR-259-spec\n  // for decoding as a standard Map\n  if (currentDecoder.mapsAsObjects) {\n    currentDecoder.mapsAsObjects = false;\n    restoreMapsAsObject = true;\n  }\n  return _read();\n}).handlesRead = true;\nfunction combine(a, b) {\n  if (typeof a === \"string\") {\n    return a + b;\n  }\n  if (a instanceof Array) {\n    return a.concat(b);\n  }\n  return Object.assign({}, a, b);\n}\nfunction getPackedValues() {\n  if (!packedValues) {\n    if (currentDecoder.getShared) {\n      loadShared();\n    } else {\n      throw new Error(\"No packed values available\");\n    }\n  }\n  return packedValues;\n}\nconst SHARED_DATA_TAG_ID = 0x53687264; // ascii 'Shrd'\ncurrentExtensionRanges.push((tag, input) => {\n  if (tag >= 225 && tag <= 255) {\n    return combine(getPackedValues().prefixes[tag - 224], input);\n  }\n  if (tag >= 28704 && tag <= 32767) {\n    return combine(getPackedValues().prefixes[tag - 28672], input);\n  }\n  if (tag >= 1879052288 && tag <= 2147483647) {\n    return combine(getPackedValues().prefixes[tag - 1879048192], input);\n  }\n  if (tag >= 216 && tag <= 223) {\n    return combine(input, getPackedValues().suffixes[tag - 216]);\n  }\n  if (tag >= 27647 && tag <= 28671) {\n    return combine(input, getPackedValues().suffixes[tag - 27639]);\n  }\n  if (tag >= 1811940352 && tag <= 1879048191) {\n    return combine(input, getPackedValues().suffixes[tag - 1811939328]);\n  }\n  if (tag == SHARED_DATA_TAG_ID) {\n    // we do a special check for this so that we can keep the currentExtensions as densely stored array (v8 stores arrays densely under about 3000 elements)\n    return {\n      packedValues: packedValues,\n      structures: currentStructures.slice(0),\n      version: input\n    };\n  }\n  if (tag == 55799) {\n    // self-descriptive CBOR tag, just return input value\n    return input;\n  }\n});\nconst isLittleEndianMachine = new Uint8Array(new Uint16Array([1]).buffer)[0] == 1;\nconst typedArrays = [Uint8Array];\nconst typedArrayTags = [64];\nfor (let i = 0; i < typedArrays.length; i++) {\n  registerTypedArray(typedArrays[i], typedArrayTags[i]);\n}\nfunction registerTypedArray(TypedArray, tag) {\n  let dvMethod = \"get\" + TypedArray.name.slice(0, -5);\n  if (typeof TypedArray !== \"function\") {\n    TypedArray = null;\n  }\n  let bytesPerElement = TypedArray.BYTES_PER_ELEMENT;\n  for (let littleEndian = 0; littleEndian < 2; littleEndian++) {\n    if (!littleEndian && bytesPerElement == 1) {\n      continue;\n    }\n    let sizeShift = bytesPerElement == 2 ? 1 : bytesPerElement == 4 ? 2 : 3;\n    currentExtensions[littleEndian ? tag : tag - 4] = bytesPerElement == 1 || littleEndian == isLittleEndianMachine ? buffer => {\n      if (!TypedArray) {\n        throw new Error(\"Could not find typed array for code \" + tag);\n      }\n      // we have to always slice/copy here to get a new ArrayBuffer that is word/byte aligned\n      return new TypedArray(Uint8Array.prototype.slice.call(buffer, 0).buffer);\n    } : buffer => {\n      if (!TypedArray) {\n        throw new Error(\"Could not find typed array for code \" + tag);\n      }\n      let dv = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n      let elements = buffer.length >> sizeShift;\n      let ta = new TypedArray(elements);\n      let method = dv[dvMethod];\n      for (let i = 0; i < elements; i++) {\n        ta[i] = method.call(dv, i << sizeShift, littleEndian);\n      }\n      return ta;\n    };\n  }\n}\nfunction readBundleExt() {\n  let length = readJustLength();\n  let bundlePosition = position + read();\n  for (let i = 2; i < length; i++) {\n    // skip past bundles that were already read\n    let bundleLength = readJustLength(); // this will increment position, so must add to position afterwards\n    position += bundleLength;\n  }\n  let dataPosition = position;\n  position = bundlePosition;\n  bundledStrings = [readStringJS(readJustLength()), readStringJS(readJustLength())];\n  bundledStrings.position0 = 0;\n  bundledStrings.position1 = 0;\n  bundledStrings.postBundlePosition = position;\n  position = dataPosition;\n  return read();\n}\nfunction readJustLength() {\n  let token = src[position++] & 0x1f;\n  if (token > 0x17) {\n    switch (token) {\n      case 0x18:\n        token = src[position++];\n        break;\n      case 0x19:\n        token = dataView.getUint16(position);\n        position += 2;\n        break;\n      case 0x1a:\n        token = dataView.getUint32(position);\n        position += 4;\n        break;\n    }\n  }\n  return token;\n}\nfunction loadShared() {\n  if (currentDecoder.getShared) {\n    let sharedData = saveState(() => {\n      // save the state in case getShared modifies our buffer\n      src = null;\n      return currentDecoder.getShared();\n    }) || {};\n    let updatedStructures = sharedData.structures || [];\n    currentDecoder.sharedVersion = sharedData.version;\n    packedValues = currentDecoder.sharedValues = sharedData.packedValues;\n    if (currentStructures === true) {\n      currentDecoder.structures = currentStructures = updatedStructures;\n    } else {\n      currentStructures.splice.apply(currentStructures, [0, updatedStructures.length].concat(updatedStructures));\n    }\n  }\n}\nfunction saveState(callback) {\n  let savedSrcEnd = srcEnd;\n  let savedPosition = position;\n  let savedSrcStringStart = srcStringStart;\n  let savedSrcStringEnd = srcStringEnd;\n  let savedSrcString = srcString;\n  let savedReferenceMap = referenceMap;\n  let savedBundledStrings = bundledStrings;\n\n  // TODO: We may need to revisit this if we do more external calls to user code (since it could be slow)\n  let savedSrc = new Uint8Array(src.slice(0, srcEnd)); // we copy the data in case it changes while external data is processed\n  let savedStructures = currentStructures;\n  let savedDecoder = currentDecoder;\n  let savedSequentialMode = sequentialMode;\n  let value = callback();\n  srcEnd = savedSrcEnd;\n  position = savedPosition;\n  srcStringStart = savedSrcStringStart;\n  srcStringEnd = savedSrcStringEnd;\n  srcString = savedSrcString;\n  referenceMap = savedReferenceMap;\n  bundledStrings = savedBundledStrings;\n  src = savedSrc;\n  sequentialMode = savedSequentialMode;\n  currentStructures = savedStructures;\n  currentDecoder = savedDecoder;\n  dataView = new DataView(src.buffer, src.byteOffset, src.byteLength);\n  return value;\n}\nfunction clearSource() {\n  src = null;\n  referenceMap = null;\n  currentStructures = null;\n}\nconst mult10 = new Array(147); // this is a table matching binary exponents to the multiplier to determine significant digit rounding\nfor (let i = 0; i < 256; i++) {\n  mult10[i] = Number(\"1e\" + Math.floor(45.15 - i * 0.30103));\n}\nconst defaultDecoder = new Decoder({\n  useRecords: false\n});\nconst decode = defaultDecoder.decode;\n\n/**\n * @internal\n * @param hex\n */\nfunction hexToBytes(hex) {\n  hex = hex.toString(16);\n  if (!hex.startsWith(\"0x\")) {\n    hex = `0x${hex}`;\n  }\n  if (!isHexStrict(hex)) {\n    throw new Error(`Given value \"${hex}\" is not a valid hex string.`);\n  }\n  hex = hex.replace(/^0x/i, \"\");\n  const bytes = [];\n  for (let c = 0; c < hex.length; c += 2) {\n    bytes.push(parseInt(hex.slice(c, c + 2), 16));\n  }\n  return bytes;\n}\n\n/**\n * @internal\n * @param hex\n */\nfunction isHexStrict(hex) {\n  return (typeof hex === \"string\" || typeof hex === \"number\") && /^(-)?0x[0-9a-f]*$/i.test(hex.toString());\n}\n\n/**\n * @internal\n * @param bytecode\n */\nfunction extractIPFSHashFromBytecode(bytecode) {\n  const numericBytecode = hexToBytes(bytecode);\n  const cborLength = numericBytecode[numericBytecode.length - 2] * 0x100 + numericBytecode[numericBytecode.length - 1];\n  const bytecodeBuffer = Uint8Array.from(numericBytecode.slice(numericBytecode.length - 2 - cborLength, -2));\n  const cborData = decode(bytecodeBuffer);\n  if (\"ipfs\" in cborData && cborData[\"ipfs\"]) {\n    try {\n      return `ipfs://${bs58.encode(cborData[\"ipfs\"])}`;\n    } catch (e) {\n      console.warn(\"feature-detection ipfs cbor failed\", e);\n    }\n  }\n  return undefined;\n}\n\n/**\n * @internal\n * @param bytecode\n */\nfunction extractMinimalProxyImplementationAddress(bytecode) {\n  // EIP-1167 clone minimal proxy - https://eips.ethereum.org/EIPS/eip-1167\n  if (bytecode.startsWith(\"0x363d3d373d3d3d363d73\")) {\n    const implementationAddress = bytecode.slice(22, 62);\n    return `0x${implementationAddress}`;\n  }\n\n  // Minimal Proxy with receive() from 0xSplits - https://github.com/0xSplits/splits-contracts/blob/c7b741926ec9746182d0d1e2c4c2046102e5d337/contracts/libraries/Clones.sol\n  if (bytecode.startsWith(\"0x36603057343d5230\")) {\n    // +40 = size of addr\n    const implementationAddress = bytecode.slice(122, 122 + 40);\n    return `0x${implementationAddress}`;\n  }\n\n  // 0age's minimal proxy - https://medium.com/coinmonks/the-more-minimal-proxy-5756ae08ee48\n  if (bytecode.startsWith(\"0x3d3d3d3d363d3d37363d73\")) {\n    // +40 = size of addr\n    const implementationAddress = bytecode.slice(24, 24 + 40);\n    return `0x${implementationAddress}`;\n  }\n\n  // vyper's minimal proxy (uniswap v1) - https://etherscan.io/address/0x09cabec1ead1c0ba254b09efb3ee13841712be14#code\n  if (bytecode.startsWith(\"0x366000600037611000600036600073\")) {\n    const implementationAddress = bytecode.slice(32, 32 + 40);\n    return `0x${implementationAddress}`;\n  }\n  return undefined;\n}\n\n/**\n * @internal\n * @param address\n * @param provider\n */\nasync function resolveContractUriFromAddress(address, provider) {\n  const {\n    bytecode\n  } = await resolveImplementation(address, provider);\n  return extractIPFSHashFromBytecode(bytecode);\n}\nasync function resolveContractUriAndBytecode(address, provider) {\n  const {\n    bytecode\n  } = await resolveImplementation(address, provider);\n  return {\n    uri: extractIPFSHashFromBytecode(bytecode),\n    bytecode\n  };\n}\n\n/**\n * Resolve the implementation address of a proxy contract and its bytecode\n * @param address the contract address\n * @param provider RPC provider\n * @returns the implementation address and its bytecode\n */\nasync function resolveImplementation(address, provider) {\n  let bytecode;\n  try {\n    bytecode = await provider.getCode(address);\n  } catch (e) {\n    throw new Error(`Failed to get bytecode for address ${address}: ${e}`);\n  }\n  if (bytecode === \"0x\") {\n    const chain = await provider.getNetwork();\n    throw new Error(`Contract at ${address} does not exist on chain '${chain.name}' (chainId: ${chain.chainId})`);\n  }\n  try {\n    // TODO support other types of proxies\n    const implementationAddress = extractMinimalProxyImplementationAddress(bytecode);\n    if (implementationAddress) {\n      return await resolveImplementation(implementationAddress, provider);\n    }\n  } catch (e) {\n    // ignore\n  }\n\n  // EIP-1967 proxy storage slots - https://eips.ethereum.org/EIPS/eip-1967\n  try {\n    const proxyStorage = await provider.getStorageAt(address, BigNumber.from(\"0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc\"));\n    const implementationAddress = `0x${proxyStorage.slice(-40)}`;\n    if (utils.isAddress(implementationAddress) && implementationAddress !== constants.AddressZero) {\n      return await resolveImplementation(implementationAddress, provider);\n    }\n  } catch (e) {\n    // ignore\n  }\n  if (!bytecode) {\n    throw new Error(`Error fetching bytecode for ${address}`);\n  }\n  return {\n    address,\n    bytecode\n  };\n}\n\nconst CONTRACT_METADATA_TIMEOUT_SEC = 2;\n\n/**\n * @internal\n * @param compilerMetadataUri\n * @param storage\n */\nasync function fetchContractMetadata(compilerMetadataUri, storage) {\n  // short timeout to avoid hanging on unpinned contract metadata CIDs\n  const metadata = await storage.downloadJSON(compilerMetadataUri, {\n    timeoutInSeconds: CONTRACT_METADATA_TIMEOUT_SEC\n  });\n  if (!metadata || !metadata.output) {\n    throw new Error(`Could not resolve metadata for contract at ${compilerMetadataUri}`);\n  }\n  const abi = AbiSchema.parse(metadata.output.abi);\n  const compilationTarget = metadata.settings.compilationTarget;\n  const targets = Object.keys(compilationTarget);\n  const name = compilationTarget[targets[0]];\n  const info = ContractInfoSchema.parse({\n    title: metadata.output.devdoc.title,\n    author: metadata.output.devdoc.author,\n    details: metadata.output.devdoc.detail,\n    notice: metadata.output.userdoc.notice\n  });\n  const licenses = [...new Set(Object.entries(metadata.sources).map(_ref => {\n    let [, src] = _ref;\n    return src.license;\n  }))];\n  return {\n    name,\n    abi,\n    metadata,\n    info,\n    licenses\n  };\n}\n\nfunction getProcessEnv(key) {\n  let defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n  if (typeof process !== \"undefined\") {\n    if (process.env[key]) {\n      return process.env[key];\n    }\n  }\n  return defaultValue;\n}\n\nconst MultichainRegistry_address = \"0xcdAD8FA86e18538aC207872E8ff3536501431B73\"; // Polygon only\n\n/**\n * @internal\n */\nfunction getMultichainRegistryAddress() {\n  return getProcessEnv(\"multiChainRegistryAddress\", MultichainRegistry_address);\n}\n\n/**\n * @internal\n */\nconst isBrowser = () => \"object\" !== \"undefined\";\n\n/**\n * @internal\n */\nconst isNode = () => !isBrowser();\n\n/**\n * @internal\n */\nfunction unique(a, fn) {\n  if (a.length === 0 || a.length === 1) {\n    return a;\n  }\n  if (!fn) {\n    return a;\n  }\n  for (let i = 0; i < a.length; i++) {\n    for (let j = i + 1; j < a.length; j++) {\n      if (fn(a[i], a[j])) {\n        a.splice(j, 1);\n      }\n    }\n  }\n  return a;\n}\n\n/**\n * @internal\n */\nfunction joinABIs(abis) {\n  const parsedABIs = abis.map(abi => AbiSchema.parse(abi)).flat();\n  const filteredABIs = unique(parsedABIs, (a, b) => {\n    return a.name === b.name && a.type === b.type && a.inputs.length === b.inputs.length;\n  });\n  const finalABIs = filteredABIs.filter(item => item.type !== \"constructor\");\n  return AbiSchema.parse(finalABIs);\n}\n\nfunction extractFeatures(input, enabledExtensions) {\n  if (!input) {\n    return;\n  }\n  for (const extensionKey in input) {\n    const extension = input[extensionKey];\n    // if extension is enabled, then add it to enabledFeatures\n    if (extension.enabled) {\n      enabledExtensions.push(extension);\n    }\n    // recurse\n    extractFeatures(extension.features, enabledExtensions);\n  }\n}\n\n/**\n * Return all the detected features in the abi\n * @param abi - parsed array of abi entries\n * @returns array of all detected extensions with full information on each feature\n * @internal\n * @deprecated use getAllDetectedExtensions instead\n */\nfunction getAllDetectedFeatures(abi) {\n  const features = [];\n  extractFeatures(detectFeatures(abi), features);\n  return features;\n}\nfunction getAllDetectedExtensionsFromBytecode(bytecode) {\n  const features = [];\n  extractFeatures(detectFeaturesFromBytecode(bytecode), features);\n  return features;\n}\nfunction constructAbiFromBytecode(bytecode) {\n  let extensions = getAllDetectedExtensionsFromBytecode(bytecode);\n  // special deduping for ERC721 and ERC20\n  if (extensions.find(f => f.name === \"ERC721\")) {\n    extensions = extensions.filter(f => f.name !== \"ERC20\");\n  }\n  const abi = joinABIs(extensions.map(f => joinABIs(f.abis)));\n  return abi;\n}\n\n/**\n * Return all the detected extensions in the abi\n * @param abi - parsed array of abi entries\n * @returns array of all detected extensions with full information on each feature\n * @public\n */\nfunction getAllDetectedExtensions(abi) {\n  return getAllDetectedFeatures(abi).map(f => ({\n    ...f,\n    extensions: f.features\n  }));\n}\n\n// Internal static cache\nconst metadataCache = {};\nlet multichainRegistry = undefined;\nfunction getCacheKey(address, chainId) {\n  return `${address}-${chainId}`;\n}\nfunction putInCache(address, chainId, metadata) {\n  metadataCache[getCacheKey(address, chainId)] = metadata;\n}\nfunction getFromCache(address, chainId) {\n  return metadataCache[getCacheKey(address, chainId)];\n}\n\n/**\n * @internal\n * @param address\n * @param provider\n * @param storage\n */\nasync function fetchContractMetadataFromAddress(address, provider, storage) {\n  let sdkOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const chainId = (await provider.getNetwork()).chainId; // TODO resolve from sdk network\n  const cached = getFromCache(address, chainId);\n  if (cached) {\n    return cached;\n  }\n  let metadata;\n\n  // we can't race here, because the contract URI might resolve first with a non pinned URI\n  const [ipfsData, registryData] = await Promise.all([resolveContractUriAndBytecode(address, provider).catch(() => undefined), getMetadataUriFromMultichainRegistry(address, chainId, sdkOptions).then(uri => {\n    if (!uri) {\n      return undefined;\n    }\n    return {\n      uri,\n      bytecode: \"\"\n    };\n  }).catch(() => undefined)]);\n  const bytecode = ipfsData?.bytecode;\n  const metadataUri = registryData?.uri || ipfsData?.uri;\n  if (!metadataUri && !bytecode) {\n    throw new Error(`Could not fetch bytecode for contract at ${address} on chain ${chainId}, double check that the address and chainId are correct.`);\n  }\n  try {\n    metadata = await fetchContractMetadata(metadataUri, storage);\n  } catch (e) {\n    // Don't warn here, its common to not have IPFS metadata for a contract, fallback to bytecode\n  }\n  if (!metadata && bytecode) {\n    const abi = constructAbiFromBytecode(bytecode);\n    if (abi && abi.length > 0) {\n      console.warn(`Contract metadata could only be partially resolved, some contract functions might be unavailable. Try importing the contract by visiting: https://thirdweb.com/${chainId}/${address}`);\n      // return partial ABI\n      metadata = {\n        name: \"Unimported Contract\",\n        abi: abi,\n        metadata: {},\n        info: {},\n        licenses: [],\n        isPartialAbi: true\n      };\n      // return without caching\n      return metadata;\n    }\n  }\n  if (!metadata) {\n    throw new Error(`Could not resolve contract. Try importing it by visiting: https://thirdweb.com/${chainId}/${address}`);\n  }\n  putInCache(address, chainId, metadata);\n  return metadata;\n}\nasync function getMetadataUriFromMultichainRegistry(address, chainId, sdkOptions) {\n  if (!multichainRegistry) {\n    const polygonChain = sdkOptions?.supportedChains?.find(c => c.chainId === 137);\n    const chain = polygonChain || Polygon;\n    multichainRegistry = new Contract(getMultichainRegistryAddress(), TWRegistryABI, getChainProvider(chain, sdkOptions));\n  }\n  const importedUri = await multichainRegistry.getMetadataUri(chainId, address);\n  return importedUri;\n}\n\n/**\n * @internal\n * @param address\n * @param provider\n * @param storage\n * @returns\n */\nasync function fetchAbiFromAddress(address, provider, storage) {\n  try {\n    const metadata = await fetchContractMetadataFromAddress(address, provider, storage);\n    if (metadata && metadata.abi) {\n      return metadata.abi;\n    }\n  } catch (e) {\n    // ignore and return undefined\n    // will fallback to embedded ABIs for prebuilts\n  }\n  return undefined;\n}\n\nfunction buildDeployTransactionFunction(fn) {\n  async function executeFn() {\n    const tx = await fn(...arguments);\n    return tx.execute();\n  }\n  executeFn.prepare = fn;\n  return executeFn;\n}\nfunction buildTransactionFunction(fn) {\n  async function executeFn() {\n    const tx = await fn(...arguments);\n    return tx.execute();\n  }\n  executeFn.prepare = fn;\n  return executeFn;\n}\n\nasync function getDefaultGasOverrides(provider) {\n  // If we're running in the browser, let users configure gas price in their wallet UI\n  if (isBrowser()) {\n    return {};\n  }\n\n  // handle smart wallet provider\n  if (provider.originalProvider) {\n    provider = provider.originalProvider;\n  }\n  const feeData = await getDynamicFeeData(provider);\n  if (feeData.maxFeePerGas && feeData.maxPriorityFeePerGas) {\n    return {\n      maxFeePerGas: feeData.maxFeePerGas,\n      maxPriorityFeePerGas: feeData.maxPriorityFeePerGas\n    };\n  } else {\n    return {\n      gasPrice: await getGasPrice(provider)\n    };\n  }\n}\nasync function getDynamicFeeData(provider) {\n  let maxFeePerGas = null;\n  let maxPriorityFeePerGas = null;\n  const [{\n    chainId\n  }, block, eth_maxPriorityFeePerGas] = await Promise.all([provider.getNetwork(), provider.getBlock(\"latest\"), provider.send(\"eth_maxPriorityFeePerGas\", []).catch(() => null)]);\n  const baseBlockFee = block && block.baseFeePerGas ? block.baseFeePerGas : utils.parseUnits(\"100\", \"wei\");\n  if (chainId === Mumbai.chainId || chainId === Polygon.chainId) {\n    // for polygon, get fee data from gas station\n    maxPriorityFeePerGas = await getPolygonGasPriorityFee(chainId);\n  } else if (eth_maxPriorityFeePerGas) {\n    // prioritize fee from eth_maxPriorityFeePerGas\n    maxPriorityFeePerGas = BigNumber.from(eth_maxPriorityFeePerGas);\n  } else {\n    // if eth_maxPriorityFeePerGas is not available, use 1.5 gwei default\n    const feeData = await provider.getFeeData();\n    maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;\n    if (!maxPriorityFeePerGas) {\n      // chain does not support eip-1559, return null for both\n      return {\n        maxFeePerGas: null,\n        maxPriorityFeePerGas: null\n      };\n    }\n  }\n\n  // eip-1559 formula, with an extra 10% tip to account for gas volatility\n  maxFeePerGas = baseBlockFee.mul(2).add(getPreferredPriorityFee(maxPriorityFeePerGas));\n  return {\n    maxFeePerGas,\n    maxPriorityFeePerGas\n  };\n}\nfunction getPreferredPriorityFee(defaultPriorityFeePerGas) {\n  let percentMultiplier = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n  const extraTip = defaultPriorityFeePerGas.div(100).mul(percentMultiplier); // + 10%\n  const txGasPrice = defaultPriorityFeePerGas.add(extraTip);\n  return txGasPrice;\n}\nasync function getGasPrice(provider) {\n  const gasPrice = await provider.getGasPrice();\n  const maxGasPrice = utils.parseUnits(\"300\", \"gwei\"); // 300 gwei\n  const extraTip = gasPrice.div(100).mul(10); // + 10%\n  const txGasPrice = gasPrice.add(extraTip);\n  if (txGasPrice.gt(maxGasPrice)) {\n    return maxGasPrice;\n  }\n  return txGasPrice;\n}\n\n/**\n * @internal\n */\nfunction getGasStationUrl(chainId) {\n  switch (chainId) {\n    case ChainId.Polygon:\n      return \"https://gasstation.polygon.technology/v2\";\n    case ChainId.Mumbai:\n      return \"https://gasstation-testnet.polygon.technology/v2\";\n  }\n}\nconst MIN_POLYGON_GAS_PRICE = /* @__PURE__ */utils.parseUnits(\"31\", \"gwei\");\nconst MIN_MUMBAI_GAS_PRICE = /* @__PURE__ */utils.parseUnits(\"1\", \"gwei\");\n\n/**\n * @internal\n */\nfunction getDefaultGasFee(chainId) {\n  switch (chainId) {\n    case ChainId.Polygon:\n      return MIN_POLYGON_GAS_PRICE;\n    case ChainId.Mumbai:\n      return MIN_MUMBAI_GAS_PRICE;\n  }\n}\n\n/**\n *\n * @returns the gas price\n * @internal\n */\nasync function getPolygonGasPriorityFee(chainId) {\n  const gasStationUrl = getGasStationUrl(chainId);\n  try {\n    const data = await (await fetch(gasStationUrl)).json();\n    // take the standard speed here, SDK options will define the extra tip\n    const priorityFee = data[\"fast\"][\"maxPriorityFee\"];\n    if (priorityFee > 0) {\n      const fixedFee = parseFloat(priorityFee).toFixed(9);\n      return utils.parseUnits(fixedFee, \"gwei\");\n    }\n  } catch (e) {\n    console.error(\"failed to fetch gas\", e);\n  }\n  return getDefaultGasFee(chainId);\n}\n\n/**\n * @internal\n * @param publishedMetadata\n * @param storage\n */\n\nasync function fetchSourceFilesFromMetadata(publishedMetadata, storage) {\n  return await Promise.all(Object.entries(publishedMetadata.metadata.sources).map(async _ref => {\n    let [path, info] = _ref;\n    const urls = info.urls;\n    const ipfsLink = urls ? urls.find(url => url.includes(\"ipfs\")) : undefined;\n    if (ipfsLink) {\n      const ipfsHash = ipfsLink.split(\"ipfs/\")[1];\n      // 3 sec timeout for sources that haven't been uploaded to ipfs\n      const timeout = new Promise((_r, rej) => setTimeout(() => rej(\"timeout\"), 3000));\n      const source = await Promise.race([(await storage.download(`ipfs://${ipfsHash}`)).text(), timeout]);\n      return {\n        filename: path,\n        source\n      };\n    } else {\n      return {\n        filename: path,\n        source: info.content || \"Could not find source for this contract\"\n      };\n    }\n  }));\n}\n\nfunction isRouterContract(abi) {\n  const isPluginRouter = isFeatureEnabled(AbiSchema.parse(abi), \"PluginRouter\");\n  const isBaseRouter = isFeatureEnabled(AbiSchema.parse(abi), \"DynamicContract\");\n  return isBaseRouter || isPluginRouter;\n}\n\nconst ERROR_SUBSTRINGS = [\"eip-155\", \"eip155\", \"protected\", \"invalid chain id for signer\", \"chain id none\", \"chain_id mismatch\", \"recovered sender mismatch\", \"transaction hash mismatch\", \"chainid no support\", \"chainid (0)\", \"chainid(0)\"];\nconst ERROR_SUBSTRINGS_COMPOSITE = [[\"account\", \"not found\"], [\"wrong\", \"chainid\"]];\n\n/* eslint-disable no-useless-computed-key */\nconst CUSTOM_GAS_FOR_CHAIN = {\n  [5001]: {\n    name: \"Mantle Testnet\",\n    gasPrice: 1\n  },\n  [71402]: {\n    name: \"Godwoken Mainnet\",\n    gasPrice: 40_000 * 10 ** 9\n  },\n  [1351057110]: {\n    name: \"Chaos (SKALE Testnet)\",\n    gasPrice: 100000\n  },\n  [361]: {\n    name: \"Theta Mainnet\",\n    gasPrice: 4000 * 10 ** 9\n  },\n  [365]: {\n    name: \"Theta Testnet\",\n    gasPrice: 4000 * 10 ** 9\n  },\n  [7700]: {\n    name: \"Canto\",\n    gasPrice: 1000 * 10 ** 9\n  },\n  [7701]: {\n    name: \"Canto Testnet\",\n    gasPrice: 1000 * 10 ** 9\n  },\n  [338]: {\n    name: \"Cronos Testnet\",\n    gasPrice: 2000 * 10 ** 9\n  },\n  [199]: {\n    name: \"BitTorrent Chain\",\n    gasPrice: 300_000 * 10 ** 9\n  }\n};\n/* eslint-enable no-useless-computed-key */\n\nfunction matchError(error) {\n  const errorIndex = ERROR_SUBSTRINGS.findIndex(substring => error.includes(substring));\n  const compositeErrorIndex = ERROR_SUBSTRINGS_COMPOSITE.findIndex(arr => {\n    let foundError = true;\n    arr.forEach(substring => {\n      foundError &&= error.includes(substring);\n    });\n    return foundError;\n  });\n  return errorIndex !== -1 || compositeErrorIndex !== -1;\n}\n\nconst CREATE2_FACTORY_BYTECODE = \"0x604580600e600039806000f350fe7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe03601600081602082378035828234f58015156039578182fd5b8082525050506014600cf3\";\nconst SIGNATURE = {\n  v: 27,\n  r: \"0x2222222222222222222222222222222222222222222222222222222222222222\",\n  s: \"0x2222222222222222222222222222222222222222222222222222222222222222\"\n};\nconst COMMON_FACTORY = \"0x4e59b44847b379578588920cA78FbF26c0B4956C\"; // for pre-eip-155 supporting chains\n\nconst GAS_LIMIT_FOR_DEPLOYER = 5_000_000;\nconst DEPLOYER_BYTECODE = \"0x60806040526040516107f33803806107f383398101604081905261002291610359565b805160005b818110156100c157828181518110610041576100416104c9565b6020026020010151600001516001600160a01b03163b600014156100af576100ad838281518110610074576100746104c9565b602002602001015160200151848381518110610092576100926104c9565b6020026020010151604001516100c960201b6100091760201c565b505b806100b9816104df565b915050610027565b505050610557565b606061011183836040518060400160405280601e81526020017f416464726573733a206c6f772d6c6576656c2063616c6c206661696c6564000081525061011860201b60201c565b9392505050565b6060610127848460008561012f565b949350505050565b6060824710156101955760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6044820152651c8818d85b1b60d21b60648201526084015b60405180910390fd5b6001600160a01b0385163b6101ec5760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e7472616374000000604482015260640161018c565b600080866001600160a01b031685876040516102089190610508565b60006040518083038185875af1925050503d8060008114610245576040519150601f19603f3d011682016040523d82523d6000602084013e61024a565b606091505b50909250905061025b828286610266565b979650505050505050565b60608315610275575081610111565b8251156102855782518084602001fd5b8160405162461bcd60e51b815260040161018c9190610524565b634e487b7160e01b600052604160045260246000fd5b604051606081016001600160401b03811182821017156102d7576102d761029f565b60405290565b604051601f8201601f191681016001600160401b03811182821017156103055761030561029f565b604052919050565b80516001600160a01b038116811461032457600080fd5b919050565b60005b8381101561034457818101518382015260200161032c565b83811115610353576000848401525b50505050565b6000602080838503121561036c57600080fd5b82516001600160401b038082111561038357600080fd5b818501915085601f83011261039757600080fd5b8151818111156103a9576103a961029f565b8060051b6103b88582016102dd565b91825283810185019185810190898411156103d257600080fd5b86860192505b838310156104bc578251858111156103f05760008081fd5b86016060601f19828d0381018213156104095760008081fd5b6104116102b5565b61041c8b850161030d565b8152604061042b81860161030d565b828d01529284015192898411156104425760008081fd5b83850194508e603f86011261045957600093508384fd5b8b85015193508984111561046f5761046f61029f565b61047f8c84601f870116016102dd565b92508383528e818587010111156104965760008081fd5b6104a5848d8501838801610329565b8101919091528452505091860191908601906103d8565b9998505050505050505050565b634e487b7160e01b600052603260045260246000fd5b600060001982141561050157634e487b7160e01b600052601160045260246000fd5b5060010190565b6000825161051a818460208701610329565b9190910192915050565b6020815260008251806020840152610543816040850160208701610329565b601f01601f19169190910160400192915050565b61028d806105666000396000f3fe6080604052600080fd5b606061004b83836040518060400160405280601e81526020017f416464726573733a206c6f772d6c6576656c2063616c6c206661696c65640000815250610052565b9392505050565b60606100618484600085610069565b949350505050565b6060824710156100cf5760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6044820152651c8818d85b1b60d21b60648201526084015b60405180910390fd5b6001600160a01b0385163b6101265760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e747261637400000060448201526064016100c6565b600080866001600160a01b031685876040516101429190610208565b60006040518083038185875af1925050503d806000811461017f576040519150601f19603f3d011682016040523d82523d6000602084013e610184565b606091505b509150915061019482828661019f565b979650505050505050565b606083156101ae57508161004b565b8251156101be5782518084602001fd5b8160405162461bcd60e51b81526004016100c69190610224565b60005b838110156101f35781810151838201526020016101db565b83811115610202576000848401525b50505050565b6000825161021a8184602087016101d8565b9190910192915050565b60208152600082518060208401526102438160408501602087016101d8565b601f01601f1916919091016040019291505056fea26469706673582212200b524eb8ceaafe6c603273ee859fddbc2d6f1b7860c3d853dcf6f129f9d9371364736f6c634300080c0033\";\nconst DEPLOYER_ABI = [{\n  inputs: [{\n    components: [{\n      internalType: \"address\",\n      name: \"predictedAddress\",\n      type: \"address\"\n    }, {\n      internalType: \"address\",\n      name: \"to\",\n      type: \"address\"\n    }, {\n      internalType: \"bytes\",\n      name: \"data\",\n      type: \"bytes\"\n    }],\n    internalType: \"struct IDeployer.Transaction[]\",\n    name: \"transactions\",\n    type: \"tuple[]\"\n  }],\n  stateMutability: \"payable\",\n  type: \"constructor\"\n}];\n\n/**\n * Check if a contract exists at the given address\n *\n * @internal\n * @param address\n * @param provider\n */\nasync function isContractDeployed(address, provider) {\n  const code = await provider.getCode(address);\n  return code !== \"0x\" && code !== \"0x0\";\n}\n\n/**\n * Check if a chain enforces EIP-155 transactions\n * Ref: https://eips.ethereum.org/EIPS/eip-155\n *\n * @internal\n * @param provider\n */\nasync function isEIP155Enforced(provider) {\n  try {\n    // TODO: Find a better way to check this.\n\n    // Send a random transaction of legacy type (pre-eip-155).\n    // It will fail. Parse the error message to check whether eip-155 is enforced.\n    await provider.sendTransaction(\"0xf8a58085174876e800830186a08080b853604580600e600039806000f350fe7fffffffffffffffafffffffffffffffffffffffffffffffffffffffffffffffe03601600081602082378035828234f58015156039578182fd5b8082525050506014600cf31ba02222222222222222222222222222222222222222222222222222222222222222a02222222222222222222222222222222222222222222222222222222222222222\");\n  } catch (e) {\n    const errorMsg = e.toString().toLowerCase();\n    const errorJson = JSON.stringify(e).toLowerCase();\n    if (matchError(errorMsg) || matchError(errorJson)) {\n      return true;\n    }\n    return false;\n  }\n  return false;\n}\n\n/**\n * Generate a transaction to be sent with a keyless signer.\n *\n * @public\n * @param transaction: Unsigned transaction object\n * @param signature: Signature bytes\n */\nfunction getKeylessTxn(transaction, signature) {\n  // 1. Create serialized txn string\n  const digest = utils.arrayify(utils.keccak256(utils.serializeTransaction(transaction)));\n\n  // 2. Determine signer address from custom signature + txn\n  const signer = utils.recoverAddress(digest, signature);\n\n  // 3. Create the signed serialized txn string.\n  // To be sent directly to the chain using a provider.\n  const signedSerializedTx = utils.serializeTransaction(transaction, signature);\n  return {\n    signer: signer,\n    transaction: signedSerializedTx\n  };\n}\n\n/**\n *\n * @public\n * @param transaction: Unsigned transaction object\n * @param signature: Signature bytes\n */\nfunction getCreate2FactoryDeploymentInfo(chainId, gasPrice) {\n  const signature = utils.joinSignature(SIGNATURE);\n  const deploymentTransaction = getKeylessTxn({\n    gasPrice: gasPrice ? gasPrice : 100 * 10 ** 9,\n    gasLimit: 100000,\n    nonce: 0,\n    data: CREATE2_FACTORY_BYTECODE,\n    chainId: chainId\n  }, signature);\n  const create2FactoryAddress = utils.getContractAddress({\n    from: deploymentTransaction.signer,\n    nonce: 0\n  });\n  return {\n    ...deploymentTransaction,\n    deployment: create2FactoryAddress\n  };\n}\n\n/**\n * Get the CREATE2 Factory address for a network\n * Source code of the factory:\n * https://github.com/Arachnid/deterministic-deployment-proxy/blob/master/source/deterministic-deployment-proxy.yul\n *\n * @internal\n * @param provider\n */\nasync function getCreate2FactoryAddress(provider) {\n  const commonFactoryExists = await isContractDeployed(COMMON_FACTORY, provider);\n  if (commonFactoryExists) {\n    return COMMON_FACTORY;\n  }\n  const enforceEip155 = await isEIP155Enforced(provider);\n  const networkId = (await provider.getNetwork()).chainId;\n  const chainId = enforceEip155 ? networkId : 0;\n  const deploymentInfo = CUSTOM_GAS_FOR_CHAIN[networkId] ? getCreate2FactoryDeploymentInfo(chainId, CUSTOM_GAS_FOR_CHAIN[networkId].gasPrice) : getCreate2FactoryDeploymentInfo(chainId);\n  return deploymentInfo.deployment;\n}\n\nconst bytecode = \"0x60606040526040805190810160405280600d81526020017f57726170706564204574686572000000000000000000000000000000000000008152506000908051906020019061004f9291906100c8565b506040805190810160405280600481526020017f57455448000000000000000000000000000000000000000000000000000000008152506001908051906020019061009b9291906100c8565b506012600260006101000a81548160ff021916908360ff16021790555034156100c357600080fd5b61016d565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061010957805160ff1916838001178555610137565b82800160010185558215610137579182015b8281111561013657825182559160200191906001019061011b565b5b5090506101449190610148565b5090565b61016a91905b8082111561016657600081600090555060010161014e565b5090565b90565b610c348061017c6000396000f3006060604052600436106100af576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806306fdde03146100b9578063095ea7b31461014757806318160ddd146101a157806323b872dd146101ca5780632e1a7d4d14610243578063313ce5671461026657806370a082311461029557806395d89b41146102e2578063a9059cbb14610370578063d0e30db0146103ca578063dd62ed3e146103d4575b6100b7610440565b005b34156100c457600080fd5b6100cc6104dd565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561010c5780820151818401526020810190506100f1565b50505050905090810190601f1680156101395780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b341561015257600080fd5b610187600480803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803590602001909190505061057b565b604051808215151515815260200191505060405180910390f35b34156101ac57600080fd5b6101b461066d565b6040518082815260200191505060405180910390f35b34156101d557600080fd5b610229600480803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803590602001909190505061068c565b604051808215151515815260200191505060405180910390f35b341561024e57600080fd5b61026460048080359060200190919050506109d9565b005b341561027157600080fd5b610279610b05565b604051808260ff1660ff16815260200191505060405180910390f35b34156102a057600080fd5b6102cc600480803573ffffffffffffffffffffffffffffffffffffffff16906020019091905050610b18565b6040518082815260200191505060405180910390f35b34156102ed57600080fd5b6102f5610b30565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561033557808201518184015260208101905061031a565b50505050905090810190601f1680156103625780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b341561037b57600080fd5b6103b0600480803573ffffffffffffffffffffffffffffffffffffffff16906020019091908035906020019091905050610bce565b604051808215151515815260200191505060405180910390f35b6103d2610440565b005b34156103df57600080fd5b61042a600480803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803573ffffffffffffffffffffffffffffffffffffffff16906020019091905050610be3565b6040518082815260200191505060405180910390f35b34600360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825401925050819055503373ffffffffffffffffffffffffffffffffffffffff167fe1fffcc4923d04b559f4d29a8bfc6cda04eb5b0d3c460751c2402c5c5cc9109c346040518082815260200191505060405180910390a2565b60008054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156105735780601f1061054857610100808354040283529160200191610573565b820191906000526020600020905b81548152906001019060200180831161055657829003601f168201915b505050505081565b600081600460003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925846040518082815260200191505060405180910390a36001905092915050565b60003073ffffffffffffffffffffffffffffffffffffffff1631905090565b600081600360008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054101515156106dc57600080fd5b3373ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff16141580156107b457507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205414155b156108cf5781600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020541015151561084457600080fd5b81600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825403925050819055505b81600360008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000828254039250508190555081600360008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825401925050819055508273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040518082815260200191505060405180910390a3600190509392505050565b80600360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205410151515610a2757600080fd5b80600360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825403925050819055503373ffffffffffffffffffffffffffffffffffffffff166108fc829081150290604051600060405180830381858888f193505050501515610ab457600080fd5b3373ffffffffffffffffffffffffffffffffffffffff167f7fcf532c15f0a6db0bd6d0e038bea71d30d808c7d98cb3bf7268a95bf5081b65826040518082815260200191505060405180910390a250565b600260009054906101000a900460ff1681565b60036020528060005260406000206000915090505481565b60018054600181600116156101000203166002900480601f016020809104026020016040519081016040528092919081815260200182805460018160011615610100020316600290048015610bc65780601f10610b9b57610100808354040283529160200191610bc6565b820191906000526020600020905b815481529060010190602001808311610ba957829003601f168201915b505050505081565b6000610bdb33848461068c565b905092915050565b60046020528160005260406000206020528060005260406000206000915091505054815600a165627a7a72305820deb4c2ccab3c2fdca32ab3f46728389c2fe2c165d5fafa07661e4e004f6c344a0029\";\n\nconst ContractPublisher_address = \"0x664244560eBa21Bf82d7150C791bE1AbcD5B4cd7\"; // Polygon only\n\n/**\n * @internal\n */\nfunction getContractPublisherAddress() {\n  return getProcessEnv(\"contractPublisherAddress\", ContractPublisher_address);\n}\n\nconst DropErc721ContractInput = /* @__PURE__ */CommonContractSchema.merge(CommonRoyaltySchema).merge(MerkleSchema).merge(CommonSymbolSchema);\nconst DropErc721ContractOutput = /* @__PURE__ */CommonContractOutputSchema.merge(CommonRoyaltySchema).merge(MerkleSchema).merge(CommonSymbolSchema);\nconst DropErc721ContractDeploy = /* @__PURE__ */DropErc721ContractInput.merge(CommonPlatformFeeSchema).merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema);\nconst DropErc721ContractSchema = {\n  deploy: DropErc721ContractDeploy,\n  output: DropErc721ContractOutput,\n  input: DropErc721ContractInput\n};\n\nconst DropErc1155ContractInput = /* @__PURE__ */CommonContractSchema.merge(CommonRoyaltySchema).merge(MerkleSchema).merge(CommonSymbolSchema);\nconst DropErc1155ContractOutput = /* @__PURE__ */CommonContractOutputSchema.merge(CommonRoyaltySchema).merge(MerkleSchema).merge(CommonSymbolSchema);\nconst DropErc1155ContractDeploy = /* @__PURE__ */DropErc1155ContractInput.merge(CommonPlatformFeeSchema).merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema);\nconst DropErc1155ContractSchema = {\n  deploy: DropErc1155ContractDeploy,\n  output: DropErc1155ContractOutput,\n  input: DropErc1155ContractInput\n};\n\nconst MarketplaceContractInput = CommonContractSchema;\nconst MarketplaceContractOutput = CommonContractOutputSchema;\nconst MarketplaceContractDeploy = /* @__PURE__ */MarketplaceContractInput.merge(CommonPlatformFeeSchema).merge(CommonTrustedForwarderSchema);\nconst MarketplaceContractSchema = {\n  deploy: MarketplaceContractDeploy,\n  output: MarketplaceContractOutput,\n  input: MarketplaceContractInput\n};\n\nconst PackContractInput = /* @__PURE__ */CommonContractSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema);\nconst PackContractOutput = /* @__PURE__ */CommonContractOutputSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema);\nconst PackContractDeploy = /* @__PURE__ */PackContractInput.merge(CommonPlatformFeeSchema).merge(CommonTrustedForwarderSchema);\nconst PackContractSchema = {\n  deploy: PackContractDeploy,\n  output: PackContractOutput,\n  input: PackContractInput\n};\n\nconst SplitRecipientInputSchema = /* @__PURE__ */(() => z.object({\n  address: AddressOrEnsSchema,\n  sharesBps: BasisPointsSchema.gt(0, \"Shares must be greater than 0\")\n}))();\nconst SplitRecipientOuputSchema = /* @__PURE__ */SplitRecipientInputSchema.extend({\n  address: AddressOrEnsSchema,\n  sharesBps: BasisPointsSchema\n});\nconst SplitsContractInput = /* @__PURE__ */(() => CommonContractSchema.extend({\n  recipients: z.array(SplitRecipientInputSchema).default([]).superRefine((val, context) => {\n    const addressMap = {};\n    let totalShares = 0;\n    for (let index = 0; index < val.length; index++) {\n      const entry = val[index];\n      if (addressMap[entry.address]) {\n        context.addIssue({\n          code: z.ZodIssueCode.custom,\n          message: `Duplicate address.`,\n          path: [index, `address`]\n        });\n      }\n      addressMap[entry.address] = true;\n      totalShares += entry.sharesBps;\n      if (totalShares > 10000) {\n        context.addIssue({\n          code: z.ZodIssueCode.custom,\n          message: `Total shares cannot go over 100%.`,\n          path: [index, `sharesBps`]\n        });\n      }\n    }\n    if (totalShares !== 10000) {\n      context.addIssue({\n        code: z.ZodIssueCode.custom,\n        message: `Total shares need to add up to 100%. Total shares are currently ${totalShares / 100}%`,\n        path: []\n      });\n    }\n  })\n}))();\nconst SplitsContractOutput = /* @__PURE__ */(() => CommonContractOutputSchema.extend({\n  recipients: z.array(SplitRecipientOuputSchema)\n}))();\nconst SplitsContractDeploy = /* @__PURE__ */SplitsContractInput.merge(SplitsContractInput).merge(CommonTrustedForwarderSchema);\nconst SplitsContractSchema = {\n  deploy: SplitsContractDeploy,\n  output: SplitsContractOutput,\n  input: SplitsContractInput\n};\n\nconst TokenErc20ContractInput = /* @__PURE__ */CommonContractSchema.merge(CommonSymbolSchema);\nconst TokenErc20ContractOutput = /* @__PURE__ */CommonContractOutputSchema.merge(CommonSymbolSchema);\nconst TokenErc20ContractDeploy = /* @__PURE__ */TokenErc20ContractInput.merge(CommonPlatformFeeSchema).merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema);\nconst TokenErc20ContractSchema = {\n  deploy: TokenErc20ContractDeploy,\n  output: TokenErc20ContractOutput,\n  input: TokenErc20ContractInput\n};\n\nconst TokenErc721ContractInput = /* @__PURE__ */CommonContractSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema);\nconst TokenErc721ContractOutput = /* @__PURE__ */CommonContractOutputSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema);\nconst TokenErc721ContractDeploy = /* @__PURE__ */TokenErc721ContractInput.merge(CommonPlatformFeeSchema).merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema);\nconst TokenErc721ContractSchema = {\n  deploy: TokenErc721ContractDeploy,\n  output: TokenErc721ContractOutput,\n  input: TokenErc721ContractInput\n};\n\nconst TokenErc1155ContractInput = /* @__PURE__ */CommonContractSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema);\nconst TokenErc1155ContractOutput = /* @__PURE__ */CommonContractOutputSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema);\nconst TokenErc1155ContractDeploy = /* @__PURE__ */TokenErc1155ContractInput.merge(CommonPlatformFeeSchema).merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema);\nconst TokenErc1155ContractSchema = {\n  deploy: TokenErc1155ContractDeploy,\n  output: TokenErc1155ContractOutput,\n  input: TokenErc1155ContractInput\n};\n\nconst VoteSettingsInputSchema = /* @__PURE__ */(() => z.object({\n  voting_delay_in_blocks: z.number().min(0).default(0),\n  voting_period_in_blocks: z.number().min(1).default(1),\n  voting_token_address: AddressOrEnsSchema,\n  voting_quorum_fraction: PercentSchema.default(0),\n  proposal_token_threshold: BigNumberishSchema.default(1)\n}))();\nconst VoteSettingsOuputSchema = /* @__PURE__ */VoteSettingsInputSchema.extend({\n  proposal_token_threshold: BigNumberSchema\n});\nconst VoteContractInput = /* @__PURE__ */CommonContractSchema.merge(VoteSettingsInputSchema);\nconst VoteContractOutput = /* @__PURE__ */CommonContractOutputSchema.merge(VoteSettingsOuputSchema);\nconst VoteContractDeploy = /* @__PURE__ */VoteContractInput.merge(CommonTrustedForwarderSchema);\nconst VoteContractSchema = {\n  deploy: VoteContractDeploy,\n  output: VoteContractOutput,\n  input: VoteContractInput\n};\n\nasync function resolveAddress(addressOrEns) {\n  return AddressOrEnsSchema.parseAsync(addressOrEns);\n}\n\n/**\n * Fetch and parse the full metadata AFTER publishing a contract, with all the extra information (version, readme, etc)\n * @internal\n * @param publishMetadataUri\n * @param storage\n */\nasync function fetchExtendedReleaseMetadata(publishMetadataUri, storage) {\n  const meta = await (await storage.download(publishMetadataUri)).text();\n  return FullPublishMetadataSchemaOutput.parse(JSON.parse(meta));\n}\n\n/**\n * @internal\n * @param publishMetadataUri\n * @param storage\n */\nasync function fetchRawPredeployMetadata(publishMetadataUri, storage) {\n  return PreDeployMetadata.parse(JSON.parse(await (await storage.download(publishMetadataUri)).text()));\n}\n\n/**\n * Fetch the metadata coming from CLI, this is before deploying or releasing the contract.\n * @internal\n * @param publishMetadataUri\n * @param storage\n */\nasync function fetchPreDeployMetadata(publishMetadataUri, storage) {\n  const rawMeta = await fetchRawPredeployMetadata(publishMetadataUri, storage);\n  const deployBytecode = await (await storage.download(rawMeta.bytecodeUri)).text();\n  const parsedMeta = await fetchContractMetadata(rawMeta.metadataUri, storage);\n  return PreDeployMetadataFetchedSchema.parse({\n    ...rawMeta,\n    ...parsedMeta,\n    bytecode: deployBytecode\n  });\n}\n\nconst deployMetadataCache = {};\nasync function fetchAndCacheDeployMetadata(publishMetadataUri, storage) {\n  if (deployMetadataCache[publishMetadataUri]) {\n    return deployMetadataCache[publishMetadataUri];\n  }\n  const compilerMetadata = await fetchPreDeployMetadata(publishMetadataUri, storage);\n  let extendedMetadata;\n  try {\n    extendedMetadata = await fetchExtendedReleaseMetadata(publishMetadataUri, storage);\n  } catch (e) {\n    // not a factory deployment, ignore\n  }\n  const data = {\n    compilerMetadata,\n    extendedMetadata\n  };\n  deployMetadataCache[publishMetadataUri] = data;\n  return data;\n}\n\nconst AddressZero = \"0x0000000000000000000000000000000000000000\";\n\nconst TWRegistry_address = \"0x7c487845f98938Bb955B1D5AD069d9a30e4131fd\";\nconst TWFactory_address = \"0x5DBC7B840baa9daBcBe9D2492E45D7244B54A2A0\";\n\n/**\n * @internal\n */\nconst OZ_DEFENDER_FORWARDER_ADDRESS = \"0xc82BbE41f2cF04e3a8efA18F7032BDD7f6d98a81\";\n\n/**\n * @internal\n */\nconst CONTRACT_ADDRESSES = {\n  [ChainId.Mainnet]: {\n    openzeppelinForwarder: OZ_DEFENDER_FORWARDER_ADDRESS,\n    openzeppelinForwarderEOA: \"0x76ce2CB1Ae48Fa067f4fb8c5f803111AE0B24BEA\",\n    biconomyForwarder: \"0x84a0856b038eaAd1cC7E297cF34A7e72685A8693\",\n    twFactory: TWFactory_address,\n    twRegistry: TWRegistry_address,\n    twBYOCRegistry: AddressZero\n  },\n  [ChainId.Goerli]: {\n    openzeppelinForwarder: \"0x5001A14CA6163143316a7C614e30e6041033Ac20\",\n    openzeppelinForwarderEOA: \"0xe73c50cB9c5B378627ff625BB6e6725A4A5D65d2\",\n    biconomyForwarder: \"0xE041608922d06a4F26C0d4c27d8bCD01daf1f792\",\n    twFactory: TWFactory_address,\n    twRegistry: TWRegistry_address,\n    twBYOCRegistry: \"0xB1Bd9d7942A250BA2Dce27DD601F2ED4211A60C4\"\n  },\n  [ChainId.Polygon]: {\n    openzeppelinForwarder: OZ_DEFENDER_FORWARDER_ADDRESS,\n    openzeppelinForwarderEOA: \"0x4f247c69184ad61036EC2Bb3213b69F10FbEDe1F\",\n    biconomyForwarder: \"0x86C80a8aa58e0A4fa09A69624c31Ab2a6CAD56b8\",\n    twFactory: TWFactory_address,\n    twRegistry: TWRegistry_address,\n    twBYOCRegistry: \"0x308473Be900F4185A56587dE54bDFF5E8f7a6AE7\"\n  },\n  [ChainId.Mumbai]: {\n    openzeppelinForwarder: OZ_DEFENDER_FORWARDER_ADDRESS,\n    openzeppelinForwarderEOA: \"0xb1A2883fc4d287d9cB8Dbb96cFF60C76BEf2D250\",\n    biconomyForwarder: \"0x9399BB24DBB5C4b782C70c2969F58716Ebbd6a3b\",\n    twFactory: TWFactory_address,\n    twRegistry: TWRegistry_address,\n    twBYOCRegistry: \"0x3F17972CB27506eb4a6a3D59659e0B57a43fd16C\"\n  },\n  [ChainId.Avalanche]: {\n    openzeppelinForwarder: OZ_DEFENDER_FORWARDER_ADDRESS,\n    openzeppelinForwarderEOA: \"0xb1A2883fc4d287d9cB8Dbb96cFF60C76BEf2D250\",\n    biconomyForwarder: \"0x64CD353384109423a966dCd3Aa30D884C9b2E057\",\n    twFactory: TWFactory_address,\n    twRegistry: TWRegistry_address,\n    twBYOCRegistry: AddressZero\n  },\n  [ChainId.AvalancheFujiTestnet]: {\n    openzeppelinForwarder: OZ_DEFENDER_FORWARDER_ADDRESS,\n    openzeppelinForwarderEOA: \"0xe73c50cB9c5B378627ff625BB6e6725A4A5D65d2\",\n    biconomyForwarder: \"0x6271Ca63D30507f2Dcbf99B52787032506D75BBF\",\n    twFactory: TWFactory_address,\n    twRegistry: TWRegistry_address,\n    twBYOCRegistry: \"0x3E6eE864f850F5e5A98bc950B68E181Cf4010F23\"\n  },\n  [ChainId.Fantom]: {\n    openzeppelinForwarder: OZ_DEFENDER_FORWARDER_ADDRESS,\n    openzeppelinForwarderEOA: \"0xb1A2883fc4d287d9cB8Dbb96cFF60C76BEf2D250\",\n    biconomyForwarder: \"0x64CD353384109423a966dCd3Aa30D884C9b2E057\",\n    twFactory: \"0x97EA0Fcc552D5A8Fb5e9101316AAd0D62Ea0876B\",\n    twRegistry: TWRegistry_address,\n    twBYOCRegistry: AddressZero\n  },\n  [ChainId.FantomTestnet]: {\n    openzeppelinForwarder: OZ_DEFENDER_FORWARDER_ADDRESS,\n    openzeppelinForwarderEOA: \"0x42D3048b595B6e1c28a588d70366CcC2AA4dB47b\",\n    biconomyForwarder: \"0x69FB8Dca8067A5D38703b9e8b39cf2D51473E4b4\",\n    twFactory: TWFactory_address,\n    twRegistry: TWRegistry_address,\n    twBYOCRegistry: \"0x3E6eE864f850F5e5A98bc950B68E181Cf4010F23\"\n  },\n  [ChainId.Arbitrum]: {\n    openzeppelinForwarder: \"0x4a8AC7f22DeD2CF923A51e4A1c67490bd8868add\",\n    openzeppelinForwarderEOA: \"0x4f247c69184ad61036EC2Bb3213b69F10FbEDe1F\",\n    biconomyForwarder: \"0xfe0fa3C06d03bDC7fb49c892BbB39113B534fB57\",\n    twFactory: \"0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0\",\n    twRegistry: TWRegistry_address,\n    twBYOCRegistry: AddressZero\n  },\n  [ChainId.ArbitrumGoerli]: {\n    openzeppelinForwarder: \"0x8cbc8B5d71702032904750A66AEfE8B603eBC538\",\n    openzeppelinForwarderEOA: \"0x119704314Ef304EaAAE4b3c7C9ABd59272A28310\",\n    biconomyForwarder: AddressZero,\n    twFactory: \"0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0\",\n    twRegistry: TWRegistry_address,\n    twBYOCRegistry: AddressZero\n  },\n  [ChainId.Optimism]: {\n    openzeppelinForwarder: \"0xd85da690EF288A6976DE0E85Fb2Aad512eBAfbf7\",\n    openzeppelinForwarderEOA: \"0x7e80648EB2071E26937F9D42A513ccf4815fc702\",\n    biconomyForwarder: \"0xefba8a2a82ec1fb1273806174f5e28fbb917cf95\",\n    twFactory: \"0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0\",\n    twRegistry: TWRegistry_address,\n    twBYOCRegistry: AddressZero\n  },\n  [ChainId.OptimismGoerli]: {\n    openzeppelinForwarder: \"0x8cbc8B5d71702032904750A66AEfE8B603eBC538\",\n    openzeppelinForwarderEOA: \"0x119704314Ef304EaAAE4b3c7C9ABd59272A28310\",\n    biconomyForwarder: AddressZero,\n    twFactory: \"0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0\",\n    twRegistry: TWRegistry_address,\n    twBYOCRegistry: AddressZero\n  },\n  [ChainId.BinanceSmartChainMainnet]: {\n    openzeppelinForwarder: \"0x7C4717039B89d5859c4Fbb85EDB19A6E2ce61171\",\n    openzeppelinForwarderEOA: \"0xE8dd2Ff0212F86d3197b4AfDC6dAC6ac47eb10aC\",\n    biconomyForwarder: \"0x86C80a8aa58e0A4fa09A69624c31Ab2a6CAD56b8\",\n    twBYOCRegistry: AddressZero,\n    twFactory: \"0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0\",\n    twRegistry: TWRegistry_address\n  },\n  [ChainId.BinanceSmartChainTestnet]: {\n    openzeppelinForwarder: \"0x44bE9D54B9C8b5e57a3325E8Ec9154640e7c6955\",\n    openzeppelinForwarderEOA: \"0x7e80648EB2071E26937F9D42A513ccf4815fc702\",\n    biconomyForwarder: \"0x61456BF1715C1415730076BB79ae118E806E74d2\",\n    twBYOCRegistry: AddressZero,\n    twFactory: \"0xd24b3de085CFd8c54b94feAD08a7962D343E6DE0\",\n    twRegistry: TWRegistry_address\n  },\n  [ChainId.Hardhat]: {\n    openzeppelinForwarder: AddressZero,\n    openzeppelinForwarderEOA: AddressZero,\n    biconomyForwarder: AddressZero,\n    twFactory: AddressZero,\n    twRegistry: AddressZero,\n    twBYOCRegistry: AddressZero\n  },\n  [ChainId.Localhost]: {\n    openzeppelinForwarder: AddressZero,\n    openzeppelinForwarderEOA: AddressZero,\n    biconomyForwarder: AddressZero,\n    twFactory: AddressZero,\n    twRegistry: AddressZero,\n    twBYOCRegistry: AddressZero\n  }\n};\n\n/**\n * @internal\n */\nfunction getContractAddressByChainId(chainId, contractName) {\n  // for testing only\n  if (chainId === ChainId.Hardhat || chainId === ChainId.Localhost) {\n    if (contractName === \"twFactory\") {\n      return getProcessEnv(\"factoryAddress\");\n    } else if (contractName === \"twRegistry\") {\n      return getProcessEnv(\"registryAddress\");\n    } else {\n      return AddressZero;\n    }\n  }\n  // real output here\n  return CONTRACT_ADDRESSES[chainId]?.[contractName];\n}\n\n/**\n * @internal\n */\n\n/**\n * @internal\n */\nconst InterfaceId_IERC721 = /* @__PURE__ */utils.arrayify(\"0x80ac58cd\");\n\n/**\n * @internal\n */\nconst InterfaceId_IERC1155 = /* @__PURE__ */utils.arrayify(\"0xd9b67a26\");\n\n/**\n * @public\n */\nlet EventType = /*#__PURE__*/function (EventType) {\n  EventType[\"Transaction\"] = \"transaction\";\n  EventType[\"Signature\"] = \"signature\";\n  return EventType;\n}({});\n\nconst THIRDWEB_DEPLOYER = \"0xdd99b75f095d0c4d5112aCe938e4e6ed962fb024\";\nasync function fetchPublishedContractFromPolygon(publisherAddress, contractName) {\n  let version = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"latest\";\n  let storage = arguments.length > 3 ? arguments[3] : undefined;\n  let clientId = arguments.length > 4 ? arguments[4] : undefined;\n  let secretKey = arguments.length > 5 ? arguments[5] : undefined;\n  const polygonChain = getSupportedChains().find(c => c.chainId === 137);\n  const chain = polygonChain || Polygon;\n  const publisher = await resolveAddress(publisherAddress);\n  const contract = new Contract(getContractPublisherAddress(), ContractPublisherAbi, getChainProvider(chain, {\n    clientId,\n    secretKey\n  }));\n  let publishedContract;\n  if (!version || version === \"latest\") {\n    const model = await contract.getPublishedContract(publisher, contractName);\n    publishedContract = PublishedContractSchema.parse({\n      id: model.contractId,\n      timestamp: model.publishTimestamp,\n      metadataUri: model.publishMetadataUri\n    });\n  } else {\n    const allVersions = (await contract.getPublishedContractVersions(publisher, contractName)).map(c => {\n      return PublishedContractSchema.parse({\n        id: c.contractId,\n        timestamp: c.publishTimestamp,\n        metadataUri: c.publishMetadataUri\n      });\n    });\n\n    // get the metadata for each version\n    const versionMetadata = await Promise.all(allVersions.map(async c => {\n      return {\n        name: c.id,\n        publishedTimestamp: c.timestamp,\n        publishedMetadata: await fetchAndCacheDeployMetadata(c.metadataUri, storage)\n      };\n    }));\n    // find the version that matches the version string\n    const versionMatch = versionMetadata.find(metadata => metadata.publishedMetadata.extendedMetadata?.version === version);\n    invariant(versionMatch, \"Contract version not found\");\n    // match the version back to the contract based on the published timestamp\n    publishedContract = allVersions.find(c => c.timestamp === versionMatch.publishedTimestamp);\n  }\n  if (!publishedContract) {\n    throw new Error(`No published contract found for ${contractName} at version by '${THIRDWEB_DEPLOYER}'`);\n  }\n  return publishedContract;\n}\n\n/**\n * Generate salt for deployment with Create2\n * Note: Salt component is generated by appending `tw` (thirdweb) to the bytecode\n *\n * @internal\n * @param bytecode: Creation bytecode of the contract to deploy\n */\nfunction getSaltHash(bytecode) {\n  const bytecodePrefixed = bytecode.startsWith(\"0x\") ? bytecode : `0x${bytecode}`;\n  const bytecodeHash = utils.id(bytecodePrefixed);\n  const salt = `tw.${bytecodeHash}`;\n  const saltHash = utils.id(salt);\n  return saltHash;\n}\n\n/**\n *\n * Construct init-bytecode, packed with salthash.\n * This hex data is intended to be sent to the CREATE2 factory address\n *\n * @internal\n * @param bytecode: Creation bytecode of the contract to deploy\n * @param encodedArgs: Abi-encoded constructor params\n */\nfunction getInitBytecodeWithSalt(bytecode, encodedArgs, salt) {\n  const bytecodePrefixed = bytecode.startsWith(\"0x\") ? bytecode : `0x${bytecode}`;\n  const saltHash = salt ? utils.id(salt) : getSaltHash(bytecodePrefixed);\n  const initBytecodeWithSalt = utils.solidityPack([\"bytes32\", \"bytes\", \"bytes\"], [saltHash, bytecodePrefixed, encodedArgs]);\n  return initBytecodeWithSalt;\n}\n\n/**\n * Pre-compute a contract's deployment address for a CREATE2 deployment.\n *\n * @public\n * @param bytecode: Creation bytecode of the contract to deploy\n * @param encodedArgs: Abi-encoded constructor params\n * @param create2FactoryAddress\n */\nfunction computeDeploymentAddress(bytecode, encodedArgs, create2FactoryAddress, salt) {\n  const bytecodePrefixed = bytecode.startsWith(\"0x\") ? bytecode : `0x${bytecode}`;\n  const saltHash = salt ? utils.id(salt) : getSaltHash(bytecodePrefixed);\n\n  // 1. create init bytecode hash with contract's bytecode and encoded args\n  const initBytecode = utils.solidityPack([\"bytes\", \"bytes\"], [bytecodePrefixed, encodedArgs]);\n\n  // 2. abi-encode pack the deployer address, salt, and bytecode hash\n  const deployInfoPacked = utils.solidityPack([\"bytes1\", \"address\", \"bytes32\", \"bytes32\"], [\"0xff\", create2FactoryAddress, saltHash, utils.solidityKeccak256([\"bytes\"], [initBytecode])]);\n\n  // 3. hash the packed deploy info\n  const hashedDeployInfo = utils.solidityKeccak256([\"bytes\"], [deployInfoPacked]);\n\n  // 4. return last 20 bytes (40 characters) of the hash -- this is the predicted address\n  return `0x${hashedDeployInfo.slice(26)}`;\n}\n\n/**\n *\n * @param abi\n * @returns\n * @internal\n */\nfunction extractConstructorParamsFromAbi(abi) {\n  const parsedAbi = AbiSchema.parse(abi || []);\n  for (const input of parsedAbi) {\n    if (input.type === \"constructor\") {\n      return input.inputs || [];\n    }\n  }\n  return [];\n}\n\nconst caches = {\n  deploymentPresets: {}\n};\n\n/**\n * Returns the RoyaltyEngineV1 address for a given chain\n * @param chainId - the chain id\n * @public\n */\nfunction getRoyaltyEngineV1ByChainId(chainId) {\n  return ROYALTY_ENGINE_V1_ADDRESS[chainId] || constants.AddressZero;\n}\nconst ROYALTY_ENGINE_V1_ADDRESS = {\n  [ChainId.Mainnet]: \"0x0385603ab55642cb4dd5de3ae9e306809991804f\",\n  [ChainId.Goerli]: \"0xEF770dFb6D5620977213f55f99bfd781D04BBE15\",\n  [ChainId.BinanceSmartChainMainnet]: \"0xEF770dFb6D5620977213f55f99bfd781D04BBE15\",\n  [ChainId.Polygon]: \"0x28EdFcF0Be7E86b07493466e7631a213bDe8eEF2\",\n  [ChainId.Mumbai]: \"0x0a01E11887f727D1b1Cd81251eeEE9BEE4262D07\",\n  [ChainId.Avalanche]: \"0xEF770dFb6D5620977213f55f99bfd781D04BBE15\",\n  [ChainId.Optimism]: \"0xEF770dFb6D5620977213f55f99bfd781D04BBE15\",\n  [ChainId.Arbitrum]: \"0xEF770dFb6D5620977213f55f99bfd781D04BBE15\"\n};\n\nasync function computeDeploymentInfo(contractType, provider, storage, create2Factory, contractOptions, clientId, secretKey) {\n  const contractName = contractOptions && contractOptions.contractName;\n  const version = contractOptions && contractOptions.version;\n  let publisherAddress = contractOptions && contractOptions.publisherAddress;\n  let metadata = contractOptions && contractOptions.metadata;\n  invariant(contractName || metadata, \"Require contract name or metadata\");\n  if (contractName && caches.deploymentPresets[contractName]) {\n    return caches.deploymentPresets[contractName];\n  }\n\n  // Different treatment for WETH contract\n  if (contractName === \"WETH9\") {\n    const address = computeDeploymentAddress(bytecode, [], create2Factory);\n    const contractDeployed = await isContractDeployed(address, provider);\n    let initBytecodeWithSalt = \"\";\n    if (!contractDeployed) {\n      initBytecodeWithSalt = getInitBytecodeWithSalt(bytecode, []);\n    }\n    return {\n      name: contractName,\n      type: contractType,\n      transaction: {\n        predictedAddress: address,\n        to: create2Factory,\n        data: initBytecodeWithSalt\n      }\n    };\n  }\n  if (!metadata) {\n    invariant(contractName, \"Require contract name\");\n    if (!publisherAddress) {\n      publisherAddress = THIRDWEB_DEPLOYER;\n    }\n    const publishedContract = await fetchPublishedContractFromPolygon(publisherAddress, contractName, version, storage, clientId, secretKey);\n    metadata = (await fetchAndCacheDeployMetadata(publishedContract.metadataUri, storage)).compilerMetadata;\n  }\n  const encodedArgs = await encodeConstructorParamsForImplementation(metadata, provider, storage, create2Factory, contractOptions?.constructorParams, clientId, secretKey);\n  const address = computeDeploymentAddress(metadata.bytecode, encodedArgs, create2Factory);\n  const contractDeployed = await isContractDeployed(address, provider);\n  let initBytecodeWithSalt = \"\";\n  if (!contractDeployed) {\n    initBytecodeWithSalt = getInitBytecodeWithSalt(metadata.bytecode, encodedArgs);\n  }\n  return {\n    name: contractName,\n    type: contractType,\n    transaction: {\n      predictedAddress: address,\n      to: create2Factory,\n      data: initBytecodeWithSalt\n    },\n    encodedArgs\n  };\n}\n\n/**\n * @internal\n *\n * Determine constructor params required by an implementation contract.\n * Return abi-encoded params.\n */\nasync function encodeConstructorParamsForImplementation(compilerMetadata, provider, storage, create2Factory, constructorParamMap, clientId, secretKey) {\n  const constructorParams = extractConstructorParamsFromAbi(compilerMetadata.abi);\n  const constructorParamTypes = constructorParams.map(p => {\n    if (p.type === \"tuple[]\") {\n      return utils.ParamType.from(p);\n    } else {\n      return p.type;\n    }\n  });\n  const constructorParamValues = await Promise.all(constructorParams.map(async p => {\n    if (constructorParamMap && constructorParamMap[p.name]) {\n      if (constructorParamMap[p.name].type) {\n        invariant(constructorParamMap[p.name].type === p.type, `Provided type ${constructorParamMap[p.name].type} doesn't match the actual type ${p.type} from Abi`);\n      }\n      return constructorParamMap[p.name].value;\n    }\n    if (p.name && p.name.includes(\"nativeTokenWrapper\")) {\n      const chainId = (await provider.getNetwork()).chainId;\n      let nativeTokenWrapperAddress = getNativeTokenByChainId(chainId).wrapped.address;\n      if (nativeTokenWrapperAddress === constants.AddressZero) {\n        const deploymentInfo = await computeDeploymentInfo(\"infra\", provider, storage, create2Factory, {\n          contractName: \"WETH9\"\n        }, clientId, secretKey);\n        if (!caches.deploymentPresets[\"WETH9\"]) {\n          caches.deploymentPresets[\"WETH9\"] = deploymentInfo;\n        }\n        nativeTokenWrapperAddress = deploymentInfo.transaction.predictedAddress;\n      }\n      return nativeTokenWrapperAddress;\n    } else if (p.name && p.name.includes(\"trustedForwarder\")) {\n      if (compilerMetadata.name === \"Pack\") {\n        // EOAForwarder for Pack\n        const deploymentInfo = await computeDeploymentInfo(\"infra\", provider, storage, create2Factory, {\n          contractName: \"ForwarderEOAOnly\"\n        }, clientId, secretKey);\n        if (!caches.deploymentPresets[\"ForwarderEOAOnly\"]) {\n          caches.deploymentPresets[\"ForwarderEOAOnly\"] = deploymentInfo;\n        }\n        return deploymentInfo.transaction.predictedAddress;\n      }\n      const deploymentInfo = await computeDeploymentInfo(\"infra\", provider, storage, create2Factory, {\n        contractName: \"Forwarder\"\n      }, clientId, secretKey);\n      if (!caches.deploymentPresets[\"Forwarder\"]) {\n        caches.deploymentPresets[\"Forwarder\"] = deploymentInfo;\n      }\n      return deploymentInfo.transaction.predictedAddress;\n    } else if (p.name && p.name.includes(\"royaltyEngineAddress\")) {\n      const chainId = (await provider.getNetwork()).chainId;\n      return getRoyaltyEngineV1ByChainId(chainId);\n    } else {\n      throw new Error(\"Can't resolve constructor arguments\");\n    }\n  }));\n  const encodedArgs = utils.defaultAbiCoder.encode(constructorParamTypes, constructorParamValues);\n  return encodedArgs;\n}\n\n/**\n *\n * @internal\n * @param provider\n * @param storage\n * @param create2Factory\n */\nasync function computeEOAForwarderAddress(provider, storage, create2Factory, clientId, secretKey) {\n  if (!create2Factory || create2Factory === \"\") {\n    create2Factory = await getCreate2FactoryAddress(provider);\n  }\n  return (await computeDeploymentInfo(\"infra\", provider, storage, create2Factory, {\n    contractName: \"ForwarderEOAOnly\"\n  }, clientId, secretKey)).transaction.predictedAddress;\n}\n\n/**\n *\n * @internal\n * @param provider\n * @param storage\n * @param create2Factory\n */\nasync function computeForwarderAddress(provider, storage, create2Factory, clientId, secretKey) {\n  if (!create2Factory || create2Factory === \"\") {\n    create2Factory = await getCreate2FactoryAddress(provider);\n  }\n  return (await computeDeploymentInfo(\"infra\", provider, storage, create2Factory, {\n    contractName: \"Forwarder\"\n  }, clientId, secretKey)).transaction.predictedAddress;\n}\n\n/**\n * @internal\n */\nconst ForwardRequest = [{\n  name: \"from\",\n  type: \"address\"\n}, {\n  name: \"to\",\n  type: \"address\"\n}, {\n  name: \"value\",\n  type: \"uint256\"\n}, {\n  name: \"gas\",\n  type: \"uint256\"\n}, {\n  name: \"nonce\",\n  type: \"uint256\"\n}, {\n  name: \"data\",\n  type: \"bytes\"\n}];\nconst ChainAwareForwardRequest = [{\n  name: \"from\",\n  type: \"address\"\n}, {\n  name: \"to\",\n  type: \"address\"\n}, {\n  name: \"value\",\n  type: \"uint256\"\n}, {\n  name: \"gas\",\n  type: \"uint256\"\n}, {\n  name: \"nonce\",\n  type: \"uint256\"\n}, {\n  name: \"data\",\n  type: \"bytes\"\n}, {\n  name: \"chainid\",\n  type: \"uint256\"\n}];\n\n/**\n * @internal\n */\nconst BiconomyForwarderAbi = [{\n  inputs: [{\n    internalType: \"address\",\n    name: \"from\",\n    type: \"address\"\n  }, {\n    internalType: \"uint256\",\n    name: \"batchId\",\n    type: \"uint256\"\n  }],\n  name: \"getNonce\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}];\nconst _nonces = {};\nconst _noncesSyncTimestamp = {};\n\n/**\n * @internal\n */\nasync function getAndIncrementNonce(forwarder, forwarderFunction, forwarderArgs) {\n  // address is only used for internal caching :)\n  const address = forwarderArgs.join(\"|\");\n  const timestamp = _noncesSyncTimestamp[address];\n  // if it's within 2 seconds we're optimistically increment the nonce\n  // should we always sync?\n  const shouldSync = Date.now() - timestamp >= 2000;\n  if (!(address in _nonces) || shouldSync) {\n    const nonceResult = await forwarder.functions[forwarderFunction](...forwarderArgs);\n    if (Array.isArray(nonceResult) && nonceResult.length > 0) {\n      _nonces[address] = BigNumber.from(nonceResult[0]);\n    } else {\n      _nonces[address] = BigNumber.from(nonceResult);\n    }\n    _noncesSyncTimestamp[address] = Date.now();\n  }\n  const nonce = _nonces[address];\n  _nonces[address] = BigNumber.from(_nonces[address]).add(1);\n  return nonce;\n}\n\n/**\n * @internal\n */\n\n/**\n * @internal\n */\n\n/**\n * @internal\n */\n\n/**\n * eip712 sign typed data with different wallet handling including ledger live\n * @internal\n */\nasync function signTypedDataInternal(signerInput, domain, types, message) {\n  // Handle ERC4337Signer\n  let signer = signerInput;\n  if (signerInput.originalSigner) {\n    signer = signerInput.originalSigner;\n  }\n  const provider = signer?.provider;\n  if (!provider) {\n    throw new Error(\"missing provider\");\n  }\n  const payload = utils._TypedDataEncoder.getPayload(domain, types, message);\n  let signature = \"\";\n  const signerAddress = (await signer.getAddress()).toLowerCase();\n\n  // an indirect way for accessing walletconnect's underlying provider\n  if (provider?.provider?.isWalletConnect) {\n    signature = await provider.send(\"eth_signTypedData\", [(await signer.getAddress()).toLowerCase(), JSON.stringify(payload)]);\n  } else {\n    try {\n      signature = await signer._signTypedData(domain, types, message);\n    } catch (err) {\n      if (err?.message?.includes(\"eth_signTypedData_v4\")) {\n        signature = await provider.send(\"eth_signTypedData\", [signerAddress, JSON.stringify(payload)]);\n      } else {\n        // magic.link signer only supports this way\n        try {\n          await provider.send(\"eth_signTypedData_v4\", [signerAddress, JSON.stringify(payload)]);\n        } catch (finalErr) {\n          throw finalErr;\n        }\n      }\n    }\n  }\n\n  // fix ledger live where signature result in v = 0, 1. ethers magically fix it in split/join.\n  return {\n    payload,\n    signature: utils.joinSignature(utils.splitSignature(signature))\n  };\n}\n\nconst NAME_ABI = [{\n  inputs: [],\n  name: \"name\",\n  outputs: [{\n    internalType: \"string\",\n    name: \"\",\n    type: \"string\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}];\nconst DOMAIN_SEPARATOR_ABI = [{\n  constant: true,\n  inputs: [],\n  name: \"DOMAIN_SEPARATOR\",\n  outputs: [{\n    internalType: \"bytes32\",\n    name: \"\",\n    type: \"bytes32\"\n  }],\n  payable: false,\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"getDomainSeperator\",\n  outputs: [{\n    internalType: \"bytes32\",\n    name: \"\",\n    type: \"bytes32\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}];\nconst NONCES_ABI = [{\n  inputs: [{\n    internalType: \"address\",\n    name: \"owner\",\n    type: \"address\"\n  }],\n  name: \"nonces\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"user\",\n    type: \"address\"\n  }],\n  name: \"getNonce\",\n  outputs: [{\n    internalType: \"uint256\",\n    name: \"nonce\",\n    type: \"uint256\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}];\nasync function getSignerNonce(signer, contractAddress) {\n  const contract = new Contract(contractAddress, NONCES_ABI, signer);\n  try {\n    return await contract.nonces(await signer.getAddress());\n  } catch (err) {\n    return await contract.getNonce(await signer.getAddress());\n  }\n}\nasync function getDomainSeperator(signer, contractAddress) {\n  const contract = new Contract(contractAddress, DOMAIN_SEPARATOR_ABI, signer);\n  try {\n    return await contract.DOMAIN_SEPARATOR();\n  } catch (err) {\n    try {\n      return await contract.getDomainSeperator();\n    } catch (err2) {\n      console.error(\"Error getting domain separator\", err2);\n    }\n  }\n}\nasync function getTokenName(signer, contractAddress) {\n  return new Contract(contractAddress, NAME_ABI, signer).name();\n}\n\n/**\n * Polygon chain has different EIP712 domain separator for USDC, DAI compared to other chains and slightly different than EIP-2612.\n */\nasync function getChainDomainSeperator(signer, domain) {\n  const contractDomainSeparator = await getDomainSeperator(signer, domain.verifyingContract);\n  const polygonDomain = {\n    name: domain.name,\n    version: domain.version,\n    verifyingContract: domain.verifyingContract,\n    salt: utils.hexZeroPad(BigNumber.from(domain.chainId).toHexString(), 32)\n  };\n  if (utils._TypedDataEncoder.hashDomain(polygonDomain) === contractDomainSeparator) {\n    return polygonDomain;\n  }\n  return domain;\n}\n\n/**\n * @internal\n */\nasync function signEIP2612Permit(signer, currencyAddress, owner, spender, value, deadline, nonce) {\n  const domain = await getChainDomainSeperator(signer, {\n    name: await getTokenName(signer, currencyAddress),\n    version: \"1\",\n    chainId: await signer.getChainId(),\n    verifyingContract: currencyAddress\n  });\n  nonce = nonce || (await getSignerNonce(signer, currencyAddress)).toString();\n  deadline = deadline || constants.MaxUint256;\n  const message = {\n    owner,\n    spender,\n    value,\n    nonce,\n    deadline\n  };\n  const types = {\n    Permit: [{\n      name: \"owner\",\n      type: \"address\"\n    }, {\n      name: \"spender\",\n      type: \"address\"\n    }, {\n      name: \"value\",\n      type: \"uint256\"\n    }, {\n      name: \"nonce\",\n      type: \"uint256\"\n    }, {\n      name: \"deadline\",\n      type: \"uint256\"\n    }]\n  };\n  const {\n    signature\n  } = await signTypedDataInternal(signer, domain, types, message);\n  return {\n    message,\n    signature\n  };\n}\n\nclass TransactionContext {\n  constructor(options) {\n    this.args = options.args;\n    this.overrides = options.overrides || {};\n    this.provider = options.provider;\n    this.signer = options.signer;\n    this.storage = options.storage;\n\n    // Connect provider to signer if it isn't already connected\n    if (!this.signer.provider) {\n      this.signer = this.signer.connect(this.provider);\n    }\n  }\n  get getSigner() {\n    return this.signer;\n  }\n  get getProvider() {\n    return this.provider;\n  }\n  get getStorage() {\n    return this.storage;\n  }\n  getArgs() {\n    return this.args;\n  }\n  getOverrides() {\n    return this.overrides;\n  }\n  getValue() {\n    return this.overrides.value || 0;\n  }\n  setArgs(args) {\n    this.args = args;\n    return this;\n  }\n  setOverrides(overrides) {\n    this.overrides = overrides;\n    return this;\n  }\n  updateOverrides(overrides) {\n    this.overrides = {\n      ...this.overrides,\n      ...overrides\n    };\n    return this;\n  }\n  setValue(value) {\n    this.updateOverrides({\n      value\n    });\n    return this;\n  }\n  setGasLimit(gasLimit) {\n    this.updateOverrides({\n      gasLimit\n    });\n    return this;\n  }\n  setGasPrice(gasPrice) {\n    this.updateOverrides({\n      gasPrice\n    });\n    return this;\n  }\n  setNonce(nonce) {\n    this.updateOverrides({\n      nonce\n    });\n    return this;\n  }\n  setMaxFeePerGas(maxFeePerGas) {\n    this.updateOverrides({\n      maxFeePerGas\n    });\n    return this;\n  }\n  setMaxPriorityFeePerGas(maxPriorityFeePerGas) {\n    this.updateOverrides({\n      maxPriorityFeePerGas\n    });\n    return this;\n  }\n  setType(type) {\n    this.updateOverrides({\n      type\n    });\n    return this;\n  }\n  setAccessList(accessList) {\n    this.updateOverrides({\n      accessList\n    });\n    return this;\n  }\n  setCustomData(customData) {\n    this.updateOverrides({\n      customData\n    });\n    return this;\n  }\n  setCcipReadEnabled(ccipReadEnabled) {\n    this.updateOverrides({\n      ccipReadEnabled\n    });\n    return this;\n  }\n  /**\n   * Set a multiple to multiply the gas limit by\n   *\n   * @example\n   * ```js\n   * // Set the gas limit multiple to 1.2 (increase by 20%)\n   * tx.setGasLimitMultiple(1.2)\n   * ```\n   */\n  setGasLimitMultiple(factor) {\n    // If gasLimit override is set, we can just set it synchronously\n    if (BigNumber.isBigNumber(this.overrides.gasLimit)) {\n      this.overrides.gasLimit = BigNumber.from(Math.floor(BigNumber.from(this.overrides.gasLimit).toNumber() * factor));\n    } else {\n      // Otherwise, set a gas multiple to use later\n      this.gasMultiple = factor;\n    }\n  }\n\n  /**\n   * Estimate the total gas cost of this transaction (in both ether and wei)\n   */\n  async estimateGasCost() {\n    const [gasLimit, gasPrice] = await Promise.all([this.estimateGasLimit(), this.getGasPrice()]);\n    const gasCost = gasLimit.mul(gasPrice);\n    return {\n      ether: utils.formatEther(gasCost),\n      wei: gasCost\n    };\n  }\n\n  /**\n   * Calculates the gas price for transactions (adding a 10% tip buffer)\n   */\n  async getGasPrice() {\n    return getGasPrice(this.provider);\n  }\n\n  /**\n   * Get the address of the transaction signer\n   */\n  async getSignerAddress() {\n    return this.signer.getAddress();\n  }\n\n  /**\n   * Get gas overrides for the transaction\n   */\n  async getGasOverrides() {\n    return getDefaultGasOverrides(this.provider);\n  }\n\n  /**\n   * Calculates the priority fee per gas according (adding a 10% buffer)\n   */\n  getPreferredPriorityFee(defaultPriorityFeePerGas) {\n    const extraTip = defaultPriorityFeePerGas.div(100).mul(10); // + 10%\n    const txGasPrice = defaultPriorityFeePerGas.add(extraTip);\n    return txGasPrice;\n  }\n}\nclass Transaction extends TransactionContext {\n  static fromContractWrapper(options) {\n    const signer = options.contractWrapper.getSigner();\n    if (!signer) {\n      throw new Error(\"Cannot create a transaction without a signer. Please ensure that you have a connected signer.\");\n    }\n    const optionsWithContract = {\n      ...options,\n      contract: options.contractWrapper.writeContract,\n      provider: options.contractWrapper.getProvider(),\n      signer,\n      gasless: options.contractWrapper.options.gasless,\n      storage: options.contractWrapper.storage\n    };\n    return new Transaction(optionsWithContract);\n  }\n  static async fromContractInfo(options) {\n    const storage = options.storage;\n    let contractAbi = options.contractAbi;\n    if (!contractAbi) {\n      try {\n        const metadata = await fetchContractMetadataFromAddress(options.contractAddress, options.provider, storage);\n        contractAbi = metadata.abi;\n      } catch {\n        throw new Error(`Could resolve contract metadata for address ${options.contractAddress}. Please pass the contract ABI manually with the 'contractAbi' option.`);\n      }\n    }\n    const contract = new Contract(options.contractAddress, contractAbi, options.provider);\n    const optionsWithContract = {\n      ...options,\n      storage,\n      contract\n    };\n    return new Transaction(optionsWithContract);\n  }\n  constructor(options) {\n    super({\n      args: options.args,\n      overrides: options.overrides,\n      provider: options.provider,\n      signer: options.signer,\n      storage: options.storage\n    });\n    this.method = options.method;\n    this.gaslessOptions = options.gasless;\n    this.parse = options.parse;\n\n    // Always connect the signer to the contract\n    this.contract = options.contract.connect(this.signer);\n\n    // Create new storage instance if one isn't provided\n    this.storage = options.storage;\n  }\n  getTarget() {\n    return this.contract.address;\n  }\n  getMethod() {\n    return this.method;\n  }\n  getGaslessOptions() {\n    return this.gaslessOptions;\n  }\n  setGaslessOptions(options) {\n    this.gaslessOptions = options;\n    return this;\n  }\n  setParse(parse) {\n    this.parse = parse;\n    return this;\n  }\n\n  /**\n   * Encode the function data for this transaction\n   */\n  encode() {\n    return this.contract.interface.encodeFunctionData(this.method, this.args);\n  }\n\n  /**\n   * Get the signed transaction\n   */\n  async sign() {\n    const populatedTx = await this.populateTransaction();\n    const signedTx = await this.contract.signer.signTransaction(populatedTx);\n    return signedTx;\n  }\n  async populateTransaction() {\n    const gasOverrides = await this.getGasOverrides();\n    const overrides = {\n      ...gasOverrides,\n      ...this.overrides\n    };\n\n    // First, if no gasLimit is passed, call estimate gas ourselves\n    if (!overrides.gasLimit) {\n      overrides.gasLimit = await this.estimateGasLimit();\n    }\n    const tx = await this.contract.populateTransaction[this.method](...this.args, overrides);\n    const populatedTx = await this.contract.signer.populateTransaction(tx);\n    return populatedTx;\n  }\n\n  /**\n   * Simulate the transaction on-chain without executing\n   */\n  async simulate() {\n    if (!this.contract.callStatic[this.method]) {\n      throw this.functionError();\n    }\n    try {\n      return await this.contract.callStatic[this.method](...this.args, ...(this.overrides.value ? [{\n        value: this.overrides.value\n      }] : []));\n    } catch (err) {\n      throw await this.transactionError(err);\n    }\n  }\n\n  /**\n   * Estimate the gas limit of this transaction\n   */\n  async estimateGasLimit() {\n    if (!this.contract.estimateGas[this.method]) {\n      throw this.functionError();\n    }\n    try {\n      const gasEstimate = await this.contract.estimateGas[this.method](...this.args, this.overrides);\n      if (this.gasMultiple) {\n        return BigNumber.from(Math.floor(BigNumber.from(gasEstimate).toNumber() * this.gasMultiple));\n      }\n      return gasEstimate;\n    } catch (err) {\n      // If gas estimation fails, we'll call static to get a better error message\n      await this.simulate();\n\n      // If transaction simulation (static call) doesn't throw, then throw a generic error\n      throw await this.transactionError(err);\n    }\n  }\n\n  /**\n   * Send the transaction without waiting for it to be mined.\n   */\n  async send() {\n    if (!this.contract.functions[this.method]) {\n      throw this.functionError();\n    }\n    if (this.gaslessOptions && (\"openzeppelin\" in this.gaslessOptions || \"biconomy\" in this.gaslessOptions)) {\n      return this.sendGasless();\n    }\n    const gasOverrides = await this.getGasOverrides();\n    const overrides = {\n      ...gasOverrides,\n      ...this.overrides\n    };\n\n    // First, if no gasLimit is passed, call estimate gas ourselves\n    if (!overrides.gasLimit) {\n      overrides.gasLimit = await this.estimateGasLimit();\n      try {\n        // for dynamic contracts, add 30% to the gas limit to account for multiple delegate calls\n        const abi = JSON.parse(this.contract.interface.format(\"json\"));\n        if (isRouterContract(abi)) {\n          overrides.gasLimit = overrides.gasLimit.mul(110).div(100);\n        }\n      } catch (err) {\n        console.warn(\"Error raising gas limit\", err);\n      }\n    }\n\n    // Now there should be no gas estimate errors\n    try {\n      return await this.contract.functions[this.method](...this.args, overrides);\n    } catch (err) {\n      throw await this.transactionError(err);\n    }\n  }\n\n  /**\n   * Send the transaction and wait for it to be mined\n   */\n  async execute() {\n    const tx = await this.send();\n    let receipt;\n    try {\n      receipt = await tx.wait();\n    } catch (err) {\n      // If tx.wait() fails, it just gives us a generic \"transaction failed\"\n      // error. So instead, we need to call static to get an informative error message\n      await this.simulate();\n\n      // If transaction simulation (static call) doesn't throw, then throw with the message that we have\n      throw await this.transactionError(err);\n    }\n    if (this.parse) {\n      return this.parse(receipt);\n    }\n    return {\n      receipt\n    };\n  }\n\n  /**\n   * Execute the transaction with gasless\n   */\n  async sendGasless() {\n    const tx = await this.prepareGasless();\n    const txHash = await defaultGaslessSendFunction(tx, this.signer, this.provider, this.storage, this.gaslessOptions);\n\n    // Need to poll here because ethers.provider.getTransaction lies about the type\n    // It can actually return null, which can happen if we're still in gasless API send queue\n    let sentTx;\n    let iteration = 1;\n    while (!sentTx) {\n      try {\n        sentTx = await this.provider.getTransaction(txHash);\n      } catch (err) {\n        // some providers can throw an error if the tx is very recent\n      }\n      // Exponential (ish) backoff for polling\n      if (!sentTx) {\n        await new Promise(resolve => setTimeout(resolve, Math.min(iteration * 1000, 10000)));\n        iteration++;\n      }\n\n      // Timeout if we still don't have it after a while\n      if (iteration > 20) {\n        throw new Error(`Unable to retrieve transaction with hash ${txHash}`);\n      }\n    }\n    return sentTx;\n  }\n\n  /**\n   * @internal\n   * @returns\n   */\n  async prepareGasless() {\n    invariant(this.gaslessOptions && (\"openzeppelin\" in this.gaslessOptions || \"biconomy\" in this.gaslessOptions), \"No gasless options set on this transaction!\");\n    const signerAddress = await this.getSignerAddress();\n    const args = [...this.args];\n    if (this.method === \"multicall\" && Array.isArray(this.args[0]) && args[0].length > 0) {\n      args[0] = args[0].map(tx => utils.solidityPack([\"bytes\", \"address\"], [tx, signerAddress]));\n    }\n    invariant(this.signer, \"Cannot execute gasless transaction without valid signer\");\n    const [{\n      chainId\n    }, from] = await Promise.all([this.provider.getNetwork(), this.overrides.from || signerAddress]);\n    const to = this.contract.address;\n    const value = this.overrides?.value || 0;\n    if (BigNumber.from(value).gt(0)) {\n      throw new Error(\"Cannot send native token value with gasless transaction\");\n    }\n    const data = this.contract.interface.encodeFunctionData(this.method, args);\n    let gas = BigNumber.from(0);\n    try {\n      const gasEstimate = await this.contract.estimateGas[this.method](...args);\n      gas = gasEstimate.mul(2);\n    } catch (e) {\n      // ignore\n    }\n\n    // in some cases WalletConnect doesn't properly give an estimate for how much gas it would actually use.\n    // as a fix, we're setting it to a high arbitrary number (500k) as the gas limit that should cover for most function calls.\n    if (gas.lt(100000)) {\n      gas = BigNumber.from(500000);\n    }\n\n    // check for gas override in callOverrides\n    if (this.overrides.gasLimit && BigNumber.from(this.overrides.gasLimit).gt(gas)) {\n      gas = BigNumber.from(this.overrides.gasLimit);\n    }\n    return {\n      from,\n      to,\n      data,\n      chainId,\n      gasLimit: gas,\n      functionName: this.method,\n      functionArgs: args,\n      callOverrides: this.overrides\n    };\n  }\n  functionError() {\n    return new Error(`Contract \"${this.contract.address}\" does not have function \"${this.method}\"`);\n  }\n\n  /**\n   * Create a nicely formatted error message with tx metadata and solidity stack trace\n   */\n  async transactionError(error) {\n    const provider = this.provider;\n\n    // Get metadata for transaction to populate into error\n    const [network, from] = await Promise.all([provider.getNetwork(), this.overrides.from || this.getSignerAddress()]);\n    const to = this.contract.address;\n    const data = this.encode();\n    const value = BigNumber.from(this.overrides.value || 0);\n    const rpcUrl = provider.connection?.url;\n\n    // Render function signature with arguments filled in\n    const functionSignature = this.contract.interface.getFunction(this.method);\n    const methodArgs = this.args.map(arg => {\n      if (JSON.stringify(arg).length <= 80) {\n        return JSON.stringify(arg);\n      }\n      return JSON.stringify(arg, undefined, 2);\n    });\n    const joinedArgs = methodArgs.join(\", \").length <= 80 ? methodArgs.join(\", \") : \"\\n\" + methodArgs.map(arg => \"  \" + arg.split(\"\\n\").join(\"\\n  \")).join(\",\\n\") + \"\\n\";\n    const method = `${functionSignature.name}(${joinedArgs})`;\n    const hash = error.transactionHash || error.transaction?.hash || error.receipt?.transactionHash;\n\n    // Parse the revert reason from the error\n    const reason = parseRevertReason(error);\n\n    // Get contract sources for stack trace\n    let sources = undefined;\n    let contractName = undefined;\n    try {\n      const metadata = await fetchContractMetadataFromAddress(this.contract.address, this.provider, this.storage);\n      if (metadata.name) {\n        contractName = metadata.name;\n      }\n      if (metadata.metadata.sources) {\n        sources = await fetchSourceFilesFromMetadata(metadata, this.storage);\n      }\n    } catch (err) {\n      // no-op\n    }\n    return new TransactionError({\n      reason,\n      from,\n      to,\n      method,\n      data,\n      network,\n      rpcUrl,\n      value,\n      hash,\n      contractName,\n      sources\n    }, error);\n  }\n}\nclass DeployTransaction extends TransactionContext {\n  constructor(options) {\n    super(options);\n    this.factory = options.factory;\n    this.events = options.events;\n  }\n  encode() {\n    return utils.hexlify(utils.concat([this.factory.bytecode, this.factory.interface.encodeDeploy(this.args)]));\n  }\n  getTarget() {\n    return constants.AddressZero;\n  }\n  getMethod() {\n    return \"deploy\";\n  }\n  async sign() {\n    const populatedTx = await this.populateTransaction();\n    return this.signer.signTransaction(populatedTx);\n  }\n  async simulate() {\n    const populatedTx = await this.populateTransaction();\n    return this.signer.call(populatedTx);\n  }\n  async estimateGasLimit() {\n    try {\n      const gasOverrides = await this.getGasOverrides();\n      const overrides = {\n        ...gasOverrides,\n        ...this.overrides\n      };\n      const populatedTx = this.factory.getDeployTransaction(...this.args, overrides);\n      return this.signer.estimateGas(populatedTx);\n    } catch (err) {\n      // No need to do simulation here, since there can't be revert errors\n      throw await this.deployError(err);\n    }\n  }\n  async send() {\n    try {\n      const populatedTx = await this.populateTransaction();\n      return await this.signer.sendTransaction(populatedTx);\n    } catch (err) {\n      throw await this.deployError(err);\n    }\n  }\n  async execute() {\n    const tx = await this.send();\n    try {\n      await tx.wait();\n    } catch (err) {\n      // If tx.wait() fails, it just gives us a generic \"transaction failed\"\n      // error. So instead, we need to call static to get an informative error message\n      await this.simulate();\n\n      // If transaction simulation (static call) doesn't throw, then throw with the message that we have\n      throw await this.deployError(err);\n    }\n    const contractAddress = utils.getContractAddress({\n      from: tx.from,\n      nonce: tx.nonce\n    });\n\n    // TODO: Remove when we delete events from deploy\n    if (this.events) {\n      this.events.emit(\"contractDeployed\", {\n        status: \"completed\",\n        contractAddress,\n        transactionHash: tx.hash\n      });\n    }\n    return contractAddress;\n  }\n  async populateTransaction() {\n    const gasOverrides = await this.getGasOverrides();\n    const overrides = {\n      ...gasOverrides,\n      ...this.overrides\n    };\n\n    // First, if no gasLimit is passed, call estimate gas ourselves\n    if (!overrides.gasLimit) {\n      overrides.gasLimit = await this.estimateGasLimit();\n    }\n    return this.factory.getDeployTransaction(...this.args, overrides);\n  }\n\n  /**\n   * Create a nicely formatted error message with tx metadata and solidity stack trace\n   */\n  async deployError(error) {\n    const provider = this.provider;\n\n    // Get metadata for transaction to populate into error\n    const [network, from] = await Promise.all([provider.getNetwork(), this.overrides.from || this.getSignerAddress()]);\n    const data = this.encode();\n    const value = BigNumber.from(this.overrides.value || 0);\n    const rpcUrl = provider.connection?.url;\n    const methodArgs = this.args.map(arg => {\n      if (JSON.stringify(arg).length <= 80) {\n        return JSON.stringify(arg);\n      }\n      return JSON.stringify(arg, undefined, 2);\n    });\n    const joinedArgs = methodArgs.join(\", \").length <= 80 ? methodArgs.join(\", \") : \"\\n\" + methodArgs.map(arg => \"  \" + arg.split(\"\\n\").join(\"\\n  \")).join(\",\\n\") + \"\\n\";\n    const method = `deployContract(${joinedArgs})`;\n    const hash = error.transactionHash || error.transaction?.hash || error.receipt?.transactionHash;\n\n    // Parse the revert reason from the error\n    const reason = parseRevertReason(error);\n    return new TransactionError({\n      reason,\n      from,\n      method,\n      data,\n      network,\n      rpcUrl,\n      value,\n      hash\n    }, error);\n  }\n}\nasync function defaultGaslessSendFunction(transaction, signer, provider, storage, gaslessOptions) {\n  if (gaslessOptions && \"biconomy\" in gaslessOptions) {\n    return biconomySendFunction(transaction, signer, provider, gaslessOptions);\n  }\n  return defenderSendFunction(transaction, signer, provider, storage, gaslessOptions);\n}\nasync function biconomySendFunction(transaction, signer, provider, gaslessOptions) {\n  const request = await biconomyPrepareRequest(transaction, signer, provider, gaslessOptions);\n  const response = await fetch(\"https://api.biconomy.io/api/v2/meta-tx/native\", request);\n  if (response.ok) {\n    const resp = await response.json();\n    if (!resp.txHash) {\n      throw new Error(`relay transaction failed: ${resp.log}`);\n    }\n    return resp.txHash;\n  }\n  throw new Error(`relay transaction failed with status: ${response.status} (${response.statusText})`);\n}\nasync function defenderSendFunction(transaction, signer, provider, storage, gaslessOptions) {\n  invariant(gaslessOptions && \"openzeppelin\" in gaslessOptions, \"calling openzeppelin gasless transaction without openzeppelin config in the SDK options\");\n  const request = await defenderPrepareRequest(transaction, signer, provider, storage, gaslessOptions);\n  const response = await fetch(gaslessOptions.openzeppelin.relayerUrl, request);\n  if (response.ok) {\n    const resp = await response.json();\n    if (!resp.result) {\n      throw new Error(`Relay transaction failed: ${resp.message}`);\n    }\n    const result = JSON.parse(resp.result);\n    return result.txHash;\n  }\n  throw new Error(`relay transaction failed with status: ${response.status} (${response.statusText})`);\n}\nasync function defenderPrepareRequest(transaction, signer, provider, storage, gaslessOptions) {\n  invariant(gaslessOptions && \"openzeppelin\" in gaslessOptions, \"calling openzeppelin gasless transaction without openzeppelin config in the SDK options\");\n  invariant(signer, \"provider is not set\");\n  invariant(provider, \"provider is not set\");\n  const forwarderAddress = gaslessOptions.openzeppelin.relayerForwarderAddress || (gaslessOptions.openzeppelin.useEOAForwarder ? CONTRACT_ADDRESSES[transaction.chainId].openzeppelinForwarderEOA || (await computeEOAForwarderAddress(provider, storage)) : CONTRACT_ADDRESSES[transaction.chainId].openzeppelinForwarder || (await computeForwarderAddress(provider, storage)));\n  const forwarder = new Contract(forwarderAddress, ForwarderABI, provider);\n  const nonce = await getAndIncrementNonce(forwarder, \"getNonce\", [transaction.from]);\n  let domain;\n  let types;\n  let message;\n  if (gaslessOptions.experimentalChainlessSupport) {\n    domain = {\n      name: \"GSNv2 Forwarder\",\n      version: \"0.0.1\",\n      verifyingContract: forwarderAddress\n    };\n    types = {\n      ForwardRequest: ChainAwareForwardRequest\n    };\n    message = {\n      from: transaction.from,\n      to: transaction.to,\n      value: BigNumber.from(0).toString(),\n      gas: BigNumber.from(transaction.gasLimit).toString(),\n      nonce: BigNumber.from(nonce).toString(),\n      data: transaction.data,\n      chainid: BigNumber.from(transaction.chainId).toString()\n    };\n  } else {\n    domain = {\n      name: gaslessOptions.openzeppelin.domainName,\n      version: gaslessOptions.openzeppelin.domainVersion,\n      chainId: transaction.chainId,\n      verifyingContract: forwarderAddress\n    };\n    types = {\n      ForwardRequest\n    };\n    message = {\n      from: transaction.from,\n      to: transaction.to,\n      value: BigNumber.from(0).toString(),\n      gas: BigNumber.from(transaction.gasLimit).toString(),\n      nonce: BigNumber.from(nonce).toString(),\n      data: transaction.data\n    };\n  }\n  let signature;\n\n  // if the executing function is \"approve\" and matches with erc20 approve signature\n  // and if the token supports permit, then we use permit for gasless instead of approve.\n  if (transaction.functionName === \"approve\" && transaction.functionArgs.length === 2) {\n    const spender = transaction.functionArgs[0];\n    const amount = transaction.functionArgs[1];\n    // TODO: support DAI permit by signDAIPermit\n    const {\n      message: permit,\n      signature: sig\n    } = await signEIP2612Permit(signer, transaction.to, transaction.from, spender, amount);\n    const {\n      r,\n      s,\n      v\n    } = utils.splitSignature(sig);\n    message = {\n      to: transaction.to,\n      owner: permit.owner,\n      spender: permit.spender,\n      value: BigNumber.from(permit.value).toString(),\n      nonce: BigNumber.from(permit.nonce).toString(),\n      deadline: BigNumber.from(permit.deadline).toString(),\n      r,\n      s,\n      v\n    };\n    signature = sig;\n  } else {\n    const {\n      signature: sig\n    } = await signTypedDataInternal(signer, domain, types, message);\n    signature = sig;\n  }\n  let messageType = \"forward\";\n\n  // if has owner property then it's permit :)\n  if (message?.owner) {\n    messageType = \"permit\";\n  }\n  return {\n    method: \"POST\",\n    body: JSON.stringify({\n      request: message,\n      signature,\n      forwarderAddress,\n      type: messageType\n    })\n  };\n}\nasync function prepareGaslessRequest(tx) {\n  const gaslessTx = await tx.prepareGasless();\n  const gaslessOptions = tx.getGaslessOptions();\n  if (gaslessOptions && \"biconomy\" in gaslessOptions) {\n    const request = await biconomyPrepareRequest(gaslessTx, tx.getSigner, tx.getProvider, gaslessOptions);\n    return {\n      url: \"https://api.biconomy.io/api/v2/meta-tx/native\",\n      ...request\n    };\n  } else {\n    invariant(gaslessOptions && \"openzeppelin\" in gaslessOptions, \"calling openzeppelin gasless transaction without openzeppelin config in the SDK options\");\n    const request = await defenderPrepareRequest(gaslessTx, tx.getSigner, tx.getProvider, tx.getStorage, gaslessOptions);\n    return {\n      url: gaslessOptions.openzeppelin.relayerUrl,\n      ...request\n    };\n  }\n}\nasync function biconomyPrepareRequest(transaction, signer, provider, gaslessOptions) {\n  invariant(gaslessOptions && \"biconomy\" in gaslessOptions, \"calling biconomySendFunction without biconomy\");\n  invariant(signer && provider, \"signer and provider must be set\");\n  const forwarder = new Contract(getContractAddressByChainId(transaction.chainId, \"biconomyForwarder\"), BiconomyForwarderAbi, provider);\n  const batchId = 0;\n  const batchNonce = await getAndIncrementNonce(forwarder, \"getNonce\", [transaction.from, batchId]);\n  const request = {\n    from: transaction.from,\n    to: transaction.to,\n    token: constants.AddressZero,\n    txGas: transaction.gasLimit.toNumber(),\n    tokenGasPrice: \"0\",\n    batchId,\n    batchNonce: batchNonce.toNumber(),\n    deadline: Math.floor(Date.now() / 1000 + (gaslessOptions && \"biconomy\" in gaslessOptions && gaslessOptions.biconomy?.deadlineSeconds || 3600)),\n    data: transaction.data\n  };\n  const hashToSign = utils.arrayify(utils.solidityKeccak256([\"address\", \"address\", \"address\", \"uint256\", \"uint256\", \"uint256\", \"uint256\", \"uint256\", \"bytes32\"], [request.from, request.to, request.token, request.txGas, request.tokenGasPrice, request.batchId, request.batchNonce, request.deadline, utils.keccak256(request.data)]));\n  const signature = await signer.signMessage(hashToSign);\n  return {\n    method: \"POST\",\n    body: JSON.stringify({\n      from: transaction.from,\n      apiId: gaslessOptions.biconomy.apiId,\n      params: [request, signature],\n      to: transaction.to,\n      gasLimit: transaction.gasLimit.toHexString()\n    }),\n    headers: {\n      \"x-api-key\": gaslessOptions.biconomy.apiKey,\n      \"Content-Type\": \"application/json;charset=utf-8\"\n    }\n  };\n}\n\n/**\n * @internal\n */\n\n/**\n * Handles metadata for a Contract\n * @remarks Read and update metadata for this contract\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * const metadata = await contract.metadata.get();\n * await contract.metadata.set({\n *   name: \"My Contract\",\n *   description: \"My contract description\"\n * })\n * ```\n * @public\n */\nclass ContractMetadata {\n  featureName = FEATURE_METADATA.name;\n  constructor(contractWrapper, schema, storage) {\n    this.contractWrapper = contractWrapper;\n    this.schema = schema;\n    this.storage = storage;\n  }\n  /**\n   * @internal\n   */\n  parseOutputMetadata(metadata) {\n    return this.schema.output.parseAsync(metadata);\n  }\n\n  /**\n   * @internal\n   */\n  parseInputMetadata(metadata) {\n    return this.schema.input.parseAsync(metadata);\n  }\n  /**\n   * Get the metadata of this contract\n   * @remarks Get the metadata of a contract\n   * @example\n   * ```javascript\n   * const metadata = await contract.metadata.get();\n   * console.log(metadata);\n   * ```\n   * @public\n   * @returns the metadata of the given contract\n   * @twfeature ContractMetadata\n   */\n  async get() {\n    let data;\n    if (this.supportsContractMetadata(this.contractWrapper)) {\n      const uri = await this.contractWrapper.read(\"contractURI\", []);\n      if (uri && uri.includes(\"://\")) {\n        data = await this.storage.downloadJSON(uri);\n      }\n    }\n    if (!data) {\n      try {\n        // try fetching metadata from bytecode and / or contract itself\n        let contractName;\n        try {\n          if (hasFunction(\"name\", this.contractWrapper)) {\n            contractName = await this.contractWrapper.read(\"name\", []);\n          }\n        } catch (err) {\n          // no-op\n        }\n        let contractSymbol;\n        try {\n          if (hasFunction(\"symbol\", this.contractWrapper)) {\n            contractSymbol = await this.contractWrapper.read(\"symbol\", []);\n          }\n        } catch (err) {\n          // no-op\n        }\n        let publishedMetadata;\n        try {\n          publishedMetadata = await fetchContractMetadataFromAddress(this.contractWrapper.address, this.contractWrapper.getProvider(), this.storage, this.contractWrapper.options);\n        } catch (err) {}\n        data = {\n          name: contractName || publishedMetadata?.name,\n          symbol: contractSymbol,\n          description: publishedMetadata?.info.title\n        };\n      } catch (e) {\n        throw new Error(\"Could not fetch contract metadata\");\n      }\n    }\n    return this.parseOutputMetadata(data);\n  }\n\n  /**\n   * Set the metadata of this contract\n   * @remarks OVERWRITE the metadata of a contract\n   * @example\n   * ```javascript\n   * await contract.metadata.set({\n   *   name: \"My Contract\",\n   *   description: \"My contract description\"\n   * })\n   * ```\n   * @public\n   * @param metadata - the metadata to set\n   * @twfeature ContractMetadata\n   */\n  set = /* @__PURE__ */buildTransactionFunction(async metadata => {\n    const uri = await this._parseAndUploadMetadata(metadata);\n    const wrapper = this.contractWrapper;\n    if (this.supportsContractMetadata(wrapper)) {\n      return Transaction.fromContractWrapper({\n        contractWrapper: this.contractWrapper,\n        method: \"setContractURI\",\n        args: [uri],\n        parse: receipt => {\n          return {\n            receipt,\n            data: this.get\n          };\n        }\n      });\n    } else {\n      throw new ExtensionNotImplementedError(FEATURE_METADATA);\n    }\n  });\n\n  /**\n   * Update the metadata of a contract\n   * @remarks Update the metadata of a contract\n   * @example\n   * ```javascript\n   * await contract.metadata.update({\n   *   description: \"My new contract description\"\n   * })\n   * ```\n   * @public\n   * @param metadata - the metadata to update\n   * @twfeature ContractMetadata\n   * */\n  update = /* @__PURE__ */buildTransactionFunction(async metadata => {\n    return await this.set.prepare({\n      ...(await this.get()),\n      ...metadata\n    });\n  });\n\n  /**\n   *\n   * @internal\n   * @param metadata - the metadata to set\n   * @returns\n   */\n  async _parseAndUploadMetadata(metadata) {\n    const parsedMetadata = await this.parseInputMetadata(metadata);\n    return this.storage.upload(parsedMetadata);\n  }\n  supportsContractMetadata(contractWrapper) {\n    return detectContractFeature(contractWrapper, \"ContractMetadata\");\n  }\n}\n\n/**\n *\n * @internal\n */\nconst roleMap = {\n  admin: \"\",\n  transfer: \"TRANSFER_ROLE\",\n  minter: \"MINTER_ROLE\",\n  pauser: \"PAUSER_ROLE\",\n  lister: \"LISTER_ROLE\",\n  asset: \"ASSET_ROLE\",\n  unwrap: \"UNWRAP_ROLE\",\n  factory: \"FACTORY_ROLE\",\n  signer: \"SIGNER_ROLE\"\n};\n\n/**\n * @public\n */\n\n/**\n * @public\n */\nconst ALL_ROLES = /* @__PURE__ */Object.keys(roleMap);\n\n/**\n * @internal\n */\nfunction getRoleHash(role) {\n  if (role === \"admin\") {\n    return utils.hexZeroPad([0], 32);\n  }\n  return utils.id(roleMap[role]);\n}\n\n/**\n * Handle contract permissions\n * @remarks Configure roles and permissions for a contract, to restrict certain actions.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * const rolesAndMembers = await contract.roles.getAll();\n * await contract.roles.grantRole(\"admin\", \"0x...\");\n * ```\n * @public\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars -- TO BE REMOVED IN V4\nclass ContractRoles {\n  featureName = FEATURE_PERMISSIONS.name;\n\n  /**\n   * @internal\n   * @remarks This is used for typing inside react hooks which is why it has to be public.\n   */\n\n  constructor(contractWrapper, roles) {\n    this.contractWrapper = contractWrapper;\n    this.roles = roles;\n  }\n\n  /** **************************\n   * READ FUNCTIONS\n   ****************************/\n\n  /**\n   * Get all members of all roles\n   * @remarks See {@link ContractRoles.get} to get a list of addresses that are members of a specific role.\n   * @example\n   * ```javascript\n   * const rolesAndMembers = await contract.roles.getAll();\n   * ```\n   * @returns A record of {@link Role}s to lists of addresses that are members of the given role.\n   * @throws If the contract does not support roles this will throw an error.\n   *\n   * @public\n   * @twfeature PermissionsEnumerable\n   */\n  async getAll() {\n    invariant(this.roles.length, \"this contract has no support for roles\");\n    const roles = {};\n    for (const role of this.roles) {\n      roles[role] = await this.get(role);\n    }\n    return roles;\n  }\n\n  /**\n   * Get all members of a specific role\n   * @remarks See {@link ContractRoles.getAll} to get get a list of addresses for all supported roles on the contract.\n   * @param role - The Role to to get a memberlist for.\n   * @returns The list of addresses that are members of the specific role.\n   * @throws If you are requesting a role that does not exist on the contract this will throw an error.\n   *\n   * @example Say you want to get the list of addresses that are members of the minter role.\n   * ```javascript\n   * const minterAddresses = await contract.roles.get(\"minter\");\n   * ```\n   *\n   * @public\n   * @twfeature Permissions\n   */\n  async get(role) {\n    invariant(this.roles.includes(role), `this contract does not support the \"${role}\" role`);\n    const wrapper = this.contractWrapper;\n    if (hasFunction(\"getRoleMemberCount\", wrapper) && hasFunction(\"getRoleMember\", wrapper)) {\n      const roleHash = getRoleHash(role);\n      const count = (await wrapper.read(\"getRoleMemberCount\", [roleHash])).toNumber();\n      return await Promise.all(Array.from(Array(count).keys()).map(i => wrapper.read(\"getRoleMember\", [roleHash, i])));\n    }\n    throw new Error(\"Contract does not support enumerating roles. Please implement IPermissionsEnumerable to unlock this functionality.\");\n  }\n\n  /**\n   * Overwrite the list of members for specific roles\n   *\n   * @remarks Every role in the list will be overwritten with the new list of addresses provided with them.\n   * If you want to add or remove addresses for a single address use {@link ContractRoles.grant} and {@link ContractRoles.revoke} respectively instead.\n   * @param rolesWithAddresses - A record of {@link Role}s to lists of addresses that should be members of the given role.\n   * @throws If you are requesting a role that does not exist on the contract this will throw an error.\n   * @example Say you want to overwrite the list of addresses that are members of the minter role.\n   * ```javascript\n   * const minterAddresses = await contract.roles.get(\"minter\");\n   * await contract.roles.setAll({\n   *  minter: []\n   * });\n   * console.log(await contract.roles.get(\"minter\")); // No matter what members had the role before, the new list will be set to []\n   * ```\n   * @public\n   * @twfeature Permissions\n   *\n   * */\n  setAll = /* @__PURE__ */buildTransactionFunction(async rolesWithAddresses => {\n    const contractEncoder = new ContractEncoder(this.contractWrapper);\n    const roles = Object.keys(rolesWithAddresses);\n    invariant(roles.length, \"you must provide at least one role to set\");\n    invariant(roles.every(role => this.roles.includes(role)), \"this contract does not support the given role\");\n    const currentRoles = await this.getAll();\n    const encoded = [];\n    // add / remove admin role at the end so we don't revoke admin then grant\n    const sortedRoles = roles.sort(role => role === \"admin\" ? 1 : -1);\n    for (let i = 0; i < sortedRoles.length; i++) {\n      const role = sortedRoles[i];\n      const addresses = await Promise.all(rolesWithAddresses[role]?.map(async addressOrEns => await resolveAddress(addressOrEns)) || []);\n      const currentAddresses = await Promise.all(currentRoles[role]?.map(async addressOrEns => await resolveAddress(addressOrEns)) || []);\n      const toAdd = addresses.filter(address => !currentAddresses.includes(address));\n      const toRemove = currentAddresses.filter(address => !addresses.includes(address));\n      if (toAdd.length) {\n        toAdd.forEach(address => {\n          encoded.push(contractEncoder.encode(\"grantRole\", [getRoleHash(role), address]));\n        });\n      }\n      if (toRemove.length) {\n        for (let j = 0; j < toRemove.length; j++) {\n          const address = toRemove[j];\n          const revokeFunctionName = await this.getRevokeRoleFunctionName(address);\n          encoded.push(contractEncoder.encode(revokeFunctionName, [getRoleHash(role), address]));\n        }\n      }\n    }\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"multicall\",\n      args: [encoded]\n    });\n  });\n\n  /**\n   * Throws an error if an address is missing the roles specified.\n   *\n   * @param roles - The roles to check\n   * @param address - The address to check\n   *\n   * @internal\n   */\n  async verify(roles, address) {\n    await Promise.all(roles.map(async role => {\n      const members = await this.get(role);\n      const resolvedAddress = await resolveAddress(address);\n      if (!members.map(a => a.toLowerCase()).includes(resolvedAddress.toLowerCase())) {\n        throw new MissingRoleError(resolvedAddress, role);\n      }\n    }));\n  }\n\n  /** **************************\n   * WRITE FUNCTIONS\n   ****************************/\n\n  /**\n   * Grant a role to a specific address\n   *\n   * @remarks Make sure you are sure you want to grant the role to the address.\n   *\n   * @example\n   * ```javascript\n   * await contract.roles.grant(\"minter\", \"{{wallet_address}}\");\n   * ```\n   *\n   * @param role - The {@link Role} to grant to the address\n   * @param address - The address to grant the role to\n   * @returns The transaction receipt\n   * @throws If you are trying to grant does not exist on the contract this will throw an error.\n   *\n   * @public\n   * @twfeature Permissions\n   */\n  grant = /* @__PURE__ */buildTransactionFunction(async (role, address) => {\n    invariant(this.roles.includes(role), `this contract does not support the \"${role}\" role`);\n    const resolvedAddress = await resolveAddress(address);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"grantRole\",\n      args: [getRoleHash(role), resolvedAddress]\n    });\n  });\n\n  /**\n   * Revoke a role from a specific address\n   *\n   * @remarks\n   *\n   * -- Caution --\n   *\n   * This will let you remove yourself from the role, too.\n   * If you remove yourself from the admin role, you will no longer be able to administer the contract.\n   * There is no way to recover from this.\n   *\n   * @example\n   * ```javascript\n   * await contract.roles.revoke(\"minter\", \"{{wallet_address}}\");\n   * ```\n   *\n   * @param role - The {@link Role} to revoke\n   * @param address - The address to revoke the role from\n   * @returns The transaction receipt\n   * @throws If you are trying to revoke does not exist on the module this will throw an error.\n   *\n   * @public\n   * @twfeature Permissions\n   */\n  revoke = /* @__PURE__ */buildTransactionFunction(async (role, address) => {\n    invariant(this.roles.includes(role), `this contract does not support the \"${role}\" role`);\n    const resolvedAddress = await resolveAddress(address);\n    const revokeFunctionName = await this.getRevokeRoleFunctionName(resolvedAddress);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: revokeFunctionName,\n      args: [getRoleHash(role), resolvedAddress]\n    });\n  });\n\n  /** **************************\n   * PRIVATE FUNCTIONS\n   ****************************/\n\n  async getRevokeRoleFunctionName(address) {\n    const resolvedAddress = await resolveAddress(address);\n    const signerAddress = await this.contractWrapper.getSignerAddress();\n    if (signerAddress.toLowerCase() === resolvedAddress.toLowerCase()) {\n      return \"renounceRole\";\n    }\n    return \"revokeRole\";\n  }\n}\n\n/**\n * Handle contract royalties\n * @remarks Configure royalties for an entire contract or a particular token.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * const royaltyInfo = await contract.royalties.getDefaultRoyaltyInfo();\n * await contract.roles.setTokenRoyaltyInfo(tokenId, {\n *   seller_fee_basis_points: 100, // 1% royalty fee\n *   fee_recipient: \"0x...\", // the fee recipient\n * });\n * ```\n * @public\n */\nclass ContractRoyalty {\n  featureName = FEATURE_ROYALTY.name;\n  constructor(contractWrapper, metadata) {\n    this.contractWrapper = contractWrapper;\n    this.metadata = metadata;\n  }\n\n  /**\n   * Get the royalty recipient and fee\n   * @returns - The royalty recipient and BPS\n   * @example\n   * ```javascript\n   * const royaltyInfo = await contract.royalties.getDefaultRoyaltyInfo();\n   * console.log(royaltyInfo.fee_recipient);\n   * console.log(royaltyInfo.seller_fee_basis_points);\n   * ```\n   * @public\n   * @twfeature Royalty\n   */\n  async getDefaultRoyaltyInfo() {\n    const [royaltyRecipient, royaltyBps] = await this.contractWrapper.read(\"getDefaultRoyaltyInfo\", []);\n    // parse it on the way out to make sure we default things if they are not set\n    return CommonRoyaltySchema.parseAsync({\n      fee_recipient: royaltyRecipient,\n      seller_fee_basis_points: royaltyBps\n    });\n  }\n\n  /**\n   * Get the royalty recipient and fee of a particular token\n   * @returns - The royalty recipient and BPS\n   * @example\n   * ```javascript\n   * const royaltyInfo = await contract.royalties.getDefaultRoyaltyInfo();\n   * console.log(royaltyInfo.fee_recipient);\n   * console.log(royaltyInfo.seller_fee_basis_points);\n   * ```\n   * @public\n   * @twfeature Royalty\n   */\n  async getTokenRoyaltyInfo(tokenId) {\n    const [royaltyRecipient, royaltyBps] = await this.contractWrapper.read(\"getRoyaltyInfoForToken\", [tokenId]);\n    return CommonRoyaltySchema.parseAsync({\n      fee_recipient: royaltyRecipient,\n      seller_fee_basis_points: royaltyBps\n    });\n  }\n\n  /**\n   * Set the royalty recipient and fee\n   * @param royaltyData - the royalty recipient and fee\n   *  @example\n   * ```javascript\n   * await contract.roles.setDefaultRoyaltyInfo({\n   *   seller_fee_basis_points: 100, // 1% royalty fee\n   *   fee_recipient: \"0x...\", // the fee recipient\n   * });\n   * ```\n   * @public\n   * @twfeature Royalty\n   */\n  setDefaultRoyaltyInfo = /* @__PURE__ */buildTransactionFunction(async royaltyData => {\n    // read the metadata from the contract\n    const oldMetadata = await this.metadata.get();\n\n    // update the metadata with the new royalty data\n    // if one of the keys is \"undefined\" it will be ignored (which is the desired behavior)\n    const mergedMetadata = await this.metadata.parseInputMetadata({\n      ...oldMetadata,\n      ...royaltyData\n    });\n\n    // why not use this.metadata.set()? - because that would end up sending it's own separate transaction to `setContractURI`\n    // but we want to send both the `setRoyaltyInfo` and `setContractURI` in one transaction!\n    const contractURI = await this.metadata._parseAndUploadMetadata(mergedMetadata);\n    if (hasFunction(\"setContractURI\", this.contractWrapper)) {\n      const contractEncoder = new ContractEncoder(this.contractWrapper);\n      // encode both the functions we want to send\n      const encoded = [contractEncoder.encode(\"setDefaultRoyaltyInfo\", [mergedMetadata.fee_recipient, mergedMetadata.seller_fee_basis_points]), contractEncoder.encode(\"setContractURI\", [contractURI])];\n      // actually send the transaction and return the receipt + a way to get the new royalty info\n\n      return Transaction.fromContractWrapper({\n        contractWrapper: this.contractWrapper,\n        method: \"multicall\",\n        args: [encoded],\n        parse: receipt => ({\n          receipt,\n          data: () => this.getDefaultRoyaltyInfo()\n        })\n      });\n    } else {\n      throw new Error(\"Updating royalties requires implementing ContractMetadata in your contract to support marketplaces like OpenSea.\");\n    }\n  });\n\n  /**\n   * Set the royalty recipient and fee for a particular token\n   * @param tokenId - the token id\n   * @param royaltyData - the royalty recipient and fee\n   * @example\n   * ```javascript\n   * const tokenId = 0;\n   * await contract.roles.setTokenRoyaltyInfo(tokenId, {\n   *   seller_fee_basis_points: 100, // 1% royalty fee\n   *   fee_recipient: \"0x...\", // the fee recipient\n   * });\n   * ```\n   * @public\n   * @twfeature Royalty\n   */\n  setTokenRoyaltyInfo = /* @__PURE__ */buildTransactionFunction(async (tokenId, royaltyData) => {\n    const parsedRoyaltyData = CommonRoyaltySchema.parse(royaltyData);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"setRoyaltyInfoForToken\",\n      args: [tokenId, parsedRoyaltyData.fee_recipient, parsedRoyaltyData.seller_fee_basis_points],\n      parse: receipt => ({\n        receipt,\n        data: () => this.getDefaultRoyaltyInfo()\n      })\n    });\n  });\n}\n\n/**\n * Handle primary sales recipients\n * @remarks Configure primary sale recipients for an entire contract.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * const salesRecipient = await contract.sales.getRecipient();\n * await contract.sales.setRecipient(recipientWalletAddress);\n * ```\n * @public\n */\nclass ContractPrimarySale {\n  featureName = FEATURE_PRIMARY_SALE.name;\n  constructor(contractWrapper) {\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * Get the primary sale recipient\n   * @returns the wallet address.\n   * @example\n   * ```javascript\n   * const salesRecipient = await contract.sales.getRecipient();\n   * ```\n   * @public\n   * @twfeature PrimarySale\n   */\n  async getRecipient() {\n    const result = await this.contractWrapper.read(\"primarySaleRecipient\", []);\n    return result;\n  }\n\n  /**\n   * Set the primary sale recipient\n   * @param recipient - the wallet address\n   * @example\n   * ```javascript\n   * await contract.sales.setRecipient(recipientWalletAddress);\n   * ```\n   * @public\n   * @twfeature PrimarySale\n   */\n  setRecipient = /* @__PURE__ */buildTransactionFunction(async recipient => {\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"setPrimarySaleRecipient\",\n      args: [recipient]\n    });\n  });\n}\n\nconst FALLBACK_METADATA = {\n  name: \"Failed to load NFT metadata\"\n};\n\n/**\n * fetches the token metadata\n * @param tokenId - the id (to get it back in the output)\n * @param tokenUri - the uri to fetch\n * @param storage - which storage to fetch from\n *\n * @internal\n */\nasync function fetchTokenMetadata(tokenId, tokenUri, storage) {\n  // check for base64 encoded JSON\n  if (tokenUri.startsWith(\"data:application/json;base64\") && typeof Buffer !== \"undefined\") {\n    const base64 = tokenUri.split(\",\")[1];\n    const jsonMetadata = JSON.parse(Buffer.from(base64, \"base64\").toString(\"utf-8\"));\n    return CommonNFTOutput.parse({\n      ...jsonMetadata,\n      id: BigNumber.from(tokenId).toString(),\n      uri: tokenUri\n    });\n  }\n  // handle dynamic id URIs (2 possible formats)\n  const parsedUri = tokenUri.replace(\"{id}\", utils.hexZeroPad(BigNumber.from(tokenId).toHexString(), 32).slice(2));\n  let jsonMetadata;\n  try {\n    jsonMetadata = await storage.downloadJSON(parsedUri);\n  } catch (err) {\n    const unparsedTokenIdUri = tokenUri.replace(\"{id}\", BigNumber.from(tokenId).toString());\n    try {\n      jsonMetadata = await storage.downloadJSON(unparsedTokenIdUri);\n    } catch (e) {\n      console.warn(`failed to get token metadata: ${JSON.stringify({\n        tokenId: tokenId.toString(),\n        tokenUri\n      })} -- falling back to default metadata`);\n      jsonMetadata = FALLBACK_METADATA;\n    }\n  }\n  return CommonNFTOutput.parse({\n    ...jsonMetadata,\n    id: BigNumber.from(tokenId).toString(),\n    uri: tokenUri\n  });\n}\n\n// Used for marketplace to fetch NFT metadata from contract address + tokenId\n/**\n * @internal\n * @param contractAddress\n * @param provider\n * @param tokenId\n * @param storage\n */\nasync function fetchTokenMetadataForContract(contractAddress, provider, tokenId, storage) {\n  let uri;\n  const erc165 = new Contract(contractAddress, ERC165Abi, provider);\n  const [isERC721, isERC1155] = await Promise.all([erc165.supportsInterface(InterfaceId_IERC721), erc165.supportsInterface(InterfaceId_IERC1155)]);\n  if (isERC721) {\n    const erc721 = new Contract(contractAddress, IERC721MetadataAbi, provider);\n    uri = await erc721.tokenURI(tokenId);\n  } else if (isERC1155) {\n    const erc1155 = new Contract(contractAddress, Erc1155MetadataAbi, provider);\n    uri = await erc1155.uri(tokenId);\n  } else {\n    throw Error(\"Contract must implement ERC 1155 or ERC 721.\");\n  }\n  if (!uri) {\n    // no uri found, return fallback metadata\n    return CommonNFTOutput.parse({\n      ...FALLBACK_METADATA,\n      id: BigNumber.from(tokenId).toString(),\n      uri: \"\"\n    });\n  }\n  return fetchTokenMetadata(tokenId, uri, storage);\n}\n\n/**\n * @internal\n * @param metadata\n * @param storage\n */\nasync function uploadOrExtractURI(metadata, storage) {\n  if (typeof metadata === \"string\") {\n    return metadata;\n  } else {\n    return await storage.upload(CommonNFTInput.parse(metadata));\n  }\n}\n\n/**\n * @internal\n * @param metadatas\n * @param storage\n * @param startNumber\n * @param contractAddress\n * @param signerAddress\n * @param options\n */\nasync function uploadOrExtractURIs(metadatas, storage, startNumber, options) {\n  if (isUriList(metadatas)) {\n    return metadatas;\n  } else if (isMetadataList(metadatas)) {\n    const uris = await storage.uploadBatch(metadatas.map(m => CommonNFTInput.parse(m)), {\n      rewriteFileNames: {\n        fileStartNumber: startNumber || 0\n      },\n      onProgress: options?.onProgress\n    });\n    return uris;\n  } else {\n    throw new Error(\"NFT metadatas must all be of the same type (all URI or all NFTMetadataInput)\");\n  }\n}\nfunction getBaseUriFromBatch(uris) {\n  const baseUri = uris[0].substring(0, uris[0].lastIndexOf(\"/\"));\n  for (let i = 0; i < uris.length; i++) {\n    const uri = uris[i].substring(0, uris[i].lastIndexOf(\"/\"));\n    if (baseUri !== uri) {\n      throw new Error(`Can only create batches with the same base URI for every entry in the batch. Expected '${baseUri}' but got '${uri}'`);\n    }\n  }\n\n  // Ensure that baseUri ends with trailing slash\n  return baseUri.replace(/\\/$/, \"\") + \"/\";\n}\nfunction isUriList(metadatas) {\n  return metadatas.find(m => typeof m !== \"string\") === undefined;\n}\nfunction isMetadataList(metadatas) {\n  return metadatas.find(m => typeof m !== \"object\") === undefined;\n}\n\n/**\n * Handles delayed reveal logic\n * @public\n */\nclass DelayedReveal {\n  constructor(contractWrapper, storage, featureName, nextTokenIdToMintFn) {\n    this.featureName = featureName;\n    this.nextTokenIdToMintFn = nextTokenIdToMintFn;\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n  }\n\n  /**\n   * Create a batch of encrypted NFTs that can be revealed at a later time.\n   * @remarks Create a batch of encrypted NFTs that can be revealed at a later time.\n   * @example\n   * ```javascript\n   * // the real NFTs, these will be encrypted until your reveal them!\n   * const realNFTs = [{\n   *   name: \"Common NFT #1\",\n   *   description: \"Common NFT, one of many.\",\n   *   image: fs.readFileSync(\"path/to/image.png\"),\n   * }, {\n   *   name: \"Super Rare NFT #2\",\n   *   description: \"You got a Super Rare NFT!\",\n   *   image: fs.readFileSync(\"path/to/image.png\"),\n   * }];\n   * // A placeholder NFT that people will get immediately in their wallet, until the reveal happens!\n   * const placeholderNFT = {\n   *   name: \"Hidden NFT\",\n   *   description: \"Will be revealed next week!\"\n   * };\n   * // Create and encrypt the NFTs\n   * await contract.revealer.createDelayedRevealBatch(\n   *   placeholderNFT,\n   *   realNFTs,\n   *   \"my secret password\",\n   * );\n   * ```\n   * @public\n   * @param placeholder - the placeholder NFT to show before the reveal\n   * @param metadatas - the final NFTs that will be hidden\n   * @param password - the password that will be used to reveal these NFTs\n   * @param options - additional options like upload progress\n   */\n  createDelayedRevealBatch = /* @__PURE__ */buildTransactionFunction(async (placeholder, metadatas, password, options) => {\n    if (!password) {\n      throw new Error(\"Password is required\");\n    }\n    const placeholderUris = await this.storage.uploadBatch([CommonNFTInput.parse(placeholder)], {\n      rewriteFileNames: {\n        fileStartNumber: 0\n      }\n    });\n    const placeholderUri = getBaseUriFromBatch(placeholderUris);\n    const startFileNumber = await this.nextTokenIdToMintFn();\n    const uris = await this.storage.uploadBatch(metadatas.map(m => CommonNFTInput.parse(m)), {\n      onProgress: options?.onProgress,\n      rewriteFileNames: {\n        fileStartNumber: startFileNumber.toNumber()\n      }\n    });\n    const baseUri = getBaseUriFromBatch(uris);\n    const baseUriId = await this.contractWrapper.read(\"getBaseURICount\", []);\n    const hashedPassword = await this.hashDelayRevealPassword(baseUriId, password);\n    const encryptedBaseUri = await this.contractWrapper.read(\"encryptDecrypt\", [utils.toUtf8Bytes(baseUri), hashedPassword]);\n    let data;\n    const legacyContract = await this.isLegacyContract();\n    if (legacyContract) {\n      data = encryptedBaseUri;\n    } else {\n      const chainId = await this.contractWrapper.getChainID();\n      const provenanceHash = utils.solidityKeccak256([\"bytes\", \"bytes\", \"uint256\"], [utils.toUtf8Bytes(baseUri), hashedPassword, chainId]);\n      data = utils.defaultAbiCoder.encode([\"bytes\", \"bytes32\"], [encryptedBaseUri, provenanceHash]);\n    }\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"lazyMint\",\n      args: [uris.length, placeholderUri.endsWith(\"/\") ? placeholderUri : `${placeholderUri}/`, data],\n      parse: receipt => {\n        const events = this.contractWrapper.parseLogs(\"TokensLazyMinted\", receipt?.logs);\n        const startingIndex = events[0].args.startTokenId;\n        const endingIndex = events[0].args.endTokenId;\n        const results = [];\n        for (let id = startingIndex; id.lte(endingIndex); id = id.add(1)) {\n          results.push({\n            id,\n            receipt\n          });\n        }\n        return results;\n      }\n    });\n  });\n\n  /**\n   * Reveal a batch of hidden NFTs\n   * @remarks Reveal the NFTs of a batch using the password.\n   * @example\n   * ```javascript\n   * // the batch to reveal\n   * const batchId = 0;\n   * // reveal the batch\n   * await contract.revealer.reveal(batchId, \"my secret password\");\n   * ```\n   * @public\n   * @param batchId - the id of the batch to reveal\n   * @param password - the password\n   */\n  reveal = /* @__PURE__ */buildTransactionFunction(async (batchId, password) => {\n    if (!password) {\n      throw new Error(\"Password is required\");\n    }\n    const key = await this.hashDelayRevealPassword(batchId, password);\n    // performing the reveal locally to make sure it'd succeed before sending the transaction\n    try {\n      const decryptedUri = await this.contractWrapper.callStatic().reveal(batchId, key);\n      // basic sanity check for making sure decryptedUri is valid\n      // this is optional because invalid decryption key would result in non-utf8 bytes and\n      // ethers would throw when trying to decode it\n      if (!decryptedUri.includes(\"://\") || !decryptedUri.endsWith(\"/\")) {\n        throw new Error(\"invalid password\");\n      }\n    } catch (e) {\n      throw new Error(\"invalid password\");\n    }\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"reveal\",\n      args: [batchId, key]\n    });\n  });\n\n  /**\n   * Gets the list of unrevealed NFT batches.\n   * @remarks Gets the list of unrevealed NFT batches.\n   * @example\n   * ```javascript\n   * const batches = await contract.revealer.getBatchesToReveal();\n   * ```\n   * @public\n   */\n  async getBatchesToReveal() {\n    const count = await this.contractWrapper.read(\"getBaseURICount\", []);\n    if (count.isZero()) {\n      return [];\n    }\n    const countRangeArray = Array.from(Array(count.toNumber()).keys());\n    // map over to get the base uri indices, which should be the end token id of every batch\n    const uriIndices = await Promise.all(countRangeArray.map(i => {\n      if (hasFunction(\"getBatchIdAtIndex\", this.contractWrapper)) {\n        return this.contractWrapper.read(\"getBatchIdAtIndex\", [i]);\n      }\n      if (hasFunction(\"baseURIIndices\", this.contractWrapper)) {\n        return this.contractWrapper.read(\"baseURIIndices\", [i]);\n      }\n      throw new Error(\"Contract does not have getBatchIdAtIndex or baseURIIndices.\");\n    }));\n\n    // first batch always start from 0. don't need to fetch the last batch so pop it from the range array\n    const uriIndicesWithZeroStart = uriIndices.slice(0, uriIndices.length - 1);\n\n    // returns the token uri for each batches. first batch always starts from token id 0.\n    const tokenMetadatas = await Promise.all(Array.from([0, ...uriIndicesWithZeroStart]).map(i => this.getNftMetadata(i.toString())));\n\n    // index is the uri indices, which is end token id. different from uris\n    const legacyContract = await this.isLegacyContract();\n    const encryptedUriData = await Promise.all(Array.from([...uriIndices]).map(i => legacyContract ? this.getLegacyEncryptedData(i) : this.contractWrapper.read(\"encryptedData\", [i])));\n    const encryptedBaseUris = encryptedUriData.map(data => {\n      if (utils.hexDataLength(data) > 0) {\n        if (legacyContract) {\n          return data;\n        }\n        const result = utils.defaultAbiCoder.decode([\"bytes\", \"bytes32\"], data);\n        return result[0];\n      } else {\n        return data;\n      }\n    });\n    return tokenMetadatas.map((meta, index) => ({\n      batchId: BigNumber.from(index),\n      batchUri: meta.uri,\n      placeholderMetadata: meta\n    })).filter((_, index) => utils.hexDataLength(encryptedBaseUris[index]) > 0);\n  }\n\n  /**\n   * Algorithm to hash delay reveal password, so we don't broadcast the input password on-chain.\n   *\n   * @internal\n   */\n  async hashDelayRevealPassword(batchTokenIndex, password) {\n    const chainId = await this.contractWrapper.getChainID();\n    const contractAddress = this.contractWrapper.address;\n    return utils.solidityKeccak256([\"string\", \"uint256\", \"uint256\", \"address\"], [password, chainId, batchTokenIndex, contractAddress]);\n  }\n  async getNftMetadata(tokenId) {\n    return fetchTokenMetadataForContract(this.contractWrapper.address, this.contractWrapper.getProvider(), tokenId, this.storage);\n  }\n  async isLegacyContract() {\n    if (hasFunction(\"contractVersion\", this.contractWrapper)) {\n      try {\n        const version = await this.contractWrapper.read(\"contractVersion\", []);\n        return version <= 2;\n      } catch (e) {\n        return false;\n      }\n    }\n    return false;\n  }\n  async getLegacyEncryptedData(index) {\n    const legacy = new Contract(this.contractWrapper.address, DeprecatedAbi, this.contractWrapper.getProvider());\n    const result = await legacy.functions[\"encryptedBaseURI\"](index);\n    if (result.length > 0) {\n      return result[0];\n    } else {\n      return \"0x\";\n    }\n  }\n}\n\nfunction abstractContractModelToLegacy(model) {\n  return {\n    startTimestamp: model.startTimestamp,\n    maxClaimableSupply: model.maxClaimableSupply,\n    supplyClaimed: model.supplyClaimed,\n    merkleRoot: model.merkleRoot,\n    pricePerToken: model.pricePerToken,\n    currency: model.currency,\n    quantityLimitPerTransaction: model.maxClaimablePerWallet,\n    waitTimeInSecondsBetweenClaims: model.waitTimeInSecondsBetweenClaims || 0\n  };\n}\n\nfunction abstractContractModelToNew(model) {\n  return {\n    startTimestamp: model.startTimestamp,\n    maxClaimableSupply: model.maxClaimableSupply,\n    supplyClaimed: model.supplyClaimed,\n    merkleRoot: model.merkleRoot,\n    pricePerToken: model.pricePerToken,\n    currency: model.currency,\n    quantityLimitPerWallet: model.maxClaimablePerWallet,\n    metadata: model.metadata || \"\"\n  };\n}\n\n/**\n * @internal\n * @param quantity\n * @param tokenDecimals\n */\nfunction convertQuantityToBigNumber(quantity, tokenDecimals) {\n  if (quantity === \"unlimited\") {\n    return constants.MaxUint256;\n  } else {\n    return utils.parseUnits(quantity, tokenDecimals);\n  }\n}\n\nfunction isNativeToken(tokenAddress) {\n  return tokenAddress.toLowerCase() === NATIVE_TOKEN_ADDRESS || tokenAddress.toLowerCase() === constants.AddressZero;\n}\n\n/**\n *\n * @param provider\n * @param asset\n * @returns\n * @internal\n */\nasync function fetchCurrencyMetadata(provider, asset) {\n  if (isNativeToken(asset)) {\n    const network = await provider.getNetwork();\n    const nativeToken = getNativeTokenByChainId(network.chainId);\n    return {\n      name: nativeToken.name,\n      symbol: nativeToken.symbol,\n      decimals: nativeToken.decimals\n    };\n  } else {\n    const erc20 = new Contract(asset, IERC20MetadataAbi, provider);\n    const [name, symbol, decimals] = await Promise.all([erc20.name(), erc20.symbol(), erc20.decimals()]);\n    return {\n      name,\n      symbol,\n      decimals\n    };\n  }\n}\n\nasync function parseSnapshotInputs(inputs) {\n  const chunkSize = 25000;\n  const chunks = Array.from({\n    length: Math.ceil(inputs.length / chunkSize)\n  }, (_, i) => inputs.slice(i * chunkSize, i * chunkSize + chunkSize));\n  const results = [];\n  for (const chunk of chunks) {\n    results.push(...(await SnapshotInputSchema.parseAsync(chunk)));\n  }\n  return results;\n}\n\n// shard using the first 2 hex character of the address\n// this splits the merkle tree into 256 shards\n// shard files will be 00.json, 01.json, 02.json, ..., ff.json\nconst SHARD_NYBBLES = 2;\nlet SnapshotFormatVersion = /*#__PURE__*/function (SnapshotFormatVersion) {\n  SnapshotFormatVersion[SnapshotFormatVersion[\"V1\"] = 1] = \"V1\";\n  SnapshotFormatVersion[SnapshotFormatVersion[\"V2\"] = 2] = \"V2\";\n  return SnapshotFormatVersion;\n}({}); // address, maxClaimable, price, currencyAddress\nclass ShardedMerkleTree {\n  constructor(storage, baseUri, originalEntriesUri, shardNybbles, tokenDecimals) {\n    this.storage = storage;\n    this.shardNybbles = shardNybbles;\n    this.baseUri = baseUri;\n    this.originalEntriesUri = originalEntriesUri;\n    this.tokenDecimals = tokenDecimals;\n    this.shards = {};\n    this.trees = {};\n  }\n  static async fromUri(uri, storage) {\n    try {\n      const shardedMerkleTreeInfo = await storage.downloadJSON(uri);\n      if (shardedMerkleTreeInfo.isShardedMerkleTree) {\n        return ShardedMerkleTree.fromShardedMerkleTreeInfo(shardedMerkleTreeInfo, storage);\n      }\n    } catch (e) {\n      return undefined;\n    }\n  }\n  static async fromShardedMerkleTreeInfo(info, storage) {\n    return new ShardedMerkleTree(storage, info.baseUri, info.originalEntriesUri, info.shardNybbles, info.tokenDecimals);\n  }\n  static hashEntry(entry, tokenDecimals, currencyDecimals, snapshotFormatVersion) {\n    switch (snapshotFormatVersion) {\n      case SnapshotFormatVersion.V1:\n        return utils.solidityKeccak256([\"address\", \"uint256\"], [entry.address, convertQuantityToBigNumber(entry.maxClaimable, tokenDecimals)]);\n      case SnapshotFormatVersion.V2:\n        return utils.solidityKeccak256([\"address\", \"uint256\", \"uint256\", \"address\"], [entry.address, convertQuantityToBigNumber(entry.maxClaimable, tokenDecimals), convertQuantityToBigNumber(entry.price || \"unlimited\", currencyDecimals), entry.currencyAddress || constants.AddressZero]);\n    }\n  }\n  static async fetchAndCacheDecimals(cache, provider, currencyAddress) {\n    if (!currencyAddress) {\n      return 18;\n    }\n    // cache decimals for each currency to avoid refetching for every address\n    let currencyDecimals = cache[currencyAddress];\n    if (currencyDecimals === undefined) {\n      const currencyMetadata = await fetchCurrencyMetadata(provider, currencyAddress);\n      currencyDecimals = currencyMetadata.decimals;\n      cache[currencyAddress] = currencyDecimals;\n    }\n    return currencyDecimals;\n  }\n  static async buildAndUpload(snapshotInput, tokenDecimals, provider, storage, snapshotFormatVersion) {\n    let shardNybbles = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : SHARD_NYBBLES;\n    const inputs = await parseSnapshotInputs(snapshotInput);\n\n    // TODO Could also derive shardNybbles from input size\n    const shards = {};\n    for (const snapshotEntry of inputs) {\n      const shard = snapshotEntry.address.slice(2, 2 + shardNybbles).toLowerCase();\n      if (shards[shard] === undefined) {\n        shards[shard] = [];\n      }\n      shards[shard].push(snapshotEntry);\n    }\n    const currencyDecimalMap = {};\n    // create shard => subtree root map\n    const subTrees = await Promise.all(Object.entries(shards).map(async _ref => {\n      let [shard, entries] = _ref;\n      return [shard, new MerkleTree(await Promise.all(entries.map(async entry => {\n        // cache decimals for each currency to avoid refetching for every address\n        const currencyDecimals = await ShardedMerkleTree.fetchAndCacheDecimals(currencyDecimalMap, provider, entry.currencyAddress);\n        return ShardedMerkleTree.hashEntry(entry, tokenDecimals, currencyDecimals, snapshotFormatVersion);\n      })), utils.keccak256, {\n        sort: true\n      }).getHexRoot()];\n    }));\n    const roots = Object.fromEntries(subTrees);\n    // create master tree from shard => subtree root map\n    const tree = new MerkleTree(Object.values(roots), utils.keccak256, {\n      sort: true\n    });\n    const shardsToUpload = [];\n    for (const [shardId, entries] of Object.entries(shards)) {\n      const data = {\n        proofs: tree.getProof(roots[shardId]).map(value => \"0x\" + value.data.toString(\"hex\")),\n        entries\n      };\n      shardsToUpload.push({\n        data: JSON.stringify(data),\n        name: `${shardId}.json`\n      });\n    }\n    const uris = await storage.uploadBatch(shardsToUpload);\n    const baseUri = uris[0].slice(0, uris[0].lastIndexOf(\"/\"));\n    const originalEntriesUri = await storage.upload(inputs);\n    const shardedMerkleInfo = {\n      merkleRoot: tree.getHexRoot(),\n      baseUri,\n      originalEntriesUri,\n      shardNybbles,\n      tokenDecimals,\n      isShardedMerkleTree: true\n    };\n    const masterUri = await storage.upload(shardedMerkleInfo);\n    return {\n      shardedMerkleInfo,\n      uri: masterUri\n    };\n  }\n  async getProof(address, provider, snapshotFormatVersion) {\n    const shardId = address.slice(2, 2 + this.shardNybbles).toLowerCase();\n    let shard = this.shards[shardId];\n    const currencyDecimalMap = {};\n    if (shard === undefined) {\n      try {\n        shard = this.shards[shardId] = await this.storage.downloadJSON(`${this.baseUri}/${shardId}.json`);\n        const hashedEntries = await Promise.all(shard.entries.map(async entry => {\n          // cache decimals for each currency to avoid refetching for every address\n          const currencyDecimals = await ShardedMerkleTree.fetchAndCacheDecimals(currencyDecimalMap, provider, entry.currencyAddress);\n          return ShardedMerkleTree.hashEntry(entry, this.tokenDecimals, currencyDecimals, snapshotFormatVersion);\n        }));\n        this.trees[shardId] = new MerkleTree(hashedEntries, utils.keccak256, {\n          sort: true\n        });\n      } catch (e) {\n        return null;\n      }\n    }\n    const entry = shard.entries.find(i => i.address.toLowerCase() === address.toLowerCase());\n    if (!entry) {\n      return null;\n    }\n    const currencyDecimals = await ShardedMerkleTree.fetchAndCacheDecimals(currencyDecimalMap, provider, entry.currencyAddress);\n    const leaf = ShardedMerkleTree.hashEntry(entry, this.tokenDecimals, currencyDecimals, snapshotFormatVersion);\n    const proof = this.trees[shardId].getProof(leaf).map(i => \"0x\" + i.data.toString(\"hex\"));\n    return SnapshotEntryWithProofSchema.parseAsync({\n      ...entry,\n      proof: proof.concat(shard.proofs)\n    });\n  }\n  async getAllEntries() {\n    try {\n      return await this.storage.downloadJSON(this.originalEntriesUri);\n    } catch (e) {\n      console.warn(\"Could not fetch original snapshot entries\", e);\n      return [];\n    }\n  }\n}\n\nasync function fetchSnapshotEntryForAddress(address, merkleRoot, merkleMetadata, provider, storage, snapshotFormatVersion) {\n  if (!merkleMetadata) {\n    return null;\n  }\n  const snapshotUri = merkleMetadata[merkleRoot];\n  if (snapshotUri) {\n    const raw = await storage.downloadJSON(snapshotUri);\n    if (raw.isShardedMerkleTree && raw.merkleRoot === merkleRoot) {\n      const merkleTree = await ShardedMerkleTree.fromShardedMerkleTreeInfo(raw, storage);\n      return await merkleTree.getProof(address, provider, snapshotFormatVersion);\n    }\n    // legacy non-sharded, just fetch it all and filter out\n    const snapshotData = await SnapshotSchema.parseAsync(raw);\n    if (merkleRoot === snapshotData.merkleRoot) {\n      return snapshotData.claims.find(c => c.address.toLowerCase() === address.toLowerCase()) || null;\n    }\n  }\n  return null;\n}\n\nfunction legacyContractModelToAbstract(model) {\n  return {\n    startTimestamp: model.startTimestamp,\n    maxClaimableSupply: model.maxClaimableSupply,\n    supplyClaimed: model.supplyClaimed,\n    merkleRoot: model.merkleRoot.toString(),\n    pricePerToken: model.pricePerToken,\n    currency: model.currency,\n    maxClaimablePerWallet: model.quantityLimitPerTransaction,\n    waitTimeInSecondsBetweenClaims: model.waitTimeInSecondsBetweenClaims\n  };\n}\n\nfunction newContractModelToAbstract(model) {\n  return {\n    startTimestamp: model.startTimestamp,\n    maxClaimableSupply: model.maxClaimableSupply,\n    supplyClaimed: model.supplyClaimed,\n    merkleRoot: model.merkleRoot.toString(),\n    pricePerToken: model.pricePerToken,\n    currency: model.currency,\n    maxClaimablePerWallet: model.quantityLimitPerWallet,\n    waitTimeInSecondsBetweenClaims: 0,\n    metadata: model.metadata\n  };\n}\n\n/**\n * @internal\n */\nclass RPCConnectionHandler extends EventEmitter {\n  constructor(network, options) {\n    super();\n    try {\n      this.options = SDKOptionsSchema.parse(options);\n    } catch (optionParseError) {\n      console.error(\"invalid sdk options object passed, falling back to default options\", optionParseError);\n      this.options = SDKOptionsSchema.parse({});\n    }\n    const [signer, provider] = getSignerAndProvider(network, this.options);\n    this.network = network;\n    this.signer = signer;\n    this.provider = provider;\n  }\n  /**\n   * The function to call whenever the network changes, such as when the users connects their wallet, disconnects their wallet, the connected chain changes, etc.\n   *\n   * @param network - a network, signer or provider that ethers js can interpret\n   */\n  updateSignerOrProvider(network) {\n    const [signer, provider] = getSignerAndProvider(network, this.options);\n    this.network = network;\n    this.signer = signer;\n    this.provider = provider;\n  }\n  /**\n   *\n   * @returns whether or not a signer is set, `true` if there is no signer so the class is in \"read only\" mode\n   */\n  isReadOnly() {\n    return !isSigner(this.signer);\n  }\n\n  /**\n   * Explicitly get the active signer.\n   * @returns the active signer, if there is one\n   */\n  getSigner() {\n    return this.signer;\n  }\n\n  /**\n   * Explicitly get the active provider.\n   * @returns the active provider\n   */\n  getProvider() {\n    return this.provider;\n  }\n\n  /**\n   *\n   * @returns the current signer if there is one, otherwise the active provider\n   */\n  getSignerOrProvider() {\n    return this.getSigner() || this.getProvider();\n  }\n}\n\n/**\n * @internal\n */\nclass ContractWrapper extends RPCConnectionHandler {\n  isValidContract = false;\n  customOverrides = () => ({});\n  /**\n   * @internal\n   */\n\n  constructor(network, contractAddress, contractAbi, options, storage) {\n    super(network, options);\n    this.abi = contractAbi;\n    this.address = contractAddress;\n    // set up the contract\n    this.writeContract = new Contract(contractAddress, contractAbi, this.getSignerOrProvider());\n    // setup the read only contract\n    this.readContract = this.writeContract.connect(this.getProvider());\n    this.storage = storage;\n  }\n  updateSignerOrProvider(network) {\n    // update the underlying base class\n    super.updateSignerOrProvider(network);\n    // re-connect the contract with the new signer / provider\n    this.writeContract = this.writeContract.connect(this.getSignerOrProvider());\n    // setup the read only contract\n    this.readContract = this.writeContract.connect(this.getProvider());\n  }\n  updateAbi(updatedAbi) {\n    // re-connect the contract with the new signer / provider\n    this.writeContract = new Contract(this.address, updatedAbi, this.getSignerOrProvider());\n\n    // setup the read only contract\n    this.readContract = this.writeContract.connect(this.getProvider());\n    this.abi = AbiSchema.parse(updatedAbi);\n  }\n\n  /**\n   * @internal\n   */\n  async getChainID() {\n    const provider = this.getProvider();\n    const {\n      chainId\n    } = await provider.getNetwork();\n    return chainId;\n  }\n  /**\n   * @internal\n   */\n  async getSignerAddress() {\n    const signer = this.getSigner();\n    if (!signer) {\n      throw new Error(\"This action requires a connected wallet to sign the transaction. Please pass a valid signer to the SDK.\");\n    }\n    return await signer.getAddress();\n  }\n\n  /**\n   * @internal\n   */\n  callStatic() {\n    return this.writeContract.callStatic;\n  }\n\n  /**\n   * @internal\n   */\n  async getCallOverrides() {\n    return getDefaultGasOverrides(this.getProvider());\n  }\n\n  /**\n   * @internal\n   */\n  emitTransactionEvent(status, transactionHash) {\n    this.emit(EventType.Transaction, {\n      status,\n      transactionHash\n    });\n  }\n\n  /**\n   * @internal\n   */\n  async multiCall(encoded) {\n    return this.sendTransaction(\"multicall\", [encoded]);\n  }\n\n  /**\n   * @internal\n   */\n  async estimateGas(fn, args) {\n    return this.writeContract.estimateGas[fn](...args);\n  }\n\n  /**\n   * @internal\n   */\n  withTransactionOverride(hook) {\n    this.customOverrides = hook;\n  }\n\n  /**\n   *\n   * @param functionName The function name on the contract to call\n   * @param args The arguments to be passed to the functionName\n   * @returns The return value of the function call\n   */\n  async read(functionName, args) {\n    const functions = extractFunctionsFromAbi(AbiSchema.parse(this.abi)).filter(f => f.name === functionName);\n    if (!functions.length) {\n      throw new Error(`Function \"${functionName.toString()}\" not found in contract. Check your dashboard for the list of functions available`);\n    }\n    const fn = functions.find(f => f.name === functionName && f.inputs.length === args.length);\n\n    // TODO extract this and re-use for deploy function to check constructor args\n    if (!fn) {\n      throw new Error(`Function \"${functionName.toString()}\" requires ${functions[0].inputs.length} arguments, but ${args.length} were provided.\\nExpected function signature: ${functions[0].signature}`);\n    }\n    const ethersFnName = `${functionName.toString()}(${fn.inputs.map(i => i.type).join()})`;\n\n    // check if the function exists on the contract, otherwise use the name passed in\n    const fnName = ethersFnName in this.readContract.functions ? ethersFnName : functionName;\n    if (fn.stateMutability === \"view\" || fn.stateMutability === \"pure\") {\n      // read function\n      const result = await this.readContract[fnName.toString()](...args);\n      return result;\n    }\n    throw new Error(\"Cannot call a write function with read()\");\n  }\n\n  /**\n   * @internal\n   */\n  async call(functionName) {\n    let args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    let overrides = arguments.length > 2 ? arguments[2] : undefined;\n    // parse last arg as tx options if present\n    const txOptions = overrides ? await CallOverrideSchema.parseAsync(overrides) : undefined;\n    const functions = extractFunctionsFromAbi(AbiSchema.parse(this.abi)).filter(f => f.name === functionName);\n    if (!functions.length) {\n      throw new Error(`Function \"${functionName}\" not found in contract. Check your dashboard for the list of functions available`);\n    }\n    const fn = functions.find(f => f.name === functionName && f.inputs.length === args.length);\n\n    // TODO extract this and re-use for deploy function to check constructor args\n    if (!fn) {\n      throw new Error(`Function \"${functionName}\" requires ${functions[0].inputs.length} arguments, but ${args.length} were provided.\\nExpected function signature: ${functions[0].signature}`);\n    }\n    const ethersFnName = `${functionName}(${fn.inputs.map(i => i.type).join()})`;\n\n    // check if the function exists on the contract, otherwise use the name passed in\n    const fnName = ethersFnName in this.readContract.functions ? ethersFnName : functionName;\n\n    // TODO validate each argument\n    if (fn.stateMutability === \"view\" || fn.stateMutability === \"pure\") {\n      // read function\n      return txOptions ? this.readContract[fnName](...args, txOptions) : this.readContract[fnName](...args);\n    } else {\n      // write function\n      const receipt = await this.sendTransaction(fnName, args, txOptions);\n      return {\n        receipt\n      };\n    }\n  }\n\n  /**\n   * @internal\n   */\n  async sendTransaction(\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  fn, args, callOverrides) {\n    if (!callOverrides) {\n      callOverrides = await this.getCallOverrides();\n    }\n    // if a custom override is set, merge our override with the custom one\n    callOverrides = {\n      ...callOverrides,\n      ...this.customOverrides()\n    };\n    // clear up the override (single use)\n    this.customOverrides = () => ({});\n    if (this.options?.gasless && (\"openzeppelin\" in this.options.gasless || \"biconomy\" in this.options.gasless)) {\n      if (fn === \"multicall\" && Array.isArray(args[0]) && args[0].length > 0) {\n        const from = await this.getSignerAddress();\n        args[0] = args[0].map(tx => utils.solidityPack([\"bytes\", \"address\"], [tx, from]));\n      }\n      const provider = this.getProvider();\n      const txHash = await this.sendGaslessTransaction(fn, args, callOverrides);\n      this.emitTransactionEvent(\"submitted\", txHash);\n      const receipt = await provider.waitForTransaction(txHash);\n      this.emitTransactionEvent(\"completed\", txHash);\n      return receipt;\n    } else {\n      // one time verification that this is a valid contract (to avoid sending funds to wrong addresses)\n      if (!this.isValidContract) {\n        const code = await this.getProvider().getCode(this.address);\n        this.isValidContract = code !== \"0x\";\n        if (!this.isValidContract) {\n          throw new Error(\"The address you're trying to send a transaction to is not a smart contract. Make sure you are on the correct network and the contract address is correct\");\n        }\n      }\n      const tx = await this.sendTransactionByFunction(fn, args, callOverrides);\n      this.emitTransactionEvent(\"submitted\", tx.hash);\n\n      // tx.wait() can fail so we need to wrap it with a catch\n      let receipt;\n      try {\n        receipt = await tx.wait();\n      } catch (err) {\n        try {\n          // If tx.wait() fails, it just gives us a generic \"transaction failed\"\n          // error. So instead, we need to call static to get an informative error message\n          await this.writeContract.callStatic[fn](...args, ...(callOverrides.value ? [{\n            value: callOverrides.value\n          }] : []));\n        } catch (staticErr) {\n          throw await this.formatError(staticErr, fn, args, callOverrides);\n        }\n        throw await this.formatError(err, fn, args, callOverrides);\n      }\n      this.emitTransactionEvent(\"completed\", tx.hash);\n      return receipt;\n    }\n  }\n\n  /**\n   * @internal\n   */\n  async sendTransactionByFunction(fn, args, callOverrides) {\n    const func = this.writeContract.functions[fn];\n    if (!func) {\n      throw new Error(`invalid function: \"${fn.toString()}\"`);\n    }\n\n    // First, if no gasLimit is passed, call estimate gas ourselves\n    if (!callOverrides.gasLimit) {\n      try {\n        callOverrides.gasLimit = await this.writeContract.estimateGas[fn](...args, callOverrides);\n      } catch (e) {\n        // If gas estimation fails, we'll call static to get a better error message\n        try {\n          await this.writeContract.callStatic[fn](...args, ...(callOverrides.value ? [{\n            value: callOverrides.value\n          }] : []));\n        } catch (err) {\n          throw await this.formatError(err, fn, args, callOverrides);\n        }\n      }\n    }\n\n    // Now there should be no gas estimate errors\n    try {\n      return await func(...args, callOverrides);\n    } catch (err) {\n      throw await this.formatError(err, fn, args, callOverrides);\n    }\n  }\n  async formatError(error, fn, args, callOverrides) {\n    const provider = this.getProvider();\n\n    // Get metadata for transaction to populate into error\n    const network = await provider.getNetwork();\n    const from = await (callOverrides.from || this.getSignerAddress());\n    const to = this.address;\n    const data = this.readContract.interface.encodeFunctionData(fn, args);\n    const value = BigNumber.from(callOverrides.value || 0);\n    const rpcUrl = provider.connection?.url;\n\n    // Render function signature with arguments filled in\n    const functionSignature = this.readContract.interface.getFunction(fn);\n    const methodArgs = args.map(arg => {\n      if (JSON.stringify(arg).length <= 80) {\n        return JSON.stringify(arg);\n      }\n      return JSON.stringify(arg, undefined, 2);\n    });\n    const joinedArgs = methodArgs.join(\", \").length <= 80 ? methodArgs.join(\", \") : \"\\n\" + methodArgs.map(arg => \"  \" + arg.split(\"\\n\").join(\"\\n  \")).join(\",\\n\") + \"\\n\";\n    const method = `${functionSignature.name}(${joinedArgs})`;\n    const hash = error.transactionHash || error.transaction?.hash || error.receipt?.transactionHash;\n\n    // Parse the revert reason from the error\n    const reason = parseRevertReason(error);\n\n    // Get contract sources for stack trace\n    let sources = undefined;\n    let contractName = undefined;\n    try {\n      const metadata = await fetchContractMetadataFromAddress(this.address, this.getProvider(), this.storage, this.options);\n      if (metadata.name) {\n        contractName = metadata.name;\n      }\n      if (metadata.metadata.sources) {\n        sources = await fetchSourceFilesFromMetadata(metadata, this.storage);\n      }\n    } catch (err) {\n      // no-op\n    }\n    return new TransactionError({\n      reason,\n      from,\n      to,\n      method,\n      data,\n      network,\n      rpcUrl,\n      value,\n      hash,\n      contractName,\n      sources\n    }, error);\n  }\n\n  /**\n   * @internal\n   */\n  async sendGaslessTransaction(fn) {\n    let args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    let callOverrides = arguments.length > 2 ? arguments[2] : undefined;\n    const signer = this.getSigner();\n    invariant(signer, \"Cannot execute gasless transaction without valid signer\");\n    const chainId = await this.getChainID();\n    const from = await this.getSignerAddress();\n    const to = this.writeContract.address;\n    const value = callOverrides?.value || 0;\n    if (BigNumber.from(value).gt(0)) {\n      throw new Error(\"Cannot send native token value with gasless transaction\");\n    }\n    const data = this.writeContract.interface.encodeFunctionData(fn, args);\n    let gas = BigNumber.from(0);\n    try {\n      const gasEstimate = await this.readContract.estimateGas[fn](...args);\n      gas = gasEstimate.mul(2);\n    } catch (e) {\n      // ignore\n    }\n\n    // in some cases WalletConnect doesn't properly gives an estimate for how much gas it would actually use.\n    // as a fix, we're setting it to a high arbitrary number (500k) as the gas limit that should cover for most function calls.\n    if (gas.lt(100000)) {\n      gas = BigNumber.from(500000);\n    }\n\n    // check for gas override in callOverrides\n    if (callOverrides.gasLimit && BigNumber.from(callOverrides.gasLimit).gt(gas)) {\n      gas = BigNumber.from(callOverrides.gasLimit);\n    }\n    const tx = {\n      from,\n      to,\n      data,\n      chainId,\n      gasLimit: gas,\n      functionName: fn.toString(),\n      functionArgs: args,\n      callOverrides\n    };\n    return await this.defaultGaslessSendFunction(tx);\n  }\n  async signTypedData(signer, domain, types, message) {\n    this.emit(EventType.Signature, {\n      status: \"submitted\",\n      message,\n      signature: \"\"\n    });\n    const {\n      signature: sig\n    } = await signTypedDataInternal(signer, domain, types, message);\n    this.emit(EventType.Signature, {\n      status: \"completed\",\n      message,\n      signature: sig\n    });\n    return sig;\n  }\n  parseLogs(eventName, logs) {\n    if (!logs || logs.length === 0) {\n      return [];\n    }\n    const topic = this.writeContract.interface.getEventTopic(eventName);\n    const parsedLogs = logs.filter(x => x.topics.indexOf(topic) >= 0);\n    return parsedLogs.map(l => this.writeContract.interface.parseLog(l));\n  }\n  async defaultGaslessSendFunction(transaction) {\n    if (this.options.gasless && \"biconomy\" in this.options.gasless) {\n      return this.biconomySendFunction(transaction);\n    }\n    return this.defenderSendFunction(transaction);\n  }\n  async biconomySendFunction(transaction) {\n    invariant(this.options.gasless && \"biconomy\" in this.options.gasless, \"calling biconomySendFunction without biconomy\");\n    const signer = this.getSigner();\n    const provider = this.getProvider();\n    invariant(signer && provider, \"signer and provider must be set\");\n    const forwarder = new Contract(getContractAddressByChainId(transaction.chainId, \"biconomyForwarder\"), BiconomyForwarderAbi, provider);\n    const batchId = 0;\n    const batchNonce = await getAndIncrementNonce(forwarder, \"getNonce\", [transaction.from, batchId]);\n    const request = {\n      from: transaction.from,\n      to: transaction.to,\n      token: constants.AddressZero,\n      txGas: transaction.gasLimit.toNumber(),\n      tokenGasPrice: \"0\",\n      batchId,\n      batchNonce: batchNonce.toNumber(),\n      deadline: Math.floor(Date.now() / 1000 + (this.options?.gasless && \"biconomy\" in this.options.gasless && this.options.gasless.biconomy?.deadlineSeconds || 3600)),\n      data: transaction.data\n    };\n    const hashToSign = utils.arrayify(utils.solidityKeccak256([\"address\", \"address\", \"address\", \"uint256\", \"uint256\", \"uint256\", \"uint256\", \"uint256\", \"bytes32\"], [request.from, request.to, request.token, request.txGas, request.tokenGasPrice, request.batchId, request.batchNonce, request.deadline, utils.keccak256(request.data)]));\n    this.emit(EventType.Signature, {\n      status: \"submitted\",\n      message: hashToSign,\n      signature: \"\"\n    });\n    const signature = await signer.signMessage(hashToSign);\n    this.emit(EventType.Signature, {\n      status: \"completed\",\n      message: hashToSign,\n      signature\n    });\n    const response = await fetch(\"https://api.biconomy.io/api/v2/meta-tx/native\", {\n      method: \"POST\",\n      body: JSON.stringify({\n        from: transaction.from,\n        apiId: this.options.gasless.biconomy.apiId,\n        params: [request, signature],\n        to: transaction.to,\n        gasLimit: transaction.gasLimit.toHexString()\n      }),\n      headers: {\n        \"x-api-key\": this.options.gasless.biconomy.apiKey,\n        \"Content-Type\": \"application/json;charset=utf-8\"\n      }\n    });\n    if (response.ok) {\n      const resp = await response.json();\n      if (!resp.txHash) {\n        throw new Error(`relay transaction failed: ${resp.log}`);\n      }\n      return resp.txHash;\n    }\n    throw new Error(`relay transaction failed with status: ${response.status} (${response.statusText})`);\n  }\n  async defenderSendFunction(transaction) {\n    invariant(this.options.gasless && \"openzeppelin\" in this.options.gasless, \"calling openzeppelin gasless transaction without openzeppelin config in the SDK options\");\n    const signer = this.getSigner();\n    const provider = this.getProvider();\n    invariant(signer, \"provider is not set\");\n    invariant(provider, \"provider is not set\");\n    const forwarderAddress = this.options.gasless.openzeppelin.relayerForwarderAddress || (this.options.gasless.openzeppelin.useEOAForwarder ? CONTRACT_ADDRESSES[transaction.chainId].openzeppelinForwarderEOA || (await computeEOAForwarderAddress(this.getProvider(), this.storage, \"\", this.options.clientId, this.options.secretKey)) : CONTRACT_ADDRESSES[transaction.chainId].openzeppelinForwarder || (await computeForwarderAddress(this.getProvider(), this.storage, \"\", this.options.clientId, this.options.secretKey)));\n    const forwarder = new Contract(forwarderAddress, ForwarderABI, provider);\n    const nonce = await getAndIncrementNonce(forwarder, \"getNonce\", [transaction.from]);\n    let domain;\n    let types;\n    let message;\n    if (this.options.gasless.experimentalChainlessSupport) {\n      domain = {\n        name: \"GSNv2 Forwarder\",\n        version: \"0.0.1\",\n        verifyingContract: forwarderAddress\n      };\n      types = {\n        ForwardRequest: ChainAwareForwardRequest\n      };\n      message = {\n        from: transaction.from,\n        to: transaction.to,\n        value: BigNumber.from(0).toString(),\n        gas: BigNumber.from(transaction.gasLimit).toString(),\n        nonce: BigNumber.from(nonce).toString(),\n        data: transaction.data,\n        chainid: BigNumber.from(transaction.chainId).toString()\n      };\n    } else {\n      domain = {\n        name: this.options.gasless.openzeppelin.domainName,\n        version: this.options.gasless.openzeppelin.domainVersion,\n        chainId: transaction.chainId,\n        verifyingContract: forwarderAddress\n      };\n      types = {\n        ForwardRequest\n      };\n      message = {\n        from: transaction.from,\n        to: transaction.to,\n        value: BigNumber.from(0).toString(),\n        gas: BigNumber.from(transaction.gasLimit).toString(),\n        nonce: BigNumber.from(nonce).toString(),\n        data: transaction.data\n      };\n    }\n    let signature;\n    this.emit(EventType.Signature, {\n      status: \"submitted\",\n      message,\n      signature: \"\"\n    });\n\n    // if the executing function is \"approve\" and matches with erc20 approve signature\n    // and if the token supports permit, then we use permit for gasless instead of approve.\n    if (transaction.functionName === \"approve\" && transaction.functionArgs.length === 2) {\n      const spender = transaction.functionArgs[0];\n      const amount = transaction.functionArgs[1];\n      // TODO: support DAI permit by signDAIPermit\n      const {\n        message: permit,\n        signature: sig\n      } = await signEIP2612Permit(signer, this.writeContract.address, transaction.from, spender, amount);\n      const {\n        r,\n        s,\n        v\n      } = utils.splitSignature(sig);\n      message = {\n        to: this.address,\n        owner: permit.owner,\n        spender: permit.spender,\n        value: BigNumber.from(permit.value).toString(),\n        nonce: BigNumber.from(permit.nonce).toString(),\n        deadline: BigNumber.from(permit.deadline).toString(),\n        r,\n        s,\n        v\n      };\n      signature = sig;\n    } else {\n      const {\n        signature: sig\n      } = await signTypedDataInternal(signer, domain, types, message);\n      signature = sig;\n    }\n    let messageType = \"forward\";\n\n    // if has owner property then it's permit :)\n    if (message?.owner) {\n      messageType = \"permit\";\n    }\n    const body = JSON.stringify({\n      request: message,\n      signature,\n      forwarderAddress,\n      type: messageType\n    });\n    this.emit(EventType.Signature, {\n      status: \"completed\",\n      message,\n      signature\n    });\n    const response = await fetch(this.options.gasless.openzeppelin.relayerUrl, {\n      method: \"POST\",\n      body\n    });\n    if (response.ok) {\n      const resp = await response.json();\n      if (!resp.result) {\n        throw new Error(`Relay transaction failed: ${resp.message}`);\n      }\n      const result = JSON.parse(resp.result);\n      return result.txHash;\n    }\n    throw new Error(`relay transaction failed with status: ${response.status} (${response.statusText})`);\n  }\n}\n\nasync function approveErc20Allowance(contractToApprove, currencyAddress, price, quantity, tokenDecimals) {\n  const signer = contractToApprove.getSigner();\n  const provider = contractToApprove.getProvider();\n  const erc20 = new ContractWrapper(signer || provider, currencyAddress, ERC20Abi, contractToApprove.options, contractToApprove.storage);\n  const owner = await contractToApprove.getSignerAddress();\n  const spender = contractToApprove.address;\n  const allowance = await erc20.read(\"allowance\", [owner, spender]);\n  const totalPrice = BigNumber.from(price).mul(BigNumber.from(quantity)).div(utils.parseUnits(\"1\", tokenDecimals));\n  if (allowance.lt(totalPrice)) {\n    await erc20.sendTransaction(\"approve\", [spender, allowance.add(totalPrice)]);\n  }\n}\n\n/**\n *\n * @param provider\n * @param inputPrice\n * @param currencyAddress\n * @returns\n * @internal\n */\nasync function normalizePriceValue(provider, inputPrice, currencyAddress) {\n  const metadata = await fetchCurrencyMetadata(provider, currencyAddress);\n  return utils.parseUnits(AmountSchema.parse(inputPrice), metadata.decimals);\n}\n\n/**\n * Returns proofs and the overrides required for the transaction.\n * @internal\n * @returns - `overrides` and `proofs` as an object.\n */\nasync function prepareClaim(addressToClaim, quantity, activeClaimCondition, merkleMetadataFetcher, tokenDecimals, contractWrapper, storage, checkERC20Allowance, snapshotFormatVersion) {\n  let maxClaimable = convertQuantityToBigNumber(activeClaimCondition.maxClaimablePerWallet, tokenDecimals);\n  let proofs = [utils.hexZeroPad([0], 32)];\n  let priceInProof = activeClaimCondition.price; // the price to send to the contract in claim proofs\n  let currencyAddressInProof = activeClaimCondition.currencyAddress;\n  try {\n    if (!activeClaimCondition.merkleRootHash.toString().startsWith(constants.AddressZero)) {\n      const snapshotEntry = await fetchSnapshotEntryForAddress(addressToClaim, activeClaimCondition.merkleRootHash.toString(), await merkleMetadataFetcher(), contractWrapper.getProvider(), storage, snapshotFormatVersion);\n      if (snapshotEntry) {\n        proofs = snapshotEntry.proof;\n        // override only if not default values (unlimited for quantity, zero addr for currency)\n        maxClaimable = snapshotEntry.maxClaimable === \"unlimited\" ? constants.MaxUint256 : utils.parseUnits(snapshotEntry.maxClaimable, tokenDecimals);\n        priceInProof = snapshotEntry.price === undefined || snapshotEntry.price === \"unlimited\" ? constants.MaxUint256 : await normalizePriceValue(contractWrapper.getProvider(), snapshotEntry.price, snapshotEntry.currencyAddress || constants.AddressZero);\n        currencyAddressInProof = snapshotEntry.currencyAddress || constants.AddressZero;\n      } else {\n        // if no snapshot entry, and it's a v1 format (exclusive allowlist) then address can't claim\n        if (snapshotFormatVersion === SnapshotFormatVersion.V1) {\n          throw new Error(\"No claim found for this address\");\n        }\n        // but if its snapshot v2 (override list behavior) then address can still claim with default settings\n      }\n    }\n  } catch (e) {\n    // have to handle the valid error case that we *do* want to throw on\n    if (e?.message === \"No claim found for this address\") {\n      throw e;\n    }\n    // other errors we wanna ignore and try to continue\n    console.warn(\"failed to check claim condition merkle root hash, continuing anyways\", e);\n  }\n  const overrides = (await contractWrapper.getCallOverrides()) || {};\n  // the actual price to check allowance against\n  // if proof price is unlimited, then we use the price from the claim condition\n  // this mimics the contract behavior\n  const pricePerToken = priceInProof.toString() !== constants.MaxUint256.toString() ? priceInProof : activeClaimCondition.price;\n  // same for currency address\n  const currencyAddress = currencyAddressInProof !== constants.AddressZero ? currencyAddressInProof : activeClaimCondition.currencyAddress;\n  if (pricePerToken.gt(0)) {\n    if (isNativeToken(currencyAddress)) {\n      overrides[\"value\"] = BigNumber.from(pricePerToken).mul(quantity).div(utils.parseUnits(\"1\", tokenDecimals));\n    } else if (checkERC20Allowance) {\n      await approveErc20Allowance(contractWrapper, currencyAddress, pricePerToken, quantity, tokenDecimals);\n    }\n  }\n  return {\n    overrides,\n    proofs,\n    maxClaimable,\n    price: pricePerToken,\n    currencyAddress: currencyAddress,\n    priceInProof,\n    currencyAddressInProof\n  };\n}\n\n/**\n * Create a snapshot (merkle tree) from a list of addresses and uploads it to IPFS\n * @param snapshotInput - the list of addresses to hash\n * @param tokenDecimals - the token decimals\n * @param provider\n * @param storage - the storage to upload to\n * @param snapshotFormatVersion\n * @returns the generated snapshot and URI\n * @internal\n */\nasync function createSnapshot(snapshotInput, tokenDecimals, provider, storage, snapshotFormatVersion) {\n  const input = await parseSnapshotInputs(snapshotInput);\n  const addresses = input.map(i => i.address);\n  const hasDuplicates = new Set(addresses).size < addresses.length;\n  if (hasDuplicates) {\n    throw new DuplicateLeafsError();\n  }\n  const tree = await ShardedMerkleTree.buildAndUpload(input, tokenDecimals, provider, storage, snapshotFormatVersion);\n  return {\n    merkleRoot: tree.shardedMerkleInfo.merkleRoot,\n    snapshotUri: tree.uri\n  };\n}\n\nfunction compare(a, b) {\n  const left = BigNumber.from(a);\n  const right = BigNumber.from(b);\n  if (left.eq(right)) {\n    return 0;\n  } else if (left.gt(right)) {\n    return 1;\n  } else {\n    return -1;\n  }\n}\n\n/**\n * @internal\n * Decorates claim conditions with merkle roots from snapshots if present\n * @param claimConditionInputs\n * @param tokenDecimals\n * @param provider\n * @param storage\n * @param snapshotFormatVersion\n */\nasync function processSnapshotData(claimConditionInputs, tokenDecimals, provider, storage, snapshotFormatVersion) {\n  const snapshotInfos = [];\n  const inputsWithSnapshots = await Promise.all(claimConditionInputs.map(async conditionInput => {\n    // check snapshots and upload if provided\n    if (conditionInput.snapshot && conditionInput.snapshot.length > 0) {\n      const snapshotInfo = await createSnapshot(conditionInput.snapshot, tokenDecimals, provider, storage, snapshotFormatVersion);\n      snapshotInfos.push(snapshotInfo);\n      conditionInput.merkleRootHash = snapshotInfo.merkleRoot;\n    } else {\n      // if no snapshot is passed or empty, reset the merkle root\n      conditionInput.merkleRootHash = utils.hexZeroPad([0], 32);\n    }\n    // fill condition with defaults values if not provided\n    return conditionInput;\n  }));\n  return {\n    inputsWithSnapshots,\n    snapshotInfos\n  };\n}\n\n/**\n * Converts a local SDK model to contract model\n * @param c\n * @param tokenDecimals\n * @param provider\n * @param storage\n * @internal\n */\nasync function convertToContractModel(c, tokenDecimals, provider, storage) {\n  const currency = c.currencyAddress === constants.AddressZero ? NATIVE_TOKEN_ADDRESS : c.currencyAddress;\n  const maxClaimableSupply = convertQuantityToBigNumber(c.maxClaimableSupply, tokenDecimals);\n  const maxClaimablePerWallet = convertQuantityToBigNumber(c.maxClaimablePerWallet, tokenDecimals);\n  let metadataOrUri;\n  if (c.metadata) {\n    if (typeof c.metadata === \"string\") {\n      metadataOrUri = c.metadata;\n    } else {\n      metadataOrUri = await storage.upload(c.metadata);\n    }\n  }\n  return {\n    startTimestamp: c.startTime,\n    maxClaimableSupply,\n    supplyClaimed: 0,\n    maxClaimablePerWallet,\n    pricePerToken: await normalizePriceValue(provider, c.price, currency),\n    currency,\n    merkleRoot: c.merkleRootHash.toString(),\n    waitTimeInSecondsBetweenClaims: c.waitInSeconds || 0,\n    metadata: metadataOrUri\n  };\n}\n\n/**\n * Create and uploads snapshots + converts claim conditions to contract format\n * @param claimConditionInputs\n * @param tokenDecimals\n * @param provider\n * @param storage\n * @param snapshotFormatVersion\n * @internal\n */\nasync function processClaimConditionInputs(claimConditionInputs, tokenDecimals, provider, storage, snapshotFormatVersion) {\n  const {\n    inputsWithSnapshots,\n    snapshotInfos\n  } = await processSnapshotData(claimConditionInputs, tokenDecimals, provider, storage, snapshotFormatVersion);\n  const parsedInputs = await ClaimConditionInputArray.parseAsync(inputsWithSnapshots);\n  // Convert processed inputs to the format the contract expects, and sort by timestamp\n  const sortedConditions = (await Promise.all(parsedInputs.map(c => convertToContractModel(c, tokenDecimals, provider, storage)))).sort((a, b) => {\n    return compare(a.startTimestamp, b.startTimestamp);\n  });\n  return {\n    snapshotInfos,\n    sortedConditions\n  };\n}\n\n/**\n *\n * @param providerOrSigner\n * @param asset\n * @param price\n * @returns\n * @internal\n */\nasync function fetchCurrencyValue(providerOrSigner, asset, price) {\n  const metadata = await fetchCurrencyMetadata(providerOrSigner, asset);\n  return {\n    ...metadata,\n    value: BigNumber.from(price),\n    displayValue: utils.formatUnits(price, metadata.decimals)\n  };\n}\n\n/**\n * @internal\n * @param merkleRoot\n * @param merkleMetadata\n * @param storage\n */\nasync function fetchSnapshot(merkleRoot, merkleMetadata, storage) {\n  if (!merkleMetadata) {\n    return null;\n  }\n  const snapshotUri = merkleMetadata[merkleRoot];\n  if (snapshotUri) {\n    const raw = await storage.downloadJSON(snapshotUri);\n    if (raw.isShardedMerkleTree && raw.merkleRoot === merkleRoot) {\n      const smt = await ShardedMerkleTree.fromUri(snapshotUri, storage);\n      return smt?.getAllEntries() || null;\n    } else {\n      const snapshotData = await SnapshotSchema.parseAsync(raw);\n      if (merkleRoot === snapshotData.merkleRoot) {\n        return snapshotData.claims.map(claim => ({\n          address: claim.address,\n          maxClaimable: claim.maxClaimable,\n          price: claim.price,\n          currencyAddress: claim.currencyAddress\n        }));\n      }\n    }\n  }\n  return null;\n}\n\n/**\n * @internal\n * @param bn\n * @param tokenDecimals\n */\nfunction convertToReadableQuantity(bn, tokenDecimals) {\n  if (bn.toString() === constants.MaxUint256.toString()) {\n    return \"unlimited\";\n  } else {\n    return utils.formatUnits(bn, tokenDecimals);\n  }\n}\n\n/**\n * Transforms a contract model to local model\n * @param pm\n * @param tokenDecimals\n * @param provider\n * @param merkleMetadata\n * @param storage\n * @param shouldDownloadSnapshot\n * @internal\n */\nasync function transformResultToClaimCondition(pm, tokenDecimals, provider, merkleMetadata, storage, shouldDownloadSnapshot) {\n  const cv = await fetchCurrencyValue(provider, pm.currency, pm.pricePerToken);\n  const maxClaimableSupply = convertToReadableQuantity(pm.maxClaimableSupply, tokenDecimals);\n  const maxClaimablePerWallet = convertToReadableQuantity(pm.maxClaimablePerWallet, tokenDecimals);\n  const availableSupply = convertToReadableQuantity(BigNumber.from(pm.maxClaimableSupply).sub(pm.supplyClaimed), tokenDecimals);\n  const currentMintSupply = convertToReadableQuantity(pm.supplyClaimed, tokenDecimals);\n  let resolvedMetadata;\n  if (pm.metadata) {\n    resolvedMetadata = await storage.downloadJSON(pm.metadata);\n  }\n  return ClaimConditionOutputSchema.parseAsync({\n    startTime: pm.startTimestamp,\n    maxClaimableSupply,\n    maxClaimablePerWallet,\n    currentMintSupply,\n    availableSupply,\n    waitInSeconds: pm.waitTimeInSecondsBetweenClaims?.toString(),\n    price: BigNumber.from(pm.pricePerToken),\n    currency: pm.currency,\n    currencyAddress: pm.currency,\n    currencyMetadata: cv,\n    merkleRootHash: pm.merkleRoot,\n    snapshot: shouldDownloadSnapshot ? await fetchSnapshot(pm.merkleRoot, merkleMetadata, storage) : undefined,\n    metadata: resolvedMetadata\n  });\n}\n\n/**\n * @internal\n * @param index\n * @param claimConditionInput\n * @param existingConditions\n */\nasync function updateExistingClaimConditions(index, claimConditionInput, existingConditions) {\n  if (index >= existingConditions.length) {\n    throw Error(`Index out of bounds - got index: ${index} with ${existingConditions.length} conditions`);\n  }\n  // merge input with existing claim condition\n  const priceDecimals = existingConditions[index].currencyMetadata.decimals;\n  const priceInWei = existingConditions[index].price;\n  const priceInTokens = utils.formatUnits(priceInWei, priceDecimals);\n\n  // merge existing (output format) with incoming (input format)\n  const newConditionParsed = await ClaimConditionInputSchema.parseAsync({\n    ...existingConditions[index],\n    price: priceInTokens,\n    ...claimConditionInput\n  });\n\n  // convert to output claim condition\n  const mergedConditionOutput = await ClaimConditionOutputSchema.parseAsync({\n    ...newConditionParsed,\n    price: priceInWei\n  });\n  return existingConditions.map((existingOutput, i) => {\n    let newConditionAtIndex;\n    if (i === index) {\n      newConditionAtIndex = mergedConditionOutput;\n    } else {\n      newConditionAtIndex = existingOutput;\n    }\n    const formattedPrice = utils.formatUnits(newConditionAtIndex.price, priceDecimals);\n    return {\n      ...newConditionAtIndex,\n      price: formattedPrice // manually transform back to input price type\n    };\n  });\n}\n\nlet Status = /*#__PURE__*/function (Status) {\n  Status[Status[\"UNSET\"] = 0] = \"UNSET\";\n  Status[Status[\"Created\"] = 1] = \"Created\";\n  Status[Status[\"Completed\"] = 2] = \"Completed\";\n  Status[Status[\"Cancelled\"] = 3] = \"Cancelled\";\n  Status[Status[\"Active\"] = 4] = \"Active\";\n  Status[Status[\"Expired\"] = 5] = \"Expired\";\n  return Status;\n}({});\n\nlet ClaimEligibility = /*#__PURE__*/function (ClaimEligibility) {\n  ClaimEligibility[\"NotEnoughSupply\"] = \"There is not enough supply to claim.\";\n  ClaimEligibility[\"AddressNotAllowed\"] = \"This address is not on the allowlist.\";\n  ClaimEligibility[\"WaitBeforeNextClaimTransaction\"] = \"Not enough time since last claim transaction. Please wait.\";\n  ClaimEligibility[\"ClaimPhaseNotStarted\"] = \"Claim phase has not started yet.\";\n  ClaimEligibility[\"AlreadyClaimed\"] = \"You have already claimed the token.\";\n  ClaimEligibility[\"WrongPriceOrCurrency\"] = \"Incorrect price or currency.\";\n  ClaimEligibility[\"OverMaxClaimablePerWallet\"] = \"Cannot claim more than maximum allowed quantity.\";\n  ClaimEligibility[\"NotEnoughTokens\"] = \"There are not enough tokens in the wallet to pay for the claim.\";\n  ClaimEligibility[\"NoActiveClaimPhase\"] = \"There is no active claim phase at the moment. Please check back in later.\";\n  ClaimEligibility[\"NoClaimConditionSet\"] = \"There is no claim condition set.\";\n  ClaimEligibility[\"NoWallet\"] = \"No wallet connected.\";\n  ClaimEligibility[\"Unknown\"] = \"No claim conditions found.\";\n  return ClaimEligibility;\n}({});\n\n/**\n * Manages claim conditions for NFT Drop contracts\n * @public\n */\nclass DropClaimConditions {\n  constructor(contractWrapper, metadata, storage) {\n    this.storage = storage;\n    this.contractWrapper = contractWrapper;\n    this.metadata = metadata;\n  }\n\n  /** ***************************************\n   * READ FUNCTIONS\n   *****************************************/\n\n  /**\n   * Get the currently active claim condition\n   *\n   * @returns the claim condition metadata\n   */\n  async getActive(options) {\n    const cc = await this.get();\n    const metadata = await this.metadata.get();\n    return await transformResultToClaimCondition(cc, await this.getTokenDecimals(), this.contractWrapper.getProvider(), metadata.merkle || {}, this.storage, options?.withAllowList || false);\n  }\n  async get(conditionId) {\n    if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {\n      const contractModel = await this.contractWrapper.read(\"claimCondition\", []);\n      return legacyContractModelToAbstract(contractModel);\n    } else if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {\n      const id = conditionId !== undefined ? conditionId : await this.contractWrapper.read(\"getActiveClaimConditionId\", []);\n      const contractModel = await this.contractWrapper.read(\"getClaimConditionById\", [id]);\n      return legacyContractModelToAbstract(contractModel);\n    } else if (this.isNewSinglePhaseDrop(this.contractWrapper)) {\n      const contractModel = await this.contractWrapper.read(\"claimCondition\", []);\n      return newContractModelToAbstract(contractModel);\n    } else if (this.isNewMultiphaseDrop(this.contractWrapper)) {\n      const id = conditionId !== undefined ? conditionId : await this.contractWrapper.read(\"getActiveClaimConditionId\", []);\n      const contractModel = await this.contractWrapper.read(\"getClaimConditionById\", [id]);\n      return newContractModelToAbstract(contractModel);\n    } else {\n      throw new Error(\"Contract does not support claim conditions\");\n    }\n  }\n\n  /**\n   * Get all the claim conditions\n   *\n   * @returns the claim conditions metadata\n   */\n  async getAll(options) {\n    if (this.isLegacyMultiPhaseDrop(this.contractWrapper) || this.isNewMultiphaseDrop(this.contractWrapper)) {\n      const [currentStartId, countBn] = await this.contractWrapper.read(\"claimCondition\", []);\n      const startId = currentStartId.toNumber();\n      const count = countBn.toNumber();\n      const conditions = [];\n      for (let i = startId; i < startId + count; i++) {\n        conditions.push(this.get(i));\n      }\n      const [metadata, decimals, ...fetchedConditions] = await Promise.all([this.metadata.get(), this.getTokenDecimals(), ...conditions]);\n      return Promise.all(fetchedConditions.map(c => transformResultToClaimCondition(c, decimals, this.contractWrapper.getProvider(), metadata.merkle, this.storage, options?.withAllowList || false)));\n    } else {\n      return [await this.getActive(options)];\n    }\n  }\n\n  /**\n   * Can Claim\n   *\n   * @remarks Check if the drop can currently be claimed.\n   *\n   * @example\n   * ```javascript\n   * // Quantity of tokens to check claimability of\n   * const quantity = 1;\n   * const canClaim = await contract.canClaim(quantity);\n   * ```\n   */\n  async canClaim(quantity, addressToCheck) {\n    // TODO switch to use verifyClaim\n    if (addressToCheck) {\n      addressToCheck = await resolveAddress(addressToCheck);\n    }\n    return (await this.getClaimIneligibilityReasons(quantity, addressToCheck)).length === 0;\n  }\n\n  /**\n   * For any claim conditions that a particular wallet is violating,\n   * this function returns human readable information about the\n   * breaks in the condition that can be used to inform the user.\n   *\n   * @param quantity - The desired quantity that would be claimed.\n   * @param addressToCheck - The wallet address, defaults to the connected wallet.\n   *\n   */\n  async getClaimIneligibilityReasons(quantity, addressToCheck) {\n    const reasons = [];\n    let activeConditionIndex;\n    let claimCondition;\n    const decimals = await this.getTokenDecimals();\n    const quantityWithDecimals = utils.parseUnits(AmountSchema.parse(quantity), decimals);\n    if (addressToCheck === undefined) {\n      try {\n        addressToCheck = await this.contractWrapper.getSignerAddress();\n      } catch (err) {\n        console.warn(\"failed to get signer address\", err);\n      }\n    }\n\n    // if we have been unable to get a signer address, we can't check eligibility, so return a NoWallet error reason\n    if (!addressToCheck) {\n      return [ClaimEligibility.NoWallet];\n    }\n    const resolvedAddress = await resolveAddress(addressToCheck);\n    try {\n      claimCondition = await this.getActive();\n    } catch (err) {\n      if (includesErrorMessage(err, \"!CONDITION\") || includesErrorMessage(err, \"no active mint condition\")) {\n        reasons.push(ClaimEligibility.NoClaimConditionSet);\n        return reasons;\n      }\n      console.warn(\"failed to get active claim condition\", err);\n      reasons.push(ClaimEligibility.Unknown);\n      return reasons;\n    }\n    if (claimCondition.availableSupply !== \"unlimited\") {\n      const supplyWithDecimals = utils.parseUnits(claimCondition.availableSupply, decimals);\n      if (supplyWithDecimals.lt(quantityWithDecimals)) {\n        reasons.push(ClaimEligibility.NotEnoughSupply);\n        return reasons;\n      }\n    }\n\n    // check for merkle root inclusion\n    const merkleRootArray = utils.stripZeros(claimCondition.merkleRootHash);\n    const hasAllowList = merkleRootArray.length > 0;\n    let allowListEntry = null;\n    if (hasAllowList) {\n      allowListEntry = await this.getClaimerProofs(resolvedAddress);\n      if (!allowListEntry && (this.isLegacySinglePhaseDrop(this.contractWrapper) || this.isLegacyMultiPhaseDrop(this.contractWrapper))) {\n        // exclusive allowlist behavior\n        reasons.push(ClaimEligibility.AddressNotAllowed);\n        return reasons;\n      }\n      if (allowListEntry) {\n        try {\n          const claimVerification = await this.prepareClaim(quantity, false, decimals, resolvedAddress);\n          let validMerkleProof;\n          if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {\n            activeConditionIndex = await this.contractWrapper.read(\"getActiveClaimConditionId\", []);\n            // legacy verifyClaimerMerkleProofs function\n            [validMerkleProof] = await this.contractWrapper.read(\"verifyClaimMerkleProof\", [activeConditionIndex, resolvedAddress, quantity, claimVerification.proofs, claimVerification.maxClaimable]);\n            if (!validMerkleProof) {\n              reasons.push(ClaimEligibility.AddressNotAllowed);\n              return reasons;\n            }\n          } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {\n            [validMerkleProof] = await this.contractWrapper.read(\"verifyClaimMerkleProof\", [resolvedAddress, quantity, {\n              proof: claimVerification.proofs,\n              maxQuantityInAllowlist: claimVerification.maxClaimable\n            }]);\n            if (!validMerkleProof) {\n              reasons.push(ClaimEligibility.AddressNotAllowed);\n              return reasons;\n            }\n          } else if (this.isNewSinglePhaseDrop(this.contractWrapper)) {\n            await this.contractWrapper.read(\"verifyClaim\", [resolvedAddress, quantity, claimVerification.currencyAddress, claimVerification.price, {\n              proof: claimVerification.proofs,\n              quantityLimitPerWallet: claimVerification.maxClaimable,\n              currency: claimVerification.currencyAddressInProof,\n              pricePerToken: claimVerification.priceInProof\n            }]);\n          } else if (this.isNewMultiphaseDrop(this.contractWrapper)) {\n            activeConditionIndex = await this.contractWrapper.read(\"getActiveClaimConditionId\", []);\n            await this.contractWrapper.read(\"verifyClaim\", [activeConditionIndex, resolvedAddress, quantity, claimVerification.currencyAddress, claimVerification.price, {\n              proof: claimVerification.proofs,\n              quantityLimitPerWallet: claimVerification.maxClaimable,\n              currency: claimVerification.currencyAddressInProof,\n              pricePerToken: claimVerification.priceInProof\n            }]);\n          }\n        } catch (e) {\n          console.warn(\"Merkle proof verification failed:\", \"reason\" in e ? e.reason : e);\n          const reason = e.reason;\n          switch (reason) {\n            case \"!Qty\":\n              reasons.push(ClaimEligibility.OverMaxClaimablePerWallet);\n              break;\n            case \"!PriceOrCurrency\":\n              reasons.push(ClaimEligibility.WrongPriceOrCurrency);\n              break;\n            case \"!MaxSupply\":\n              reasons.push(ClaimEligibility.NotEnoughSupply);\n              break;\n            case \"cant claim yet\":\n              reasons.push(ClaimEligibility.ClaimPhaseNotStarted);\n              break;\n            default:\n              {\n                reasons.push(ClaimEligibility.AddressNotAllowed);\n                break;\n              }\n          }\n          return reasons;\n        }\n      }\n    }\n    if (this.isNewSinglePhaseDrop(this.contractWrapper) || this.isNewMultiphaseDrop(this.contractWrapper)) {\n      let claimedSupply = BigNumber.from(0);\n      let maxClaimable = convertQuantityToBigNumber(claimCondition.maxClaimablePerWallet, decimals);\n      try {\n        claimedSupply = await this.getSupplyClaimedByWallet(resolvedAddress);\n      } catch (e) {\n        // no-op\n      }\n      if (allowListEntry) {\n        maxClaimable = convertQuantityToBigNumber(allowListEntry.maxClaimable, decimals);\n      }\n      if (maxClaimable.gt(0) && maxClaimable.lt(claimedSupply.add(quantityWithDecimals))) {\n        reasons.push(ClaimEligibility.OverMaxClaimablePerWallet);\n        return reasons;\n      }\n\n      // if there is no allowlist, or if there is an allowlist and the address is not in it\n      // if maxClaimable is 0, we consider it as the address is not allowed\n      if (!hasAllowList || hasAllowList && !allowListEntry) {\n        if (maxClaimable.lte(claimedSupply) || maxClaimable.eq(0)) {\n          reasons.push(ClaimEligibility.AddressNotAllowed);\n          return reasons;\n        }\n      }\n    }\n\n    // check for claim timestamp between claims (ONLY FOR LEGACY)\n    if (this.isLegacySinglePhaseDrop(this.contractWrapper) || this.isLegacyMultiPhaseDrop(this.contractWrapper)) {\n      let [lastClaimedTimestamp, timestampForNextClaim] = [BigNumber.from(0), BigNumber.from(0)];\n      if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {\n        activeConditionIndex = await this.contractWrapper.read(\"getActiveClaimConditionId\", []);\n        [lastClaimedTimestamp, timestampForNextClaim] = await this.contractWrapper.read(\"getClaimTimestamp\", [activeConditionIndex, resolvedAddress]);\n      } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {\n        // check for claim timestamp between claims\n        [lastClaimedTimestamp, timestampForNextClaim] = await this.contractWrapper.read(\"getClaimTimestamp\", [resolvedAddress]);\n      }\n      const now = BigNumber.from(Date.now()).div(1000);\n      if (lastClaimedTimestamp.gt(0) && now.lt(timestampForNextClaim)) {\n        // contract will return MaxUint256 if user has already claimed and cannot claim again\n        if (timestampForNextClaim.eq(constants.MaxUint256)) {\n          reasons.push(ClaimEligibility.AlreadyClaimed);\n        } else {\n          reasons.push(ClaimEligibility.WaitBeforeNextClaimTransaction);\n        }\n        return reasons;\n      }\n    }\n\n    // if not within a browser conetext, check for wallet balance.\n    // In browser context, let the wallet do that job\n    if (claimCondition.price.gt(0) && isNode()) {\n      const totalPrice = claimCondition.price.mul(BigNumber.from(quantity));\n      const provider = this.contractWrapper.getProvider();\n      if (isNativeToken(claimCondition.currencyAddress)) {\n        const balance = await provider.getBalance(resolvedAddress);\n        if (balance.lt(totalPrice)) {\n          reasons.push(ClaimEligibility.NotEnoughTokens);\n        }\n      } else {\n        const erc20 = new ContractWrapper(provider, claimCondition.currencyAddress, ERC20Abi, {}, this.storage);\n        const balance = await erc20.read(\"balanceOf\", [resolvedAddress]);\n        if (balance.lt(totalPrice)) {\n          reasons.push(ClaimEligibility.NotEnoughTokens);\n        }\n      }\n    }\n    return reasons;\n  }\n\n  /**\n   * Returns allow list information and merkle proofs for the given address.\n   * @param claimerAddress - the claimer address\n   * @param claimConditionId - optional the claim condition id to get the proofs for\n   */\n  async getClaimerProofs(claimerAddress, claimConditionId) {\n    const claimCondition = await this.get(claimConditionId);\n    const merkleRoot = claimCondition.merkleRoot;\n    const merkleRootArray = utils.stripZeros(merkleRoot);\n    if (merkleRootArray.length > 0) {\n      const metadata = await this.metadata.get();\n      const resolvedAddress = await resolveAddress(claimerAddress);\n      return await fetchSnapshotEntryForAddress(resolvedAddress, merkleRoot.toString(), metadata.merkle, this.contractWrapper.getProvider(), this.storage, this.getSnapshotFormatVersion());\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Get the total supply claimed by a specific wallet\n   * @param walletAddress the wallet address to check\n   * @returns the total supply claimed\n   */\n  async getSupplyClaimedByWallet(walletAddress) {\n    const resolvedAddress = await resolveAddress(walletAddress);\n    if (this.isNewSinglePhaseDrop(this.contractWrapper)) {\n      return await this.contractWrapper.read(\"getSupplyClaimedByWallet\", [resolvedAddress]);\n    }\n    if (this.isNewMultiphaseDrop(this.contractWrapper)) {\n      const activeClaimConditionId = await this.contractWrapper.read(\"getActiveClaimConditionId\", []);\n      return await this.contractWrapper.read(\"getSupplyClaimedByWallet\", [activeClaimConditionId, resolvedAddress]);\n    }\n    throw new Error(\"This contract does not support the getSupplyClaimedByWallet function\");\n  }\n\n  /** ***************************************\n   * WRITE FUNCTIONS\n   *****************************************/\n\n  /**\n   * Set public mint conditions\n   *\n   * @remarks Sets the public mint conditions that need to be fullfiled by users to claim NFTs.\n   *\n   * @example\n   * ```javascript\n   * const presaleStartTime = new Date();\n   * const publicSaleStartTime = new Date(Date.now() + 60 * 60 * 24 * 1000);\n   *\n   * // Optionally specify addresses that can claim\n   * const snapshots = ['0x...', '0x...']\n   *\n   * // Or alternatively, you can pass snapshots with the max number of NFTs each address can claim\n   * // const snapshots = [{ address: '0x...', maxClaimable: 1 }, { address: '0x...', maxClaimable: 2 }]\n   *\n   * const claimConditions = [\n   *   {\n   *     startTime: presaleStartTime, // start the presale now\n   *     maxClaimableSupply: 2, // limit how many mints for this presale\n   *     price: 0.01, // presale price\n   *     snapshot: snapshots, // limit minting to only certain addresses\n   *   },\n   *   {\n   *     startTime: publicSaleStartTime, // 24h after presale, start public sale\n   *     price: 0.08, // public sale price\n   *   }\n   * ]);\n   *\n   * await dropContract.claimConditions.set(claimConditions);\n   * ```\n   *\n   * @param claimConditionInputs - The claim conditions\n   * @param resetClaimEligibilityForAll - Whether to reset the state of who already claimed NFTs previously\n   */\n  set = /* @__PURE__ */buildTransactionFunction((() => {\n    var _this = this;\n    return async function (claimConditionInputs) {\n      let resetClaimEligibilityForAll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      let claimConditionsProcessed = claimConditionInputs;\n      if (_this.isLegacySinglePhaseDrop(_this.contractWrapper) || _this.isNewSinglePhaseDrop(_this.contractWrapper)) {\n        resetClaimEligibilityForAll = true;\n        if (claimConditionInputs.length === 0) {\n          claimConditionsProcessed = [{\n            startTime: new Date(0),\n            currencyAddress: constants.AddressZero,\n            price: 0,\n            maxClaimableSupply: 0,\n            maxClaimablePerWallet: 0,\n            waitInSeconds: 0,\n            merkleRootHash: utils.hexZeroPad([0], 32),\n            snapshot: []\n          }];\n        } else if (claimConditionInputs.length > 1) {\n          throw new Error(\"Single phase drop contract cannot have multiple claim conditions, only one is allowed\");\n        }\n      }\n\n      // if using new snapshot format, make sure that maxClaimablePerWallet is set if allowlist is set as well\n      if (_this.isNewSinglePhaseDrop(_this.contractWrapper) || _this.isNewMultiphaseDrop(_this.contractWrapper)) {\n        claimConditionsProcessed.forEach(cc => {\n          if (cc.snapshot && cc.snapshot.length > 0 && (cc.maxClaimablePerWallet === undefined || cc.maxClaimablePerWallet === \"unlimited\")) {\n            throw new Error(\"maxClaimablePerWallet must be set to a specific value when an allowlist is set.\\n\" + \"Example: Set it to 0 to only allow addresses in the allowlist to claim the amount specified in the allowlist.\\n\" + \"contract.claimConditions.set([{ snapshot: [{ address: '0x...', maxClaimable: 1 }], maxClaimablePerWallet: 0 }])\");\n          }\n          if (cc.snapshot && cc.snapshot.length > 0 && cc.maxClaimablePerWallet?.toString() === \"0\" && cc.snapshot.map(s => {\n            if (typeof s === \"string\") {\n              return 0;\n            } else {\n              return Number(s.maxClaimable?.toString() || 0);\n            }\n          }).reduce((acc, current) => {\n            return acc + current;\n          }, 0) === 0) {\n            throw new Error(\"maxClaimablePerWallet is set to 0, and all addresses in the allowlist have max claimable 0. This means that no one can claim.\");\n          }\n        });\n      }\n\n      // process inputs\n      const {\n        snapshotInfos,\n        sortedConditions\n      } = await processClaimConditionInputs(claimConditionsProcessed, await _this.getTokenDecimals(), _this.contractWrapper.getProvider(), _this.storage, _this.getSnapshotFormatVersion());\n      const merkleInfo = {};\n      snapshotInfos.forEach(s => {\n        merkleInfo[s.merkleRoot] = s.snapshotUri;\n      });\n      const metadata = await _this.metadata.get();\n      const encoded = [];\n\n      // upload new merkle roots to snapshot URIs if updated\n      if (!deepEqual(metadata.merkle, merkleInfo)) {\n        const mergedMetadata = await _this.metadata.parseInputMetadata({\n          ...metadata,\n          merkle: merkleInfo\n        });\n        // using internal method to just upload, avoids one contract call\n        const contractURI = await _this.metadata._parseAndUploadMetadata(mergedMetadata);\n\n        // TODO (cc) we could write the merkle tree info on the claim condition metadata instead\n        // TODO (cc) but we still need to maintain the behavior here for older contracts\n        if (hasFunction(\"setContractURI\", _this.contractWrapper)) {\n          const contractEncoder = new ContractEncoder(_this.contractWrapper);\n          encoded.push(contractEncoder.encode(\"setContractURI\", [contractURI]));\n        } else {\n          throw new Error(\"Setting a merkle root requires implementing ContractMetadata in your contract to support storing a merkle root.\");\n        }\n      }\n      const cw = _this.contractWrapper;\n      const baseContractEncoder = new ContractEncoder(cw);\n      if (_this.isLegacySinglePhaseDrop(cw)) {\n        const contractEncoderLegacy = new ContractEncoder(cw);\n        encoded.push(contractEncoderLegacy.encode(\"setClaimConditions\", [abstractContractModelToLegacy(sortedConditions[0]), resetClaimEligibilityForAll]));\n      } else if (_this.isLegacyMultiPhaseDrop(cw)) {\n        encoded.push(baseContractEncoder.encode(\"setClaimConditions\", [sortedConditions.map(abstractContractModelToLegacy), resetClaimEligibilityForAll]));\n      } else if (_this.isNewSinglePhaseDrop(cw)) {\n        encoded.push(baseContractEncoder.encode(\"setClaimConditions\", [abstractContractModelToNew(sortedConditions[0]), resetClaimEligibilityForAll]));\n      } else if (_this.isNewMultiphaseDrop(cw)) {\n        encoded.push(baseContractEncoder.encode(\"setClaimConditions\", [sortedConditions.map(abstractContractModelToNew), resetClaimEligibilityForAll]));\n      } else {\n        throw new Error(\"Contract does not support claim conditions\");\n      }\n      if (hasFunction(\"multicall\", _this.contractWrapper)) {\n        return Transaction.fromContractWrapper({\n          contractWrapper: _this.contractWrapper,\n          method: \"multicall\",\n          args: [encoded]\n        });\n      }\n      throw new Error(\"Contract does not support multicall\");\n    };\n  })());\n\n  /**\n   * Update a single claim condition with new data.\n   *\n   * @param index - the index of the claim condition to update, as given by the index from the result of `getAll()`\n   * @param claimConditionInput - the new data to update, previous data will be retained\n   */\n  update = /* @__PURE__ */buildTransactionFunction(async (index, claimConditionInput) => {\n    const existingConditions = await this.getAll();\n    const newConditionInputs = await updateExistingClaimConditions(index, claimConditionInput, existingConditions);\n    return await this.set.prepare(newConditionInputs);\n  });\n\n  /** ***************************************\n   * PRIVATE FUNCTIONS\n   *****************************************/\n\n  async getTokenDecimals() {\n    if (detectContractFeature(this.contractWrapper, \"ERC20\")) {\n      return this.contractWrapper.read(\"decimals\", []);\n    } else {\n      return Promise.resolve(0);\n    }\n  }\n\n  /**\n   * Returns proofs and the overrides required for the transaction.\n   *\n   * @returns - `overrides` and `proofs` as an object.\n   * @internal\n   */\n  async prepareClaim(quantity, checkERC20Allowance) {\n    let decimals = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let address = arguments.length > 3 ? arguments[3] : undefined;\n    const addressToClaim = address ? address : await this.contractWrapper.getSignerAddress();\n    return prepareClaim(addressToClaim, quantity, await this.getActive(), async () => (await this.metadata.get()).merkle, decimals, this.contractWrapper, this.storage, checkERC20Allowance, this.getSnapshotFormatVersion());\n  }\n  async getClaimArguments(destinationAddress, quantity, claimVerification) {\n    const resolvedAddress = await resolveAddress(destinationAddress);\n    if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {\n      return [resolvedAddress, quantity, claimVerification.currencyAddress, claimVerification.price, claimVerification.proofs, claimVerification.maxClaimable];\n    } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {\n      return [resolvedAddress, quantity, claimVerification.currencyAddress, claimVerification.price, {\n        proof: claimVerification.proofs,\n        maxQuantityInAllowlist: claimVerification.maxClaimable\n      }, utils.toUtf8Bytes(\"\")];\n    }\n    return [resolvedAddress, quantity, claimVerification.currencyAddress, claimVerification.price, {\n      proof: claimVerification.proofs,\n      quantityLimitPerWallet: claimVerification.maxClaimable,\n      pricePerToken: claimVerification.priceInProof,\n      currency: claimVerification.currencyAddressInProof\n    }, utils.toUtf8Bytes(\"\")];\n  }\n\n  /**\n   * Construct a claim transaction without executing it.\n   * This is useful for estimating the gas cost of a claim transaction, overriding transaction options and having fine grained control over the transaction execution.\n   * @param destinationAddress\n   * @param quantity\n   * @param options\n   *\n   * @deprecated Use `contract.erc721.claim.prepare(...args)` instead\n   */\n  async getClaimTransaction(destinationAddress, quantity, options) {\n    // TODO: Transaction Sequence Pattern\n    if (options?.pricePerToken) {\n      throw new Error(\"Price per token is be set via claim conditions by calling `contract.erc721.claimConditions.set()`\");\n    }\n    const claimVerification = await this.prepareClaim(quantity, options?.checkERC20Allowance === undefined ? true : options.checkERC20Allowance, await this.getTokenDecimals());\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"claim\",\n      args: await this.getClaimArguments(destinationAddress, quantity, claimVerification),\n      overrides: claimVerification.overrides\n    });\n  }\n  isNewSinglePhaseDrop(contractWrapper) {\n    return detectContractFeature(contractWrapper, \"ERC721ClaimConditionsV2\") || detectContractFeature(contractWrapper, \"ERC20ClaimConditionsV2\");\n  }\n  isNewMultiphaseDrop(contractWrapper) {\n    return detectContractFeature(contractWrapper, \"ERC721ClaimPhasesV2\") || detectContractFeature(contractWrapper, \"ERC20ClaimPhasesV2\");\n  }\n  isLegacySinglePhaseDrop(contractWrapper) {\n    return detectContractFeature(contractWrapper, \"ERC721ClaimConditionsV1\") || detectContractFeature(contractWrapper, \"ERC20ClaimConditionsV1\");\n  }\n  isLegacyMultiPhaseDrop(contractWrapper) {\n    return detectContractFeature(contractWrapper, \"ERC721ClaimPhasesV1\") || detectContractFeature(contractWrapper, \"ERC20ClaimPhasesV1\");\n  }\n  getSnapshotFormatVersion() {\n    return this.isLegacyMultiPhaseDrop(this.contractWrapper) || this.isLegacySinglePhaseDrop(this.contractWrapper) ? SnapshotFormatVersion.V1 : SnapshotFormatVersion.V2;\n  }\n}\n\n/**\n * Manages claim conditions for Edition Drop contracts\n * @public\n */\nclass DropErc1155ClaimConditions {\n  constructor(contractWrapper, metadata, storage) {\n    this.storage = storage;\n    this.contractWrapper = contractWrapper;\n    this.metadata = metadata;\n  }\n\n  /** ***************************************\n   * READ FUNCTIONS\n   *****************************************/\n\n  /**\n   * Get the currently active claim condition\n   *\n   * @returns the claim condition metadata\n   */\n  async getActive(tokenId, options) {\n    const mc = await this.get(tokenId);\n    const metadata = await this.metadata.get();\n    return await transformResultToClaimCondition(mc, 0, this.contractWrapper.getProvider(), metadata.merkle, this.storage, options?.withAllowList || false);\n  }\n  async get(tokenId, conditionId) {\n    if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {\n      const contractModel = await this.contractWrapper.read(\"claimCondition\", [tokenId]);\n      return legacyContractModelToAbstract(contractModel);\n    } else if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {\n      const id = conditionId !== undefined ? conditionId : await this.contractWrapper.read(\"getActiveClaimConditionId\", [tokenId]);\n      const contractModel = await this.contractWrapper.read(\"getClaimConditionById\", [tokenId, id]);\n      return legacyContractModelToAbstract(contractModel);\n    } else if (this.isNewSinglePhaseDrop(this.contractWrapper)) {\n      const contractModel = await this.contractWrapper.read(\"claimCondition\", [tokenId]);\n      return newContractModelToAbstract(contractModel);\n    } else if (this.isNewMultiphaseDrop(this.contractWrapper)) {\n      const id = conditionId !== undefined ? conditionId : await this.contractWrapper.read(\"getActiveClaimConditionId\", [tokenId]);\n      const contractModel = await this.contractWrapper.read(\"getClaimConditionById\", [tokenId, id]);\n      return newContractModelToAbstract(contractModel);\n    } else {\n      throw new Error(\"Contract does not support claim conditions\");\n    }\n  }\n\n  /**\n   * Get all the claim conditions\n   *\n   * @returns the claim conditions metadata\n   */\n  async getAll(tokenId, options) {\n    if (this.isLegacyMultiPhaseDrop(this.contractWrapper) || this.isNewMultiphaseDrop(this.contractWrapper)) {\n      const claimCondition = await this.contractWrapper.read(\"claimCondition\", [tokenId]);\n      const startId = claimCondition.currentStartId.toNumber();\n      const count = claimCondition.count.toNumber();\n      const conditions = [];\n      for (let i = startId; i < startId + count; i++) {\n        conditions.push(await this.get(tokenId, i));\n      }\n      const metadata = await this.metadata.get();\n      return Promise.all(conditions.map(c => transformResultToClaimCondition(c, 0, this.contractWrapper.getProvider(), metadata.merkle, this.storage, options?.withAllowList || false)));\n    } else {\n      return [await this.getActive(tokenId, options)];\n    }\n  }\n\n  /**\n   * Can Claim\n   *\n   * @remarks Check if a particular NFT can currently be claimed by a given user.\n   *\n   * @example\n   * ```javascript\n   * // Quantity of tokens to check claimability of\n   * const quantity = 1;\n   * const canClaim = await contract.canClaim(quantity);\n   * ```\n   */\n  async canClaim(tokenId, quantity, addressToCheck) {\n    // TODO switch to use verifyClaim\n    if (addressToCheck) {\n      addressToCheck = await resolveAddress(addressToCheck);\n    }\n    return (await this.getClaimIneligibilityReasons(tokenId, quantity, addressToCheck)).length === 0;\n  }\n\n  /**\n   * For any claim conditions that a particular wallet is violating,\n   * this function returns human-readable information about the\n   * breaks in the condition that can be used to inform the user.\n   *\n   * @param tokenId - the token id to check\n   * @param quantity - The desired quantity that would be claimed.\n   * @param addressToCheck - The wallet address, defaults to the connected wallet.\n   *\n   */\n  async getClaimIneligibilityReasons(tokenId, quantity, addressToCheck) {\n    const reasons = [];\n    let activeConditionIndex;\n    let claimCondition;\n    if (addressToCheck === undefined) {\n      try {\n        addressToCheck = await this.contractWrapper.getSignerAddress();\n      } catch (err) {\n        console.warn(\"failed to get signer address\", err);\n      }\n    }\n\n    // if we have been unable to get a signer address, we can't check eligibility, so return a NoWallet error reason\n    if (!addressToCheck) {\n      return [ClaimEligibility.NoWallet];\n    }\n    const resolvedAddress = await resolveAddress(addressToCheck);\n    try {\n      claimCondition = await this.getActive(tokenId);\n    } catch (err) {\n      if (includesErrorMessage(err, \"!CONDITION\") || includesErrorMessage(err, \"no active mint condition\")) {\n        reasons.push(ClaimEligibility.NoClaimConditionSet);\n        return reasons;\n      }\n      reasons.push(ClaimEligibility.Unknown);\n      return reasons;\n    }\n    if (claimCondition.availableSupply !== \"unlimited\") {\n      if (BigNumber.from(claimCondition.availableSupply).lt(quantity)) {\n        reasons.push(ClaimEligibility.NotEnoughSupply);\n        return reasons;\n      }\n    }\n\n    // check for merkle root inclusion\n    const merkleRootArray = utils.stripZeros(claimCondition.merkleRootHash);\n    const hasAllowList = merkleRootArray.length > 0;\n    let allowListEntry = null;\n    if (hasAllowList) {\n      allowListEntry = await this.getClaimerProofs(tokenId, resolvedAddress);\n      if (!allowListEntry && (this.isLegacySinglePhaseDrop(this.contractWrapper) || this.isLegacyMultiPhaseDrop(this.contractWrapper))) {\n        // exclusive allowlist behavior\n        reasons.push(ClaimEligibility.AddressNotAllowed);\n        return reasons;\n      }\n      if (allowListEntry) {\n        try {\n          const claimVerification = await this.prepareClaim(tokenId, quantity, false, resolvedAddress);\n          let validMerkleProof;\n          if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {\n            activeConditionIndex = await this.contractWrapper.read(\"getActiveClaimConditionId\", [tokenId]);\n            // legacy verifyClaimerMerkleProofs function\n            [validMerkleProof] = await this.contractWrapper.read(\"verifyClaimMerkleProof\", [activeConditionIndex, resolvedAddress, tokenId, quantity, claimVerification.proofs, claimVerification.maxClaimable]);\n            if (!validMerkleProof) {\n              reasons.push(ClaimEligibility.AddressNotAllowed);\n              return reasons;\n            }\n          } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {\n            [validMerkleProof] = await this.contractWrapper.read(\"verifyClaimMerkleProof\", [tokenId, resolvedAddress, quantity, {\n              proof: claimVerification.proofs,\n              maxQuantityInAllowlist: claimVerification.maxClaimable\n            }]);\n            if (!validMerkleProof) {\n              reasons.push(ClaimEligibility.AddressNotAllowed);\n              return reasons;\n            }\n          } else if (this.isNewSinglePhaseDrop(this.contractWrapper)) {\n            await this.contractWrapper.read(\"verifyClaim\", [tokenId, resolvedAddress, quantity, claimVerification.currencyAddress, claimVerification.price, {\n              proof: claimVerification.proofs,\n              quantityLimitPerWallet: claimVerification.maxClaimable,\n              currency: claimVerification.currencyAddressInProof,\n              pricePerToken: claimVerification.priceInProof\n            }]);\n          } else if (this.isNewMultiphaseDrop(this.contractWrapper)) {\n            activeConditionIndex = await this.contractWrapper.read(\"getActiveClaimConditionId\", [tokenId]);\n            await this.contractWrapper.read(\"verifyClaim\", [activeConditionIndex, resolvedAddress, tokenId, quantity, claimVerification.currencyAddress, claimVerification.price, {\n              proof: claimVerification.proofs,\n              quantityLimitPerWallet: claimVerification.maxClaimable,\n              currency: claimVerification.currencyAddressInProof,\n              pricePerToken: claimVerification.priceInProof\n            }]);\n          }\n        } catch (e) {\n          console.warn(\"Merkle proof verification failed:\", \"reason\" in e ? e.reason : e);\n          const reason = e.reason;\n          switch (reason) {\n            case \"!Qty\":\n              reasons.push(ClaimEligibility.OverMaxClaimablePerWallet);\n              break;\n            case \"!PriceOrCurrency\":\n              reasons.push(ClaimEligibility.WrongPriceOrCurrency);\n              break;\n            case \"!MaxSupply\":\n              reasons.push(ClaimEligibility.NotEnoughSupply);\n              break;\n            case \"cant claim yet\":\n              reasons.push(ClaimEligibility.ClaimPhaseNotStarted);\n              break;\n            default:\n              {\n                reasons.push(ClaimEligibility.AddressNotAllowed);\n                break;\n              }\n          }\n          return reasons;\n        }\n      }\n    }\n    if (this.isNewSinglePhaseDrop(this.contractWrapper) || this.isNewMultiphaseDrop(this.contractWrapper)) {\n      let claimedSupply = BigNumber.from(0);\n      let maxClaimable = convertQuantityToBigNumber(claimCondition.maxClaimablePerWallet, 0);\n      try {\n        claimedSupply = await this.getSupplyClaimedByWallet(tokenId, resolvedAddress);\n      } catch (e) {\n        // no-op\n      }\n      if (allowListEntry) {\n        maxClaimable = convertQuantityToBigNumber(allowListEntry.maxClaimable, 0);\n      }\n      if (maxClaimable.gt(0) && maxClaimable.lt(claimedSupply.add(quantity))) {\n        reasons.push(ClaimEligibility.OverMaxClaimablePerWallet);\n        return reasons;\n      }\n\n      // if there is no allowlist, or if there is an allowlist and the address is not in it\n      // if maxClaimable is 0, we consider it as the address is not allowed\n      if (!hasAllowList || hasAllowList && !allowListEntry) {\n        if (maxClaimable.lte(claimedSupply) || maxClaimable.eq(0)) {\n          reasons.push(ClaimEligibility.AddressNotAllowed);\n          return reasons;\n        }\n      }\n    }\n\n    // check for claim timestamp between claims\n    let [lastClaimedTimestamp, timestampForNextClaim] = [BigNumber.from(0), BigNumber.from(0)];\n    if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {\n      activeConditionIndex = await this.contractWrapper.read(\"getActiveClaimConditionId\", [tokenId]);\n      [lastClaimedTimestamp, timestampForNextClaim] = await this.contractWrapper.read(\"getClaimTimestamp\", [tokenId, activeConditionIndex, resolvedAddress]);\n    } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {\n      [lastClaimedTimestamp, timestampForNextClaim] = await this.contractWrapper.read(\"getClaimTimestamp\", [tokenId, resolvedAddress]);\n    }\n    const now = BigNumber.from(Date.now()).div(1000);\n    if (lastClaimedTimestamp.gt(0) && now.lt(timestampForNextClaim)) {\n      // contract will return MaxUint256 if user has already claimed and cannot claim again\n      if (timestampForNextClaim.eq(constants.MaxUint256)) {\n        reasons.push(ClaimEligibility.AlreadyClaimed);\n      } else {\n        reasons.push(ClaimEligibility.WaitBeforeNextClaimTransaction);\n      }\n      return reasons;\n    }\n\n    // if not within a browser conetext, check for wallet balance.\n    // In browser context, let the wallet do that job\n    if (claimCondition.price.gt(0) && isNode()) {\n      const totalPrice = claimCondition.price.mul(quantity);\n      const provider = this.contractWrapper.getProvider();\n      if (isNativeToken(claimCondition.currencyAddress)) {\n        const balance = await provider.getBalance(resolvedAddress);\n        if (balance.lt(totalPrice)) {\n          reasons.push(ClaimEligibility.NotEnoughTokens);\n        }\n      } else {\n        const erc20 = new ContractWrapper(provider, claimCondition.currencyAddress, ERC20Abi, {}, this.storage);\n        const balance = await erc20.read(\"balanceOf\", [resolvedAddress]);\n        if (balance.lt(totalPrice)) {\n          reasons.push(ClaimEligibility.NotEnoughTokens);\n        }\n      }\n    }\n    return reasons;\n  }\n\n  /**\n   * Returns allow list information and merkle proofs for the given address.\n   * @param tokenId - the token ID to check\n   * @param claimerAddress - the claimer address\n   * @param claimConditionId - optional the claim condition id to get the proofs for\n   */\n  async getClaimerProofs(tokenId, claimerAddress, claimConditionId) {\n    const claimCondition = await this.get(tokenId, claimConditionId);\n    const merkleRoot = claimCondition.merkleRoot;\n    const merkleRootArray = utils.stripZeros(merkleRoot);\n    if (merkleRootArray.length > 0) {\n      const metadata = await this.metadata.get();\n      const resolvedAddress = await resolveAddress(claimerAddress);\n      return await fetchSnapshotEntryForAddress(resolvedAddress, merkleRoot.toString(), metadata.merkle, this.contractWrapper.getProvider(), this.storage, this.getSnapshotFormatVersion());\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Get the total supply claimed by a specific wallet\n   * @param walletAddress the wallet address to check\n   * @returns the total supply claimed\n   */\n  async getSupplyClaimedByWallet(tokenId, walletAddress) {\n    const resolvedAddress = await resolveAddress(walletAddress);\n    if (this.isNewSinglePhaseDrop(this.contractWrapper)) {\n      return await this.contractWrapper.read(\"getSupplyClaimedByWallet\", [tokenId, resolvedAddress]);\n    }\n    if (this.isNewMultiphaseDrop(this.contractWrapper)) {\n      const activeClaimConditionId = await this.contractWrapper.read(\"getActiveClaimConditionId\", [tokenId]);\n      return await this.contractWrapper.read(\"getSupplyClaimedByWallet\", [tokenId, activeClaimConditionId, resolvedAddress]);\n    }\n    throw new Error(\"This contract does not support the getSupplyClaimedByWallet function\");\n  }\n\n  /** ***************************************\n   * WRITE FUNCTIONS\n   *****************************************/\n\n  /**\n   * Set claim conditions on a single NFT\n   *\n   * @remarks Sets the public mint conditions that need to be fulfilled by users to claim a particular NFT in this contract.\n   *\n   * @example\n   * ```javascript\n   * const presaleStartTime = new Date();\n   * const publicSaleStartTime = new Date(Date.now() + 60 * 60 * 24 * 1000);\n   *\n   * // Optionally specify addresses that can claim\n   * const snapshots = ['0x...', '0x...']\n   *\n   * // Or alternatively, you can pass snapshots with the max number of NFTs each address can claim\n   * // const snapshots = [{ address: '0x...', maxClaimable: 1 }, { address: '0x...', maxClaimable: 2 }]\n   *\n   * const claimConditions = [\n   *   {\n   *     startTime: presaleStartTime, // start the presale now\n   *     maxClaimableSupply: 2, // limit how many mints for this presale\n   *     price: 0.01, // presale price\n   *     snapshot: snapshots, // limit minting to only certain addresses\n   *   },\n   *   {\n   *     startTime: publicSaleStartTime, // 24h after presale, start public sale\n   *     price: 0.08, // public sale price\n   *   }\n   * ]);\n   *\n   * const tokenId = 0; // the id of the NFT to set claim conditions on\n   * await dropContract.claimConditions.set(tokenId, claimConditions);\n   * ```\n   *\n   * @param tokenId - The id of the NFT to set the claim conditions on\n   * @param claimConditionInputs - The claim conditions\n   * @param resetClaimEligibilityForAll - Whether to reset the state of who already claimed NFTs previously\n   */\n  set = /* @__PURE__ */buildTransactionFunction((() => {\n    var _this = this;\n    return async function (tokenId, claimConditionInputs) {\n      let resetClaimEligibilityForAll = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      return _this.setBatch.prepare([{\n        tokenId,\n        claimConditions: claimConditionInputs\n      }], resetClaimEligibilityForAll);\n    };\n  })());\n\n  /**\n   * Set claim conditions on multiple NFTs at once\n   *\n   * @remarks Sets the claim conditions that need to be fulfilled by users to claim the given NFTs in this contract.\n   *\n   * @example\n   * ```javascript\n   * const claimConditionsForTokens = [\n   *   {\n   *     tokenId: 0,\n   *     claimConditions: [{\n   *       startTime: new Date(), // start the claim phase now\n   *       maxClaimableSupply: 2, // limit how many mints for this tokenId\n   *       price: 0.01, // price for this tokenId\n   *       snapshot: ['0x...', '0x...'], // limit minting to only certain addresses\n   *     }]\n   *   },\n   *   {\n   *     tokenId: 1,\n   *     claimConditions: [{\n   *       startTime: new Date(),\n   *       price: 0.08, // different price for this tokenId\n   *     }]\n   *   },\n   * ];\n   *\n   * await dropContract.claimConditions.setBatch(claimConditionsForTokens);\n   * ```\n   *\n   * @param claimConditionsForToken - The claim conditions for each NFT\n   * @param resetClaimEligibilityForAll - Whether to reset the state of who already claimed NFTs previously\n   */\n  setBatch = /* @__PURE__ */buildTransactionFunction((() => {\n    var _this2 = this;\n    return async function (claimConditionsForToken) {\n      let resetClaimEligibilityForAll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      const merkleInfo = {};\n      const processedClaimConditions = await Promise.all(claimConditionsForToken.map(async _ref => {\n        let {\n          tokenId,\n          claimConditions\n        } = _ref;\n        // sanitize for single phase deletions\n        let claimConditionsProcessed = claimConditions;\n        if (_this2.isLegacySinglePhaseDrop(_this2.contractWrapper)) {\n          resetClaimEligibilityForAll = true;\n          if (claimConditions.length === 0) {\n            claimConditionsProcessed = [{\n              startTime: new Date(0),\n              currencyAddress: constants.AddressZero,\n              price: 0,\n              maxClaimableSupply: 0,\n              maxClaimablePerWallet: 0,\n              waitInSeconds: 0,\n              merkleRootHash: utils.hexZeroPad([0], 32),\n              snapshot: []\n            }];\n          } else if (claimConditions.length > 1) {\n            throw new Error(\"Single phase drop contract cannot have multiple claim conditions, only one is allowed\");\n          }\n        }\n        // if using new snapshot format, make sure that maxClaimablePerWallet is set if allowlist is set as well\n        if (_this2.isNewSinglePhaseDrop(_this2.contractWrapper) || _this2.isNewMultiphaseDrop(_this2.contractWrapper)) {\n          claimConditionsProcessed.forEach(cc => {\n            if (cc.snapshot && cc.snapshot.length > 0 && (cc.maxClaimablePerWallet === undefined || cc.maxClaimablePerWallet === \"unlimited\")) {\n              throw new Error(\"maxClaimablePerWallet must be set to a specific value when an allowlist is set.\\n\" + \"Set it to 0 to only allow addresses in the allowlist to claim the amount specified in the allowlist.\" + \"\\n\\nex:\\n\" + \"contract.claimConditions.set(tokenId, [{ snapshot: [{ address: '0x...', maxClaimable: 1 }], maxClaimablePerWallet: 0 }])\");\n            }\n            if (cc.snapshot && cc.snapshot.length > 0 && cc.maxClaimablePerWallet?.toString() === \"0\" && cc.snapshot.map(s => {\n              if (typeof s === \"string\") {\n                return 0;\n              } else {\n                return Number(s.maxClaimable?.toString() || 0);\n              }\n            }).reduce((acc, current) => {\n              return acc + current;\n            }, 0) === 0) {\n              throw new Error(\"maxClaimablePerWallet is set to 0, and all addresses in the allowlist have max claimable 0. This means that no one can claim.\");\n            }\n          });\n        }\n        // process inputs\n        const {\n          snapshotInfos,\n          sortedConditions\n        } = await processClaimConditionInputs(claimConditionsProcessed, 0, _this2.contractWrapper.getProvider(), _this2.storage, _this2.getSnapshotFormatVersion());\n        snapshotInfos.forEach(s => {\n          merkleInfo[s.merkleRoot] = s.snapshotUri;\n        });\n        return {\n          tokenId,\n          sortedConditions\n        };\n      }));\n      const metadata = await _this2.metadata.get();\n      const encoded = [];\n\n      // keep the old merkle roots from other tokenIds\n      for (const key of Object.keys(metadata.merkle || {})) {\n        merkleInfo[key] = metadata.merkle[key];\n      }\n\n      // upload new merkle roots to snapshot URIs if updated\n      if (!deepEqual(metadata.merkle, merkleInfo)) {\n        const mergedMetadata = await _this2.metadata.parseInputMetadata({\n          ...metadata,\n          merkle: merkleInfo\n        });\n        // using internal method to just upload, avoids one contract call\n        const contractURI = await _this2.metadata._parseAndUploadMetadata(mergedMetadata);\n        if (hasFunction(\"setContractURI\", _this2.contractWrapper)) {\n          const contractEncoder = new ContractEncoder(_this2.contractWrapper);\n          encoded.push(contractEncoder.encode(\"setContractURI\", [contractURI]));\n        } else {\n          throw new Error(\"Setting a merkle root requires implementing ContractMetadata in your contract to support storing a merkle root.\");\n        }\n      }\n      processedClaimConditions.forEach(_ref2 => {\n        let {\n          tokenId,\n          sortedConditions\n        } = _ref2;\n        const baseContractEncoder = new ContractEncoder(_this2.contractWrapper);\n        if (_this2.isLegacySinglePhaseDrop(_this2.contractWrapper)) {\n          const legacyContractEncoder = new ContractEncoder(_this2.contractWrapper);\n          encoded.push(legacyContractEncoder.encode(\"setClaimConditions\", [tokenId, abstractContractModelToLegacy(sortedConditions[0]), resetClaimEligibilityForAll]));\n        } else if (_this2.isLegacyMultiPhaseDrop(_this2.contractWrapper)) {\n          encoded.push(baseContractEncoder.encode(\"setClaimConditions\", [tokenId, sortedConditions.map(abstractContractModelToLegacy), resetClaimEligibilityForAll]));\n        } else if (_this2.isNewSinglePhaseDrop(_this2.contractWrapper)) {\n          encoded.push(baseContractEncoder.encode(\"setClaimConditions\", [tokenId, abstractContractModelToNew(sortedConditions[0]), resetClaimEligibilityForAll]));\n        } else if (_this2.isNewMultiphaseDrop(_this2.contractWrapper)) {\n          encoded.push(baseContractEncoder.encode(\"setClaimConditions\", [tokenId, sortedConditions.map(abstractContractModelToNew), resetClaimEligibilityForAll]));\n        } else {\n          throw new Error(\"Contract does not support claim conditions\");\n        }\n      });\n      if (hasFunction(\"multicall\", _this2.contractWrapper)) {\n        return Transaction.fromContractWrapper({\n          contractWrapper: _this2.contractWrapper,\n          method: \"multicall\",\n          args: [encoded]\n        });\n      }\n      throw new Error(\"Contract does not support multicall\");\n    };\n  })());\n\n  /**\n   * Update a single claim condition with new data.\n   * @param tokenId - the token id to update\n   * @param index - the index of the claim condition to update, as given by the index from the result of `getAll()`\n   * @param claimConditionInput - the new data to update, previous data will be retained\n   */\n  update = /* @__PURE__ */buildTransactionFunction(async (tokenId, index, claimConditionInput) => {\n    const existingConditions = await this.getAll(tokenId);\n    const newConditionInputs = await updateExistingClaimConditions(index, claimConditionInput, existingConditions);\n    return await this.set.prepare(tokenId, newConditionInputs);\n  });\n\n  /**\n   * Returns proofs and the overrides required for the transaction.\n   *\n   * @returns - `overrides` and `proofs` as an object.\n   */\n  async prepareClaim(tokenId, quantity, checkERC20Allowance, address) {\n    const addressToClaim = await resolveAddress(address ? address : await this.contractWrapper.getSignerAddress());\n    return prepareClaim(addressToClaim, quantity, await this.getActive(tokenId), async () => (await this.metadata.get()).merkle, 0, this.contractWrapper, this.storage, checkERC20Allowance, this.getSnapshotFormatVersion());\n  }\n  async getClaimArguments(tokenId, destinationAddress, quantity, claimVerification) {\n    const resolvedAddress = await resolveAddress(destinationAddress);\n    if (this.isLegacyMultiPhaseDrop(this.contractWrapper)) {\n      return [resolvedAddress, tokenId, quantity, claimVerification.currencyAddress, claimVerification.price, claimVerification.proofs, claimVerification.maxClaimable];\n    } else if (this.isLegacySinglePhaseDrop(this.contractWrapper)) {\n      return [resolvedAddress, tokenId, quantity, claimVerification.currencyAddress, claimVerification.price, {\n        proof: claimVerification.proofs,\n        maxQuantityInAllowlist: claimVerification.maxClaimable\n      }, utils.toUtf8Bytes(\"\")];\n    }\n    return [resolvedAddress, tokenId, quantity, claimVerification.currencyAddress, claimVerification.price, {\n      proof: claimVerification.proofs,\n      quantityLimitPerWallet: claimVerification.maxClaimable,\n      pricePerToken: claimVerification.priceInProof,\n      currency: claimVerification.currencyAddressInProof\n    }, utils.toUtf8Bytes(\"\")];\n  }\n\n  /**\n   * Construct a claim transaction without executing it.\n   * This is useful for estimating the gas cost of a claim transaction, overriding transaction options and having fine grained control over the transaction execution.\n   * @param destinationAddress - Address you want to send the token to\n   * @param tokenId - Id of the token you want to claim\n   * @param quantity - Quantity of the tokens you want to claim\n   *\n   * @deprecated Use `contract.erc1155.claim.prepare(...args)` instead\n   */\n  async getClaimTransaction(destinationAddress, tokenId, quantity, options) {\n    if (options?.pricePerToken) {\n      throw new Error(\"Price per token should be set via claim conditions by calling `contract.erc1155.claimConditions.set()`\");\n    }\n    const claimVerification = await this.prepareClaim(tokenId, quantity, options?.checkERC20Allowance || true);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"claim\",\n      args: await this.getClaimArguments(tokenId, destinationAddress, quantity, claimVerification),\n      overrides: claimVerification.overrides\n    });\n  }\n  isNewSinglePhaseDrop(contractWrapper) {\n    return detectContractFeature(contractWrapper, \"ERC1155ClaimConditionsV2\");\n  }\n  isNewMultiphaseDrop(contractWrapper) {\n    return detectContractFeature(contractWrapper, \"ERC1155ClaimPhasesV2\");\n  }\n  isLegacySinglePhaseDrop(contractWrapper) {\n    return detectContractFeature(contractWrapper, \"ERC1155ClaimConditionsV1\");\n  }\n  isLegacyMultiPhaseDrop(contractWrapper) {\n    return detectContractFeature(contractWrapper, \"ERC1155ClaimPhasesV1\");\n  }\n  getSnapshotFormatVersion() {\n    return this.isLegacyMultiPhaseDrop(this.contractWrapper) || this.isLegacySinglePhaseDrop(this.contractWrapper) ? SnapshotFormatVersion.V1 : SnapshotFormatVersion.V2;\n  }\n}\n\n/**\n * Mint Many ERC20 Tokens at once\n * @remarks Token batch minting functionality that handles unit parsing for you.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * await contract.token.mint.batch.to(walletAddress, [nftMetadata1, nftMetadata2, ...]);\n * ```\n * @public\n */\n\nclass Erc20BatchMintable {\n  featureName = FEATURE_TOKEN_BATCH_MINTABLE.name;\n  constructor(erc20, contractWrapper) {\n    this.erc20 = erc20;\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * Mint Tokens To Many Wallets\n   *\n   * @remarks Mint tokens to many wallets in one transaction.\n   *\n   * @example\n   * ```javascript\n   * // Data of the tokens you want to mint\n   * const data = [\n   *   {\n   *     toAddress: \"{{wallet_address}}\", // Address to mint tokens to\n   *     amount: 0.2, // How many tokens to mint to specified address\n   *   },\n   *  {\n   *    toAddress: \"0x...\",\n   *    amount: 1.4,\n   *  }\n   * ]\n   *\n   * await contract.token.mint.batch(data);\n   * ```\n   */\n  to = /* @__PURE__ */buildTransactionFunction(async args => {\n    const encoded = [];\n    const contractEncoder = new ContractEncoder(this.contractWrapper);\n    for (const arg of args) {\n      encoded.push(contractEncoder.encode(\"mintTo\", [await resolveAddress(arg.toAddress), await this.erc20.normalizeAmount(arg.amount)]));\n    }\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"multicall\",\n      args: [encoded]\n    });\n  });\n}\n\nclass Erc20Burnable {\n  featureName = FEATURE_TOKEN_BURNABLE.name;\n  constructor(erc20, contractWrapper) {\n    this.erc20 = erc20;\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * Burn Tokens\n   *\n   * @remarks Burn tokens held by the connected wallet\n   *\n   * @example\n   * ```javascript\n   * // The amount of this token you want to burn\n   * const amount = 1.2;\n   *\n   * await contract.token.burn.tokens(amount);\n   * ```\n   */\n  tokens = /* @__PURE__ */buildTransactionFunction(async amount => {\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"burn\",\n      args: [await this.erc20.normalizeAmount(amount)]\n    });\n  });\n\n  /**\n   * Burn Tokens\n   *\n   * @remarks Burn tokens held by the specified wallet\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet sending the tokens\n   * const holderAddress = \"{{wallet_address}}\";\n   *\n   * // The amount of this token you want to burn\n   * const amount = 1.2;\n   *\n   * await contract.token.burn.from(holderAddress, amount);\n   * ```\n   */\n  from = /* @__PURE__ */buildTransactionFunction(async (holder, amount) => {\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"burnFrom\",\n      args: [await resolveAddress(holder), await this.erc20.normalizeAmount(amount)]\n    });\n  });\n}\n\n/**\n * Configure and claim ERC20 tokens\n * @remarks Manage claim phases and claim ERC20 tokens that have been lazily minted.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * await contract.token.drop.claim.to(\"0x...\", quantity);\n * ```\n */\n\nclass Erc20ClaimableWithConditions {\n  featureName = FEATURE_TOKEN_CLAIM_CONDITIONS_V2.name;\n  /**\n   * Configure claim conditions\n   * @remarks Define who can claim NFTs in the collection, when and how many.\n   * @example\n   * ```javascript\n   * const presaleStartTime = new Date();\n   * const publicSaleStartTime = new Date(Date.now() + 60 * 60 * 24 * 1000);\n   * const claimConditions = [\n   *   {\n   *     startTime: presaleStartTime, // start the presale now\n   *     maxClaimableSupply: 2, // limit how many mints for this presale\n   *     price: 0.01, // presale price\n   *     snapshot: ['0x...', '0x...'], // limit minting to only certain addresses\n   *   },\n   *   {\n   *     startTime: publicSaleStartTime, // 24h after presale, start public sale\n   *     price: 0.08, // public sale price\n   *   }\n   * ]);\n   * await contract.token.drop.claim.conditions.set(claimConditions);\n   * ```\n   */\n\n  constructor(erc20, contractWrapper, storage) {\n    this.erc20 = erc20;\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n    const metadata = new ContractMetadata(this.contractWrapper, CustomContractSchema, this.storage);\n    this.conditions = new DropClaimConditions(this.contractWrapper, metadata, this.storage);\n  }\n\n  /**\n   * Claim a certain amount of tokens to a specific Wallet\n   *\n   * @remarks Let the specified wallet claim Tokens.\n   *\n   * @example\n   * ```javascript\n   * const address = \"{{wallet_address}}\"; // address of the wallet you want to claim the NFTs\n   * const quantity = 42.69; // how many tokens you want to claim\n   *\n   * const tx = await contract.token.drop.claim.to(address, quantity);\n   * const receipt = tx.receipt; // the transaction receipt\n   * ```\n   *\n   * @param destinationAddress - Address you want to send the token to\n   * @param amount - Quantity of the tokens you want to claim\n   * @param checkERC20Allowance - Optional, check if the wallet has enough ERC20 allowance to claim the tokens, and if not, approve the transfer\n   * @param claimData\n   * @returns - The transaction receipt\n   */\n  to = /* @__PURE__ */buildTransactionFunction(async (destinationAddress, amount, options) => {\n    const quantity = await this.erc20.normalizeAmount(amount);\n    return await this.conditions.getClaimTransaction(destinationAddress, quantity, options);\n  });\n}\n\n/**\n * Configure and claim ERC20 tokens\n * @remarks Manage claim phases and claim ERC20 tokens that have been lazily minted.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * await contract.token.drop.claim.to(\"0x...\", quantity);\n * ```\n */\n\nclass Erc20Droppable {\n  /**\n   * Configure claim conditions\n   * @remarks Define who can claim NFTs in the collection, when and how many.\n   * @example\n   * ```javascript\n   * const presaleStartTime = new Date();\n   * const publicSaleStartTime = new Date(Date.now() + 60 * 60 * 24 * 1000);\n   * const claimConditions = [\n   *   {\n   *     startTime: presaleStartTime, // start the presale now\n   *     maxClaimableSupply: 2, // limit how many mints for this presale\n   *     price: 0.01, // presale price\n   *     snapshot: ['0x...', '0x...'], // limit minting to only certain addresses\n   *   },\n   *   {\n   *     startTime: publicSaleStartTime, // 24h after presale, start public sale\n   *     price: 0.08, // public sale price\n   *   }\n   * ]);\n   * await contract.nft.drop.claim.conditions.set(claimConditions);\n   * ```\n   */\n\n  constructor(erc20, contractWrapper, storage) {\n    this.erc20 = erc20;\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n    this.claim = new Erc20ClaimableWithConditions(this.erc20, this.contractWrapper, this.storage);\n  }\n}\n\n/**\n * Mint ERC20 Tokens\n * @remarks Token minting functionality that handles unit parsing for you.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * await contract.nft.mint.to(walletAddress, nftMetadata);\n * ```\n * @public\n */\n\nclass Erc20Mintable {\n  featureName = FEATURE_TOKEN_MINTABLE.name;\n\n  /**\n   * Batch mint Tokens to many addresses\n   */\n\n  constructor(erc20, contractWrapper) {\n    this.erc20 = erc20;\n    this.contractWrapper = contractWrapper;\n    this.batch = this.detectErc20BatchMintable();\n  }\n\n  /**\n   * Mint Tokens\n   *\n   * @remarks Mint tokens to a specified address.\n   *\n   * @example\n   * ```javascript\n   * const toAddress = \"{{wallet_address}}\"; // Address of the wallet you want to mint the tokens to\n   * const amount = \"1.5\"; // The amount of this token you want to mint\n   * await contract.token.mint.to(toAddress, amount);\n   * ```\n   */\n  to = /* @__PURE__ */buildTransactionFunction(async (to, amount) => {\n    return await this.getMintTransaction(to, amount);\n  });\n\n  /**\n   * @deprecated Use `contract.erc20.mint.prepare(...args)` instead\n   */\n  async getMintTransaction(to, amount) {\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"mintTo\",\n      args: [await resolveAddress(to), await this.erc20.normalizeAmount(amount)]\n    });\n  }\n  detectErc20BatchMintable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC20BatchMintable\")) {\n      return new Erc20BatchMintable(this.erc20, this.contractWrapper);\n    }\n    return undefined;\n  }\n}\n\nasync function setErc20Allowance(contractToApprove, value, currencyAddress, overrides) {\n  if (isNativeToken(currencyAddress)) {\n    overrides[\"value\"] = value;\n  } else {\n    const signer = contractToApprove.getSigner();\n    const provider = contractToApprove.getProvider();\n    const erc20 = new ContractWrapper(signer || provider, currencyAddress, ERC20Abi, contractToApprove.options, contractToApprove.storage);\n    const owner = await contractToApprove.getSignerAddress();\n    const spender = contractToApprove.address;\n    const allowance = await erc20.read(\"allowance\", [owner, spender]);\n    if (allowance.lt(value)) {\n      // approve overrides the previous allowance, set it to the minimum required for this tx\n      await erc20.sendTransaction(\"approve\", [spender, value]);\n    }\n    return overrides;\n  }\n}\n\n/**\n * Enables generating ERC20 Tokens with rules and an associated signature, which can then be minted by anyone securely\n * @public\n */\n// TODO consolidate into a single class\n\nclass Erc20SignatureMintable {\n  featureName = FEATURE_TOKEN_SIGNATURE_MINTABLE.name;\n  constructor(contractWrapper, roles) {\n    this.contractWrapper = contractWrapper;\n    this.roles = roles;\n  }\n\n  /**\n   * Mint tokens from a signature\n   *\n   * @remarks Mint a certain amount of tokens from a previously generated signature.\n   *\n   * @example\n   * ```javascript\n   * // see how to craft a payload to sign in the `generate()` documentation\n   * const signedPayload = contract.erc20.signature.generate(payload);\n   *\n   * // Use the signed payload to mint the tokens\n   * const tx = contract.erc20.signature.mint(signedPayload);\n   * ```\n   * @param signedPayload - the previously generated payload and signature with {@link Erc20SignatureMintable.generate}\n   * @twfeature ERC20SignatureMintable\n   */\n  mint = /* @__PURE__ */buildTransactionFunction(async signedPayload => {\n    const mintRequest = signedPayload.payload;\n    const signature = signedPayload.signature;\n    const message = await this.mapPayloadToContractStruct(mintRequest);\n    const overrides = await this.contractWrapper.getCallOverrides();\n    // TODO: Transaction Sequence Pattern\n    await setErc20Allowance(this.contractWrapper, BigNumber.from(message.price), mintRequest.currencyAddress, overrides);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"mintWithSignature\",\n      args: [message, signature],\n      overrides\n    });\n  });\n\n  /**\n   * Mint any number of generated tokens signatures at once\n   * @remarks Mint multiple token signatures in one transaction. Note that this is only possible for free mints (cannot batch mints with a price attached to it for security reasons)\n   * @param signedPayloads - the array of signed payloads to mint\n   * @twfeature ERC20SignatureMintable\n   */\n  mintBatch = /* @__PURE__ */buildTransactionFunction(async signedPayloads => {\n    const contractPayloads = await Promise.all(signedPayloads.map(async s => {\n      const message = await this.mapPayloadToContractStruct(s.payload);\n      const signature = s.signature;\n      const price = s.payload.price;\n      if (BigNumber.from(price).gt(0)) {\n        throw new Error(\"Can only batch free mints. For mints with a price, use regular mint()\");\n      }\n      return {\n        message,\n        signature\n      };\n    }));\n    const contractEncoder = new ContractEncoder(this.contractWrapper);\n    const encoded = contractPayloads.map(p => {\n      return contractEncoder.encode(\"mintWithSignature\", [p.message, p.signature]);\n    });\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"multicall\",\n      args: [encoded]\n    });\n  });\n\n  /**\n   * Verify that a payload is correctly signed\n   * @param signedPayload - the payload to verify\n   * @twfeature ERC20SignatureMintable\n   *\n   * ```javascript\n   * const startTime = new Date();\n   * const endTime = new Date(Date.now() + 60 * 60 * 24 * 1000);\n   * const payload = {\n   *   quantity: 4.2, // The quantity of tokens to be minted\n   *   to: {{wallet_address}}, // Who will receive the tokens\n   *   price: 0.5, // the price to pay for minting those tokens\n   *   currencyAddress: NATIVE_TOKEN_ADDRESS, // the currency to pay with\n   *   mintStartTime: startTime, // can mint anytime from now\n   *   mintEndTime: endTime, // to 24h from now,\n   *   primarySaleRecipient: \"0x...\", // custom sale recipient for this token mint\n   * };\n   *\n   * const signedPayload = await contract.erc20.signature.generate(payload);\n   * // Now you can verify if the signed payload is valid\n   * const isValid = await contract.erc20.signature.verify(signedPayload);\n   * ```\n   */\n  async verify(signedPayload) {\n    const mintRequest = signedPayload.payload;\n    const signature = signedPayload.signature;\n    const message = await this.mapPayloadToContractStruct(mintRequest);\n    const verification = await this.contractWrapper.read(\"verify\", [message, signature]);\n    return verification[0];\n  }\n\n  /**\n   * Generate a signature that can be used to mint a certain amount of tokens\n   *\n   * @remarks Takes in a quantity of tokens, some conditions for how it can be minted and signs it with your private key. The generated signature can then be used to mint those tokens using the exact payload and signature generated.\n   *\n   * @example\n   * ```javascript\n   * const startTime = new Date();\n   * const endTime = new Date(Date.now() + 60 * 60 * 24 * 1000);\n   * const payload = {\n   *   quantity: 4.2, // The quantity of tokens to be minted\n   *   to: {{wallet_address}}, // Who will receive the tokens\n   *   price: 0.5, // the price to pay for minting those tokens\n   *   currencyAddress: NATIVE_TOKEN_ADDRESS, // the currency to pay with\n   *   mintStartTime: startTime, // can mint anytime from now\n   *   mintEndTime: endTime, // to 24h from now,\n   *   primarySaleRecipient: \"0x...\", // custom sale recipient for this token mint\n   * };\n   *\n   * const signedPayload = await contract.erc20.signature.generate(payload);\n   * // now anyone can use these to mint the NFT using `contract.erc20.signature.mint(signedPayload)`\n   * ```\n   * @param mintRequest - the payload to sign\n   * @returns the signed payload and the corresponding signature\n   * @twfeature ERC20SignatureMintable\n   */\n  async generate(mintRequest) {\n    return (await this.generateBatch([mintRequest]))[0];\n  }\n\n  /**\n   * Generate a batch of signatures that can be used to mint many token signatures.\n   *\n   * @remarks See {@link Erc20SignatureMintable.generate}\n   *\n   * @param payloadsToSign - the payloads to sign\n   * @returns an array of payloads and signatures\n   * @twfeature ERC20SignatureMintable\n   */\n  async generateBatch(payloadsToSign) {\n    await this.roles?.verify([\"minter\"], await this.contractWrapper.getSignerAddress());\n    const parsedRequests = await Promise.all(payloadsToSign.map(m => Signature20PayloadInput.parseAsync(m)));\n    const chainId = await this.contractWrapper.getChainID();\n    const signer = this.contractWrapper.getSigner();\n    invariant(signer, \"No signer available\");\n\n    // ERC20Permit (EIP-712) spec differs from signature mint 721, 1155.\n    const name = await this.contractWrapper.read(\"name\", []);\n    return await Promise.all(parsedRequests.map(async m => {\n      const finalPayload = await Signature20PayloadOutput.parseAsync(m);\n      const signature = await this.contractWrapper.signTypedData(signer, {\n        name,\n        version: \"1\",\n        chainId,\n        verifyingContract: this.contractWrapper.address\n      }, {\n        MintRequest: MintRequest20\n      }, await this.mapPayloadToContractStruct(finalPayload));\n      return {\n        payload: finalPayload,\n        signature: signature.toString()\n      };\n    }));\n  }\n\n  /** ******************************\n   * PRIVATE FUNCTIONS\n   *******************************/\n  /**\n   * Maps a payload to the format expected by the contract\n   *\n   * @internal\n   *\n   * @param mintRequest - The payload to map.\n   * @returns - The mapped payload.\n   */\n  async mapPayloadToContractStruct(mintRequest) {\n    const normalizedPrice = await normalizePriceValue(this.contractWrapper.getProvider(), mintRequest.price, mintRequest.currencyAddress);\n    const amountWithDecimals = utils.parseUnits(mintRequest.quantity, await this.contractWrapper.read(\"decimals\", []));\n    return {\n      to: mintRequest.to,\n      primarySaleRecipient: mintRequest.primarySaleRecipient,\n      quantity: amountWithDecimals,\n      price: normalizedPrice,\n      currency: mintRequest.currencyAddress,\n      validityEndTimestamp: mintRequest.mintEndTime,\n      validityStartTimestamp: mintRequest.mintStartTime,\n      uid: mintRequest.uid\n    };\n  }\n}\n\n/**\n * Checks whether the given DetectableFeature is defined\n * @internal\n * @param namespace The namespace to check\n * @param feature The corresponding feature\n */\nfunction assertEnabled(namespace, feature) {\n  if (!namespace) {\n    throw new ExtensionNotImplementedError(feature);\n  }\n  return namespace;\n}\n\nasync function normalizeAmount(contractWrapper, amount) {\n  const decimals = await contractWrapper.read(\"decimals\", []);\n  return utils.parseUnits(AmountSchema.parse(amount), decimals);\n}\n\n/**\n * Standard ERC20 Token functions\n * @remarks Basic functionality for a ERC20 contract that handles all unit transformation for you.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * await contract.erc20.transfer(walletAddress, amount);\n * ```\n * @public\n */\nclass Erc20 {\n  featureName = FEATURE_TOKEN.name;\n  /**\n   * Mint tokens\n   */\n\n  get chainId() {\n    return this._chainId;\n  }\n  constructor(contractWrapper, storage, chainId) {\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n    this.mintable = this.detectErc20Mintable();\n    this.burnable = this.detectErc20Burnable();\n    this.droppable = this.detectErc20Droppable();\n    this.signatureMintable = this.detectErc20SignatureMintable();\n    this._chainId = chainId;\n  }\n\n  /**\n   * @internal\n   */\n  onNetworkUpdated(network) {\n    this.contractWrapper.updateSignerOrProvider(network);\n  }\n\n  /**\n   * @internal\n   */\n  getAddress() {\n    return this.contractWrapper.address;\n  }\n\n  ////// Standard ERC20 Extension //////\n\n  /**\n   * Get the token metadata\n   * @remarks name, symbol, etc...\n   * @example\n   * ```javascript\n   * const token = await contract.erc20.get();\n   * ```\n   * @returns The token metadata\n   * @twfeature ERC20\n   */\n  async get() {\n    return await fetchCurrencyMetadata(this.contractWrapper.getProvider(), this.getAddress());\n  }\n\n  /**\n   * Get token balance for the currently connected wallet\n   *\n   * @remarks Get a wallets token balance.\n   *\n   * @example\n   * ```javascript\n   * const balance = await contract.erc20.balance();\n   * ```\n   *\n   * @returns The balance of a specific wallet.\n   * @twfeature ERC20\n   */\n  async balance() {\n    return await this.balanceOf(await this.contractWrapper.getSignerAddress());\n  }\n\n  /**\n   * Get token balance for a specific wallet\n   *\n   * @remarks Get a wallets token balance.\n   *\n   * @example\n   * ```javascript\n   * const walletAddress = \"{{wallet_address}}\";\n   * const balance = await contract.erc20.balanceOf(walletAddress);\n   * ```\n   *\n   * @returns The balance of a specific wallet.\n   * @twfeature ERC20\n   */\n  async balanceOf(address) {\n    return this.getValue(await this.contractWrapper.read(\"balanceOf\", [await resolveAddress(address)]));\n  }\n\n  /**\n   * Get the total supply for this token\n   * @remarks Get how much supply has been minted\n   * @example\n   * ```javascript\n   * const balance = await contract.erc20.totalSupply();\n   * ```\n   * @twfeature ERC20\n   */\n  async totalSupply() {\n    return await this.getValue(await this.contractWrapper.read(\"totalSupply\", []));\n  }\n\n  /**\n   * Get token allowance\n   *\n   * @remarks Get the allowance of a 'spender' wallet over the connected wallet's funds - the allowance of a different address for a token is the amount of tokens that the `spender` wallet is allowed to spend on behalf of the connected wallet.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet to check token allowance\n   * const spenderAddress = \"0x...\";\n   * const allowance = await contract.erc20.allowance(spenderAddress);\n   * ```\n   *\n   * @returns The allowance of one wallet over anothers funds.\n   * @twfeature ERC20\n   */\n  async allowance(spender) {\n    const [owner, spenderAddress] = await Promise.all([this.contractWrapper.getSignerAddress(), resolveAddress(spender)]);\n    return await this.allowanceOf(owner, spenderAddress);\n  }\n\n  /**\n   * Get token allowance of a specific wallet\n   *\n   * @remarks Get the allowance of one wallet over another wallet's funds - the allowance of a different address for a token is the amount of tokens that the wallet is allowed to spend on behalf of the specified wallet.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet who owns the funds\n   * const owner = \"{{wallet_address}}\";\n   * // Address of the wallet to check token allowance\n   * const spender = \"0x...\";\n   * const allowance = await contract.erc20.allowanceOf(owner, spender);\n   * ```\n   *\n   * @returns The allowance of one wallet over anothers funds.\n   * @twfeature ERC20\n   */\n  async allowanceOf(owner, spender) {\n    const args = await Promise.all([resolveAddress(owner), resolveAddress(spender)]);\n    return await this.getValue(await this.contractWrapper.read(\"allowance\", args));\n  }\n\n  /**\n   * Transfer tokens\n   *\n   * @remarks Transfer tokens from the connected wallet to another wallet.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet you want to send the tokens to\n   * const toAddress = \"0x...\";\n   * // The amount of tokens you want to send\n   * const amount = 0.1;\n   * await contract.erc20.transfer(toAddress, amount);\n   * ```\n   * @twfeature ERC20\n   */\n  transfer = /* @__PURE__ */buildTransactionFunction(async (to, amount) => {\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"transfer\",\n      args: await Promise.all([resolveAddress(to), this.normalizeAmount(amount)])\n    });\n  });\n\n  /**\n   * Transfer tokens from a specific address\n   *\n   * @remarks Transfer tokens from one wallet to another\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet sending the tokens\n   * const fromAddress = \"{{wallet_address}}\";\n   * // Address of the wallet you want to send the tokens to\n   * const toAddress = \"0x...\";\n   * // The number of tokens you want to send\n   * const amount = 1.2\n   * // Note that the connected wallet must have approval to transfer the tokens of the fromAddress\n   * await contract.erc20.transferFrom(fromAddress, toAddress, amount);\n   * ```\n   * @twfeature ERC20\n   */\n  transferFrom = /* @__PURE__ */buildTransactionFunction(async (from, to, amount) => {\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"transferFrom\",\n      args: await Promise.all([resolveAddress(from), resolveAddress(to), this.normalizeAmount(amount)])\n    });\n  });\n\n  /**\n   * Set token allowance\n   * @remarks Allows the specified `spender` wallet to transfer the given `amount` of tokens to another wallet\n   * @example\n   * ```javascript\n   * // Address of the wallet to allow transfers from\n   * const spenderAddress = \"0x...\";\n   * // The number of tokens to give as allowance\n   * const amount = 100\n   * await contract.erc20.setAllowance(spenderAddress, amount);\n   * ```\n   * @twfeature ERC20\n   */\n  setAllowance = /* @__PURE__ */buildTransactionFunction(async (spender, amount) => {\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"approve\",\n      args: await Promise.all([resolveAddress(spender), this.normalizeAmount(amount)])\n    });\n  });\n\n  /**\n   * Transfer tokens to many wallets\n   *\n   * @remarks Mint tokens from the connected wallet to many wallets\n   *\n   * @example\n   * ```javascript\n   * // Data of the tokens you want to mint\n   * const data = [\n   *   {\n   *     toAddress: \"{{wallet_address}}\", // Address to mint tokens to\n   *     amount: 100, // How many tokens to mint to specified address\n   *   },\n   *  {\n   *    toAddress: \"0x...\",\n   *    amount: 100,\n   *  }\n   * ]\n   *\n   * await contract.erc20.transferBatch(data);\n   * ```\n   */\n  transferBatch = /* @__PURE__ */buildTransactionFunction(async args => {\n    const contractEncoder = new ContractEncoder(this.contractWrapper);\n    const encoded = (await Promise.all(args.map(arg => Promise.all([this.normalizeAmount(arg.amount), resolveAddress(arg.toAddress)])))).map(_ref => {\n      let [amountWithDecimals, address] = _ref;\n      return contractEncoder.encode(\"transfer\", [address, amountWithDecimals]);\n    });\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"multicall\",\n      args: [encoded]\n    });\n  });\n\n  ////// ERC20 Mintable Extension //////\n\n  /**\n   * Mint tokens\n   *\n   * @remarks Mint tokens to the connected wallet.\n   *\n   * @example\n   * ```javascript\n   * const amount = \"1.5\"; // The amount of this token you want to mint\n   * await contract.erc20.mint(amount);\n   * ```\n   * @twfeature ERC20Mintable\n   */\n  mint = /* @__PURE__ */buildTransactionFunction(async amount => {\n    return this.mintTo.prepare(await this.contractWrapper.getSignerAddress(), amount);\n  });\n\n  /**\n   * Mint tokens to a specific wallet\n   *\n   * @remarks Mint tokens to a specified address.\n   *\n   * @example\n   * ```javascript\n   * const toAddress = \"{{wallet_address}}\"; // Address of the wallet you want to mint the tokens to\n   * const amount = \"1.5\"; // The amount of this token you want to mint\n   * await contract.erc20.mintTo(toAddress, amount);\n   * ```\n   * @twfeature ERC20Mintable\n   */\n  mintTo = /* @__PURE__ */buildTransactionFunction(async (receiver, amount) => {\n    return assertEnabled(this.mintable, FEATURE_TOKEN_MINTABLE).to.prepare(receiver, amount);\n  });\n\n  /**\n   * Construct a mint transaction without executing it\n   * @remarks This is useful for estimating the gas cost of a mint transaction, overriding transaction options and having fine grained control over the transaction execution.\n   * @param receiver - Address you want to send the token to\n   * @param amount - The amount of tokens you want to mint\n   *\n   * @deprecated Use `contract.erc20.mint.prepare(...args)` instead\n   * @twfeature ERC20Mintable\n   */\n  async getMintTransaction(receiver, amount) {\n    return assertEnabled(this.mintable, FEATURE_TOKEN_MINTABLE).getMintTransaction(receiver, amount);\n  }\n\n  ////// ERC20 BatchMintable Extension //////\n\n  /**\n   * Mint tokens to many wallets\n   *\n   * @remarks Mint tokens to many wallets in one transaction.\n   *\n   * @example\n   * ```javascript\n   * // Data of the tokens you want to mint\n   * const data = [\n   *   {\n   *     toAddress: \"{{wallet_address}}\", // Address to mint tokens to\n   *     amount: 0.2, // How many tokens to mint to specified address\n   *   },\n   *  {\n   *    toAddress: \"0x...\",\n   *    amount: 1.4,\n   *  }\n   * ]\n   *\n   * await contract.mintBatchTo(data);\n   * ```\n   * @twfeature ERC20BatchMintable\n   */\n  mintBatchTo = /* @__PURE__ */buildTransactionFunction(async args => {\n    return assertEnabled(this.mintable?.batch, FEATURE_TOKEN_BATCH_MINTABLE).to.prepare(args);\n  });\n\n  ////// ERC20 Burnable Extension //////\n\n  /**\n   * Burn tokens\n   *\n   * @remarks Burn tokens held by the connected wallet\n   *\n   * @example\n   * ```javascript\n   * // The amount of this token you want to burn\n   * const amount = 1.2;\n   *\n   * await contract.erc20.burn(amount);\n   * ```\n   * @twfeature ERC20Burnable\n   */\n  burn = /* @__PURE__ */buildTransactionFunction(async amount => {\n    return assertEnabled(this.burnable, FEATURE_TOKEN_BURNABLE).tokens.prepare(amount);\n  });\n\n  /**\n   * Burn tokens from a specific wallet\n   *\n   * @remarks Burn tokens held by the specified wallet\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet sending the tokens\n   * const holderAddress = \"{{wallet_address}}\";\n   *\n   * // The amount of this token you want to burn\n   * const amount = 1.2;\n   *\n   * await contract.erc20.burnFrom(holderAddress, amount);\n   * ```\n   * @twfeature ERC20Burnable\n   */\n  burnFrom = /* @__PURE__ */buildTransactionFunction(async (holder, amount) => {\n    return assertEnabled(this.burnable, FEATURE_TOKEN_BURNABLE).from.prepare(holder, amount);\n  });\n\n  ////// ERC20 Claimable Extension //////\n\n  /**\n   * Claim tokens\n   *\n   * @remarks Let the specified wallet claim Tokens.\n   *\n   * @example\n   * ```javascript\n   * const address = \"{{wallet_address}}\"; // address of the wallet you want to claim the NFTs\n   * const quantity = 42.69; // how many tokens you want to claim\n   *\n   * const tx = await contract.erc20.claim(address, quantity);\n   * const receipt = tx.receipt; // the transaction receipt\n   * ```\n   *\n   * @param destinationAddress - Address you want to send the token to\n   * @param amount - Quantity of the tokens you want to claim\n   * @param checkERC20Allowance - Optional, check if the wallet has enough ERC20 allowance to claim the tokens, and if not, approve the transfer\n   * @param claimData\n   * @returns - The transaction receipt\n   * @twfeature ERC20ClaimPhasesV2 | ERC20ClaimPhasesV1 | ERC20ClaimConditionsV2 | ERC20ClaimConditionsV1\n   */\n  claim = /* @__PURE__ */buildTransactionFunction(async (amount, options) => {\n    return this.claimTo.prepare(await this.contractWrapper.getSignerAddress(), amount, options);\n  });\n\n  /**\n   * Claim tokens to a specific wallet\n   *\n   * @remarks Let the specified wallet claim Tokens.\n   *\n   * @example\n   * ```javascript\n   * const address = \"{{wallet_address}}\"; // address of the wallet you want to claim the NFTs\n   * const quantity = 42.69; // how many tokens you want to claim\n   *\n   * const tx = await contract.erc20.claim(address, quantity);\n   * const receipt = tx.receipt; // the transaction receipt\n   * ```\n   *\n   * @param destinationAddress - Address you want to send the token to\n   * @param amount - Quantity of the tokens you want to claim\n   * @param checkERC20Allowance - Optional, check if the wallet has enough ERC20 allowance to claim the tokens, and if not, approve the transfer\n   * @param claimData\n   * @returns - The transaction receipt\n   * @twfeature ERC20ClaimPhasesV2 | ERC20ClaimPhasesV1 | ERC20ClaimConditionsV2 | ERC20ClaimConditionsV1\n   */\n  claimTo = /* @__PURE__ */buildTransactionFunction(async (destinationAddress, amount, options) => {\n    return assertEnabled(this.droppable?.claim, FEATURE_TOKEN_CLAIM_CONDITIONS_V2).to.prepare(destinationAddress, amount, options);\n  });\n\n  /**\n   * Configure claim conditions\n   * @remarks Define who can claim NFTs in the collection, when and how many.\n   * @example\n   * ```javascript\n   * const presaleStartTime = new Date();\n   * const publicSaleStartTime = new Date(Date.now() + 60 * 60 * 24 * 1000);\n   * const claimConditions = [\n   *   {\n   *     startTime: presaleStartTime, // start the presale now\n   *     maxClaimableSupply: 2, // limit how many mints for this presale\n   *     price: 0.01, // presale price\n   *     snapshot: ['0x...', '0x...'], // limit minting to only certain addresses\n   *   },\n   *   {\n   *     startTime: publicSaleStartTime, // 24h after presale, start public sale\n   *     price: 0.08, // public sale price\n   *   }\n   * ]);\n   * await contract.erc20.claimConditions.set(claimConditions);\n   * ```\n   * @twfeature ERC20ClaimPhasesV2 | ERC20ClaimPhasesV1 | ERC20ClaimConditionsV2 | ERC20ClaimConditionsV1\n   */\n  get claimConditions() {\n    return assertEnabled(this.droppable?.claim, FEATURE_TOKEN_CLAIM_CONDITIONS_V2).conditions;\n  }\n\n  ////// ERC20 SignatureMint Extension //////\n\n  /**\n   * Mint with signature\n   * @remarks Generate dynamic tokens with your own signature, and let others mint them using that signature.\n   * @example\n   * ```javascript\n   * // see how to craft a payload to sign in the `contract.erc20.signature.generate()` documentation\n   * const signedPayload = contract.erc20.signature().generate(payload);\n   *\n   * // now the payload can be used to mint tokens\n   * const tx = contract.erc20.signature.mint(signedPayload);\n   * ```\n   * @twfeature ERC20SignatureMintable\n   */\n  get signature() {\n    return assertEnabled(this.signatureMintable, FEATURE_TOKEN_SIGNATURE_MINTABLE);\n  }\n\n  /** ******************************\n   * PRIVATE FUNCTIONS\n   *******************************/\n\n  /**\n   * returns the wei amount from a token amount\n   * @internal\n   * @param amount\n   */\n  async normalizeAmount(amount) {\n    return normalizeAmount(this.contractWrapper, amount);\n  }\n\n  /**\n   * @internal\n   */\n  async getValue(value) {\n    return await fetchCurrencyValue(this.contractWrapper.getProvider(), this.getAddress(), BigNumber.from(value));\n  }\n  detectErc20Mintable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC20\")) {\n      return new Erc20Mintable(this, this.contractWrapper);\n    }\n    return undefined;\n  }\n  detectErc20Burnable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC20Burnable\")) {\n      return new Erc20Burnable(this, this.contractWrapper);\n    }\n    return undefined;\n  }\n  detectErc20Droppable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC20ClaimConditionsV1\") || detectContractFeature(this.contractWrapper, \"ERC20ClaimConditionsV2\") || detectContractFeature(this.contractWrapper, \"ERC20ClaimPhasesV1\") || detectContractFeature(this.contractWrapper, \"ERC20ClaimPhasesV2\")) {\n      return new Erc20Droppable(this, this.contractWrapper, this.storage);\n    }\n    return undefined;\n  }\n  detectErc20SignatureMintable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC20SignatureMintable\")) {\n      return new Erc20SignatureMintable(this.contractWrapper);\n    }\n    return undefined;\n  }\n}\n\n/**\n * Mint Many ERC721 NFTs at once\n * @remarks NFT batch minting functionality that handles IPFS storage for you.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * await contract.nft.mint.batch.to(walletAddress, [nftMetadata1, nftMetadata2, ...]);\n * ```\n * @public\n */\n\nclass Erc721BatchMintable {\n  featureName = FEATURE_NFT_BATCH_MINTABLE.name;\n  constructor(erc721, contractWrapper, storage) {\n    this.erc721 = erc721;\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n  }\n\n  /**\n   * Mint Many unique NFTs\n   *\n   * @remarks Mint many unique NFTs at once to a specified wallet.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet you want to mint the NFT to\n   * const walletAddress = \"{{wallet_address}}\";\n   *\n   * // Custom metadata of the NFTs you want to mint.\n   * const metadatas = [{\n   *   name: \"Cool NFT #1\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   * }, {\n   *   name: \"Cool NFT #2\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/other/image.png\"),\n   * }];\n   *\n   * const tx = await contract.mint.batch.to(walletAddress, metadatas);\n   * const receipt = tx[0].receipt; // same transaction receipt for all minted NFTs\n   * const firstTokenId = tx[0].id; // token id of the first minted NFT\n   * const firstNFT = await tx[0].data(); // (optional) fetch details of the first minted NFT\n   * ```\n   */\n  to = /* @__PURE__ */buildTransactionFunction(async (to, metadatas) => {\n    const [uris, resolvedAddress] = await Promise.all([uploadOrExtractURIs(metadatas, this.storage), resolveAddress(to)]);\n    const contractEncoder = new ContractEncoder(this.contractWrapper);\n    const encoded = uris.map(uri => contractEncoder.encode(\"mintTo\", [resolvedAddress, uri]));\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"multicall\",\n      args: [encoded],\n      parse: receipt => {\n        const events = this.contractWrapper.parseLogs(\"TokensMinted\", receipt.logs);\n        if (events.length === 0 || events.length < metadatas.length) {\n          throw new Error(\"TokenMinted event not found, minting failed\");\n        }\n        return events.map(e => {\n          const id = e.args.tokenIdMinted;\n          return {\n            id,\n            receipt,\n            data: () => this.erc721.get(id)\n          };\n        });\n      }\n    });\n  });\n}\n\n/**\n * Configure and claim ERC721 NFTs\n * @remarks Manage claim phases and claim ERC721 NFTs that have been lazily minted.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * await contract.erc721.claim(quantity);\n * await contract.erc721.claimConditions.getActive();\n * ```\n */\n\nclass Erc721ClaimableWithConditions {\n  featureName = FEATURE_NFT_CLAIM_CONDITIONS_V2.name;\n\n  /**\n   * Configure claim conditions\n   * @remarks Define who can claim NFTs in the collection, when and how many.\n   * @example\n   * ```javascript\n   * const presaleStartTime = new Date();\n   * const publicSaleStartTime = new Date(Date.now() + 60 * 60 * 24 * 1000);\n   * const claimConditions = [\n   *   {\n   *     startTime: presaleStartTime, // start the presale now\n   *     maxClaimableSupply: 2, // limit how many mints for this presale\n   *     price: 0.01, // presale price\n   *     snapshot: ['0x...', '0x...'], // limit minting to only certain addresses\n   *   },\n   *   {\n   *     startTime: publicSaleStartTime, // 24h after presale, start public sale\n   *     price: 0.08, // public sale price\n   *   }\n   * ]);\n   * await contract.erc721.claimConditions.set(claimConditions);\n   * ```\n   */\n\n  constructor(erc721, contractWrapper, storage) {\n    this.erc721 = erc721;\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n    const metadata = new ContractMetadata(this.contractWrapper, CustomContractSchema, this.storage);\n    this.conditions = new DropClaimConditions(this.contractWrapper, metadata, this.storage);\n  }\n\n  /**\n   * Claim unique NFTs to a specific Wallet\n   *\n   * @remarks Let the specified wallet claim NFTs.\n   *\n   * @example\n   * ```javascript\n   * const address = \"{{wallet_address}}\"; // address of the wallet you want to claim the NFTs\n   * const quantity = 1; // how many unique NFTs you want to claim\n   *\n   * const tx = await contract.erc721.claimTo(address, quantity);\n   * const receipt = tx[0].receipt; // the transaction receipt\n   * const claimedTokenId = tx[0].id; // the id of the first NFT claimed\n   * const claimedNFT = await tx[0].data(); // (optional) get the first claimed NFT metadata\n   * ```\n   *\n   * @param destinationAddress - Address you want to send the token to\n   * @param quantity - Quantity of the tokens you want to claim\n   * @param options\n   * @returns - an array of results containing the id of the token claimed, the transaction receipt and a promise to optionally fetch the nft metadata\n   */\n  to = /* @__PURE__ */buildTransactionFunction(async (destinationAddress, quantity, options) => {\n    // TODO: Transaction Sequence Pattern\n    const tx = await this.conditions.getClaimTransaction(destinationAddress, quantity, options);\n    tx.setParse(receipt => {\n      const event = this.contractWrapper.parseLogs(\"TokensClaimed\", receipt?.logs);\n      const startingIndex = event[0].args.startTokenId;\n      const endingIndex = startingIndex.add(quantity);\n      const results = [];\n      for (let id = startingIndex; id.lt(endingIndex); id = id.add(1)) {\n        results.push({\n          id,\n          receipt,\n          data: () => this.erc721.get(id)\n        });\n      }\n      return results;\n    });\n    return tx;\n  });\n}\n\nasync function calculateClaimCost(contractWrapper, pricePerToken, quantity, currencyAddress, checkERC20Allowance) {\n  let overrides = {};\n  const currency = currencyAddress || NATIVE_TOKEN_ADDRESS;\n  const normalizedPrice = await normalizePriceValue(contractWrapper.getProvider(), pricePerToken, currency);\n  const totalCost = normalizedPrice.mul(quantity);\n  if (totalCost.gt(0)) {\n    if (currency === NATIVE_TOKEN_ADDRESS) {\n      overrides = {\n        value: totalCost\n      };\n    } else if (currency !== NATIVE_TOKEN_ADDRESS && checkERC20Allowance) {\n      await approveErc20Allowance(contractWrapper, currency, totalCost, quantity, 0);\n    }\n  }\n  return overrides;\n}\n\n/**\n * Configure and claim ERC721 NFTs\n * @remarks Manage claim phases and claim ERC721 NFTs that have been lazily minted.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * await contract.erc721.claim(tokenId, quantity);\n * ```\n */\n\nclass Erc721Claimable {\n  featureName = FEATURE_NFT_CLAIM_CUSTOM.name;\n  constructor(erc721, contractWrapper) {\n    this.erc721 = erc721;\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * Construct a claim transaction without executing it.\n   * This is useful for estimating the gas cost of a claim transaction, overriding transaction options and having fine grained control over the transaction execution.\n   * @param destinationAddress - Address you want to send the token to\n   * @param tokenId - Id of the token you want to claim\n   * @param quantity - Quantity of the tokens you want to claim\n   * @param options - Options for claiming the NFTs\n   *\n   * @deprecated Use `contract.erc721.claim.prepare(...args)` instead\n   */\n  async getClaimTransaction(destinationAddress, quantity, options) {\n    // TODO: Transaction Sequence Pattern\n    let overrides = {};\n    if (options && options.pricePerToken) {\n      overrides = await calculateClaimCost(this.contractWrapper, options.pricePerToken, quantity, options.currencyAddress, options.checkERC20Allowance);\n    }\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"claim\",\n      args: [destinationAddress, quantity],\n      overrides\n    });\n  }\n\n  /**\n   * Claim NFTs to a specific Wallet\n   *\n   * @remarks Let the specified wallet claim NFTs.\n   *\n   * @example\n   * ```javascript\n   * const address = \"{{wallet_address}}\"; // address of the wallet you want to claim the NFTs\n   * const quantity = 1; // how many NFTs you want to claim\n   *\n   * const tx = await contract.erc721.claimTo(address, quantity);\n   * const receipt = tx[0].receipt; // the transaction receipt\n   * ```\n   *\n   * @param destinationAddress - Address you want to send the token to\n   * @param quantity - Quantity of the tokens you want to claim\n   * @param options - Options for claiming the NFTs\n   *\n   * @returns - Receipt for the transaction\n   */\n  to = /* @__PURE__ */buildTransactionFunction(async (destinationAddress, quantity, options) => {\n    // TODO: Transaction Sequence Pattern\n    const tx = await this.getClaimTransaction(destinationAddress, quantity, options);\n    tx.setParse(receipt => {\n      const event = this.contractWrapper.parseLogs(\"TokensClaimed\", receipt?.logs);\n      const startingIndex = event[0].args.startTokenId;\n      const endingIndex = startingIndex.add(quantity);\n      const results = [];\n      for (let id = startingIndex; id.lt(endingIndex); id = id.add(1)) {\n        results.push({\n          id,\n          receipt,\n          data: () => this.erc721.get(id)\n        });\n      }\n      return results;\n    });\n    return tx;\n  });\n}\n\n/**\n * Lazily mint and claim ERC721 NFTs\n * @remarks Manage claim phases and claim ERC721 NFTs that have been lazily minted.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * await contract.drop.claim(quantity);\n * ```\n */\n\nclass Erc721LazyMintable {\n  featureName = FEATURE_NFT_LAZY_MINTABLE.name;\n\n  /**\n   * Delayed reveal\n   * @remarks Create a batch of encrypted NFTs that can be revealed at a later time.\n   * @example\n   * ```javascript\n   * // the real NFTs, these will be encrypted until you reveal them\n   * const realNFTs = [{\n   *   name: \"Common NFT #1\",\n   *   description: \"Common NFT, one of many.\",\n   *   image: fs.readFileSync(\"path/to/image.png\"),\n   * }, {\n   *   name: \"Super Rare NFT #2\",\n   *   description: \"You got a Super Rare NFT!\",\n   *   image: fs.readFileSync(\"path/to/image.png\"),\n   * }];\n   * // A placeholder NFT that people will get immediately in their wallet, and will be converted to the real NFT at reveal time\n   * const placeholderNFT = {\n   *   name: \"Hidden NFT\",\n   *   description: \"Will be revealed next week!\"\n   * };\n   * // Create and encrypt the NFTs\n   * await contract.nft.drop.revealer.createDelayedRevealBatch(\n   *   placeholderNFT,\n   *   realNFTs,\n   *   \"my secret password\",\n   * );\n   * // Whenever you're ready, reveal your NFTs at any time\n   * const batchId = 0; // the batch to reveal\n   * await contract.erc721.revealer.reveal(batchId, \"my secret password\");\n   * ```\n   */\n\n  constructor(erc721, contractWrapper, storage) {\n    this.erc721 = erc721;\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n    this.revealer = this.detectErc721Revealable();\n  }\n\n  /**\n   * Create a batch of unique NFTs to be claimed in the future\n   *\n   * @remarks Create batch allows you to create a batch of many unique NFTs in one transaction.\n   *\n   * @example\n   * ```javascript\n   * // Custom metadata of the NFTs to create\n   * const metadatas = [{\n   *   name: \"Cool NFT\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   * }, {\n   *   name: \"Cool NFT\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"),\n   * }];\n   *\n   * const results = await contract.erc721.lazyMint(metadatas); // uploads and creates the NFTs on chain\n   * const firstTokenId = results[0].id; // token id of the first created NFT\n   * const firstNFT = await results[0].data(); // (optional) fetch details of the first created NFT\n   * ```\n   *\n   * @param metadatas - The metadata to include in the batch.\n   * @param options - optional upload progress callback\n   */\n  lazyMint = /* @__PURE__ */buildTransactionFunction(async (metadatas, options) => {\n    const startFileNumber = await this.erc721.nextTokenIdToMint();\n    const batch = await uploadOrExtractURIs(metadatas, this.storage, startFileNumber.toNumber(), options);\n    // ensure baseUri is the same for the entire batch\n    const baseUri = getBaseUriFromBatch(batch);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"lazyMint\",\n      args: [batch.length, baseUri.endsWith(\"/\") ? baseUri : `${baseUri}/`, utils.toUtf8Bytes(\"\")],\n      parse: receipt => {\n        const event = this.contractWrapper.parseLogs(\"TokensLazyMinted\", receipt?.logs);\n        const startingIndex = event[0].args.startTokenId;\n        const endingIndex = event[0].args.endTokenId;\n        const results = [];\n        for (let id = startingIndex; id.lte(endingIndex); id = id.add(1)) {\n          results.push({\n            id,\n            receipt,\n            data: () => this.erc721.getTokenMetadata(id)\n          });\n        }\n        return results;\n      }\n    });\n  });\n\n  /** ******************************\n   * PRIVATE FUNCTIONS\n   *******************************/\n  detectErc721Revealable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC721Revealable\")) {\n      return new DelayedReveal(this.contractWrapper, this.storage, FEATURE_NFT_REVEALABLE.name, () => this.erc721.nextTokenIdToMint());\n    }\n    return undefined;\n  }\n}\n\n/**\n * Mint ERC721 NFTs\n * @remarks NFT minting functionality that handles IPFS storage for you.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * await contract.nft.mint.to(walletAddress, nftMetadata);\n * ```\n * @public\n */\n\nclass Erc721Mintable {\n  featureName = FEATURE_NFT_MINTABLE.name;\n  constructor(erc721, contractWrapper, storage) {\n    this.erc721 = erc721;\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n    this.batch = this.detectErc721BatchMintable();\n  }\n\n  /**\n   * Mint a unique NFT\n   *\n   * @remarks Mint a unique NFT to a specified wallet.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet you want to mint the NFT to\n   * const walletAddress = \"{{wallet_address}}\";\n   *\n   * // Custom metadata of the NFT, note that you can fully customize this metadata with other properties.\n   * const metadata = {\n   *   name: \"Cool NFT\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   * };\n   *\n   * const tx = await contract.nft.mint.to(walletAddress, metadata);\n   * const receipt = tx.receipt; // the transaction receipt\n   * const tokenId = tx.id; // the id of the NFT minted\n   * const nft = await tx.data(); // (optional) fetch details of minted NFT\n   * ```\n   */\n  to = /* @__PURE__ */buildTransactionFunction(async (to, metadata) => {\n    const [uri, toAddress] = await Promise.all([uploadOrExtractURI(metadata, this.storage), resolveAddress(to)]);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"mintTo\",\n      args: [toAddress, uri],\n      parse: receipt => {\n        const event = this.contractWrapper.parseLogs(\"Transfer\", receipt?.logs);\n        if (event.length === 0) {\n          throw new Error(\"TransferEvent event not found\");\n        }\n        const id = event[0].args.tokenId;\n        return {\n          id,\n          receipt,\n          data: () => this.erc721.get(id)\n        };\n      }\n    });\n  });\n\n  /**\n   * @deprecated Use `contract.erc721.mint.prepare(...args)` instead\n   */\n  async getMintTransaction(to, metadata) {\n    return this.to.prepare(await resolveAddress(to), metadata);\n  }\n  detectErc721BatchMintable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC721BatchMintable\")) {\n      return new Erc721BatchMintable(this.erc721, this.contractWrapper, this.storage);\n    }\n    return undefined;\n  }\n}\n\n/**\n * List owned ERC721 NFTs\n * @remarks Easily list all the NFTs from a ERC721 contract, owned by a certain wallet.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * const walletAddress = \"0x...\";\n * const ownedNFTs = await contract.nft.query.owned.all(walletAddress);\n * ```\n * @public\n */\n\nclass Erc721Enumerable {\n  featureName = FEATURE_NFT_ENUMERABLE.name;\n  constructor(erc721, contractWrapper) {\n    this.erc721 = erc721;\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * Get all NFTs owned by a specific wallet\n   *\n   * @remarks Get all the data associated with the NFTs owned by a specific wallet.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet to get the NFTs of\n   * const address = \"{{wallet_address}}\";\n   * const nfts = await contract.nft.query.owned.all(address);\n   * ```\n   * @param walletAddress - the wallet address to query, defaults to the connected wallet\n   * @returns The NFT metadata for all NFTs in the contract.\n   */\n  async all(walletAddress) {\n    const tokenIds = await this.tokenIds(walletAddress);\n    return await Promise.all(tokenIds.map(tokenId => this.erc721.get(tokenId.toString())));\n  }\n\n  /**\n   * Get all token ids of NFTs owned by a specific wallet.\n   * @param walletAddress - the wallet address to query, defaults to the connected wallet\n   */\n  async tokenIds(walletAddress) {\n    const address = await resolveAddress(walletAddress || (await this.contractWrapper.getSignerAddress()));\n    const balance = await this.contractWrapper.read(\"balanceOf\", [address]);\n    const indices = Array.from(Array(balance.toNumber()).keys());\n    return await Promise.all(indices.map(i => this.contractWrapper.read(\"tokenOfOwnerByIndex\", [address, i])));\n  }\n}\n\n/**\n * List owned ERC721 NFTs\n * @remarks Easily list all the NFTs from a ERC721 contract, owned by a certain wallet.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * const walletAddress = \"0x...\";\n * const ownedNFTs = await contract.nft.query.owned.all(walletAddress);\n * ```\n * @public\n */\n\nclass Erc721AQueryable {\n  featureName = FEATURE_NFT_QUERYABLE.name;\n  constructor(erc721, contractWrapper) {\n    this.erc721 = erc721;\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * Get all NFTs owned by a specific wallet\n   *\n   * @remarks Get all the data associated with the NFTs owned by a specific wallet.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet to get the NFTs of\n   * const address = \"{{wallet_address}}\";\n   * const nfts = await contract.nft.query.owned.all(address);\n   * ```\n   * @param walletAddress - the wallet address to query, defaults to the connected wallet\n   * @returns The NFT metadata for all NFTs in the contract.\n   */\n  async all(walletAddress) {\n    const tokenIds = await this.tokenIds(walletAddress);\n    return await Promise.all(tokenIds.map(tokenId => this.erc721.get(tokenId.toString())));\n  }\n\n  /**\n   * Get all token ids of NFTs owned by a specific wallet.\n   * @param walletAddress - the wallet address to query, defaults to the connected wallet\n   */\n  async tokenIds(walletAddress) {\n    const address = await resolveAddress(walletAddress || (await this.contractWrapper.getSignerAddress()));\n    return await this.contractWrapper.read(\"tokensOfOwner\", [address]);\n  }\n}\n\n/**\n * List ERC721 NFTs\n * @remarks Easily list all the NFTs in a ERC721 contract.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * const nfts = await contract.nft.query.all();\n * ```\n * @public\n */\n\nclass Erc721Supply {\n  featureName = FEATURE_NFT_SUPPLY.name;\n  constructor(erc721, contractWrapper) {\n    this.erc721 = erc721;\n    this.contractWrapper = contractWrapper;\n    this.owned = this.detectErc721Owned();\n  }\n\n  /**\n   * Get all NFTs\n   *\n   * @remarks Get all the data associated with every NFT in this contract.\n   *\n   * By default, returns the first 100 NFTs, use queryParams to fetch more.\n   *\n   * @example\n   * ```javascript\n   * const nfts = await contract.nft.query.all();\n   * ```\n   * @param queryParams - optional filtering to only fetch a subset of results.\n   * @returns The NFT metadata for all NFTs queried.\n   */\n  async all(queryParams) {\n    let startTokenId = BigNumber.from(0);\n    if (hasFunction(\"startTokenId\", this.contractWrapper)) {\n      startTokenId = await this.contractWrapper.read(\"startTokenId\", []);\n    }\n    const start = BigNumber.from(queryParams?.start || 0).add(startTokenId).toNumber();\n    const count = BigNumber.from(queryParams?.count || DEFAULT_QUERY_ALL_COUNT).toNumber();\n    const maxSupply = await this.erc721.nextTokenIdToMint();\n    const maxId = Math.min(maxSupply.add(startTokenId).toNumber(), start + count);\n    return await Promise.all([...Array(maxId - start).keys()].map(i => this.erc721.get((start + i).toString())));\n  }\n\n  /**\n   * Return all the owners of each token id in this contract\n   * @returns\n   */\n  async allOwners() {\n    let totalCount;\n    let startTokenId = BigNumber.from(0);\n    if (hasFunction(\"startTokenId\", this.contractWrapper)) {\n      startTokenId = await this.contractWrapper.read(\"startTokenId\", []);\n    }\n    try {\n      totalCount = await this.erc721.totalClaimedSupply();\n    } catch (e) {\n      totalCount = await this.totalCount();\n    }\n    totalCount = totalCount.add(startTokenId);\n\n    // TODO use multicall3 if available\n    // TODO can't call toNumber() here, this can be a very large number\n    const arr = [...new Array(totalCount.toNumber()).keys()];\n    const owners = await Promise.all(arr.map(i => this.erc721.ownerOf(i).catch(() => constants.AddressZero)));\n    return arr.map(i => ({\n      tokenId: i,\n      owner: owners[i]\n    })).filter(o => o.owner !== constants.AddressZero);\n  }\n\n  /**\n   * Get the number of NFTs minted\n   * @remarks This returns the total number of NFTs minted in this contract, **not** the total supply of a given token.\n   *\n   * @returns the total number of NFTs minted in this contract\n   * @public\n   */\n  async totalCount() {\n    return await this.erc721.nextTokenIdToMint();\n  }\n\n  /**\n   * Get the number of NFTs of this contract currently owned by end users\n   * @returns the total number of NFTs of this contract in circulation (minted & not burned)\n   * @public\n   */\n  async totalCirculatingSupply() {\n    return await this.contractWrapper.read(\"totalSupply\", []);\n  }\n  detectErc721Owned() {\n    if (detectContractFeature(this.contractWrapper, \"ERC721Enumerable\")) {\n      return new Erc721Enumerable(this.erc721, this.contractWrapper);\n    } else if (detectContractFeature(this.contractWrapper, \"ERC721AQueryable\")) {\n      return new Erc721AQueryable(this.erc721, this.contractWrapper);\n    }\n    return undefined;\n  }\n}\n\n/**\n * @internal\n */\nconst TieredDropPayloadSchema = /* @__PURE__ */(() => BaseSignaturePayloadInput.extend({\n  tierPriority: z.array(z.string()),\n  royaltyRecipient: AddressOrEnsSchema.default(constants.AddressZero),\n  royaltyBps: BasisPointsSchema.default(0),\n  quantity: BigNumberSchema.default(1)\n}))();\n\nclass Erc721TieredDrop {\n  featureName = FEATURE_NFT_TIERED_DROP.name;\n  constructor(erc721, contractWrapper, storage) {\n    this.erc721 = erc721;\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n  }\n  async getMetadataInTier(tier) {\n    const tiers = await this.contractWrapper.read(\"getMetadataForAllTiers\", []);\n    const batches = tiers.find(t => t.tier === tier);\n    if (!batches) {\n      throw new Error(\"Tier not found in contract.\");\n    }\n    const nfts = await Promise.all(batches.ranges.map((range, i) => {\n      const nftsInRange = [];\n      const baseUri = batches.baseURIs[i];\n      for (let j = range.startIdInclusive.toNumber(); j < range.endIdNonInclusive.toNumber(); j++) {\n        const uri = baseUri.endsWith(\"/\") ? `${baseUri}${j}` : `${baseUri}/${j}`;\n        const metadata = this.storage.downloadJSON(uri);\n        nftsInRange.push(metadata);\n      }\n      return nftsInRange;\n    }).flat());\n    return nfts;\n  }\n  async getTokensInTier(tier) {\n    const endIndex = await this.contractWrapper.read(\"getTokensInTierLen\", []);\n    if (endIndex.eq(0)) {\n      return [];\n    }\n    const ranges = await this.contractWrapper.read(\"getTokensInTier\", [tier, 0, endIndex]);\n    const nfts = await Promise.all(ranges.map(range => {\n      const nftsInRange = [];\n      for (let i = range.startIdInclusive.toNumber(); i < range.endIdNonInclusive.toNumber(); i++) {\n        nftsInRange.push(this.erc721.get(i));\n      }\n      return nftsInRange;\n    }).flat());\n    return nfts;\n  }\n  createBatchWithTier = /* @__PURE__ */buildTransactionFunction(async (metadatas, tier, options) => {\n    // TODO: Change this to on extension\n    const startFileNumber = await this.erc721.nextTokenIdToMint();\n    const batch = await uploadOrExtractURIs(metadatas, this.storage, startFileNumber.toNumber(), options);\n    const baseUri = getBaseUriFromBatch(batch);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"lazyMint\",\n      args: [batch.length, baseUri.endsWith(\"/\") ? baseUri : `${baseUri}/`, tier, utils.toUtf8Bytes(\"\")],\n      parse: receipt => {\n        const event = this.contractWrapper.parseLogs(\"TokensLazyMinted\", receipt?.logs);\n        const startingIndex = event[0].args[1];\n        const endingIndex = event[0].args[2];\n        const results = [];\n        for (let id = startingIndex; id.lte(endingIndex); id = id.add(1)) {\n          results.push({\n            id,\n            receipt,\n            data: () => this.erc721.getTokenMetadata(id)\n          });\n        }\n        return results;\n      }\n    });\n  });\n  createDelayedRevealBatchWithTier = /* @__PURE__ */buildTransactionFunction(async (placeholder, metadatas, password, tier, options) => {\n    if (!password) {\n      throw new Error(\"Password is required\");\n    }\n    const placeholderUris = await this.storage.uploadBatch([CommonNFTInput.parse(placeholder)], {\n      rewriteFileNames: {\n        fileStartNumber: 0\n      }\n    });\n    const placeholderUri = getBaseUriFromBatch(placeholderUris);\n    const startFileNumber = await this.erc721.nextTokenIdToMint();\n    const uris = await this.storage.uploadBatch(metadatas.map(m => CommonNFTInput.parse(m)), {\n      onProgress: options?.onProgress,\n      rewriteFileNames: {\n        fileStartNumber: startFileNumber.toNumber()\n      }\n    });\n    const baseUri = getBaseUriFromBatch(uris);\n    const baseUriId = await this.contractWrapper.read(\"getBaseURICount\", []);\n    const chainId = await this.contractWrapper.getChainID();\n    const hashedPassword = utils.solidityKeccak256([\"string\", \"uint256\", \"uint256\", \"address\"], [password, chainId, baseUriId, this.contractWrapper.address]);\n    const encryptedBaseUri = await this.contractWrapper.read(\"encryptDecrypt\", [utils.toUtf8Bytes(baseUri), hashedPassword]);\n    const provenanceHash = utils.solidityKeccak256([\"bytes\", \"bytes\", \"uint256\"], [utils.toUtf8Bytes(baseUri), hashedPassword, chainId]);\n    const data = utils.defaultAbiCoder.encode([\"bytes\", \"bytes32\"], [encryptedBaseUri, provenanceHash]);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"lazyMint\",\n      args: [uris.length, placeholderUri.endsWith(\"/\") ? placeholderUri : `${placeholderUri}/`, tier, data],\n      parse: receipt => {\n        const event = this.contractWrapper.parseLogs(\"TokensLazyMinted\", receipt?.logs);\n        const startingIndex = event[0].args[1];\n        const endingIndex = event[0].args[2];\n        const results = [];\n        for (let id = startingIndex; id.lte(endingIndex); id = id.add(1)) {\n          results.push({\n            id,\n            receipt,\n            data: () => this.erc721.getTokenMetadata(id)\n          });\n        }\n        return results;\n      }\n    });\n  });\n  reveal = /* @__PURE__ */buildTransactionFunction(async (batchId, password) => {\n    if (!password) {\n      throw new Error(\"Password is required\");\n    }\n    const chainId = await this.contractWrapper.getChainID();\n    const key = utils.solidityKeccak256([\"string\", \"uint256\", \"uint256\", \"address\"], [password, chainId, batchId, this.contractWrapper.address]);\n    // performing the reveal locally to make sure it'd succeed before sending the transaction\n    try {\n      const decryptedUri = await this.contractWrapper.callStatic().reveal(batchId, key);\n      // basic sanity check for making sure decryptedUri is valid\n      // this is optional because invalid decryption key would result in non-utf8 bytes and\n      // ethers would throw when trying to decode it\n      if (!decryptedUri.includes(\"://\") || !decryptedUri.endsWith(\"/\")) {\n        throw new Error(\"invalid password\");\n      }\n    } catch (e) {\n      throw new Error(\"invalid password\");\n    }\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"reveal\",\n      args: [batchId, key]\n    });\n  });\n  async generate(payloadToSign) {\n    const [payload] = await this.generateBatch([payloadToSign]);\n    return payload;\n  }\n  async generateBatch(payloadsToSign) {\n    const parsedPayloads = await Promise.all(payloadsToSign.map(payload => TieredDropPayloadSchema.parseAsync(payload)));\n    const chainId = await this.contractWrapper.getChainID();\n    const signer = this.contractWrapper.getSigner();\n    invariant(signer, \"No signer available\");\n    return await Promise.all(parsedPayloads.map(async payload => {\n      const signature = await this.contractWrapper.signTypedData(signer, {\n        name: \"SignatureAction\",\n        version: \"1\",\n        chainId,\n        verifyingContract: this.contractWrapper.address\n      }, {\n        GenericRequest: GenericRequest\n      }, await this.mapPayloadToContractStruct(payload));\n      return {\n        payload,\n        signature: signature.toString()\n      };\n    }));\n  }\n  async verify(signedPayload) {\n    const message = await this.mapPayloadToContractStruct(signedPayload.payload);\n    const verification = await this.contractWrapper.read(\"verify\", [message, signedPayload.signature]);\n    return verification[0];\n  }\n  async claimWithSignature(signedPayload) {\n    const message = await this.mapPayloadToContractStruct(signedPayload.payload);\n    const normalizedTotalPrice = await normalizePriceValue(this.contractWrapper.getProvider(), signedPayload.payload.price, signedPayload.payload.currencyAddress);\n    const overrides = await this.contractWrapper.getCallOverrides();\n    await setErc20Allowance(this.contractWrapper, normalizedTotalPrice, signedPayload.payload.currencyAddress, overrides);\n    const receipt = await this.contractWrapper.sendTransaction(\"claimWithSignature\", [message, signedPayload.signature], overrides);\n    const event = this.contractWrapper.parseLogs(\"TokensClaimed\", receipt?.logs);\n    const startingIndex = event[0].args.startTokenId;\n    const endingIndex = startingIndex.add(event[0].args.quantityClaimed);\n    const results = [];\n    for (let id = startingIndex; id.lt(endingIndex); id = id.add(1)) {\n      results.push({\n        id,\n        receipt,\n        data: () => this.erc721.get(id)\n      });\n    }\n    return results;\n  }\n  async mapPayloadToContractStruct(payload) {\n    const normalizedTotalPrice = await normalizePriceValue(this.contractWrapper.getProvider(), payload.price, payload.currencyAddress);\n    const data = utils.defaultAbiCoder.encode([\"string[]\", \"address\", \"address\", \"uint256\", \"address\", \"uint256\", \"uint256\", \"address\"], [payload.tierPriority, payload.to, payload.royaltyRecipient, payload.royaltyBps, payload.primarySaleRecipient, payload.quantity, normalizedTotalPrice, payload.currencyAddress]);\n    return {\n      uid: payload.uid,\n      validityStartTimestamp: payload.mintStartTime,\n      validityEndTimestamp: payload.mintEndTime,\n      data\n    };\n  }\n}\n\nclass Erc721Burnable {\n  featureName = FEATURE_NFT_BURNABLE.name;\n  constructor(contractWrapper) {\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * Burn NFTs\n   *\n   * @remarks Burn NFTs held by the connected wallet\n   *\n   * @example\n   * ```javascript\n   * // The token ID of the NFT you want to burn\n   * const tokenId = 0;\n   *\n   * await contract.nft.burn.token(tokenId);\n   * ```\n   */\n  token = /* @__PURE__ */buildTransactionFunction(async tokenId => {\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"burn\",\n      args: [tokenId]\n    });\n  });\n}\n\nfunction toWei(amount) {\n  return utils.parseEther(AmountSchema.parse(amount));\n}\n\n/**\n * Claim ERC721 NFTs from a Zora Drop\n * @remarks Purchase NFTs on a Zora Drop\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * await contract.erc721.claim(tokenId, quantity);\n * ```\n */\nclass Erc721ClaimableZora {\n  featureName = FEATURE_NFT_CLAIM_ZORA.name;\n  constructor(erc721, contractWrapper) {\n    this.erc721 = erc721;\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * Claim NFT\n   *\n   * @remarks Let the specified wallet claim NFTs.\n   *\n   * @example\n   * ```javascript\n   * const address = \"{{wallet_address}}\"; // address of the wallet you want to claim the NFTs\n   * const quantity = 1; // how many NFTs you want to claim\n   *\n   * const tx = await contract.erc721.claimTo(address, quantity);\n   * const receipt = tx[0].receipt; // the transaction receipt\n   * ```\n   *\n   * @param destinationAddress - Address you want to send the token to, needs to be the connected wallet address\n   * @param quantity - Quantity of the tokens you want to claim\n   * @param options - Not applicable\n   *\n   * @returns - Receipt for the transaction\n   */\n  to = /* @__PURE__ */buildTransactionFunction(async (destinationAddress, quantity, options) => {\n    // TODO validation on destinationAddr / options\n    const signerAddress = await this.contractWrapper.getSigner()?.getAddress();\n    if (destinationAddress !== signerAddress) {\n      throw new Error(\"Zora Drop: Destination address must match connected wallet address\");\n    }\n    if (options?.pricePerToken) {\n      throw new Error(\"Zora Drop: Custom pricePerToken is not supported. Price is automatically calculated\");\n    }\n    const saleDetails = await this.getSaleDetails();\n    const price = saleDetails.publicSalePrice;\n    const zoraFee = toWei(\"0.000777\");\n    const totalPrice = BigNumber.from(price).add(zoraFee).mul(quantity);\n    const tx = Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"purchase\",\n      args: [quantity],\n      overrides: {\n        value: totalPrice\n      }\n    });\n    tx.setParse(receipt => {\n      const event = this.contractWrapper.parseLogs(\"Sale\", receipt?.logs);\n      const startingIndex = event[0].args.firstPurchasedTokenId;\n      const endingIndex = startingIndex.add(quantity);\n      const results = [];\n      for (let id = startingIndex; id.lt(endingIndex); id = id.add(1)) {\n        results.push({\n          id,\n          receipt,\n          data: () => this.erc721.get(id)\n        });\n      }\n      return results;\n    });\n    return tx;\n  });\n  async getSaleDetails() {\n    return this.contractWrapper.read(\"saleDetails\", []);\n  }\n}\n\nclass Erc721LoyaltyCard {\n  featureName = FEATURE_NFT_LOYALTY_CARD.name;\n  constructor(contractWrapper) {\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * Cancel loyalty card NFTs\n   *\n   * @remarks Cancel loyalty card NFTs held by the connected wallet\n   *\n   * @example\n   * ```javascript\n   * // The token ID of the loyalty card you want to cancel\n   * const tokenId = 0;\n   *\n   * await contract.nft.loyaltyCard.cancel(tokenId);\n   * ```\n   */\n  cancel = /* @__PURE__ */buildTransactionFunction(async tokenId => {\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"cancel\",\n      args: [tokenId]\n    });\n  });\n\n  /**\n   * Revoke loyalty card NFTs\n   *\n   * @remarks Revoke loyalty card NFTs held by some owner.\n   *\n   * @example\n   * ```javascript\n   * // The token ID of the loyalty card you want to revoke\n   * const tokenId = 0;\n   *\n   * await contract.nft.loyaltyCard.revoke(tokenId);\n   * ```\n   */\n  revoke = /* @__PURE__ */buildTransactionFunction(async tokenId => {\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"revoke\",\n      args: [tokenId]\n    });\n  });\n}\n\nclass Erc721UpdatableMetadata {\n  featureName = FEATURE_NFT_UPDATABLE_METADATA.name;\n  constructor(contractWrapper, storage) {\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n  }\n\n  /**\n   * Update the metadata of an NFT\n   *\n   * @remarks Update the metadata of an NFT\n   *\n   * @example\n   * ```javascript\n   * // The token ID of the NFT whose metadata you want to update\n   * const tokenId = 0;\n   * // The new metadata\n   * const metadata = { name: \"My NFT\", description: \"My NFT description\"\"}\n   *\n   * await contract.nft.metadata.update(tokenId, metadata);\n   * ```\n   */\n  update = /* @__PURE__ */buildTransactionFunction(async (tokenId, metadata) => {\n    const uri = await uploadOrExtractURI(metadata, this.storage);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"setTokenURI\",\n      args: [tokenId, uri]\n    });\n  });\n}\n\n/**\n * Set shared metadata for ERC721 NFTs (Open Edition)\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * await contract.erc721.sharedMetadata.set(metadata);\n * ```\n */\nclass Erc721SharedMetadata {\n  featureName = FEATURE_NFT_SHARED_METADATA.name;\n  constructor(contractWrapper, storage) {\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n  }\n\n  /**\n   * Get Shared Metadata\n   *\n   * @remarks Get the shared metadata for the Open Edition NFTs.\n   *\n   * @example\n   * ```javascript\n   * const contract = await sdk.getContract(\"{{contract_address}}\");\n   *\n   * const tx = await contract.erc721.sharedMetadata.get();\n   * ```\n   *\n   * @returns - The shared metadata for the Open Edition NFTs.\n   */\n  async get() {\n    const metadata = await this.contractWrapper.read(\"sharedMetadata\", []);\n    if (metadata.every(value => value === \"\")) {\n      return undefined;\n    }\n    return {\n      name: metadata.name,\n      description: metadata.description,\n      image: metadata.imageURI,\n      animation_url: metadata.animationURI\n    };\n  }\n\n  /**\n   * Set Shared Metadata\n   *\n   * @remarks Set the shared metadata for the Open Edition NFTs.\n   *\n   * @example\n   * ```javascript\n   * const metadata = {\n   *  name: \"My NFT\",\n   *  description: \"This is my NFT\",\n   *  image: ...\n   *  animation_url: ...\n   * };\n   *\n   * const contract = await sdk.getContract(\"{{contract_address}}\");\n   *\n   * const tx = await contract.erc721.sharedMetadata.set(metadata);\n   * ```\n   *\n   * @param metadata - The metadata you want to set for the shared metadata.\n   *\n   * @returns - Receipt for the transaction\n   */\n  set = /* @__PURE__ */buildTransactionFunction(async metadata => {\n    const parsedMetadata = BasicNFTInput.parse(metadata);\n    // cleanup description\n    parsedMetadata.description = this.sanitizeJSONString(parsedMetadata.description);\n\n    // take the input and upload image and animation if it is not a URI already\n    const batch = [];\n    if (isFileOrBuffer(parsedMetadata.image)) {\n      batch.push(this.storage.upload(parsedMetadata.image));\n    } else if (typeof parsedMetadata.image === \"string\") {\n      batch.push(Promise.resolve(parsedMetadata.image));\n    } else {\n      batch.push(Promise.resolve(undefined));\n    }\n    if (isFileOrBuffer(parsedMetadata.animation_url)) {\n      batch.push(this.storage.upload(parsedMetadata.animation_url));\n    } else if (typeof parsedMetadata.animation_url === \"string\") {\n      batch.push(Promise.resolve(parsedMetadata.animation_url));\n    } else {\n      batch.push(Promise.resolve(undefined));\n    }\n    const [imageUri, animationUri] = await Promise.all(batch);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"setSharedMetadata\",\n      args: [{\n        name: `${parsedMetadata.name || \"\"}`,\n        description: parsedMetadata.description || \"\",\n        imageURI: imageUri || \"\",\n        animationURI: animationUri || \"\"\n      }]\n    });\n  });\n  sanitizeJSONString(val) {\n    if (!val) {\n      return val;\n    }\n    const sanitized = JSON.stringify(val);\n    return sanitized.slice(1, sanitized.length - 1);\n  }\n}\n\n/**\n * Enables generating dynamic ERC721 NFTs with rules and an associated signature, which can then be minted by anyone securely\n * @public\n */\nclass Erc721WithQuantitySignatureMintable {\n  featureName = FEATURE_NFT_SIGNATURE_MINTABLE_V2.name;\n  constructor(contractWrapper, storage) {\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n  }\n\n  /**\n   * Mint a dynamically generated NFT\n   *\n   * @remarks Mint a dynamic NFT with a previously generated signature.\n   *\n   * @example\n   * ```javascript\n   * // see how to craft a payload to sign in the `generate()` documentation\n   * const signedPayload = contract.erc721.signature.generate(payload);\n   *\n   * // now anyone can mint the NFT\n   * const tx = contract.erc721.signature.mint(signedPayload);\n   * const receipt = tx.receipt; // the mint transaction receipt\n   * const mintedId = tx.id; // the id of the NFT minted\n   * ```\n   * @param signedPayload - the previously generated payload and signature with {@link Erc721WithQuantitySignatureMintable.generate}\n   * @twfeature ERC721SignatureMint\n   */\n  mint = /* @__PURE__ */buildTransactionFunction(async signedPayload => {\n    const mintRequest = signedPayload.payload;\n    const signature = signedPayload.signature;\n    const overrides = await this.contractWrapper.getCallOverrides();\n    const parse = receipt => {\n      const t = this.contractWrapper.parseLogs(\"TokensMintedWithSignature\", receipt.logs);\n      if (t.length === 0) {\n        throw new Error(\"No MintWithSignature event found\");\n      }\n      const id = t[0].args.tokenIdMinted;\n      return {\n        id,\n        receipt\n      };\n    };\n    if (await this.isLegacyNFTContract()) {\n      const message = await this.mapLegacyPayloadToContractStruct(mintRequest);\n      const price = message.price;\n\n      // TODO: Transaction Sequence Pattern\n      await setErc20Allowance(this.contractWrapper, price, mintRequest.currencyAddress, overrides);\n      return Transaction.fromContractWrapper({\n        contractWrapper: this.contractWrapper,\n        method: \"mintWithSignature\",\n        args: [message, signature],\n        overrides,\n        parse\n      });\n    } else {\n      const message = await this.mapPayloadToContractStruct(mintRequest);\n      const price = message.pricePerToken.mul(message.quantity);\n\n      // TODO: Transaction Sequence Pattern\n      await setErc20Allowance(this.contractWrapper, price, mintRequest.currencyAddress, overrides);\n      return Transaction.fromContractWrapper({\n        contractWrapper: this.contractWrapper,\n        method: \"mintWithSignature\",\n        args: [message, signature],\n        overrides,\n        parse\n      });\n    }\n  });\n\n  /**\n   * Mint any number of dynamically generated NFT at once\n   * @remarks Mint multiple dynamic NFTs in one transaction. Note that this is only possible for free mints (cannot batch mints with a price attached to it for security reasons)\n   * @param signedPayloads - the array of signed payloads to mint\n   * @twfeature ERC721SignatureMint\n   */\n  mintBatch = /* @__PURE__ */buildTransactionFunction(async signedPayloads => {\n    const isLegacyNFTContract = await this.isLegacyNFTContract();\n    const contractPayloads = (await Promise.all(signedPayloads.map(s => isLegacyNFTContract ? this.mapLegacyPayloadToContractStruct(s.payload) : this.mapPayloadToContractStruct(s.payload)))).map((message, index) => {\n      const s = signedPayloads[index];\n      const signature = s.signature;\n      const price = s.payload.price;\n      if (BigNumber.from(price).gt(0)) {\n        throw new Error(\"Can only batch free mints. For mints with a price, use regular mint()\");\n      }\n      return {\n        message,\n        signature\n      };\n    });\n    const contractEncoder = new ContractEncoder(this.contractWrapper);\n    const encoded = contractPayloads.map(p => {\n      if (isLegacyNFTContract) {\n        return contractEncoder.encode(\"mintWithSignature\", [p.message, p.signature]);\n      } else {\n        return contractEncoder.encode(\"mintWithSignature\", [p.message, p.signature]);\n      }\n    });\n    if (hasFunction(\"multicall\", this.contractWrapper)) {\n      return Transaction.fromContractWrapper({\n        contractWrapper: this.contractWrapper,\n        method: \"multicall\",\n        args: [encoded],\n        parse: receipt => {\n          const events = this.contractWrapper.parseLogs(\"TokensMintedWithSignature\", receipt.logs);\n          if (events.length === 0) {\n            throw new Error(\"No MintWithSignature event found\");\n          }\n          return events.map(log => ({\n            id: log.args.tokenIdMinted,\n            receipt\n          }));\n        }\n      });\n    } else {\n      throw new Error(\"Multicall not available on this contract!\");\n    }\n  });\n\n  /**\n   * Verify that a payload is correctly signed\n   * @param signedPayload - the payload to verify\n   * @twfeature ERC721SignatureMint\n   *\n   * @example\n   * ```javascript\n   * const nftMetadata = {\n   *   name: \"Cool NFT #1\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   * };\n   *\n   * const startTime = new Date();\n   * const endTime = new Date(Date.now() + 60 * 60 * 24 * 1000);\n   * const payload = {\n   *   metadata: nftMetadata, // The NFT to mint\n   *   to: {{wallet_address}}, // Who will receive the NFT\n   *   quantity: 2, // the quantity of NFTs to mint\n   *   price: 0.5, // the price per NFT\n   *   currencyAddress: NATIVE_TOKEN_ADDRESS, // the currency to pay with\n   *   mintStartTime: startTime, // can mint anytime from now\n   *   mintEndTime: endTime, // to 24h from now\n   *   royaltyRecipient: \"0x...\", // custom royalty recipient for this NFT\n   *   royaltyBps: 100, // custom royalty fees for this NFT (in bps)\n   *   primarySaleRecipient: \"0x...\", // custom sale recipient for this NFT\n   * };\n   *\n   * const signedPayload = await contract.erc721.signature.generate(payload);\n   * // Now you can verify if the signed payload is valid\n   * const isValid = await contract.erc721.signature.verify(signedPayload);\n   * ```\n   */\n  async verify(signedPayload) {\n    const isLegacyNFTContract = await this.isLegacyNFTContract();\n    const mintRequest = signedPayload.payload;\n    const signature = signedPayload.signature;\n    let message;\n    let verification;\n    if (isLegacyNFTContract) {\n      message = await this.mapLegacyPayloadToContractStruct(mintRequest);\n      verification = await this.contractWrapper.read(\"verify\", [message, signature]);\n    } else {\n      message = await this.mapPayloadToContractStruct(mintRequest);\n      verification = await this.contractWrapper.read(\"verify\", [message, signature]);\n    }\n    return verification[0];\n  }\n\n  /**\n   * Generate a signature that can be used to mint a dynamic NFT\n   *\n   * @remarks Takes in an NFT and some information about how it can be minted, uploads the metadata and signs it with your private key. The generated signature can then be used to mint an NFT using the exact payload and signature generated.\n   *\n   * @example\n   * ```javascript\n   * const nftMetadata = {\n   *   name: \"Cool NFT #1\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   * };\n   *\n   * const startTime = new Date();\n   * const endTime = new Date(Date.now() + 60 * 60 * 24 * 1000);\n   * const payload = {\n   *   metadata: nftMetadata, // The NFT to mint\n   *   to: {{wallet_address}}, // Who will receive the NFT\n   *   quantity: 2, // the quantity of NFTs to mint\n   *   price: 0.5, // the price per NFT\n   *   currencyAddress: NATIVE_TOKEN_ADDRESS, // the currency to pay with\n   *   mintStartTime: startTime, // can mint anytime from now\n   *   mintEndTime: endTime, // to 24h from now\n   *   royaltyRecipient: \"0x...\", // custom royalty recipient for this NFT\n   *   royaltyBps: 100, // custom royalty fees for this NFT (in bps)\n   *   primarySaleRecipient: \"0x...\", // custom sale recipient for this NFT\n   * };\n   *\n   * const signedPayload = await contract.erc721.signature.generate(payload);\n   * // now anyone can use these to mint the NFT using `contract.erc721.signature.mint(signedPayload)`\n   * ```\n   * @param mintRequest - the payload to sign\n   * @returns the signed payload and the corresponding signature\n   * @twfeature ERC721SignatureMint\n   */\n  async generate(mintRequest) {\n    return (await this.generateBatch([mintRequest]))[0];\n  }\n\n  /**\n   * Genrate a batch of signatures that can be used to mint many dynamic NFTs.\n   *\n   * @remarks See {@link Erc721WithQuantitySignatureMintable.generate}\n   *\n   * @param payloadsToSign - the payloads to sign\n   * @returns an array of payloads and signatures\n   * @twfeature ERC721SignatureMint\n   */\n  async generateBatch(payloadsToSign) {\n    const isLegacyNFTContract = await this.isLegacyNFTContract();\n    const parsedRequests = await Promise.all(payloadsToSign.map(m => Signature721WithQuantityInput.parseAsync(m)));\n    const metadatas = parsedRequests.map(r => r.metadata);\n    const uris = await uploadOrExtractURIs(metadatas, this.storage);\n    const chainId = await this.contractWrapper.getChainID();\n    const signer = this.contractWrapper.getSigner();\n    invariant(signer, \"No signer available\");\n    return await Promise.all(parsedRequests.map(async (m, i) => {\n      const uri = uris[i];\n      const finalPayload = await Signature721WithQuantityOutput.parseAsync({\n        ...m,\n        uri\n      });\n      let signature;\n      if (isLegacyNFTContract) {\n        signature = await this.contractWrapper.signTypedData(signer, {\n          name: \"TokenERC721\",\n          version: \"1\",\n          chainId,\n          verifyingContract: this.contractWrapper.address\n        }, {\n          MintRequest: MintRequest721\n        }, await this.mapLegacyPayloadToContractStruct(finalPayload));\n      } else {\n        signature = await this.contractWrapper.signTypedData(signer, {\n          name: \"SignatureMintERC721\",\n          version: \"1\",\n          chainId,\n          verifyingContract: await this.contractWrapper.address\n        }, {\n          MintRequest: MintRequest721withQuantity\n        },\n        // TYPEHASH\n        await this.mapPayloadToContractStruct(finalPayload));\n      }\n      return {\n        payload: finalPayload,\n        signature: signature.toString()\n      };\n    }));\n  }\n\n  /** ******************************\n   * PRIVATE FUNCTIONS\n   *******************************/\n\n  /**\n   * Maps a payload to the format expected by the contract\n   *\n   * @internal\n   *\n   * @param mintRequest - The payload to map.\n   * @returns - The mapped payload.\n   */\n  async mapPayloadToContractStruct(mintRequest) {\n    const normalizedPricePerToken = await normalizePriceValue(this.contractWrapper.getProvider(), mintRequest.price, mintRequest.currencyAddress);\n    return {\n      to: mintRequest.to,\n      royaltyRecipient: mintRequest.royaltyRecipient,\n      royaltyBps: mintRequest.royaltyBps,\n      primarySaleRecipient: mintRequest.primarySaleRecipient,\n      uri: mintRequest.uri,\n      quantity: mintRequest.quantity,\n      pricePerToken: normalizedPricePerToken,\n      currency: mintRequest.currencyAddress,\n      validityStartTimestamp: mintRequest.mintStartTime,\n      validityEndTimestamp: mintRequest.mintEndTime,\n      uid: mintRequest.uid\n    };\n  }\n  async mapLegacyPayloadToContractStruct(mintRequest) {\n    const normalizedPricePerToken = await normalizePriceValue(this.contractWrapper.getProvider(), mintRequest.price, mintRequest.currencyAddress);\n    return {\n      to: mintRequest.to,\n      price: normalizedPricePerToken,\n      uri: mintRequest.uri,\n      currency: mintRequest.currencyAddress,\n      validityEndTimestamp: mintRequest.mintEndTime,\n      validityStartTimestamp: mintRequest.mintStartTime,\n      uid: mintRequest.uid,\n      royaltyRecipient: mintRequest.royaltyRecipient,\n      royaltyBps: mintRequest.royaltyBps,\n      primarySaleRecipient: mintRequest.primarySaleRecipient\n    };\n  }\n  async isLegacyNFTContract() {\n    return detectContractFeature(this.contractWrapper, \"ERC721SignatureMintV1\");\n  }\n}\n\n/**\n * Standard ERC721 NFT functions\n * @remarks Basic functionality for a ERC721 contract that handles IPFS storage for you.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * await contract.erc721.transfer(walletAddress, tokenId);\n * ```\n * @public\n */\nclass Erc721 {\n  featureName = FEATURE_NFT.name;\n  get chainId() {\n    return this._chainId;\n  }\n  constructor(contractWrapper, storage, chainId) {\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n    this.query = this.detectErc721Enumerable();\n    this.mintable = this.detectErc721Mintable();\n    this.burnable = this.detectErc721Burnable();\n    this.lazyMintable = this.detectErc721LazyMintable();\n    this.tieredDropable = this.detectErc721TieredDrop();\n    this.signatureMintable = this.detectErc721SignatureMintable();\n    this.claimWithConditions = this.detectErc721ClaimableWithConditions();\n    this.claimCustom = this.detectErc721Claimable();\n    this.claimZora = this.detectErc721ClaimableZora();\n    this.erc721SharedMetadata = this.detectErc721SharedMetadata();\n    this.loyaltyCard = this.detectErc721LoyaltyCard();\n    this.updatableMetadata = this.detectErc721UpdatableMetadata();\n    this._chainId = chainId;\n  }\n\n  /**\n   * @internal\n   */\n  onNetworkUpdated(network) {\n    this.contractWrapper.updateSignerOrProvider(network);\n  }\n  getAddress() {\n    return this.contractWrapper.address;\n  }\n\n  ////// Standard ERC721 Extension //////\n\n  /**\n   * Get a single NFT\n   *\n   * @example\n   * ```javascript\n   * const tokenId = 0;\n   * const nft = await contract.erc721.get(tokenId);\n   * ```\n   * @param tokenId - the tokenId of the NFT to retrieve\n   * @returns The NFT metadata\n   * @twfeature ERC721\n   */\n  async get(tokenId) {\n    const [owner, metadata] = await Promise.all([this.ownerOf(tokenId).catch(() => constants.AddressZero), this.getTokenMetadata(tokenId).catch(() => ({\n      id: tokenId.toString(),\n      uri: \"\",\n      ...FALLBACK_METADATA\n    }))]);\n    return {\n      owner,\n      metadata,\n      type: \"ERC721\",\n      supply: \"1\"\n    };\n  }\n\n  /**\n   * Get the current owner of an NFT\n   *\n   * @param tokenId - the tokenId of the NFT\n   * @returns the address of the owner\n   * @twfeature ERC721\n   */\n  async ownerOf(tokenId) {\n    return await this.contractWrapper.read(\"ownerOf\", [tokenId]);\n  }\n\n  /**\n   * Get NFT balance of a specific wallet\n   *\n   * @remarks Get a wallets NFT balance (number of NFTs in this contract owned by the wallet).\n   *\n   * @example\n   * ```javascript\n   * const walletAddress = \"{{wallet_address}}\";\n   * const balance = await contract.erc721.balanceOf(walletAddress);\n   * console.log(balance);\n   * ```\n   * @twfeature ERC721\n   */\n  async balanceOf(address) {\n    return await this.contractWrapper.read(\"balanceOf\", [await resolveAddress(address)]);\n  }\n\n  /**\n   * Get NFT balance for the currently connected wallet\n   */\n  async balance() {\n    return await this.balanceOf(await this.contractWrapper.getSignerAddress());\n  }\n\n  /**\n   * Get whether this wallet has approved transfers from the given operator\n   * @param address - the wallet address\n   * @param operator - the operator address\n   */\n  async isApproved(address, operator) {\n    const [_address, _operator] = await Promise.all([resolveAddress(address), resolveAddress(operator)]);\n    return await this.contractWrapper.read(\"isApprovedForAll\", [_address, _operator]);\n  }\n\n  /**\n   * Transfer an NFT\n   *\n   * @remarks Transfer an NFT from the connected wallet to another wallet.\n   *\n   * @example\n   * ```javascript\n   * const walletAddress = \"{{wallet_address}}\";\n   * const tokenId = 0;\n   * await contract.erc721.transfer(walletAddress, tokenId);\n   * ```\n   * @twfeature ERC721\n   */\n  transfer = /* @__PURE__ */buildTransactionFunction(async (to, tokenId) => {\n    const [from, _to] = await Promise.all([this.contractWrapper.getSignerAddress(), resolveAddress(to)]);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"transferFrom(address,address,uint256)\",\n      args: [from, _to, tokenId]\n    });\n  });\n\n  /**\n   * Transfer an NFT from a specific wallet\n   *\n   * @remarks Transfer an NFT from the given wallet to another wallet.\n   *\n   * @example\n   * ```javascript\n   * const fromWalletAddress = \"{{wallet_address}}\";\n   * const toWalletAddress = \"{{wallet_address}}\";\n   * const tokenId = 0;\n   * await contract.erc721.transferFrom(fromWalletAddress, toWalletAddress, tokenId);\n   * ```\n   * @twfeature ERC721\n   */\n  transferFrom = /* @__PURE__ */buildTransactionFunction(async (from, to, tokenId) => {\n    const [fromAddress, toAddress] = await Promise.all([resolveAddress(from), resolveAddress(to)]);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"transferFrom(address,address,uint256)\",\n      args: [fromAddress, toAddress, tokenId]\n    });\n  });\n\n  /**\n   * Set approval for all NFTs\n   * @remarks Approve or remove operator as an operator for the caller. Operators can call transferFrom or safeTransferFrom for any token owned by the caller.\n   * @example\n   * ```javascript\n   * const operator = \"{{wallet_address}}\";\n   * await contract.erc721.setApprovalForAll(operator, true);\n   * ```\n   * @param operator - the operator's address\n   * @param approved - whether to approve or remove\n   * @twfeature ERC721\n   */\n  setApprovalForAll = /* @__PURE__ */buildTransactionFunction(async (operator, approved) => {\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"setApprovalForAll\",\n      args: [await resolveAddress(operator), approved]\n    });\n  });\n\n  /**\n   * Set approval for a single NFT\n   * @remarks Approve an operator for the NFT owner. Operators can call transferFrom or safeTransferFrom for the specified token.\n   * @example\n   * ```javascript\n   * const operator = \"{{wallet_address}}\";\n   * const tokenId = 0;\n   * await contract.erc721.setApprovalForToken(operator, tokenId);\n   * ```\n   * @param operator - the operator's address\n   * @param tokenId - the tokenId to give approval for\n   *\n   * @internal\n   */\n  setApprovalForToken = /* @__PURE__ */buildTransactionFunction(async (operator, tokenId) => {\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"approve\",\n      args: [await resolveAddress(operator), tokenId]\n    });\n  });\n\n  ////// ERC721 Supply Extension //////\n\n  /**\n   * Get all NFTs\n   *\n   * @remarks Get all the data associated with every NFT in this contract.\n   *\n   * By default, returns the first 100 NFTs, use queryParams to fetch more.\n   *\n   * @example\n   * ```javascript\n   * const nfts = await contract.erc721.getAll();\n   * console.log(nfts);\n   * ```\n   * @param queryParams - optional filtering to only fetch a subset of results.\n   * @returns The NFT metadata for all NFTs queried.\n   * @twfeature ERC721Supply | ERC721Enumerable\n   */\n  async getAll(queryParams) {\n    return assertEnabled(this.query, FEATURE_NFT_SUPPLY).all(queryParams);\n  }\n\n  /**\n   * Get all NFT owners\n   * @example\n   * ```javascript\n   * const owners = await contract.erc721.getAllOwners();\n   * console.log(owners);\n   * ```\n   * @returns an array of token ids and owners\n   * @twfeature ERC721Supply | ERC721Enumerable\n   */\n  async getAllOwners() {\n    return assertEnabled(this.query, FEATURE_NFT_SUPPLY).allOwners();\n  }\n\n  /**\n   * Get the total number of NFTs minted\n   * @remarks This returns the total number of NFTs minted in this contract, **not** the total supply of a given token.\n   * @example\n   * ```javascript\n   * const count = await contract.erc721.totalCount();\n   * console.log(count);\n   * ```\n   *\n   * @returns the total number of NFTs minted in this contract\n   * @public\n   */\n  async totalCount() {\n    return this.nextTokenIdToMint();\n  }\n\n  /**\n   * Get the total count NFTs minted in this contract\n   * @twfeature ERC721Supply | ERC721Enumerable\n   */\n  async totalCirculatingSupply() {\n    return assertEnabled(this.query, FEATURE_NFT_SUPPLY).totalCirculatingSupply();\n  }\n\n  ////// ERC721 Enumerable Extension //////\n\n  /**\n   * Get all NFTs owned by a specific wallet\n   *\n   * @remarks Get all the data associated with the NFTs owned by a specific wallet.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet to get the NFTs of\n   * const address = \"{{wallet_address}}\";\n   * const nfts = await contract.erc721.getOwned(address);\n   * console.log(nfts);\n   * ```\n   * @param walletAddress - the wallet address to query, defaults to the connected wallet\n   * @returns The NFT metadata for all NFTs in the contract.\n   * @twfeature ERC721Supply | ERC721Enumerable\n   */\n  async getOwned(walletAddress) {\n    if (walletAddress) {\n      walletAddress = await resolveAddress(walletAddress);\n    }\n    if (this.query?.owned) {\n      return this.query.owned.all(walletAddress);\n    } else {\n      const [address, allOwners] = await Promise.all([walletAddress || this.contractWrapper.getSignerAddress(), this.getAllOwners()]);\n      return await Promise.all((allOwners || []).filter(i => address?.toLowerCase() === i.owner?.toLowerCase()).map(i => this.get(i.tokenId)));\n    }\n  }\n\n  /**\n   * Get all token ids of NFTs owned by a specific wallet.\n   * @param walletAddress - the wallet address to query, defaults to the connected wallet\n   */\n  async getOwnedTokenIds(walletAddress) {\n    if (walletAddress) {\n      walletAddress = await resolveAddress(walletAddress);\n    }\n    if (this.query?.owned) {\n      return this.query.owned.tokenIds(walletAddress);\n    } else {\n      const [address, allOwners] = await Promise.all([walletAddress || this.contractWrapper.getSignerAddress(), this.getAllOwners()]);\n      return (allOwners || []).filter(i => address?.toLowerCase() === i.owner?.toLowerCase()).map(i => BigNumber.from(i.tokenId));\n    }\n  }\n\n  ////// ERC721 Mintable Extension //////\n\n  /**\n   * Mint an NFT\n   *\n   * @remarks Mint an NFT to the connected wallet.\n   *\n   * @example\n   * ```javascript\n   * // Custom metadata of the NFT, note that you can fully customize this metadata with other properties.\n   * const metadata = {\n   *   name: \"Cool NFT\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   * };\n   *\n   * const tx = await contract.erc721.mint(metadata);\n   * const receipt = tx.receipt; // the transaction receipt\n   * const tokenId = tx.id; // the id of the NFT minted\n   * const nft = await tx.data(); // (optional) fetch details of minted NFT\n   * ```\n   * @twfeature ERC721Mintable\n   */\n  mint = /* @__PURE__ */buildTransactionFunction(async metadata => {\n    return this.mintTo.prepare(await this.contractWrapper.getSignerAddress(), metadata);\n  });\n\n  /**\n   * Mint an NFT to a specific wallet\n   *\n   * @remarks Mint a unique NFT to a specified wallet.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet you want to mint the NFT to\n   * const walletAddress = \"{{wallet_address}}\";\n   *\n   * // Custom metadata of the NFT, note that you can fully customize this metadata with other properties.\n   * const metadata = {\n   *   name: \"Cool NFT\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   * };\n   *\n   * const tx = await contract.erc721.mintTo(walletAddress, metadata);\n   * const receipt = tx.receipt; // the transaction receipt\n   * const tokenId = tx.id; // the id of the NFT minted\n   * const nft = await tx.data(); // (optional) fetch details of minted NFT\n   * ```\n   * @twfeature ERC721Mintable\n   */\n  mintTo = /* @__PURE__ */buildTransactionFunction(async (receiver, metadata) => {\n    return assertEnabled(this.mintable, FEATURE_NFT_MINTABLE).to.prepare(receiver, metadata);\n  });\n\n  /**\n   * Construct a mint transaction without executing it.\n   * This is useful for estimating the gas cost of a mint transaction, overriding transaction options and having fine grained control over the transaction execution.\n   * @param receiver - Address you want to send the token to\n   * @param metadata - The metadata of the NFT you want to mint\n   *\n   * @deprecated Use `contract.erc721.mint.prepare(...args)` instead\n   * @twfeature ERC721Mintable\n   */\n  async getMintTransaction(receiver, metadata) {\n    return this.mintTo.prepare(receiver, metadata);\n  }\n\n  ////// ERC721 Batch Mintable Extension //////\n\n  /**\n   * Mint many NFTs\n   *\n   * @remarks Mint many unique NFTs at once to the connected wallet\n   *\n   * @example\n   * ```javascript*\n   * // Custom metadata of the NFTs you want to mint.\n   * const metadatas = [{\n   *   name: \"Cool NFT #1\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   * }, {\n   *   name: \"Cool NFT #2\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/other/image.png\"),\n   * }];\n   *\n   * const tx = await contract.erc721.mintBatch(metadatas);\n   * const receipt = tx[0].receipt; // same transaction receipt for all minted NFTs\n   * const firstTokenId = tx[0].id; // token id of the first minted NFT\n   * const firstNFT = await tx[0].data(); // (optional) fetch details of the first minted NFT\n   * ```\n   * @twfeature ERC721BatchMintable\n   */\n  mintBatch = /* @__PURE__ */buildTransactionFunction(async metadatas => {\n    return this.mintBatchTo.prepare(await this.contractWrapper.getSignerAddress(), metadatas);\n  });\n\n  /**\n   * Mint many NFTs to a specific wallet\n   *\n   * @remarks Mint many unique NFTs at once to a specified wallet.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet you want to mint the NFT to\n   * const walletAddress = \"{{wallet_address}}\";\n   *\n   * // Custom metadata of the NFTs you want to mint.\n   * const metadatas = [{\n   *   name: \"Cool NFT #1\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   * }, {\n   *   name: \"Cool NFT #2\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/other/image.png\"),\n   * }];\n   *\n   * const tx = await contract.erc721.mintBatchTo(walletAddress, metadatas);\n   * const receipt = tx[0].receipt; // same transaction receipt for all minted NFTs\n   * const firstTokenId = tx[0].id; // token id of the first minted NFT\n   * const firstNFT = await tx[0].data(); // (optional) fetch details of the first minted NFT\n   * ```\n   * @twfeature ERC721BatchMintable\n   */\n  mintBatchTo = /* @__PURE__ */buildTransactionFunction(async (receiver, metadatas) => {\n    return assertEnabled(this.mintable?.batch, FEATURE_NFT_BATCH_MINTABLE).to.prepare(receiver, metadatas);\n  });\n\n  ////// ERC721 Burnable Extension //////\n\n  /**\n   * Burn a single NFT\n   * @param tokenId - the token Id to burn\n   *\n   * @example\n   * ```javascript\n   * const result = await contract.erc721.burn(tokenId);\n   * ```\n   * @twfeature ERC721Burnable\n   */\n  burn = /* @__PURE__ */buildTransactionFunction(async tokenId => {\n    return assertEnabled(this.burnable, FEATURE_NFT_BURNABLE).token.prepare(tokenId);\n  });\n\n  ////// ERC721 Loyalty Card Extension //////\n\n  /**\n   * Cancel loyalty card NFTs\n   *\n   * @remarks Cancel loyalty card NFTs held by the connected wallet\n   *\n   * @example\n   * ```javascript\n   * // The token ID of the loyalty card you want to cancel\n   * const tokenId = 0;\n   *\n   * const result = await contract.erc721.cancel(tokenId);\n   * ```\n   * @twfeature ERC721LoyaltyCard\n   */\n  cancel = /* @__PURE__ */buildTransactionFunction(async tokenId => {\n    return assertEnabled(this.loyaltyCard, FEATURE_NFT_LOYALTY_CARD).cancel.prepare(tokenId);\n  });\n\n  /**\n   * Revoke loyalty card NFTs\n   *\n   * @remarks Revoke loyalty card NFTs held by some owner.\n   *\n   * @example\n   * ```javascript\n   * // The token ID of the loyalty card you want to revoke\n   * const tokenId = 0;\n   *\n   * const result = await contract.erc721.revoke(tokenId);\n   * ```\n   * @twfeature ERC721LoyaltyCard\n   */\n  revoke = /* @__PURE__ */buildTransactionFunction(async tokenId => {\n    return assertEnabled(this.loyaltyCard, FEATURE_NFT_LOYALTY_CARD).revoke.prepare(tokenId);\n  });\n\n  ////// ERC721 LazyMint Extension //////\n\n  /**\n   * Lazy mint NFTs\n   *\n   * @remarks Create batch allows you to create a batch of many unique NFTs in one transaction.\n   *\n   * @example\n   * ```javascript\n   * // Custom metadata of the NFTs to create\n   * const metadatas = [{\n   *   name: \"Cool NFT\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   * }, {\n   *   name: \"Cool NFT\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"),\n   * }];\n   *\n   * const results = await contract.erc721.lazyMint(metadatas); // uploads and creates the NFTs on chain\n   * const firstTokenId = results[0].id; // token id of the first created NFT\n   * const firstNFT = await results[0].data(); // (optional) fetch details of the first created NFT\n   * ```\n   *\n   * @param metadatas - The metadata to include in the batch.\n   * @param options - optional upload progress callback\n   * @twfeature ERC721LazyMintable\n   */\n  lazyMint = /* @__PURE__ */buildTransactionFunction(async (metadatas, options) => {\n    return assertEnabled(this.lazyMintable, FEATURE_NFT_LAZY_MINTABLE).lazyMint.prepare(metadatas, options);\n  });\n\n  ////// ERC721 Metadata Extension //////\n\n  /**\n   * Update the metadata of an NFT\n   *\n   * @remarks Update the metadata of an NFT\n   *\n   * @example\n   * ```javascript\n   * // The token ID of the NFT whose metadata you want to update\n   * const tokenId = 0;\n   * // The new metadata\n   * const metadata = { name: \"My NFT\", description: \"My NFT description\"\"}\n   *\n   * await contract.erc721.update(tokenId, metadata);\n   * ```\n   * @twfeature ERC721UpdatableMetadata\n   */\n  update = /* @__PURE__ */buildTransactionFunction(async (tokenId, metadata) => {\n    return assertEnabled(this.updatableMetadata, FEATURE_NFT_UPDATABLE_METADATA).update.prepare(tokenId, metadata);\n  });\n\n  ////// ERC721 Claimable Extension //////\n\n  /**\n   * Claim NFTs\n   *\n   * @remarks Let the specified wallet claim NFTs.\n   *\n   * @example\n   * ```javascript\n   * const quantity = 1; // how many unique NFTs you want to claim\n   *\n   * const tx = await contract.erc721.claim(quantity);\n   * const receipt = tx.receipt; // the transaction receipt\n   * const claimedTokenId = tx.id; // the id of the NFT claimed\n   * const claimedNFT = await tx.data(); // (optional) get the claimed NFT metadata\n   * ```\n   *\n   * @param quantity - Quantity of the tokens you want to claim\n   *\n   * @returns - an array of results containing the id of the token claimed, the transaction receipt and a promise to optionally fetch the nft metadata\n   * @twfeature ERC721ClaimCustom | ERC721ClaimPhasesV2 | ERC721ClaimPhasesV1 | ERC721ClaimConditionsV2 | ERC721ClaimConditionsV1 | ERC721ClaimZora\n   */\n  claim = /* @__PURE__ */buildTransactionFunction(async (quantity, options) => {\n    return this.claimTo.prepare(await this.contractWrapper.getSignerAddress(), quantity, options);\n  });\n\n  /**\n   * Claim NFTs to a specific wallet\n   *\n   * @remarks Let the specified wallet claim NFTs.\n   *\n   * @example\n   * ```javascript\n   * const address = \"{{wallet_address}}\"; // address of the wallet you want to claim the NFTs\n   * const quantity = 1; // how many unique NFTs you want to claim\n   *\n   * const tx = await contract.erc721.claimTo(address, quantity);\n   * const receipt = tx.receipt; // the transaction receipt\n   * const claimedTokenId = tx.id; // the id of the NFT claimed\n   * const claimedNFT = await tx.data(); // (optional) get the claimed NFT metadata\n   * ```\n   *\n   * @param destinationAddress - Address you want to send the token to\n   * @param quantity - Quantity of the tokens you want to claim\n   * @param options\n   * @returns - an array of results containing the id of the token claimed, the transaction receipt and a promise to optionally fetch the nft metadata\n   * @twfeature ERC721ClaimCustom | ERC721ClaimPhasesV2 | ERC721ClaimPhasesV1 | ERC721ClaimConditionsV2 | ERC721ClaimConditionsV1 | ERC721ClaimZora\n   */\n  claimTo = /* @__PURE__ */buildTransactionFunction(async (destinationAddress, quantity, options) => {\n    const claimWithConditions = this.claimWithConditions;\n    const claim = this.claimCustom;\n    const claimZora = this.claimZora;\n    if (claimWithConditions) {\n      return claimWithConditions.to.prepare(destinationAddress, quantity, options);\n    }\n    if (claim) {\n      return claim.to.prepare(destinationAddress, quantity, options);\n    }\n    if (claimZora) {\n      return claimZora.to.prepare(destinationAddress, quantity, options);\n    }\n    throw new ExtensionNotImplementedError(FEATURE_NFT_CLAIM_CUSTOM);\n  });\n\n  /**\n   * Construct a claim transaction without executing it.\n   * This is useful for estimating the gas cost of a claim transaction, overriding transaction options and having fine grained control over the transaction execution.\n   * @param destinationAddress\n   * @param quantity\n   * @param options\n   *\n   * @deprecated Use `contract.erc721.claim.prepare(...args)` instead\n   * @twfeature ERC721ClaimCustom | ERC721ClaimPhasesV2 | ERC721ClaimPhasesV1 | ERC721ClaimConditionsV2 | ERC721ClaimConditionsV1\n   */\n  async getClaimTransaction(destinationAddress, quantity, options) {\n    const claimWithConditions = this.claimWithConditions;\n    const claim = this.claimCustom;\n    if (claimWithConditions) {\n      return claimWithConditions.conditions.getClaimTransaction(destinationAddress, quantity, options);\n    }\n    if (claim) {\n      return claim.getClaimTransaction(destinationAddress, quantity, options);\n    }\n    throw new ExtensionNotImplementedError(FEATURE_NFT_CLAIM_CUSTOM);\n  }\n\n  /**\n   * Get the claimed supply\n   *\n   * @remarks Get the number of claimed NFTs in this Drop.\n   *\n   * * @example\n   * ```javascript\n   * const claimedNFTCount = await contract.totalClaimedSupply();\n   * console.log(`NFTs claimed: ${claimedNFTCount}`);\n   * ```\n   * @returns the unclaimed supply\n   * @twfeature ERC721ClaimCustom | ERC721ClaimPhasesV2 | ERC721ClaimPhasesV1 | ERC721ClaimConditionsV2 | ERC721ClaimConditionsV1\n   */\n  async totalClaimedSupply() {\n    const contract = this.contractWrapper;\n    if (hasFunction(\"totalMinted\", contract)) {\n      return this.contractWrapper.read(\"totalMinted\", []);\n    }\n    if (hasFunction(\"nextTokenIdToClaim\", contract)) {\n      return this.contractWrapper.read(\"nextTokenIdToClaim\", []);\n    }\n    throw new Error(\"No function found on contract to get total claimed supply\");\n  }\n\n  /**\n   * Get the unclaimed supply\n   *\n   * @remarks Get the number of unclaimed NFTs in this Drop.\n   *\n   * * @example\n   * ```javascript\n   * const unclaimedNFTCount = await contract.totalUnclaimedSupply();\n   * console.log(`NFTs left to claim: ${unclaimedNFTCount}`);\n   * ```\n   * @returns the unclaimed supply\n   * @twfeature ERC721ClaimCustom | ERC721ClaimPhasesV2 | ERC721ClaimPhasesV1 | ERC721ClaimConditionsV2 | ERC721ClaimConditionsV1\n   */\n  async totalUnclaimedSupply() {\n    const [nextTokenIdToMint, totalClaimedSupply] = await Promise.all([this.nextTokenIdToMint(), this.totalClaimedSupply()]);\n    return nextTokenIdToMint.sub(totalClaimedSupply);\n  }\n\n  /**\n   * Configure claim conditions\n   * @remarks Define who can claim NFTs in the collection, when and how many.\n   * @example\n   * ```javascript\n   * const presaleStartTime = new Date();\n   * const publicSaleStartTime = new Date(Date.now() + 60 * 60 * 24 * 1000);\n   * const claimConditions = [\n   *   {\n   *     startTime: presaleStartTime, // start the presale now\n   *     maxClaimableSupply: 2, // limit how many mints for this presale\n   *     price: 0.01, // presale price\n   *     snapshot: ['0x...', '0x...'], // limit minting to only certain addresses\n   *   },\n   *   {\n   *     startTime: publicSaleStartTime, // 24h after presale, start public sale\n   *     price: 0.08, // public sale price\n   *   }\n   * ]);\n   * await contract.erc721.claimConditions.set(claimConditions);\n   * ```\n   * @twfeature ERC721ClaimPhasesV2 | ERC721ClaimPhasesV1 | ERC721ClaimConditionsV2 | ERC721ClaimConditionsV1\n   */\n  get claimConditions() {\n    return assertEnabled(this.claimWithConditions, FEATURE_NFT_CLAIM_CONDITIONS_V2).conditions;\n  }\n\n  ////// ERC721 Tiered Drop Extension //////\n\n  /**\n   * Tiered Drop\n   * @remarks Drop lazy minted NFTs using a tiered drop mechanism.\n   * @twfeature ERC721TieredDrop\n   */\n  get tieredDrop() {\n    return assertEnabled(this.tieredDropable, FEATURE_NFT_TIERED_DROP);\n  }\n\n  ////// ERC721 SignatureMint Extension //////\n\n  /**\n   * Mint with signature\n   * @remarks Generate dynamic NFTs with your own signature, and let others mint them using that signature.\n   * @example\n   * ```javascript\n   * // see how to craft a payload to sign in the `contract.erc721.signature.generate()` documentation\n   * const signedPayload = await contract.erc721.signature.generate(payload);\n   *\n   * // now anyone can mint the NFT\n   * const tx = await contract.erc721.signature.mint(signedPayload);\n   * const receipt = tx.receipt; // the mint transaction receipt\n   * const mintedId = tx.id; // the id of the NFT minted\n   * ```\n   * @twfeature ERC721SignatureMintV1 | ERC721SignatureMintV2\n   */\n  get signature() {\n    return assertEnabled(this.signatureMintable, FEATURE_NFT_SIGNATURE_MINTABLE_V2);\n  }\n\n  ////// ERC721 DelayedReveal Extension //////\n\n  /**\n   * Mint delayed reveal NFTs\n   * @remarks Create a batch of encrypted NFTs that can be revealed at a later time.\n   * @example\n   * ```javascript\n   * // the real NFTs, these will be encrypted until you reveal them\n   * const realNFTs = [{\n   *   name: \"Common NFT #1\",\n   *   description: \"Common NFT, one of many.\",\n   *   image: fs.readFileSync(\"path/to/image.png\"),\n   * }, {\n   *   name: \"Super Rare NFT #2\",\n   *   description: \"You got a Super Rare NFT!\",\n   *   image: fs.readFileSync(\"path/to/image.png\"),\n   * }];\n   * // A placeholder NFT that people will get immediately in their wallet, and will be converted to the real NFT at reveal time\n   * const placeholderNFT = {\n   *   name: \"Hidden NFT\",\n   *   description: \"Will be revealed next week!\"\n   * };\n   * // Create and encrypt the NFTs\n   * await contract.erc721.revealer.createDelayedRevealBatch(\n   *   placeholderNFT,\n   *   realNFTs,\n   *   \"my secret password\",\n   * );\n   * // Whenever you're ready, reveal your NFTs at any time\n   * const batchId = 0; // the batch to reveal\n   * await contract.erc721.revealer.reveal(batchId, \"my secret password\");\n   * ```\n   * @twfeature ERC721Revealable\n   */\n  get revealer() {\n    return assertEnabled(this.lazyMintable?.revealer, FEATURE_NFT_REVEALABLE);\n  }\n\n  ////// ERC721 Shared Metadata Extension (Open Edition) //////\n\n  /**\n   * Set shared metadata for all NFTs\n   * @remarks Set shared metadata for all NFTs in the collection. (Open Edition)\n   * @example\n   * ```javascript\n   * // defiine the metadata\n   * const metadata = {\n   *  name: \"Shared Metadata\",\n   *  description: \"Every NFT in this collection will share this metadata.\"\n   * };\n   *\n   *\n   * const tx = contract.erc721.sharedMetadata.set(metadata);\n   * ```\n   * @twfeature ERC721SharedMetadata\n   */\n  get sharedMetadata() {\n    return assertEnabled(this.erc721SharedMetadata, FEATURE_NFT_SHARED_METADATA);\n  }\n\n  /** ******************************\n   * PRIVATE FUNCTIONS\n   *******************************/\n\n  /**\n   * @internal\n   */\n  async getTokenMetadata(tokenId) {\n    const tokenUri = await this.contractWrapper.read(\"tokenURI\", [tokenId]);\n    if (!tokenUri) {\n      throw new NotFoundError();\n    }\n    return fetchTokenMetadata(tokenId, tokenUri, this.storage);\n  }\n\n  /**\n   * Return the next available token ID to mint\n   * @internal\n   */\n  async nextTokenIdToMint() {\n    if (hasFunction(\"nextTokenIdToMint\", this.contractWrapper)) {\n      let nextTokenIdToMint = await this.contractWrapper.read(\"nextTokenIdToMint\", []);\n      // handle open editions and contracts with startTokenId\n      if (hasFunction(\"startTokenId\", this.contractWrapper)) {\n        nextTokenIdToMint = nextTokenIdToMint.sub(await this.contractWrapper.read(\"startTokenId\", []));\n      }\n      return nextTokenIdToMint;\n    } else if (hasFunction(\"totalSupply\", this.contractWrapper)) {\n      return await this.contractWrapper.read(\"totalSupply\", []);\n    } else {\n      throw new Error(\"Contract requires either `nextTokenIdToMint` or `totalSupply` function available to determine the next token ID to mint\");\n    }\n  }\n  detectErc721Enumerable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC721Supply\") || hasFunction(\"nextTokenIdToMint\", this.contractWrapper)) {\n      return new Erc721Supply(this, this.contractWrapper);\n    }\n    return undefined;\n  }\n  detectErc721Mintable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC721Mintable\")) {\n      return new Erc721Mintable(this, this.contractWrapper, this.storage);\n    }\n    return undefined;\n  }\n  detectErc721Burnable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC721Burnable\")) {\n      return new Erc721Burnable(this.contractWrapper);\n    }\n    return undefined;\n  }\n  detectErc721LazyMintable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC721LazyMintable\")) {\n      return new Erc721LazyMintable(this, this.contractWrapper, this.storage);\n    }\n    return undefined;\n  }\n  detectErc721TieredDrop() {\n    if (detectContractFeature(this.contractWrapper, \"ERC721TieredDrop\")) {\n      return new Erc721TieredDrop(this, this.contractWrapper, this.storage);\n    }\n    return undefined;\n  }\n  detectErc721SignatureMintable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC721SignatureMintV1\") || detectContractFeature(this.contractWrapper, \"ERC721SignatureMintV2\")) {\n      return new Erc721WithQuantitySignatureMintable(this.contractWrapper, this.storage);\n    }\n    return undefined;\n  }\n  detectErc721ClaimableWithConditions() {\n    if (detectContractFeature(this.contractWrapper, \"ERC721ClaimConditionsV1\") || detectContractFeature(this.contractWrapper, \"ERC721ClaimConditionsV2\") || detectContractFeature(this.contractWrapper, \"ERC721ClaimPhasesV1\") || detectContractFeature(this.contractWrapper, \"ERC721ClaimPhasesV2\")) {\n      return new Erc721ClaimableWithConditions(this, this.contractWrapper, this.storage);\n    }\n    return undefined;\n  }\n  detectErc721Claimable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC721ClaimCustom\")) {\n      return new Erc721Claimable(this, this.contractWrapper);\n    }\n    return undefined;\n  }\n  detectErc721ClaimableZora() {\n    if (detectContractFeature(this.contractWrapper, \"ERC721ClaimZora\")) {\n      return new Erc721ClaimableZora(this, this.contractWrapper);\n    }\n    return undefined;\n  }\n  detectErc721SharedMetadata() {\n    if (detectContractFeature(this.contractWrapper, \"ERC721SharedMetadata\")) {\n      return new Erc721SharedMetadata(this.contractWrapper, this.storage);\n    }\n    return undefined;\n  }\n  detectErc721LoyaltyCard() {\n    if (detectContractFeature(this.contractWrapper, \"ERC721LoyaltyCard\")) {\n      return new Erc721LoyaltyCard(this.contractWrapper);\n    }\n    return undefined;\n  }\n  detectErc721UpdatableMetadata() {\n    if (detectContractFeature(this.contractWrapper, \"ERC721UpdatableMetadata\")) {\n      return new Erc721UpdatableMetadata(this.contractWrapper, this.storage);\n    }\n    return undefined;\n  }\n}\n\n/**\n * Mint Many ERC1155 NFTs at once\n * @remarks NFT batch minting functionality that handles IPFS storage for you.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * await contract.edition.mint.batch.to(walletAddress, [nftMetadataWithSupply1, nftMetadataWithSupply2, ...]);\n * ```\n * @public\n */\n\nclass Erc1155BatchMintable {\n  featureName = FEATURE_EDITION_BATCH_MINTABLE.name;\n  constructor(erc1155, contractWrapper, storage) {\n    this.erc1155 = erc1155;\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n  }\n\n  /**\n   * Mint Many NFTs with limited supplies\n   *\n   * @remarks Mint many different NFTs with limited supplies to a specified wallet.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet you want to mint the NFT to\n   * const toAddress = \"{{wallet_address}}\"\n   *\n   * // Custom metadata and supplies of your NFTs\n   * const metadataWithSupply = [{\n   *   supply: 50, // The number of this NFT you want to mint\n   *   metadata: {\n   *     name: \"Cool NFT #1\",\n   *     description: \"This is a cool NFT\",\n   *     image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   *   },\n   * }, {\n   *   supply: 100,\n   *   metadata: {\n   *     name: \"Cool NFT #2\",\n   *     description: \"This is a cool NFT\",\n   *     image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   *   },\n   * }];\n   *\n   * const tx = await contract.edition.mint.batch.to(toAddress, metadataWithSupply);\n   * const receipt = tx[0].receipt; // same transaction receipt for all minted NFTs\n   * const firstTokenId = tx[0].id; // token id of the first minted NFT\n   * const firstNFT = await tx[0].data(); // (optional) fetch details of the first minted NFT\n   * ```\n   */\n  to = /* @__PURE__ */buildTransactionFunction(async (to, metadataWithSupply) => {\n    const metadatas = metadataWithSupply.map(a => a.metadata);\n    const supplies = metadataWithSupply.map(a => a.supply);\n    const uris = await uploadOrExtractURIs(metadatas, this.storage);\n    const resolvedAddress = await resolveAddress(to);\n    const contractEncoder = new ContractEncoder(this.contractWrapper);\n    const encoded = await Promise.all(uris.map(async (uri, index) => contractEncoder.encode(\"mintTo\", [resolvedAddress, constants.MaxUint256, uri, supplies[index]])));\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"multicall\",\n      args: [encoded],\n      parse: receipt => {\n        const events = this.contractWrapper.parseLogs(\"TokensMinted\", receipt.logs);\n        if (events.length === 0 || events.length < metadatas.length) {\n          throw new Error(\"TokenMinted event not found, minting failed\");\n        }\n        return events.map(e => {\n          const id = e.args.tokenIdMinted;\n          return {\n            id,\n            receipt,\n            data: () => this.erc1155.get(id)\n          };\n        });\n      }\n    });\n  });\n}\n\nclass Erc1155Burnable {\n  featureName = FEATURE_EDITION_BURNABLE.name;\n  constructor(contractWrapper) {\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * Burn a specified amount of a NFTs\n   *\n   * @remarks Burn the specified NFTs from the connected wallet\n   *\n   * @param tokenId - the token Id to burn\n   * @param amount - amount to burn\n   *\n   * @example\n   * ```javascript\n   * // The token ID to burn NFTs of\n   * const tokenId = 0;\n   * // The amount of the NFT you want to burn\n   * const amount = 2;\n   *\n   * const result = await contract.edition.burn.tokens(tokenId, amount);\n   * ```\n   */\n  tokens = /* @__PURE__ */buildTransactionFunction(async (tokenId, amount) => {\n    const account = await this.contractWrapper.getSignerAddress();\n    return this.from.prepare(account, tokenId, amount);\n  });\n\n  /**\n   * Burn a specified amount of a NFTs\n   *\n   * @remarks Burn the specified NFTs from a specified wallet\n   *\n   * @param account - the address to burn NFTs from\n   * @param tokenId - the tokenId to burn\n   * @param amount - amount to burn\n   *\n   * @example\n   * ```javascript\n   * // The address of the wallet to burn NFTS from\n   * const account = \"0x...\";\n   * // The token ID to burn NFTs of\n   * const tokenId = 0;\n   * // The amount of this NFT you want to burn\n   * const amount = 2;\n   *\n   * const result = await contract.edition.burn.from(account, tokenId, amount);\n   * ```\n   */\n  from = /* @__PURE__ */buildTransactionFunction(async (account, tokenId, amount) => {\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"burn\",\n      args: [await resolveAddress(account), tokenId, amount]\n    });\n  });\n\n  /**\n   * Burn a batch of NFTs\n   *\n   * @remarks Burn the batch NFTs from the connected wallet\n   *\n   * @param tokenIds - the tokenIds to burn\n   * @param amounts - amount of each token to burn\n   *\n   * @example\n   * ```javascript\n   * // The token IDs to burn NFTs of\n   * const tokenIds = [0, 1];\n   * // The amounts of each NFT you want to burn\n   * const amounts = [2, 2];\n   *\n   * const result = await contract.edition.burn.batch(tokenIds, amounts);\n   * ```\n   */\n  batch = /* @__PURE__ */buildTransactionFunction(async (tokenIds, amounts) => {\n    const account = await this.contractWrapper.getSignerAddress();\n    return this.batchFrom.prepare(account, tokenIds, amounts);\n  });\n\n  /**\n   * Burn a batch of NFTs\n   *\n   * @remarks Burn the batch NFTs from the specified wallet\n   *\n   * @param account - the address to burn NFTs from\n   * @param tokenIds - the tokenIds to burn\n   * @param amounts - amount of each token to burn\n   *\n   * @example\n   * ```javascript\n   * // The address of the wallet to burn NFTS from\n   * const account = \"0x...\";\n   * // The token IDs to burn NFTs of\n   * const tokenIds = [0, 1];\n   * // The amounts of each NFT you want to burn\n   * const amounts = [2, 2];\n   *\n   * const result = await contract.edition.burn.batchFrom(account, tokenIds, amounts);\n   * ```\n   */\n  batchFrom = /* @__PURE__ */buildTransactionFunction(async (account, tokenIds, amounts) => {\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"burnBatch\",\n      args: [await resolveAddress(account), tokenIds, amounts]\n    });\n  });\n}\n\n/**\n * List ERC1155 NFTs\n * @remarks Easily list all the NFTs in a ERC1155 contract.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * const nfts = await contract.edition.query.all();\n * ```\n * @public\n */\n\nclass Erc1155Enumerable {\n  featureName = FEATURE_EDITION_ENUMERABLE.name;\n  constructor(erc1155, contractWrapper) {\n    this.erc1155 = erc1155;\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * Get All NFTs\n   *\n   * @remarks Get all the data associated with every NFT in this contract.\n   *\n   * By default, returns the first 100 NFTs, use queryParams to fetch more.\n   *\n   * @example\n   * ```javascript\n   * const nfts = await contract.edition.query.all();\n   * ```\n   * @param queryParams - optional filtering to only fetch a subset of results.\n   * @returns The NFT metadata for all NFTs queried.\n   */\n  async all(queryParams) {\n    const start = BigNumber.from(queryParams?.start || 0).toNumber();\n    const count = BigNumber.from(queryParams?.count || DEFAULT_QUERY_ALL_COUNT).toNumber();\n    const maxId = Math.min((await this.totalCount()).toNumber(), start + count);\n    return await Promise.all([...Array(maxId - start).keys()].map(i => this.erc1155.get((start + i).toString())));\n  }\n\n  /**\n   * Get the number of NFTs minted\n   * @remarks This returns the total number of NFTs minted in this contract, **not** the total supply of a given token.\n   *\n   * @returns the total number of NFTs minted in this contract\n   * @public\n   */\n  async totalCount() {\n    return await this.contractWrapper.read(\"nextTokenIdToMint\", []);\n  }\n\n  /**\n   * Get the supply of token for a given tokenId.\n   * @remarks This is **not** the sum of supply of all NFTs in the contract.\n   *\n   * @returns the total number of NFTs minted in this contract\n   * @public\n   */\n  async totalCirculatingSupply(tokenId) {\n    return await this.contractWrapper.read(\"totalSupply\", [tokenId]);\n  }\n\n  /**\n   * Get all NFTs owned by a specific wallet\n   *\n   * @remarks Get all the data associated with the NFTs owned by a specific wallet.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet to get the NFTs of\n   * const address = \"{{wallet_address}}\";\n   * const nfts = await contract.edition.query.owned(address);\n   * ```\n   *\n   * @returns The NFT metadata for all NFTs in the contract.\n   */\n  async owned(walletAddress) {\n    const [address, maxId] = await Promise.all([resolveAddress(walletAddress || (await this.contractWrapper.getSignerAddress())), this.contractWrapper.read(\"nextTokenIdToMint\", [])]);\n    const balances = await this.contractWrapper.read(\"balanceOfBatch\", [Array(maxId.toNumber()).fill(address), Array.from(Array(maxId.toNumber()).keys())]);\n    const ownedBalances = balances.map((b, i) => {\n      return {\n        tokenId: i,\n        balance: b\n      };\n    }).filter(b => b.balance.gt(0));\n    const nfts = (await Promise.all(ownedBalances.map(item => this.erc1155.get(item.tokenId.toString())))).map((editionMetadata, index) => ({\n      ...editionMetadata,\n      owner: address,\n      quantityOwned: ownedBalances[index].balance.toString()\n    }));\n    return nfts;\n  }\n}\n\nasync function getPrebuiltInfo(address, provider) {\n  try {\n    const contract = new Contract(address, IThirdwebContractABI, provider);\n    const [type, version] = await Promise.all([utils.toUtf8String(await contract.contractType()) // eslint-disable-next-line no-control-regex\n    .replace(/\\x00/g, \"\"), await contract.contractVersion()]);\n    return {\n      type,\n      version\n    };\n  } catch (e) {\n    return undefined;\n  }\n}\n\nclass Erc1155LazyMintable {\n  featureName = FEATURE_EDITION_LAZY_MINTABLE_V2.name;\n\n  /**\n   * Delayed reveal\n   * @remarks Create a batch of encrypted NFTs that can be revealed at a later time.\n   * @example\n   * ```javascript\n   * // the real NFTs, these will be encrypted until you reveal them\n   * const realNFTs = [{\n   *   name: \"Common NFT #1\",\n   *   description: \"Common NFT, one of many.\",\n   *   image: fs.readFileSync(\"path/to/image.png\"),\n   * }, {\n   *   name: \"Super Rare NFT #2\",\n   *   description: \"You got a Super Rare NFT!\",\n   *   image: fs.readFileSync(\"path/to/image.png\"),\n   * }];\n   * // A placeholder NFT that people will get immediately in their wallet, and will be converted to the real NFT at reveal time\n   * const placeholderNFT = {\n   *   name: \"Hidden NFT\",\n   *   description: \"Will be revealed next week!\"\n   * };\n   * // Create and encrypt the NFTs\n   * await contract.edition.drop.revealer.createDelayedRevealBatch(\n   *   placeholderNFT,\n   *   realNFTs,\n   *   \"my secret password\",\n   * );\n   * // Whenever you're ready, reveal your NFTs at any time\n   * const batchId = 0; // the batch to reveal\n   * await contract.edition.drop.revealer.reveal(batchId, \"my secret password\");\n   * ```\n   */\n\n  constructor(erc1155, contractWrapper, storage) {\n    this.erc1155 = erc1155;\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n    this.revealer = this.detectErc1155Revealable();\n  }\n\n  /**\n   * Create a batch of NFTs to be claimed in the future\n   *\n   * @remarks Create batch allows you to create a batch of many NFTs in one transaction.\n   *\n   * @example\n   * ```javascript\n   * // Custom metadata of the NFTs to create\n   * const metadatas = [{\n   *   name: \"Cool NFT\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   * }, {\n   *   name: \"Cool NFT\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"),\n   * }];\n   *\n   * const results = await contract.erc1155.lazyMint(metadatas); // uploads and creates the NFTs on chain\n   * const firstTokenId = results[0].id; // token id of the first created NFT\n   * const firstNFT = await results[0].data(); // (optional) fetch details of the first created NFT\n   * ```\n   *\n   * @param metadatas - The metadata to include in the batch.\n   * @param options - optional upload progress callback\n   */\n  lazyMint = /* @__PURE__ */buildTransactionFunction(async (metadatas, options) => {\n    const startFileNumber = await this.erc1155.nextTokenIdToMint();\n    const batch = await uploadOrExtractURIs(metadatas, this.storage, startFileNumber.toNumber(), options);\n    // ensure baseUri is the same for the entire batch\n    const baseUri = batch[0].substring(0, batch[0].lastIndexOf(\"/\"));\n    for (let i = 0; i < batch.length; i++) {\n      const uri = batch[i].substring(0, batch[i].lastIndexOf(\"/\"));\n      if (baseUri !== uri) {\n        throw new Error(`Can only create batches with the same base URI for every entry in the batch. Expected '${baseUri}' but got '${uri}'`);\n      }\n    }\n    const parse = receipt => {\n      const event = this.contractWrapper.parseLogs(\"TokensLazyMinted\", receipt?.logs);\n      const startingIndex = event[0].args.startTokenId;\n      const endingIndex = event[0].args.endTokenId;\n      const results = [];\n      for (let id = startingIndex; id.lte(endingIndex); id = id.add(1)) {\n        results.push({\n          id,\n          receipt,\n          data: () => this.erc1155.getTokenMetadata(id)\n        });\n      }\n      return results;\n    };\n    const prebuiltInfo = await getPrebuiltInfo(this.contractWrapper.address, this.contractWrapper.getProvider());\n    if (this.isLegacyEditionDropContract(this.contractWrapper, prebuiltInfo)) {\n      return Transaction.fromContractWrapper({\n        contractWrapper: this.contractWrapper,\n        method: \"lazyMint\",\n        args: [batch.length, `${baseUri.endsWith(\"/\") ? baseUri : `${baseUri}/`}`],\n        parse\n      });\n    } else {\n      // new contracts/extensions have support for delayed reveal that adds an extra parameter to lazyMint\n      return Transaction.fromContractWrapper({\n        contractWrapper: this.contractWrapper,\n        method: \"lazyMint\",\n        args: [batch.length, `${baseUri.endsWith(\"/\") ? baseUri : `${baseUri}/`}`, utils.toUtf8Bytes(\"\")],\n        parse\n      });\n    }\n  });\n\n  /** ******************************\n   * PRIVATE FUNCTIONS\n   *******************************/\n  detectErc1155Revealable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC1155Revealable\")) {\n      return new DelayedReveal(this.contractWrapper, this.storage, FEATURE_EDITION_REVEALABLE.name, () => this.erc1155.nextTokenIdToMint());\n    }\n    return undefined;\n  }\n  isLegacyEditionDropContract(contractWrapper, info) {\n    return info && info.type === \"DropERC1155\" && info.version < 3 || false;\n  }\n}\n\n/**\n * Mint ERC1155 NFTs\n * @remarks NFT minting functionality that handles IPFS storage for you.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * await contract.edition.mint.to(walletAddress, nftMetadata);\n * ```\n * @public\n */\n\nclass Erc1155Mintable {\n  featureName = FEATURE_EDITION_MINTABLE.name;\n\n  /**\n   * Batch mint Tokens to many addresses\n   */\n\n  constructor(erc1155, contractWrapper, storage) {\n    this.erc1155 = erc1155;\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n    this.batch = this.detectErc1155BatchMintable();\n  }\n\n  /**\n   * Mint an NFT with a limited supply\n   *\n   * @remarks Mint an NFT with a limited supply to a specified wallet.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet you want to mint the NFT to\n   * const toAddress = \"{{wallet_address}}\"\n   *\n   * // Custom metadata of the NFT, note that you can fully customize this metadata with other properties.\n   * const metadata = {\n   *   name: \"Cool NFT\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   * }\n   *\n   * const metadataWithSupply = {\n   *   metadata,\n   *   supply: 1000, // The number of this NFT you want to mint\n   * }\n   *\n   * const tx = await contract.edition.mint.to(toAddress, metadataWithSupply);\n   * const receipt = tx.receipt; // the transaction receipt\n   * const tokenId = tx.id; // the id of the NFT minted\n   * const nft = await tx.data(); // (optional) fetch details of minted NFT\n   * ```\n   *\n   */\n  to = /* @__PURE__ */buildTransactionFunction(async (to, metadataWithSupply) => {\n    const tx = await this.getMintTransaction(to, metadataWithSupply);\n    tx.setParse(receipt => {\n      const event = this.contractWrapper.parseLogs(\"TransferSingle\", receipt?.logs);\n      if (event.length === 0) {\n        throw new Error(\"TransferSingleEvent event not found\");\n      }\n      const id = event[0].args.id;\n      return {\n        id,\n        receipt,\n        data: () => this.erc1155.get(id.toString())\n      };\n    });\n    return tx;\n  });\n\n  /**\n   * @deprecated Use `contract.erc1155.mint.prepare(...args)` instead\n   */\n  async getMintTransaction(to, metadataWithSupply) {\n    const uri = await uploadOrExtractURI(metadataWithSupply.metadata, this.storage);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"mintTo\",\n      args: [await resolveAddress(to), constants.MaxUint256, uri, metadataWithSupply.supply]\n    });\n  }\n\n  /**\n   * Increase the supply of an existing NFT and mint it to a given wallet address\n   *\n   * @param to - the address to mint to\n   * @param tokenId - the token id of the NFT to increase supply of\n   * @param additionalSupply - the additional amount to mint\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet you want to mint the NFT to\n   * const toAddress = \"{{wallet_address}}\"\n   * const tokenId = 0;\n   * const additionalSupply = 1000;\n   *\n   * const tx = await contract.edition.mint.additionalSupplyTo(toAddress, tokenId, additionalSupply);\n   * ```\n   */\n  additionalSupplyTo = /* @__PURE__ */buildTransactionFunction(async (to, tokenId, additionalSupply) => {\n    const metadata = await this.erc1155.getTokenMetadata(tokenId);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"mintTo\",\n      args: [await resolveAddress(to), tokenId, metadata.uri, additionalSupply],\n      parse: receipt => {\n        return {\n          id: BigNumber.from(tokenId),\n          receipt,\n          data: () => this.erc1155.get(tokenId)\n        };\n      }\n    });\n  });\n  detectErc1155BatchMintable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC1155BatchMintable\")) {\n      return new Erc1155BatchMintable(this.erc1155, this.contractWrapper, this.storage);\n    }\n  }\n}\n\n/**\n * @internal\n */\nconst AirdropAddressInput = /* @__PURE__ */(() => z.object({\n  address: AddressOrEnsSchema,\n  quantity: AmountSchema.default(1)\n}))();\n\n/**\n * @internal\n */\nconst AirdropInputSchema = /* @__PURE__ */(() => z.union([z.array(z.string()).transform(async strings => await Promise.all(strings.map(address => AirdropAddressInput.parseAsync({\n  address\n})))), z.array(AirdropAddressInput)]))();\n\n/**\n * Configure and claim ERC1155 NFTs\n * @remarks Manage claim phases and claim ERC1155 NFTs that have been lazily minted.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * await contract.edition.drop.claim.to(\"0x...\", tokenId, quantity);\n * ```\n */\nclass ERC1155Claimable {\n  featureName = FEATURE_EDITION_CLAIM_CUSTOM.name;\n  constructor(contractWrapper) {\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * Construct a claim transaction without executing it.\n   * This is useful for estimating the gas cost of a claim transaction, overriding transaction options and having fine grained control over the transaction execution.\n   * @param destinationAddress - Address you want to send the token to\n   * @param tokenId - Id of the token you want to claim\n   * @param quantity - Quantity of the tokens you want to claim\n   * @param options - Options for claiming the NFTs\n   *\n   * @deprecated Use `contract.erc1155.claim.prepare(...args)` instead\n   */\n  async getClaimTransaction(destinationAddress, tokenId, quantity, options) {\n    let overrides = {};\n    if (options && options.pricePerToken) {\n      overrides = await calculateClaimCost(this.contractWrapper, options.pricePerToken, quantity, options.currencyAddress, options.checkERC20Allowance);\n    }\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"claim\",\n      args: [await resolveAddress(destinationAddress), tokenId, quantity],\n      overrides\n    });\n  }\n\n  /**\n   * Claim NFTs to a specific Wallet\n   *\n   * @remarks Let the specified wallet claim NFTs.\n   *\n   * @example\n   * ```javascript\n   * const address = \"{{wallet_address}}\"; // address of the wallet you want to claim the NFTs\n   * const tokenId = 0; // the id of the NFT you want to claim\n   * const quantity = 1; // how many NFTs you want to claim\n   *\n   * const tx = await contract.erc1155.claimTo(address, tokenId, quantity);\n   * const receipt = tx.receipt; // the transaction receipt\n   * ```\n   *\n   * @param destinationAddress - Address you want to send the token to\n   * @param tokenId - Id of the token you want to claim\n   * @param quantity - Quantity of the tokens you want to claim\n   * @param options - Options for claiming the NFTs\n   *\n   * @returns - Receipt for the transaction\n   */\n  to = /* @__PURE__ */buildTransactionFunction(async (destinationAddress, tokenId, quantity, options) => {\n    return await this.getClaimTransaction(destinationAddress, tokenId, quantity, options);\n  });\n}\n\n/**\n * Configure and claim ERC1155 NFTs\n * @remarks Manage claim phases and claim ERC1155 NFTs that have been lazily minted.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * await contract.erc1155.claim(tokenId, quantity);\n * await contract.erc1155.claimConditions.getActive(tokenId);\n * ```\n */\nclass Erc1155ClaimableWithConditions {\n  featureName = FEATURE_EDITION_CLAIM_CONDITIONS_V2.name;\n  constructor(contractWrapper, storage) {\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n    const metadata = new ContractMetadata(this.contractWrapper, CustomContractSchema, this.storage);\n    this.conditions = new DropErc1155ClaimConditions(contractWrapper, metadata, this.storage);\n  }\n\n  /**\n   * Claim NFTs to a specific Wallet\n   *\n   * @remarks Let the specified wallet claim NFTs.\n   *\n   * @example\n   * ```javascript\n   * const address = \"{{wallet_address}}\"; // address of the wallet you want to claim the NFTs\n   * const tokenId = 0; // the id of the NFT you want to claim\n   * const quantity = 1; // how many NFTs you want to claim\n   *\n   * const tx = await contract.erc1155.claimTo(address, tokenId, quantity);\n   * const receipt = tx.receipt; // the transaction receipt\n   * ```\n   *\n   * @param destinationAddress - Address you want to send the token to\n   * @param tokenId - Id of the token you want to claim\n   * @param quantity - Quantity of the tokens you want to claim\n   *\n   * @returns - Receipt for the transaction\n   */\n  to = /* @__PURE__ */buildTransactionFunction(async (destinationAddress, tokenId, quantity, options) => {\n    return await this.conditions.getClaimTransaction(destinationAddress, tokenId, quantity, options);\n  });\n}\n\n/**\n * Enables generating dynamic ERC1155 NFTs with rules and an associated signature, which can then be minted by anyone securely\n * @public\n */\nclass Erc1155SignatureMintable {\n  featureName = FEATURE_EDITION_SIGNATURE_MINTABLE.name;\n  constructor(contractWrapper, storage, roles) {\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n    this.roles = roles;\n  }\n\n  /**\n   * Mint a dynamically generated NFT\n   *\n   * @remarks Mint a dynamic NFT with a previously generated signature.\n   *\n   * @example\n   * ```javascript\n   * // see how to craft a payload to sign in the `generate()` documentation\n   * const signedPayload = contract.erc1155.signature.generate(payload);\n   *\n   * // now anyone can mint the NFT\n   * const tx = contract.erc1155.signature.mint(signedPayload);\n   * ```\n   * @param signedPayload - the previously generated payload and signature with {@link Erc1155SignatureMintable.generate}\n   * @twfeature ERC1155SignatureMintable\n   */\n  mint = /* @__PURE__ */buildTransactionFunction(async signedPayload => {\n    const mintRequest = signedPayload.payload;\n    const signature = signedPayload.signature;\n    const message = await this.mapPayloadToContractStruct(mintRequest);\n    const overrides = await this.contractWrapper.getCallOverrides();\n    // TODO: Transaction Sequence Pattern\n    await setErc20Allowance(this.contractWrapper, message.pricePerToken.mul(message.quantity), mintRequest.currencyAddress, overrides);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"mintWithSignature\",\n      args: [message, signature],\n      overrides,\n      parse: receipt => {\n        const t = this.contractWrapper.parseLogs(\"TokensMintedWithSignature\", receipt.logs);\n        if (t.length === 0) {\n          throw new Error(\"No MintWithSignature event found\");\n        }\n        const id = t[0].args.tokenIdMinted;\n        return {\n          id,\n          receipt\n        };\n      }\n    });\n  });\n\n  /**\n   * Mint any number of dynamically generated NFT at once\n   * @remarks Mint multiple dynamic NFTs in one transaction. Note that this is only possible for free mints (cannot batch mints with a price attached to it for security reasons)\n   *\n   * @example\n   * ```javascript\n   * // see how to craft a batch of payloads to sign in the `generateBatch()` documentation\n   * const signedPayloads = contract.erc1155.signature.generateBatch(payloads);\n   *\n   * // now anyone can mint the NFT\n   * const tx = contract.erc1155.signature.mintBatch(signedPayloads);\n   * ```\n   *\n   * @param signedPayloads - the array of signed payloads to mint\n   * @twfeature ERC1155SignatureMintable\n   */\n  mintBatch = /* @__PURE__ */buildTransactionFunction(async signedPayloads => {\n    const contractPayloads = await Promise.all(signedPayloads.map(async s => {\n      const message = await this.mapPayloadToContractStruct(s.payload);\n      const signature = s.signature;\n      const price = s.payload.price;\n      if (BigNumber.from(price).gt(0)) {\n        throw new Error(\"Can only batch free mints. For mints with a price, use regular mint()\");\n      }\n      return {\n        message,\n        signature\n      };\n    }));\n    const contractEncoder = new ContractEncoder(this.contractWrapper);\n    const encoded = contractPayloads.map(p => {\n      return contractEncoder.encode(\"mintWithSignature\", [p.message, p.signature]);\n    });\n    if (hasFunction(\"multicall\", this.contractWrapper)) {\n      return Transaction.fromContractWrapper({\n        contractWrapper: this.contractWrapper,\n        method: \"multicall\",\n        args: [encoded],\n        parse: receipt => {\n          const events = this.contractWrapper.parseLogs(\"TokensMintedWithSignature\", receipt.logs);\n          if (events.length === 0) {\n            throw new Error(\"No MintWithSignature event found\");\n          }\n          return events.map(log => ({\n            id: log.args.tokenIdMinted,\n            receipt\n          }));\n        }\n      });\n    } else {\n      throw new Error(\"Multicall not supported on this contract!\");\n    }\n  });\n\n  /**\n   * Verify that a payload is correctly signed\n   * @param signedPayload - the payload to verify\n   * @twfeature ERC1155SignatureMintable\n   *\n   * @example\n   * ```javascript\n   * const nftMetadata = {\n   *   name: \"Cool NFT #1\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   * };\n   *\n   * const startTime = new Date();\n   * const endTime = new Date(Date.now() + 60 * 60 * 24 * 1000);\n   * const payload = {\n   *   metadata: nftMetadata, // The NFT to mint\n   *   to: {{wallet_address}}, // Who will receive the NFT\n   *   quantity: 2, // the quantity of NFTs to mint\n   *   price: 0.5, // the price per NFT\n   *   currencyAddress: NATIVE_TOKEN_ADDRESS, // the currency to pay with\n   *   mintStartTime: startTime, // can mint anytime from now\n   *   mintEndTime: endTime, // to 24h from now\n   *   royaltyRecipient: \"0x...\", // custom royalty recipient for this NFT\n   *   royaltyBps: 100, // custom royalty fees for this NFT (in bps)\n   *   primarySaleRecipient: \"0x...\", // custom sale recipient for this NFT\n   * };\n   *\n   * const signedPayload = contract.erc1155.signature.generate(payload);\n   * // Now you can verify that the payload is valid\n   * const isValid = await contract.erc1155.signature.verify(signedPayload);\n   * ```\n   */\n  async verify(signedPayload) {\n    const mintRequest = signedPayload.payload;\n    const signature = signedPayload.signature;\n    const message = await this.mapPayloadToContractStruct(mintRequest);\n    const verification = await this.contractWrapper.read(\"verify\", [message, signature]);\n    return verification[0];\n  }\n\n  /**\n   * Generate a signature that can be used to mint an NFT dynamically.\n   *\n   * @remarks Takes in an NFT and some information about how it can be minted, uploads the metadata and signs it with your private key. The generated signature can then be used to mint an NFT using the exact payload and signature generated.\n   *\n   * @example\n   * ```javascript\n   * const nftMetadata = {\n   *   name: \"Cool NFT #1\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   * };\n   *\n   * const startTime = new Date();\n   * const endTime = new Date(Date.now() + 60 * 60 * 24 * 1000);\n   * const payload = {\n   *   metadata: nftMetadata, // The NFT to mint\n   *   to: {{wallet_address}}, // Who will receive the NFT\n   *   quantity: 2, // the quantity of NFTs to mint\n   *   price: 0.5, // the price per NFT\n   *   currencyAddress: NATIVE_TOKEN_ADDRESS, // the currency to pay with\n   *   mintStartTime: startTime, // can mint anytime from now\n   *   mintEndTime: endTime, // to 24h from now\n   *   royaltyRecipient: \"0x...\", // custom royalty recipient for this NFT\n   *   royaltyBps: 100, // custom royalty fees for this NFT (in bps)\n   *   primarySaleRecipient: \"0x...\", // custom sale recipient for this NFT\n   * };\n   *\n   * const signedPayload = await contract.erc1155.signature.generate(payload);\n   * // now anyone can use these to mint the NFT using `contract.erc1155.signature.mint(signedPayload)`\n   * ```\n   * @param payloadToSign - the payload to sign\n   * @returns the signed payload and the corresponding signature\n   * @twfeature ERC1155SignatureMintable\n   */\n  async generate(payloadToSign) {\n    const payload = {\n      ...payloadToSign,\n      tokenId: constants.MaxUint256\n    };\n    return this.generateFromTokenId(payload);\n  }\n\n  /**\n   * Generate a signature that can be used to mint additionaly supply to an existing NFT.\n   *\n   * @remarks Takes in a payload with the token ID of an existing NFT, and signs it with your private key. The generated signature can then be used to mint additional supply to the NFT using the exact payload and signature generated.\n   *\n   * @example\n   * ```javascript\n   * const nftMetadata = {\n   *   name: \"Cool NFT #1\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   * };\n   *\n   * const startTime = new Date();\n   * const endTime = new Date(Date.now() + 60 * 60 * 24 * 1000);\n   * const payload = {\n   *   tokenId: 0, // Instead of metadata, we specificy the token ID of the NFT to mint supply to\n   *   to: {{wallet_address}}, // Who will receive the NFT (or AddressZero for anyone)\n   *   quantity: 2, // the quantity of NFTs to mint\n   *   price: 0.5, // the price per NFT\n   *   currencyAddress: NATIVE_TOKEN_ADDRESS, // the currency to pay with\n   *   mintStartTime: startTime, // can mint anytime from now\n   *   mintEndTime: endTime, // to 24h from now\n   *   royaltyRecipient: \"0x...\", // custom royalty recipient for this NFT\n   *   royaltyBps: 100, // custom royalty fees for this NFT (in bps)\n   *   primarySaleRecipient: \"0x...\", // custom sale recipient for this NFT\n   * };\n   *\n   * const signedPayload = await contract.erc1155.signature.generateFromTokenId(payload);\n   * // now anyone can use these to mint the NFT using `contract.erc1155.signature.mint(signedPayload)`\n   * ```\n   * @param payloadToSign - the payload to sign\n   * @returns the signed payload and the corresponding signature\n   * @twfeature ERC1155SignatureMintable\n   */\n  async generateFromTokenId(payloadToSign) {\n    const payloads = await this.generateBatchFromTokenIds([payloadToSign]);\n    return payloads[0];\n  }\n\n  /**\n   * Generate a batch of signatures that can be used to mint many new NFTs dynamically.\n   *\n   * @remarks See {@link Erc1155SignatureMintable.generate}\n   *\n   * @param payloadsToSign - the payloads to sign\n   * @returns an array of payloads and signatures\n   * @twfeature ERC1155SignatureMintable\n   */\n  async generateBatch(payloadsToSign) {\n    const payloads = payloadsToSign.map(payload => ({\n      ...payload,\n      tokenId: constants.MaxUint256\n    }));\n    return this.generateBatchFromTokenIds(payloads);\n  }\n\n  /**\n   * Genrate a batch of signatures that can be used to mint new NFTs or additionaly supply to existing NFTs dynamically.\n   *\n   * @remarks See {@link Erc1155SignatureMintable.generateFromTokenId}\n   *\n   * @param payloadsToSign - the payloads to sign with tokenIds specified\n   * @returns an array of payloads and signatures\n   * @twfeature ERC1155SignatureMintable\n   */\n  async generateBatchFromTokenIds(payloadsToSign) {\n    await this.roles?.verify([\"minter\"], await this.contractWrapper.getSignerAddress());\n    const parsedRequests = await Promise.all(payloadsToSign.map(m => Signature1155PayloadInputWithTokenId.parseAsync(m)));\n    const metadatas = parsedRequests.map(r => r.metadata);\n    const uris = await uploadOrExtractURIs(metadatas, this.storage);\n    const chainId = await this.contractWrapper.getChainID();\n    const signer = this.contractWrapper.getSigner();\n    invariant(signer, \"No signer available\");\n    const contractInfo = await getPrebuiltInfo(this.contractWrapper.address, this.contractWrapper.getProvider());\n    const isLegacyContract = contractInfo?.type === \"TokenERC1155\";\n    return await Promise.all(parsedRequests.map(async (m, i) => {\n      const uri = uris[i];\n      const finalPayload = await Signature1155PayloadOutput.parseAsync({\n        ...m,\n        uri\n      });\n      const signature = await this.contractWrapper.signTypedData(signer, {\n        name: isLegacyContract ? \"TokenERC1155\" : \"SignatureMintERC1155\",\n        version: \"1\",\n        chainId,\n        verifyingContract: this.contractWrapper.address\n      }, {\n        MintRequest: MintRequest1155\n      },\n      // TYPEHASH\n      await this.mapPayloadToContractStruct(finalPayload));\n      return {\n        payload: finalPayload,\n        signature: signature.toString()\n      };\n    }));\n  }\n\n  /** ******************************\n   * PRIVATE FUNCTIONS\n   *******************************/\n\n  /**\n   * Maps a payload to the format expected by the contract\n   *\n   * @internal\n   *\n   * @param mintRequest - The payload to map.\n   * @returns - The mapped payload.\n   */\n  async mapPayloadToContractStruct(mintRequest) {\n    const normalizedPricePerToken = await normalizePriceValue(this.contractWrapper.getProvider(), mintRequest.price, mintRequest.currencyAddress);\n    return {\n      to: mintRequest.to,\n      tokenId: mintRequest.tokenId,\n      uri: mintRequest.uri,\n      quantity: mintRequest.quantity,\n      pricePerToken: normalizedPricePerToken,\n      currency: mintRequest.currencyAddress,\n      validityStartTimestamp: mintRequest.mintStartTime,\n      validityEndTimestamp: mintRequest.mintEndTime,\n      uid: mintRequest.uid,\n      royaltyRecipient: mintRequest.royaltyRecipient,\n      royaltyBps: mintRequest.royaltyBps,\n      primarySaleRecipient: mintRequest.primarySaleRecipient\n    };\n  }\n}\n\n/**\n * Standard ERC1155 NFT functions\n * @remarks Basic functionality for a ERC1155 contract that handles IPFS storage for you.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * await contract.erc1155.transfer(walletAddress, tokenId, quantity);\n * ```\n * @public\n */\nclass Erc1155 {\n  featureName = FEATURE_EDITION.name;\n  get chainId() {\n    return this._chainId;\n  }\n  constructor(contractWrapper, storage, chainId) {\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n    this.query = this.detectErc1155Enumerable();\n    this.mintable = this.detectErc1155Mintable();\n    this.burnable = this.detectErc1155Burnable();\n    this.lazyMintable = this.detectErc1155LazyMintable();\n    this.signatureMintable = this.detectErc1155SignatureMintable();\n    this.claimCustom = this.detectErc1155Claimable();\n    this.claimWithConditions = this.detectErc1155ClaimableWithConditions();\n    this._chainId = chainId;\n  }\n\n  /**\n   * @internal\n   */\n  onNetworkUpdated(network) {\n    this.contractWrapper.updateSignerOrProvider(network);\n  }\n  getAddress() {\n    return this.contractWrapper.address;\n  }\n\n  ////// Standard ERC1155 functions //////\n\n  /**\n   * Get a single NFT\n   *\n   * @example\n   * ```javascript\n   * const tokenId = 0;\n   * const nft = await contract.erc1155.get(tokenId);\n   * ```\n   * @param tokenId - the tokenId of the NFT to retrieve\n   * @returns The NFT metadata\n   * @twfeature ERC1155\n   */\n  async get(tokenId) {\n    const [supply, metadata] = await Promise.all([this.contractWrapper.read(\"totalSupply\", [tokenId]).catch(() => BigNumber.from(0)), this.getTokenMetadata(tokenId).catch(() => ({\n      id: tokenId.toString(),\n      uri: \"\",\n      ...FALLBACK_METADATA\n    }))]);\n    return {\n      owner: constants.AddressZero,\n      metadata,\n      type: \"ERC1155\",\n      supply: supply.toString()\n    };\n  }\n\n  /**\n   * Get the total supply of a specific token\n   * @example\n   * ```javascript\n   * const tokenId = 0;\n   * const nft = await contract.erc1155.totalSupply(tokenId);\n   * ```\n   * @param tokenId - The token ID to get the total supply of\n   * @returns the total supply\n   * @twfeature ERC1155\n   */\n  async totalSupply(tokenId) {\n    if (detectContractFeature(this.contractWrapper, \"ERC1155Supply\")) {\n      return await this.contractWrapper.read(\"totalSupply\", [tokenId]);\n    } else {\n      throw new ExtensionNotImplementedError(FEATURE_EDITION_SUPPLY);\n    }\n  }\n\n  /**\n   * Get NFT balance of a specific wallet\n   *\n   * @remarks Get a wallets NFT balance (number of NFTs in this contract owned by the wallet).\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet to check NFT balance\n   * const walletAddress = \"{{wallet_address}}\";\n   * const tokenId = 0; // Id of the NFT to check\n   * const balance = await contract.erc1155.balanceOf(walletAddress, tokenId);\n   * ```\n   * @twfeature ERC1155\n   */\n  async balanceOf(address, tokenId) {\n    return await this.contractWrapper.read(\"balanceOf\", [await resolveAddress(address), tokenId]);\n  }\n\n  /**\n   * Get NFT balance for the currently connected wallet\n   */\n  async balance(tokenId) {\n    return await this.balanceOf(await this.contractWrapper.getSignerAddress(), tokenId);\n  }\n\n  /**\n   * Get whether this wallet has approved transfers from the given operator\n   * @param address - the wallet address\n   * @param operator - the operator address\n   */\n  async isApproved(address, operator) {\n    return await this.contractWrapper.read(\"isApprovedForAll\", [await resolveAddress(address), await resolveAddress(operator)]);\n  }\n\n  /**\n   * Transfer an NFT\n   *\n   * @remarks Transfer an NFT from the connected wallet to another wallet.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet you want to send the NFT to\n   * const toAddress = \"{{wallet_address}}\";\n   * const tokenId = \"0\"; // The token ID of the NFT you want to send\n   * const amount = 3; // How many copies of the NFTs to transfer\n   * await contract.erc1155.transfer(toAddress, tokenId, amount);\n   * ```\n   * @twfeature ERC1155\n   */\n  transfer = /* @__PURE__ */buildTransactionFunction((() => {\n    var _this = this;\n    return async function (to, tokenId, amount) {\n      let data = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [0];\n      const from = await _this.contractWrapper.getSignerAddress();\n      return Transaction.fromContractWrapper({\n        contractWrapper: _this.contractWrapper,\n        method: \"safeTransferFrom\",\n        args: [from, await resolveAddress(to), tokenId, amount, data]\n      });\n    };\n  })());\n\n  /**\n   * Transfer an NFT from a specific wallet\n   *\n   * @remarks Transfer an NFT from a specific wallet to another wallet.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet you want to send the NFT to\n   * const toAddress = \"{{wallet_address}}\";\n   * const tokenId = \"0\"; // The token ID of the NFT you want to send\n   * const amount = 3; // How many copies of the NFTs to transfer\n   * await contract.erc1155.transfer(toAddress, tokenId, amount);\n   * ```\n   * @twfeature ERC1155\n   */\n  transferFrom = /* @__PURE__ */buildTransactionFunction((() => {\n    var _this2 = this;\n    return async function (from, to, tokenId, amount) {\n      let data = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [0];\n      return Transaction.fromContractWrapper({\n        contractWrapper: _this2.contractWrapper,\n        method: \"safeTransferFrom\",\n        args: [await resolveAddress(from), await resolveAddress(to), tokenId, amount, data]\n      });\n    };\n  })());\n\n  /**\n   * Set approval for all NFTs\n   * @remarks Approve or remove operator as an operator for the caller. Operators can call transferFrom or safeTransferFrom for any token owned by the caller.\n   * @example\n   * ```javascript\n   * const operator = \"{{wallet_address}}\";\n   * await contract.erc1155.setApprovalForAll(operator, true);\n   * ```\n   * @param operator - the operator's address\n   * @param approved - whether to approve or remove\n   * @twfeature ERC1155\n   */\n  setApprovalForAll = /* @__PURE__ */buildTransactionFunction(async (operator, approved) => {\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"setApprovalForAll\",\n      args: [operator, approved]\n    });\n  });\n\n  /**\n   * Airdrop multiple NFTs\n   *\n   * @remarks Airdrop one or multiple NFTs to the provided wallet addresses.\n   *\n   * @example\n   * ```javascript\n   * // The token ID of the NFT you want to airdrop\n   * const tokenId = \"0\";\n   * // Array of objects of addresses and quantities to airdrop NFTs to\n   * const addresses = [\n   *  {\n   *    address: \"0x...\",\n   *    quantity: 2,\n   *  },\n   *  {\n   *   address: \"0x...\",\n   *    quantity: 3,\n   *  },\n   * ];\n   * await contract.erc1155.airdrop(tokenId, addresses);\n   *\n   * // You can also pass an array of addresses, it will airdrop 1 NFT per address\n   * const tokenId = \"0\";\n   * const addresses = [\n   *  \"0x...\", \"0x...\", \"0x...\",\n   * ]\n   * await contract.erc1155.airdrop(tokenId, addresses);\n   * ```\n   * @twfeature ERC1155BatchTransferable\n   */\n  airdrop = /* @__PURE__ */buildTransactionFunction((() => {\n    var _this3 = this;\n    return async function (tokenId, addresses, fromAddress) {\n      let data = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [0];\n      const from = fromAddress ? await resolveAddress(fromAddress) : await _this3.contractWrapper.getSignerAddress();\n      const balanceOf = await _this3.balanceOf(from, tokenId);\n      const input = await AirdropInputSchema.parseAsync(addresses);\n      const totalToAirdrop = input.reduce((prev, curr) => {\n        return BigNumber.from(prev).add(BigNumber.from(curr?.quantity || 1));\n      }, BigNumber.from(0));\n      if (balanceOf.lt(BigNumber.from(totalToAirdrop))) {\n        throw new Error(`The caller owns ${balanceOf.toString()} NFTs, but wants to airdrop ${totalToAirdrop.toString()} NFTs.`);\n      }\n      const contractEncoder = new ContractEncoder(_this3.contractWrapper);\n      const encoded = input.map(_ref => {\n        let {\n          address: to,\n          quantity\n        } = _ref;\n        return contractEncoder.encode(\"safeTransferFrom\", [from, to, tokenId, quantity, data]);\n      });\n      return Transaction.fromContractWrapper({\n        contractWrapper: _this3.contractWrapper,\n        method: \"multicall\",\n        args: [encoded]\n      });\n    };\n  })());\n\n  /**\n   * Return the next available token ID to mint\n   * @internal\n   */\n  async nextTokenIdToMint() {\n    if (hasFunction(\"nextTokenIdToMint\", this.contractWrapper)) {\n      return await this.contractWrapper.read(\"nextTokenIdToMint\", []);\n    } else {\n      throw new Error(\"Contract requires the `nextTokenIdToMint` function available to determine the next token ID to mint\");\n    }\n  }\n\n  ////// ERC1155 Enumerable Extension //////\n\n  /**\n   * Get all NFTs\n   *\n   * @remarks Get all the data associated with every NFT in this contract.\n   *\n   * By default, returns the first 100 NFTs, use queryParams to fetch more.\n   *\n   * @example\n   * ```javascript\n   * const nfts = await contract.erc1155.getAll();\n   * ```\n   * @param queryParams - optional filtering to only fetch a subset of results.\n   * @returns The NFT metadata for all NFTs queried.\n   * @twfeature ERC1155Enumerable\n   */\n  async getAll(queryParams) {\n    return assertEnabled(this.query, FEATURE_EDITION_ENUMERABLE).all(queryParams);\n  }\n\n  /**\n   * Get the total number of NFTs minted\n   * @remarks This returns the total number of NFTs minted in this contract, **not** the total supply of a given token.\n   * @example\n   * ```javascript\n   * const count = await contract.erc1155.totalCount();\n   * console.log(count);\n   * ```\n   * @returns the total number of NFTs minted in this contract\n   * @public\n   * @twfeature ERC1155Enumerable\n   */\n  async totalCount() {\n    return assertEnabled(this.query, FEATURE_EDITION_ENUMERABLE).totalCount();\n  }\n\n  /**\n   * Get the total supply of a specific NFT\n   * @remarks This is **not** the sum of supply of all NFTs in the contract.\n   *\n   * @returns the total number of NFTs minted in this contract\n   * @public\n   * @twfeature ERC1155Enumerable\n   */\n  async totalCirculatingSupply(tokenId) {\n    return assertEnabled(this.query, FEATURE_EDITION_ENUMERABLE).totalCirculatingSupply(tokenId);\n  }\n\n  /**\n   * Get all NFTs owned by a specific wallet\n   *\n   * @remarks Get all the data associated with the NFTs owned by a specific wallet.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet to get the NFTs of\n   * const address = \"{{wallet_address}}\";\n   * const nfts = await contract.erc1155.getOwned(address);\n   * ```\n   *\n   * @returns The NFT metadata for all NFTs in the contract.\n   * @twfeature ERC1155Enumerable\n   */\n  async getOwned(walletAddress) {\n    if (walletAddress) {\n      walletAddress = await resolveAddress(walletAddress);\n    }\n    return assertEnabled(this.query, FEATURE_EDITION_ENUMERABLE).owned(walletAddress);\n  }\n\n  ////// ERC1155 Mintable Extension //////\n\n  /**\n   * Mint an NFT\n   *\n   * @remarks Mint an NFT with a limited supply to the connected wallet.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet you want to mint the NFT to\n   * const toAddress = \"{{wallet_address}}\"\n   *\n   * // Custom metadata of the NFT, note that you can fully customize this metadata with other properties.\n   * const metadata = {\n   *   name: \"Cool NFT\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   * }\n   *\n   * const metadataWithSupply = {\n   *   metadata,\n   *   supply: 1000, // The number of this NFT you want to mint\n   * }\n   *\n   * const tx = await contract.erc1155.mint(toAddress, metadataWithSupply);\n   * const receipt = tx.receipt; // the transaction receipt\n   * const tokenId = tx.id; // the id of the NFT minted\n   * const nft = await tx.data(); // (optional) fetch details of minted NFT\n   * ```\n   * @twfeature ERC1155Mintable\n   */\n  mint = /* @__PURE__ */buildTransactionFunction(async metadataWithSupply => {\n    return this.mintTo.prepare(await this.contractWrapper.getSignerAddress(), metadataWithSupply);\n  });\n\n  /**\n   * Mint an NFT to a specific wallet\n   *\n   * @remarks Mint an NFT with a limited supply to a specified wallet.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet you want to mint the NFT to\n   * const toAddress = \"{{wallet_address}}\"\n   *\n   * // Custom metadata of the NFT, note that you can fully customize this metadata with other properties.\n   * const metadata = {\n   *   name: \"Cool NFT\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   * }\n   *\n   * const metadataWithSupply = {\n   *   metadata,\n   *   supply: 1000, // The number of this NFT you want to mint\n   * }\n   *\n   * const tx = await contract.erc1155.mintTo(toAddress, metadataWithSupply);\n   * const receipt = tx.receipt; // the transaction receipt\n   * const tokenId = tx.id; // the id of the NFT minted\n   * const nft = await tx.data(); // (optional) fetch details of minted NFT\n   * ```\n   * @twfeature ERC1155Mintable\n   */\n  mintTo = /* @__PURE__ */buildTransactionFunction(async (receiver, metadataWithSupply) => {\n    return assertEnabled(this.mintable, FEATURE_EDITION_MINTABLE).to.prepare(receiver, metadataWithSupply);\n  });\n\n  /**\n   * Construct a mint transaction without executing it.\n   * This is useful for estimating the gas cost of a mint transaction, overriding transaction options and having fine grained control over the transaction execution.\n   * @param receiver - Address you want to send the token to\n   * @param metadataWithSupply - The metadata of the NFT you want to mint\n   *\n   * @deprecated Use `contract.erc1155.mint.prepare(...args)` instead\n   * @twfeature ERC1155Mintable\n   */\n  async getMintTransaction(receiver, metadataWithSupply) {\n    return assertEnabled(this.mintable, FEATURE_EDITION_MINTABLE).getMintTransaction(receiver, metadataWithSupply);\n  }\n\n  /**\n   * Increase the supply of an existing NFT\n   * @remarks Increase the supply of an existing NFT and mint it to the connected wallet address\n   * @example\n   * ```javascript\n   * const tokenId = 0;\n   * const additionalSupply = 1000;\n   * await contract.erc1155.mintAdditionalSupply(tokenId, additionalSupply);\n   * ```\n   *\n   * @param tokenId - the token id of the NFT to increase supply of\n   * @param additionalSupply - the additional amount to mint\n   * @twfeature ERC1155Mintable\n   */\n  mintAdditionalSupply = /* @__PURE__ */buildTransactionFunction(async (tokenId, additionalSupply) => {\n    return assertEnabled(this.mintable, FEATURE_EDITION_MINTABLE).additionalSupplyTo.prepare(await this.contractWrapper.getSignerAddress(), tokenId, additionalSupply);\n  });\n\n  /**\n   * Increase the supply of an existing NFT and mint it to a given wallet address\n   *\n   * @param to - the address to mint to\n   * @param tokenId - the token id of the NFT to increase supply of\n   * @param additionalSupply - the additional amount to mint\n   * @twfeature ERC1155Mintable\n   */\n  mintAdditionalSupplyTo = /* @__PURE__ */buildTransactionFunction(async (receiver, tokenId, additionalSupply) => {\n    return assertEnabled(this.mintable, FEATURE_EDITION_MINTABLE).additionalSupplyTo.prepare(receiver, tokenId, additionalSupply);\n  });\n\n  ////// ERC1155 BatchMintable Extension //////\n\n  /**\n   * Mint multiple NFTs at once\n   *\n   * @remarks Mint multiple different NFTs with limited supplies to the connected wallet.\n   *\n   * @example\n   * ```javascript\n   * // Custom metadata and supplies of your NFTs\n   * const metadataWithSupply = [{\n   *   supply: 50, // The number of this NFT you want to mint\n   *   metadata: {\n   *     name: \"Cool NFT #1\",\n   *     description: \"This is a cool NFT\",\n   *     image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   *   },\n   * }, {\n   *   supply: 100,\n   *   metadata: {\n   *     name: \"Cool NFT #2\",\n   *     description: \"This is a cool NFT\",\n   *     image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   *   },\n   * }];\n   *\n   * const tx = await contract.erc1155.mintBatch(metadataWithSupply);\n   * const receipt = tx[0].receipt; // same transaction receipt for all minted NFTs\n   * const firstTokenId = tx[0].id; // token id of the first minted NFT\n   * const firstNFT = await tx[0].data(); // (optional) fetch details of the first minted NFT\n   * ```\n   * @twfeature ERC1155BatchMintable\n   */\n  mintBatch = /* @__PURE__ */buildTransactionFunction(async metadataWithSupply => {\n    return this.mintBatchTo.prepare(await this.contractWrapper.getSignerAddress(), metadataWithSupply);\n  });\n\n  /**\n   * Mint multiple NFTs at once to a specific wallet\n   *\n   * @remarks Mint multiple different NFTs with limited supplies to a specified wallet.\n   *\n   * @example\n   * ```javascript\n   * // Address of the wallet you want to mint the NFT to\n   * const toAddress = \"{{wallet_address}}\"\n   *\n   * // Custom metadata and supplies of your NFTs\n   * const metadataWithSupply = [{\n   *   supply: 50, // The number of this NFT you want to mint\n   *   metadata: {\n   *     name: \"Cool NFT #1\",\n   *     description: \"This is a cool NFT\",\n   *     image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   *   },\n   * }, {\n   *   supply: 100,\n   *   metadata: {\n   *     name: \"Cool NFT #2\",\n   *     description: \"This is a cool NFT\",\n   *     image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   *   },\n   * }];\n   *\n   * const tx = await contract.erc1155.mintBatchTo(toAddress, metadataWithSupply);\n   * const receipt = tx[0].receipt; // same transaction receipt for all minted NFTs\n   * const firstTokenId = tx[0].id; // token id of the first minted NFT\n   * const firstNFT = await tx[0].data(); // (optional) fetch details of the first minted NFT\n   * ```\n   * @twfeature ERC1155BatchMintable\n   */\n  mintBatchTo = /* @__PURE__ */buildTransactionFunction(async (receiver, metadataWithSupply) => {\n    return assertEnabled(this.mintable?.batch, FEATURE_EDITION_BATCH_MINTABLE).to.prepare(receiver, metadataWithSupply);\n  });\n\n  ////// ERC1155 Burnable Extension //////\n\n  /**\n   * Burn NFTs\n   *\n   * @remarks Burn the specified NFTs from the connected wallet\n   *\n   * @param tokenId - the token Id to burn\n   * @param amount - amount to burn\n   *\n   * @example\n   * ```javascript\n   * // The token ID to burn NFTs of\n   * const tokenId = 0;\n   * // The amount of the NFT you want to burn\n   * const amount = 2;\n   *\n   * const result = await contract.erc1155.burn(tokenId, amount);\n   * ```\n   * @twfeature ERC1155Burnable\n   */\n  burn = /* @__PURE__ */buildTransactionFunction(async (tokenId, amount) => {\n    return assertEnabled(this.burnable, FEATURE_EDITION_BURNABLE).tokens.prepare(tokenId, amount);\n  });\n\n  /**\n   * Burn NFTs from a specific wallet\n   *\n   * @remarks Burn the specified NFTs from a specified wallet\n   *\n   * @param account - the address to burn NFTs from\n   * @param tokenId - the tokenId to burn\n   * @param amount - amount to burn\n   *\n   * @example\n   * ```javascript\n   * // The address of the wallet to burn NFTS from\n   * const account = \"0x...\";\n   * // The token ID to burn NFTs of\n   * const tokenId = 0;\n   * // The amount of this NFT you want to burn\n   * const amount = 2;\n   *\n   * const result = await contract.erc1155.burnFrom(account, tokenId, amount);\n   * ```\n   * @twfeature ERC1155Burnable\n   */\n  burnFrom = /* @__PURE__ */buildTransactionFunction(async (account, tokenId, amount) => {\n    return assertEnabled(this.burnable, FEATURE_EDITION_BURNABLE).from.prepare(account, tokenId, amount);\n  });\n\n  /**\n   * Burn a batch of NFTs\n   *\n   * @remarks Burn the batch NFTs from the connected wallet\n   *\n   * @param tokenIds - the tokenIds to burn\n   * @param amounts - amount of each token to burn\n   *\n   * @example\n   * ```javascript\n   * // The token IDs to burn NFTs of\n   * const tokenIds = [0, 1];\n   * // The amounts of each NFT you want to burn\n   * const amounts = [2, 2];\n   *\n   * const result = await contract.erc1155.burnBatch(tokenIds, amounts);\n   * ```\n   * @twfeature ERC1155Burnable\n   */\n  burnBatch = /* @__PURE__ */buildTransactionFunction(async (tokenIds, amounts) => {\n    return assertEnabled(this.burnable, FEATURE_EDITION_BURNABLE).batch.prepare(tokenIds, amounts);\n  });\n\n  /**\n   * Burn a batch of NFTs from a specific wallet\n   *\n   * @remarks Burn the batch NFTs from the specified wallet\n   *\n   * @param account - the address to burn NFTs from\n   * @param tokenIds - the tokenIds to burn\n   * @param amounts - amount of each token to burn\n   *\n   * @example\n   * ```javascript\n   * // The address of the wallet to burn NFTS from\n   * const account = \"0x...\";\n   * // The token IDs to burn NFTs of\n   * const tokenIds = [0, 1];\n   * // The amounts of each NFT you want to burn\n   * const amounts = [2, 2];\n   *\n   * const result = await contract.erc1155.burnBatchFrom(account, tokenIds, amounts);\n   * ```\n   * @twfeature ERC1155Burnable\n   */\n  burnBatchFrom = /* @__PURE__ */buildTransactionFunction(async (account, tokenIds, amounts) => {\n    return assertEnabled(this.burnable, FEATURE_EDITION_BURNABLE).batchFrom.prepare(account, tokenIds, amounts);\n  });\n\n  ////// ERC721 LazyMint Extension //////\n\n  /**\n   * Lazy mint NFTs\n   *\n   * @remarks Create batch allows you to create a batch of many NFTs in one transaction.\n   *\n   * @example\n   * ```javascript\n   * // Custom metadata of the NFTs to create\n   * const metadatas = [{\n   *   name: \"Cool NFT\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"), // This can be an image url or file\n   * }, {\n   *   name: \"Cool NFT\",\n   *   description: \"This is a cool NFT\",\n   *   image: fs.readFileSync(\"path/to/image.png\"),\n   * }];\n   *\n   * const results = await contract.erc1155.lazyMint(metadatas); // uploads and creates the NFTs on chain\n   * const firstTokenId = results[0].id; // token id of the first created NFT\n   * const firstNFT = await results[0].data(); // (optional) fetch details of the first created NFT\n   * ```\n   *\n   * @param metadatas - The metadata to include in the batch.\n   * @param options - optional upload progress callback\n   * @twfeature ERC1155LazyMintableV1 | ERC1155LazyMintableV2\n   */\n  lazyMint = /* @__PURE__ */buildTransactionFunction(async (metadatas, options) => {\n    return assertEnabled(this.lazyMintable, FEATURE_EDITION_LAZY_MINTABLE_V2).lazyMint.prepare(metadatas, options);\n  });\n\n  ////// ERC1155 Claimable Extension //////\n\n  /**\n   * Construct a claim transaction without executing it.\n   * This is useful for estimating the gas cost of a claim transaction, overriding transaction options and having fine grained control over the transaction execution.\n   * @param destinationAddress - Address you want to send the token to\n   * @param tokenId - Id of the token you want to claim\n   * @param quantity - Quantity of the tokens you want to claim\n   * @param options - Optional claim verification data (e.g. price, currency, etc...)\n   *\n   * @deprecated Use `contract.erc1155.claim.prepare(...args)` instead\n   */\n  async getClaimTransaction(destinationAddress, tokenId, quantity, options) {\n    const claimWithConditions = this.claimWithConditions;\n    const claim = this.claimCustom;\n    if (claimWithConditions) {\n      return claimWithConditions.conditions.getClaimTransaction(destinationAddress, tokenId, quantity, options);\n    }\n    if (claim) {\n      return claim.getClaimTransaction(destinationAddress, tokenId, quantity, options);\n    }\n    throw new ExtensionNotImplementedError(FEATURE_EDITION_CLAIM_CUSTOM);\n  }\n\n  /**\n   * Claim NFTs\n   *\n   * @remarks Let the connected wallet claim NFTs.\n   *\n   * @example\n   * ```javascript\n   * const tokenId = 0; // the id of the NFT you want to claim\n   * const quantity = 1; // how many NFTs you want to claim\n   *\n   * const tx = await contract.erc1155.claim(tokenId, quantity);\n   * const receipt = tx.receipt; // the transaction receipt\n   * ```\n   *\n   * @param tokenId - Id of the token you want to claim\n   * @param quantity - Quantity of the tokens you want to claim\n   * @param options - Optional claim verification data (e.g. price, currency, etc...)\n   *\n   * @returns - Receipt for the transaction\n   * @twfeature ERC1155ClaimCustom | ERC1155ClaimPhasesV2 | ERC1155ClaimPhasesV1 | ERC1155ClaimConditionsV2 | ERC1155ClaimConditionsV1\n   */\n  claim = /* @__PURE__ */buildTransactionFunction(async (tokenId, quantity, options) => {\n    return this.claimTo.prepare(await this.contractWrapper.getSignerAddress(), tokenId, quantity, options);\n  });\n\n  /**\n   * Claim NFTs to a specific Wallet\n   *\n   * @remarks Let the specified wallet claim NFTs.\n   *\n   * @example\n   * ```javascript\n   * const address = \"{{wallet_address}}\"; // address of the wallet you want to claim the NFTs\n   * const tokenId = 0; // the id of the NFT you want to claim\n   * const quantity = 1; // how many NFTs you want to claim\n   *\n   * const tx = await contract.erc1155.claimTo(address, tokenId, quantity);\n   * const receipt = tx.receipt; // the transaction receipt\n   * ```\n   *\n   * @param destinationAddress - Address you want to send the token to\n   * @param tokenId - Id of the token you want to claim\n   * @param quantity - Quantity of the tokens you want to claim\n   * @param options - Optional claim verification data (e.g. price, currency, etc...)\n   *\n   * @returns - Receipt for the transaction\n   * @twfeature ERC1155ClaimCustom | ERC1155ClaimPhasesV2 | ERC1155ClaimPhasesV1 | ERC1155ClaimConditionsV2 | ERC1155ClaimConditionsV1\n   */\n  claimTo = /* @__PURE__ */buildTransactionFunction(async (destinationAddress, tokenId, quantity, options) => {\n    const claimWithConditions = this.claimWithConditions;\n    const claim = this.claimCustom;\n    if (claimWithConditions) {\n      return claimWithConditions.to.prepare(destinationAddress, tokenId, quantity, options);\n    }\n    if (claim) {\n      return claim.to.prepare(destinationAddress, tokenId, quantity, options);\n    }\n    throw new ExtensionNotImplementedError(FEATURE_EDITION_CLAIM_CUSTOM);\n  });\n\n  /**\n   * Configure claim conditions\n   * @remarks Define who can claim NFTs in the collection, when and how many.\n   * @example\n   * ```javascript\n   * const presaleStartTime = new Date();\n   * const publicSaleStartTime = new Date(Date.now() + 60 * 60 * 24 * 1000);\n   * const claimConditions = [\n   *   {\n   *     startTime: presaleStartTime, // start the presale now\n   *     maxClaimableSupply: 2, // limit how many mints for this presale\n   *     price: 0.01, // presale price\n   *     snapshot: ['0x...', '0x...'], // limit minting to only certain addresses\n   *   },\n   *   {\n   *     startTime: publicSaleStartTime, // 24h after presale, start public sale\n   *     price: 0.08, // public sale price\n   *   }\n   * ]);\n   * await contract.erc1155.claimConditions.set(tokenId, claimConditions);\n   * ```\n   * @twfeature ERC1155ClaimPhasesV2 | ERC1155ClaimPhasesV1 | ERC1155ClaimConditionsV2 | ERC1155ClaimConditionsV1\n   */\n  get claimConditions() {\n    return assertEnabled(this.claimWithConditions, FEATURE_EDITION_CLAIM_CONDITIONS_V2).conditions;\n  }\n\n  ////// ERC1155 SignatureMintable Extension //////\n\n  /**\n   * Mint with signature\n   * @remarks Generate dynamic NFTs with your own signature, and let others mint them using that signature.\n   * @example\n   * ```javascript\n   * // see how to craft a payload to sign in the `contract.erc1155.signature.generate()` documentation\n   * const signedPayload = contract.erc1155.signature().generate(payload);\n   *\n   * // now anyone can mint the NFT\n   * const tx = contract.erc1155.signature.mint(signedPayload);\n   * const receipt = tx.receipt; // the mint transaction receipt\n   * const mintedId = tx.id; // the id of the NFT minted\n   * ```\n   * @twfeature ERC1155SignatureMintable\n   */\n  get signature() {\n    return assertEnabled(this.signatureMintable, FEATURE_EDITION_SIGNATURE_MINTABLE);\n  }\n\n  ////// ERC1155 DelayedReveal Extension //////\n\n  /**\n   * Mint delayed reveal NFTs\n   * @remarks Create a batch of encrypted NFTs that can be revealed at a later time.\n   * @example\n   * ```javascript\n   * // the real NFTs, these will be encrypted until you reveal them\n   * const realNFTs = [{\n   *   name: \"Common NFT #1\",\n   *   description: \"Common NFT, one of many.\",\n   *   image: fs.readFileSync(\"path/to/image.png\"),\n   * }, {\n   *   name: \"Super Rare NFT #2\",\n   *   description: \"You got a Super Rare NFT!\",\n   *   image: fs.readFileSync(\"path/to/image.png\"),\n   * }];\n   * // A placeholder NFT that people will get immediately in their wallet, and will be converted to the real NFT at reveal time\n   * const placeholderNFT = {\n   *   name: \"Hidden NFT\",\n   *   description: \"Will be revealed next week!\"\n   * };\n   * // Create and encrypt the NFTs\n   * await contract.erc1155.drop.revealer.createDelayedRevealBatch(\n   *   placeholderNFT,\n   *   realNFTs,\n   *   \"my secret password\",\n   * );\n   * // Whenever you're ready, reveal your NFTs at any time\n   * const batchId = 0; // the batch to reveal\n   * await contract.erc1155.revealer.reveal(batchId, \"my secret password\");\n   * ```\n   * @twfeature ERC1155Revealable\n   */\n  get revealer() {\n    return assertEnabled(this.lazyMintable?.revealer, FEATURE_EDITION_REVEALABLE);\n  }\n\n  /** ******************************\n   * PRIVATE FUNCTIONS\n   *******************************/\n\n  /**\n   * @internal\n   * @param tokenId - the token Id to fetch\n   */\n  async getTokenMetadata(tokenId) {\n    const tokenUri = await this.contractWrapper.read(\"uri\", [tokenId]);\n    if (!tokenUri) {\n      throw new NotFoundError();\n    }\n    return fetchTokenMetadata(tokenId, tokenUri, this.storage);\n  }\n  detectErc1155Enumerable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC1155Enumerable\")) {\n      return new Erc1155Enumerable(this, this.contractWrapper);\n    }\n  }\n  detectErc1155Mintable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC1155Mintable\")) {\n      return new Erc1155Mintable(this, this.contractWrapper, this.storage);\n    }\n    return undefined;\n  }\n  detectErc1155Burnable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC1155Burnable\")) {\n      return new Erc1155Burnable(this.contractWrapper);\n    }\n    return undefined;\n  }\n  detectErc1155LazyMintable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC1155LazyMintableV1\") || detectContractFeature(this.contractWrapper, \"ERC1155LazyMintableV2\")) {\n      return new Erc1155LazyMintable(this, this.contractWrapper, this.storage);\n    }\n    return undefined;\n  }\n  detectErc1155SignatureMintable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC1155SignatureMintable\")) {\n      return new Erc1155SignatureMintable(this.contractWrapper, this.storage);\n    }\n    return undefined;\n  }\n  detectErc1155Claimable() {\n    if (detectContractFeature(this.contractWrapper, \"ERC1155ClaimCustom\")) {\n      return new ERC1155Claimable(this.contractWrapper);\n    }\n    return undefined;\n  }\n  detectErc1155ClaimableWithConditions() {\n    if (detectContractFeature(this.contractWrapper, \"ERC1155ClaimConditionsV1\") || detectContractFeature(this.contractWrapper, \"ERC1155ClaimConditionsV2\") || detectContractFeature(this.contractWrapper, \"ERC1155ClaimPhasesV1\") || detectContractFeature(this.contractWrapper, \"ERC1155ClaimPhasesV2\")) {\n      return new Erc1155ClaimableWithConditions(this.contractWrapper, this.storage);\n    }\n    return undefined;\n  }\n}\n\nfunction cleanCurrencyAddress(currencyAddress) {\n  if (isNativeToken(currencyAddress)) {\n    return NATIVE_TOKEN_ADDRESS;\n  }\n  return currencyAddress;\n}\n\n/**\n * This method checks if the given token is approved for the transferrerContractAddress contract.\n * This is particularly useful for contracts that need to transfer NFTs on the users' behalf\n *\n * @internal\n * @param provider - The connected provider\n * @param transferrerContractAddress - The address of the marketplace contract\n * @param assetContract - The address of the asset contract.\n * @param tokenId - The token id of the token.\n * @param owner - The address of the account that owns the token.\n * @returns - True if the transferrerContractAddress is approved on the token, false otherwise.\n */\nasync function isTokenApprovedForTransfer(provider, transferrerContractAddress, assetContract, tokenId, owner) {\n  try {\n    const erc165 = new Contract(assetContract, ERC165Abi, provider);\n    const isERC721 = await erc165.supportsInterface(InterfaceId_IERC721);\n    const isERC1155 = await erc165.supportsInterface(InterfaceId_IERC1155);\n    if (isERC721) {\n      const asset = new Contract(assetContract, Erc721Abi, provider);\n      const approved = await asset.isApprovedForAll(owner, transferrerContractAddress);\n      if (approved) {\n        return true;\n      }\n\n      // Handle reverts in case of non-existent tokens\n      let approvedAddress;\n      try {\n        approvedAddress = await asset.getApproved(tokenId);\n      } catch (e) {}\n      return approvedAddress?.toLowerCase() === transferrerContractAddress.toLowerCase();\n    } else if (isERC1155) {\n      const asset = new Contract(assetContract, Erc1155Abi, provider);\n      return await asset.isApprovedForAll(owner, transferrerContractAddress);\n    } else {\n      console.error(\"Contract does not implement ERC 1155 or ERC 721.\");\n      return false;\n    }\n  } catch (err) {\n    console.error(\"Failed to check if token is approved\", err);\n    return false;\n  }\n}\n\n/**\n * Checks if the marketplace is approved to make transfers on the assetContract\n * If not, it tries to set the approval.\n * @param contractWrapper\n * @param marketplaceAddress\n * @param assetContract\n * @param tokenId\n * @param from\n */\nasync function handleTokenApproval(contractWrapper, marketplaceAddress, assetContract, tokenId, from) {\n  const erc165 = new ContractWrapper(contractWrapper.getSignerOrProvider(), assetContract, ERC165Abi, contractWrapper.options, contractWrapper.storage);\n  const isERC721 = await erc165.read(\"supportsInterface\", [InterfaceId_IERC721]);\n  const isERC1155 = await erc165.read(\"supportsInterface\", [InterfaceId_IERC1155]);\n  // check for token approval\n  if (isERC721) {\n    const asset = new ContractWrapper(contractWrapper.getSignerOrProvider(), assetContract, Erc721Abi, contractWrapper.options, contractWrapper.storage);\n    const approved = await asset.read(\"isApprovedForAll\", [from, marketplaceAddress]);\n    if (!approved) {\n      const isTokenApproved = (await asset.read(\"getApproved\", [tokenId])).toLowerCase() === marketplaceAddress.toLowerCase();\n      if (!isTokenApproved) {\n        await asset.sendTransaction(\"setApprovalForAll\", [marketplaceAddress, true]);\n      }\n    }\n  } else if (isERC1155) {\n    const asset = new ContractWrapper(contractWrapper.getSignerOrProvider(), assetContract, Erc1155Abi, contractWrapper.options, contractWrapper.storage);\n    const approved = await asset.read(\"isApprovedForAll\", [from, marketplaceAddress]);\n    if (!approved) {\n      await asset.sendTransaction(\"setApprovalForAll\", [marketplaceAddress, true]);\n    }\n  } else {\n    throw Error(\"Contract must implement ERC 1155 or ERC 721.\");\n  }\n}\n\n/**\n * Used to verify fields in new listing.\n * @internal\n */\n// TODO this should be done in zod\nfunction validateNewListingParam(param) {\n  invariant(param.assetContractAddress !== undefined && param.assetContractAddress !== null, \"Asset contract address is required\");\n  invariant(param.buyoutPricePerToken !== undefined && param.buyoutPricePerToken !== null, \"Buyout price is required\");\n  invariant(param.listingDurationInSeconds !== undefined && param.listingDurationInSeconds !== null, \"Listing duration is required\");\n  invariant(param.startTimestamp !== undefined && param.startTimestamp !== null, \"Start time is required\");\n  invariant(param.tokenId !== undefined && param.tokenId !== null, \"Token ID is required\");\n  invariant(param.quantity !== undefined && param.quantity !== null, \"Quantity is required\");\n  switch (param.type) {\n    case \"NewAuctionListing\":\n      {\n        invariant(param.reservePricePerToken !== undefined && param.reservePricePerToken !== null, \"Reserve price is required\");\n      }\n  }\n}\n\n/**\n * Maps a contract offer to the strict interface\n *\n * @internal\n * @param offer\n * @returns - An `Offer` object\n */\nasync function mapOffer(provider, listingId, offer) {\n  return {\n    quantity: offer.quantityDesired,\n    pricePerToken: offer.pricePerToken,\n    currencyContractAddress: offer.currency,\n    buyerAddress: offer.offeror,\n    quantityDesired: offer.quantityWanted,\n    currencyValue: await fetchCurrencyValue(provider, offer.currency, offer.quantityWanted.mul(offer.pricePerToken)),\n    listingId\n  };\n}\nfunction isWinningBid(winningPrice, newBidPrice, bidBuffer) {\n  bidBuffer = BigNumber.from(bidBuffer);\n  winningPrice = BigNumber.from(winningPrice);\n  newBidPrice = BigNumber.from(newBidPrice);\n  if (winningPrice.eq(BigNumber.from(0))) {\n    return false;\n  }\n  const buffer = newBidPrice.sub(winningPrice).mul(MAX_BPS).div(winningPrice);\n  return buffer.gte(bidBuffer);\n}\nasync function getAllInBatches(start, end, fn) {\n  const batches = [];\n  while (end - start > DEFAULT_QUERY_ALL_COUNT) {\n    batches.push(fn(start, start + DEFAULT_QUERY_ALL_COUNT - 1));\n    start += DEFAULT_QUERY_ALL_COUNT;\n  }\n  batches.push(fn(start, end - 1));\n  return await Promise.all(batches);\n}\n\n/**\n * Listen to Contract events in real time\n * @public\n */\nclass ContractEvents {\n  constructor(contractWrapper) {\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * Subscribe to transactions in this contract.\n   * @remarks Will emit an \"event\" object containing the transaction status ('submitted' and 'completed') and hash\n   * @example\n   * ```javascript\n   * contract.events.addTransactionListener((event) => {\n   *   console.log(event);\n   * }\n   * ```\n   * @param listener - the callback function that will be called on every transaction\n   * @public\n   */\n  addTransactionListener(listener) {\n    this.contractWrapper.addListener(EventType.Transaction, listener);\n  }\n\n  /**\n   * Remove a transaction listener\n   * @remarks Remove a listener that was added with addTransactionListener\n   * @example\n   * ```javascript\n   * contract.events.removeTransactionListener((event) => {\n   *  console.log(event);\n   * }\n   * ```\n   * @param listener - the callback function to remove\n   * @public\n   */\n  removeTransactionListener(listener) {\n    this.contractWrapper.off(EventType.Transaction, listener);\n  }\n\n  /**\n   * Subscribe to contract events\n   * @remarks You can add a listener for any contract event to run a function when\n   * the event is emitted. For example, if you wanted to listen for a \"TokensMinted\" event,\n   * you could do the following:\n   * @example\n   * ```javascript\n   * contract.events.addEventListener(\"TokensMinted\", (event) => {\n   *   console.log(event);\n   * });\n   * ```\n   * @public\n   * @param eventName - the event name as defined in the contract\n   * @param listener - the callback function that will be called on every new event\n   * @returns a function to un-subscribe from the event\n   */\n  addEventListener(\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  eventName, listener) {\n    // validates event, throws error if not found\n    const event = this.contractWrapper.readContract.interface.getEvent(eventName);\n    const address = this.contractWrapper.address;\n    const filter = {\n      address,\n      topics: [this.contractWrapper.readContract.interface.getEventTopic(event)]\n    };\n    const wrappedListener = log => {\n      const parsedLog = this.contractWrapper.readContract.interface.parseLog(log);\n      listener(this.toContractEvent(parsedLog.eventFragment, parsedLog.args, log));\n    };\n    this.contractWrapper.getProvider().on(filter, wrappedListener);\n    return () => {\n      this.contractWrapper.getProvider().off(filter, wrappedListener);\n    };\n  }\n\n  /**\n   * Listen to all events emitted from this contract\n   *\n   * @example\n   * ```javascript\n   * contract.events.listenToAllEvents((event) => {\n   *   console.log(event.eventName) // the name of the emitted event\n   *   console.log(event.data) // event payload\n   * }\n   * ```\n   * @public\n   * @param listener - the callback function that will be called on every new event\n   * @returns A function that can be called to stop listening to events\n   */\n  listenToAllEvents(listener) {\n    const address = this.contractWrapper.address;\n    const filter = {\n      address\n    };\n    const wrappedListener = log => {\n      try {\n        const parsedLog = this.contractWrapper.readContract.interface.parseLog(log);\n        listener(this.toContractEvent(parsedLog.eventFragment, parsedLog.args, log));\n      } catch (e) {\n        console.error(\"Could not parse event:\", log, e);\n      }\n    };\n    this.contractWrapper.getProvider().on(filter, wrappedListener);\n    return () => {\n      this.contractWrapper.getProvider().off(filter, wrappedListener);\n    };\n  }\n\n  /**\n   * Remove an event listener from this contract\n   * @remarks Remove a listener that was added with addEventListener\n   * @example\n   * ```javascript\n   * contract.events.removeEventListener(\"TokensMinted\", (event) => {\n   *   console.log(event);\n   * });\n   * ```\n   * @public\n   * @param eventName - the event name as defined in the contract\n   * @param listener - the listener to unregister\n   */\n  removeEventListener(\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  eventName, listener) {\n    // validates event, throws error if not found\n    const event = this.contractWrapper.readContract.interface.getEvent(eventName);\n    this.contractWrapper.readContract.off(event.name, listener);\n  }\n\n  /**\n   * Remove all listeners on this contract\n   * @remarks Remove all listeners from a contract\n   * @example\n   * ```javascript\n   * contract.events.removeAllListeners();\n   * ```\n   * @public\n   */\n  removeAllListeners() {\n    this.contractWrapper.readContract.removeAllListeners();\n    const address = this.contractWrapper.address;\n    const filter = {\n      address\n    };\n    this.contractWrapper.getProvider().removeAllListeners(filter);\n  }\n\n  /**\n   * Get All Events\n   * @remarks Get a list of all the events emitted from this contract during the specified time period\n   * @example\n   * ```javascript\n   * // Optionally pass in filters to limit the blocks from which events are retrieved\n   * const filters = {\n   *   fromBlock: 0,\n   *   toBlock: 1000000,\n   * }\n   * const events = await contract.events.getAllEvents(filters);\n   * console.log(events[0].eventName);\n   * console.log(events[0].data);\n   * ```\n   *\n   * @param filters - Specify the from and to block numbers to get events for, defaults to all blocks\n   * @returns The event objects of the events emitted with event names and data for each event\n   */\n  async getAllEvents() {\n    let filters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      fromBlock: 0,\n      toBlock: \"latest\",\n      order: \"desc\"\n    };\n    const events = await this.contractWrapper.readContract.queryFilter({}, filters.fromBlock, filters.toBlock);\n    const orderedEvents = events.sort((a, b) => {\n      return filters.order === \"desc\" ? b.blockNumber - a.blockNumber : a.blockNumber - b.blockNumber;\n    });\n    return this.parseEvents(orderedEvents);\n  }\n\n  /**\n   * Get Events\n   * @remarks Get a list of the events of a specific type emitted from this contract during the specified time period\n   * @example\n   * ```javascript\n   * // The name of the event to get logs for\n   * const eventName = \"Transfer\";\n   *\n   * // Optionally pass in options to limit the blocks from which events are retrieved\n   * const options = {\n   *   fromBlock: 0,\n   *   toBlock: 1000000, // can also pass \"latest\"\n   *   order: \"desc\",\n   *   // Configure event filters (filter on indexed event parameters)\n   *   filters: {\n   *     from: \"0x...\",\n   *     to: \"0x...\"\n   *   }\n   * };\n   *\n   * const events = await contract.events.getEvents(eventName, options);\n   * console.log(events[0].eventName);\n   * console.log(events[0].data);\n   * ```\n   *\n   * @param eventName - The name of the event to get logs for\n   * @param options - Specify the from and to block numbers to get events for, defaults to all blocks. @see EventQueryOptions\n   * @returns The requested event objects with event data\n   */\n  async getEvents(eventName) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      fromBlock: 0,\n      toBlock: \"latest\",\n      order: \"desc\"\n    };\n    const eventInterface = this.contractWrapper.readContract.interface.getEvent(eventName);\n    const args = options.filters ? eventInterface.inputs.map(e => options.filters[e.name]) : [];\n    const filter = this.contractWrapper.readContract.filters[eventInterface.name](...args);\n    const events = await this.contractWrapper.readContract.queryFilter(filter, options.fromBlock, options.toBlock);\n    const orderedEvents = events.sort((a, b) => {\n      return options.order === \"desc\" ? b.blockNumber - a.blockNumber : a.blockNumber - b.blockNumber;\n    });\n    return this.parseEvents(orderedEvents);\n  }\n  parseEvents(events) {\n    return events.map(e => {\n      const transaction = Object.fromEntries(Object.entries(e).filter(a => typeof a[1] !== \"function\" && a[0] !== \"args\"));\n      if (e.args) {\n        const entries = Object.entries(e.args);\n        const args = entries.slice(entries.length / 2, entries.length);\n        const data = {};\n        for (const [key, value] of args) {\n          data[key] = value;\n        }\n        return {\n          eventName: e.event || \"\",\n          data: data,\n          transaction\n        };\n      }\n      return {\n        eventName: e.event || \"\",\n        data: {},\n        transaction\n      };\n    });\n  }\n  toContractEvent(event, args, rawLog) {\n    const transaction = Object.fromEntries(Object.entries(rawLog).filter(a => typeof a[1] !== \"function\" && a[0] !== \"args\"));\n    const results = {};\n    event.inputs.forEach((param, index) => {\n      if (Array.isArray(args[index])) {\n        const components = param.components;\n        if (components) {\n          const arr = args[index];\n          if (param.type === \"tuple[]\") {\n            // tuple[]\n            const objArray = [];\n            for (let i = 0; i < arr.length; i++) {\n              const tuple = arr[i];\n              const obj = {};\n              for (let j = 0; j < components.length; j++) {\n                const name = components[j].name;\n                obj[name] = tuple[j];\n              }\n              objArray.push(obj);\n            }\n            results[param.name] = objArray;\n          } else {\n            // simple tuple\n            const obj = {};\n            for (let i = 0; i < components.length; i++) {\n              const name = components[i].name;\n              obj[name] = arr[i];\n            }\n            results[param.name] = obj;\n          }\n        }\n      } else {\n        results[param.name] = args[index];\n      }\n    });\n    return {\n      eventName: event.name,\n      data: results,\n      transaction\n    };\n  }\n}\n\n/**\n * @internal\n */\nconst DirectListingInputParamsSchema = /* @__PURE__ */(() => z.object({\n  /**\n   * The address of the asset being listed.\n   */\n  assetContractAddress: AddressOrEnsSchema,\n  /**\n   * The ID of the token to list.\n   */\n  tokenId: BigNumberishSchema,\n  /**\n   * The quantity of tokens to include in the listing.\n   *\n   * For ERC721s, this value should always be 1 (and will be forced internally regardless of what is passed here).\n   */\n  quantity: BigNumberishSchema.default(1),\n  /**\n   * The address of the currency to accept for the listing.\n   */\n  currencyContractAddress: AddressOrEnsSchema.default(NATIVE_TOKEN_ADDRESS),\n  /**\n   * The price to pay per unit of NFTs listed.\n   */\n  pricePerToken: AmountSchema,\n  /**\n   * The start time of the listing.\n   */\n  startTimestamp: RawDateSchema.default(new Date()),\n  /**\n   * The end time of the listing.\n   */\n  endTimestamp: EndDateSchema,\n  /**\n   * Whether the listing is reserved to be bought from a specific set of buyers.\n   */\n  isReservedListing: z.boolean().default(false)\n}))();\n\n/**\n * @public\n */\n\n/**\n * Allows overriding transaction behavior for this contract\n * @public\n */\nclass ContractInterceptor {\n  constructor(contractWrapper) {\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * The next transaction executed will add/replace any overrides passed via the passed in hook.\n   * @remarks Overridden values will be applied to the next transaction executed.\n   * @example\n   * ```javascript\n   * contract.interceptor.overrideNextTransaction(() => ({\n   *   gasLimit: 3000000,\n   * }));\n   * ```\n   * @param hook - the hook to add or replace any CallOverrides (gas limit, gas price, nonce, from, value, etc...)\n   * @public\n   */\n  overrideNextTransaction(hook) {\n    this.contractWrapper.withTransactionOverride(hook);\n  }\n}\n\n/**\n * Estimates the gas cost of Contract calls\n * @public\n */\nclass GasCostEstimator {\n  constructor(contractWrapper) {\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * Estimates the cost of gas in native token of the current chain\n   * Pass in the same parameters as the contract's function.\n   * @remarks Estimate the cost of gas in native token of the current chain\n   * @example\n   * ```javascript\n   * const costOfClaim = await nftDrop?.estimator.gasCostOf(\"claim\", [\n   *   \"0x...\", // receiver\n   *   1, // quantity\n   *   \"0x...\", // currency\n   *   1, // price per token\n   *   [], // proofs\n   *   1, // proof max quantity per transaction\n   * ]);\n   * ```\n   * @returns the estimated price in native currency (ETH, MATIC, etc) of calling this function\n   * @public\n   */\n  async gasCostOf(\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  fn, args) {\n    const [price, gasUnits] = await Promise.all([this.contractWrapper.getProvider().getGasPrice(), this.contractWrapper.estimateGas(fn, args)]);\n    return utils.formatEther(gasUnits.mul(price));\n  }\n\n  /**\n   * Estimates the gas limit of a transaction\n   * Pass in the same parameters as the contract's function.\n   * @remarks Estimates the gas limit of a transaction\n   * @example\n   * ```javascript\n   * const gasLimitOfClaim = await nftDrop?.estimator.gasLimitOf(\"claim\", [\n   *   \"0x...\", // receiver\n   *   1, // quantity\n   *   \"0x...\", // currency\n   *   1, // price per token\n   *   [], // proofs\n   *   1, // proof max quantity per transaction\n   * ]);\n   * ```\n   * @returns the estimated gas limit of the transaction\n   * @public\n   */\n  async gasLimitOf(\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  fn, args) {\n    return this.contractWrapper.estimateGas(fn, args);\n  }\n\n  /**\n   * Returns the current gas price in gwei\n   * @remarks Get the current gas price in gwei\n   * @example\n   * ```javascript\n   * const gasCostInGwei = await contract.estimator.currentGasPriceInGwei();\n   * ```\n   * @returns the current gas price in gwei\n   * @public\n   */\n  async currentGasPriceInGwei() {\n    const price = await this.contractWrapper.getProvider().getGasPrice();\n    return utils.formatUnits(price, \"gwei\");\n  }\n}\n\n/**\n * Handles direct listings\n * @public\n */\nclass MarketplaceV3DirectListings {\n  featureName = FEATURE_DIRECT_LISTINGS.name;\n\n  // utilities\n\n  constructor(contractWrapper, storage) {\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n    this.events = new ContractEvents(this.contractWrapper);\n    this.encoder = new ContractEncoder(this.contractWrapper);\n    this.interceptor = new ContractInterceptor(this.contractWrapper);\n    this.estimator = new GasCostEstimator(this.contractWrapper);\n  }\n  getAddress() {\n    return this.contractWrapper.address;\n  }\n\n  /** ******************************\n   * READ FUNCTIONS\n   *******************************/\n\n  /**\n   * Get the total number of direct listings\n   *\n   * @returns Returns the total number of direct listings created.\n   * @public\n   *\n   * @example\n   * ```javascript\n   * const totalListings = await contract.directListings.getTotalCount();\n   * ```\n   * @twfeature DirectListings\n   */\n  async getTotalCount() {\n    return await this.contractWrapper.read(\"totalListings\", []);\n  }\n\n  /**\n   * Get all direct listings\n   *\n   * @example\n   * ```javascript\n   * const listings = await contract.directListings.getAll();\n   * ```\n   *\n   * @param filter - optional filter parameters\n   * @returns the Direct listing object array\n   * @twfeature DirectListings\n   */\n  async getAll(filter) {\n    const totalListings = await this.getTotalCount();\n    const start = BigNumber.from(filter?.start || 0).toNumber();\n    const end = totalListings.toNumber();\n    if (end === 0) {\n      throw new Error(`No listings exist on the contract.`);\n    }\n    let rawListings = [];\n    const batches = await getAllInBatches(start, end, (startId, endId) => this.contractWrapper.read(\"getAllListings\", [startId, endId]));\n    rawListings = batches.flat();\n    const filteredListings = await this.applyFilter(rawListings, filter);\n    return await Promise.all(filteredListings.map(listing => this.mapListing(listing)));\n  }\n\n  /**\n   * Get all valid direct listings\n   *\n   * @remarks A valid listing is where the listing is active, and the creator still owns & has approved Marketplace to transfer the listed NFTs.\n   *\n   * @example\n   * ```javascript\n   * const listings = await contract.directListings.getAllValid();\n   * ```\n   *\n   * @param filter - optional filter parameters\n   * @returns the Direct listing object array\n   * @twfeature DirectListings\n   */\n  async getAllValid(filter) {\n    const totalListings = await this.getTotalCount();\n    const start = BigNumber.from(filter?.start || 0).toNumber();\n    const end = totalListings.toNumber();\n    if (end === 0) {\n      throw new Error(`No listings exist on the contract.`);\n    }\n    let rawListings = [];\n    const batches = await getAllInBatches(start, end, (startId, endId) => this.contractWrapper.read(\"getAllValidListings\", [startId, endId]));\n    rawListings = batches.flat();\n    const filteredListings = await this.applyFilter(rawListings, filter);\n    return await Promise.all(filteredListings.map(listing => this.mapListing(listing)));\n  }\n\n  /**\n   * Get a single direct listing\n   *\n   * @example\n   * ```javascript\n   * const listingId = 0;\n   * const listing = await contract.directListings.getListing(listingId);\n   * ```\n   *\n   * @param listingId - the listing id\n   * @returns the Direct listing object\n   *\n   * @example\n   * ```javascript\n   * const listingId = 0;\n   * const listing = await contract.directListings.getListing(listingId);\n   * ```\n   * @twfeature DirectListings\n   */\n  async getListing(listingId) {\n    const listing = await this.contractWrapper.read(\"getListing\", [listingId]);\n    return await this.mapListing(listing);\n  }\n\n  /**\n   * Check if a buyer is approved for a specific direct listing\n   *\n   * @example\n   * ```javascript\n   * const listingId = 0;\n   * const isBuyerApproved = await contract.directListings.isBuyerApprovedForListing(listingId, \"{{wallet_address}}\");\n   *\n   * @param listingId - the listing id\n   * @param buyer - buyer address\n   * @twfeature DirectListings\n   */\n  async isBuyerApprovedForListing(listingId, buyer) {\n    const listing = await this.validateListing(BigNumber.from(listingId));\n    if (!listing.isReservedListing) {\n      throw new Error(`Listing ${listingId} is not a reserved listing.`);\n    }\n    return await this.contractWrapper.read(\"isBuyerApprovedForListing\", [listingId, await resolveAddress(buyer)]);\n  }\n\n  /**\n   * Check if a currency is approved for a specific direct listing\n   *\n   * @example\n   * ```javascript\n   * const listingId = 0;\n   * const currencyContractAddress = '0x1234';\n   * const isApproved = await contract.directListings.isCurrencyApprovedForListing(listingId, currencyContractAddress);\n   * ```\n   *\n   * @param listingId - the listing id\n   * @param currency - currency address\n   * @twfeature DirectListings\n   */\n  async isCurrencyApprovedForListing(listingId, currency) {\n    await this.validateListing(BigNumber.from(listingId));\n    return await this.contractWrapper.read(\"isCurrencyApprovedForListing\", [listingId, await resolveAddress(currency)]);\n  }\n\n  /**\n   * Check price per token for an approved currency\n   *\n   * @example\n   * ```javascript\n   * const listingId = 0;\n   * const currencyContractAddress = '0x1234';\n   * const price = await contract.directListings.currencyPriceForListing(listingId, currencyContractAddress);\n   * ```\n   *\n   * @param listingId - the listing id\n   * @param currencyContractAddress - currency contract address\n   * @twfeature DirectListings\n   */\n  async currencyPriceForListing(listingId, currencyContractAddress) {\n    const listing = await this.validateListing(BigNumber.from(listingId));\n    const resolvedCurrencyAddress = await resolveAddress(currencyContractAddress);\n    if (resolvedCurrencyAddress === listing.currencyContractAddress) {\n      return listing.pricePerToken;\n    }\n    const isApprovedCurrency = await this.isCurrencyApprovedForListing(listingId, resolvedCurrencyAddress);\n    if (!isApprovedCurrency) {\n      throw new Error(`Currency ${resolvedCurrencyAddress} is not approved for Listing ${listingId}.`);\n    }\n    return await this.contractWrapper.read(\"currencyPriceForListing\", [listingId, resolvedCurrencyAddress]);\n  }\n\n  /** ******************************\n   * WRITE FUNCTIONS\n   *******************************/\n\n  /**\n   * Create new direct listing\n   *\n   * @remarks Create a new listing on the marketplace where people can buy an asset directly.\n   *\n   * @example\n   * ```javascript\n   * // Data of the listing you want to create\n   * const listing = {\n   *   // address of the contract the asset you want to list is on\n   *   assetContractAddress: \"0x...\",\n   *   // token ID of the asset you want to list\n   *   tokenId: \"0\",\n   *   // how many of the asset you want to list\n   *   quantity: 1,\n   *   // address of the currency contract that will be used to pay for the listing\n   *   currencyContractAddress: NATIVE_TOKEN_ADDRESS,\n   *   // The price to pay per unit of NFTs listed.\n   *   pricePerToken: 1.5,\n   *   // when should the listing open up for offers\n   *   startTimestamp: new Date(Date.now()),\n   *   // how long the listing will be open for\n   *   endTimestamp: new Date(Date.now() + 5 * 24 * 60 * 60 * 1000),\n   *   // Whether the listing is reserved for a specific set of buyers.\n   *   isReservedListing: false\n   * }\n   *\n   * const tx = await contract.directListings.createListing(listing);\n   * const receipt = tx.receipt; // the transaction receipt\n   * const id = tx.id; // the id of the newly created listing\n   * ```\n   * @twfeature DirectListings\n   */\n  createListing = /* @__PURE__ */buildTransactionFunction(async listing => {\n    const parsedListing = await DirectListingInputParamsSchema.parseAsync(listing);\n    await handleTokenApproval(this.contractWrapper, this.getAddress(), parsedListing.assetContractAddress, parsedListing.tokenId, await this.contractWrapper.getSignerAddress());\n    const normalizedPricePerToken = await normalizePriceValue(this.contractWrapper.getProvider(), parsedListing.pricePerToken, parsedListing.currencyContractAddress);\n    const block = await this.contractWrapper.getProvider().getBlock(\"latest\");\n    const blockTime = block.timestamp;\n    if (parsedListing.startTimestamp.lt(blockTime)) {\n      parsedListing.startTimestamp = BigNumber.from(blockTime);\n    }\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"createListing\",\n      args: [{\n        assetContract: parsedListing.assetContractAddress,\n        tokenId: parsedListing.tokenId,\n        quantity: parsedListing.quantity,\n        currency: cleanCurrencyAddress(parsedListing.currencyContractAddress),\n        pricePerToken: normalizedPricePerToken,\n        startTimestamp: parsedListing.startTimestamp,\n        endTimestamp: parsedListing.endTimestamp,\n        reserved: parsedListing.isReservedListing\n      }],\n      parse: receipt => {\n        const event = this.contractWrapper.parseLogs(\"NewListing\", receipt?.logs);\n        return {\n          id: event[0].args.listingId,\n          receipt\n        };\n      }\n    });\n  });\n\n  /**\n   * Create a batch of new listings\n   *\n   * @remarks Create a batch of new listings on the marketplace\n   *\n   * @example\n   * ```javascript\n   * const listings = [...];\n   * const tx = await contract.directListings.createListingsBatch(listings);\n   * ```\n   */\n  createListingsBatch = /* @__PURE__ */buildTransactionFunction(async listings => {\n    const data = await Promise.all(listings.map(async listing => {\n      const tx = await this.createListing.prepare(listing);\n      return tx.encode();\n    }));\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"multicall\",\n      args: [data],\n      parse: receipt => {\n        const events = this.contractWrapper.parseLogs(\"NewListing\", receipt?.logs);\n        return events.map(event => {\n          return {\n            id: event.args.listingId,\n            receipt\n          };\n        });\n      }\n    });\n  });\n\n  /**\n   * Update a direct listing\n   *\n   * @param listing - the new listing information\n   *\n   * @example\n   * ```javascript\n   * // Data of the listing you want to update\n   *\n   * const listingId = 0; // ID of the listing you want to update\n   *\n   * const listing = {\n   *   // address of the contract the asset you want to list is on\n   *   assetContractAddress: \"0x...\", // should be same as original listing\n   *   // token ID of the asset you want to list\n   *   tokenId: \"0\", // should be same as original listing\n   *   // how many of the asset you want to list\n   *   quantity: 1,\n   *   // address of the currency contract that will be used to pay for the listing\n   *   currencyContractAddress: NATIVE_TOKEN_ADDRESS,\n   *   // The price to pay per unit of NFTs listed.\n   *   pricePerToken: 1.5,\n   *   // when should the listing open up for offers\n   *   startTimestamp: new Date(Date.now()), // can't change this if listing already active\n   *   // how long the listing will be open for\n   *   endTimestamp: new Date(Date.now() + 5 * 24 * 60 * 60 * 1000),\n   *   // Whether the listing is reserved for a specific set of buyers.\n   *   isReservedListing: false\n   * }\n   *\n   * const tx = await contract.directListings.updateListing(listingId, listing);\n   * const receipt = tx.receipt; // the transaction receipt\n   * const id = tx.id; // the id of the newly created listing\n   * ```\n   * @twfeature DirectListings\n   */\n  updateListing = /* @__PURE__ */buildTransactionFunction(async (listingId, listing) => {\n    const parsedListing = await DirectListingInputParamsSchema.parseAsync(listing);\n    await handleTokenApproval(this.contractWrapper, this.getAddress(), parsedListing.assetContractAddress, parsedListing.tokenId, await this.contractWrapper.getSignerAddress());\n    const normalizedPricePerToken = await normalizePriceValue(this.contractWrapper.getProvider(), parsedListing.pricePerToken, parsedListing.currencyContractAddress);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"updateListing\",\n      args: [listingId, {\n        assetContract: parsedListing.assetContractAddress,\n        tokenId: parsedListing.tokenId,\n        quantity: parsedListing.quantity,\n        currency: cleanCurrencyAddress(parsedListing.currencyContractAddress),\n        pricePerToken: normalizedPricePerToken,\n        startTimestamp: parsedListing.startTimestamp,\n        endTimestamp: parsedListing.endTimestamp,\n        reserved: parsedListing.isReservedListing\n      }],\n      parse: receipt => {\n        const event = this.contractWrapper.parseLogs(\"UpdatedListing\", receipt?.logs);\n        return {\n          id: event[0].args.listingId,\n          receipt\n        };\n      }\n    });\n  });\n\n  /**\n   * Cancel Direct Listing\n   *\n   * @remarks Cancel a direct listing on the marketplace\n   *\n   * @example\n   * ```javascript\n   * // The listing ID of the direct listing you want to cancel\n   * const listingId = 0;\n   *\n   * await contract.directListings.cancelListing(listingId);\n   * ```\n   * @twfeature DirectListings\n   */\n  cancelListing = /* @__PURE__ */buildTransactionFunction(async listingId => {\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"cancelListing\",\n      args: [listingId]\n    });\n  });\n\n  /**\n   * Buy direct listing for a specific wallet\n   *\n   * @remarks Buy from a specific direct listing from the marketplace.\n   *\n   * @example\n   * ```javascript\n   * // The ID of the listing you want to buy from\n   * const listingId = 0;\n   * // Quantity of the asset you want to buy\n   * const quantityDesired = 1;\n   *\n   * await contract.directListings.buyFromListing(listingId, quantityDesired, \"{{wallet_address}}\");\n   * ```\n   *\n   * @param listingId - The listing id to buy\n   * @param quantityDesired - the quantity to buy\n   * @param receiver - optional receiver of the bought listing if different from the connected wallet\n   * @twfeature DirectListings\n   */\n  buyFromListing = /* @__PURE__ */buildTransactionFunction(async (listingId, quantityDesired, receiver) => {\n    if (receiver) {\n      receiver = await resolveAddress(receiver);\n    }\n    const listing = await this.validateListing(BigNumber.from(listingId));\n    const {\n      valid,\n      error\n    } = await this.isStillValidListing(listing, quantityDesired);\n    if (!valid) {\n      throw new Error(`Listing ${listingId} is no longer valid. ${error}`);\n    }\n    const buyFor = receiver ? receiver : await this.contractWrapper.getSignerAddress();\n    const quantity = BigNumber.from(quantityDesired);\n    const value = BigNumber.from(listing.pricePerToken).mul(quantity);\n    const overrides = (await this.contractWrapper.getCallOverrides()) || {};\n    await setErc20Allowance(this.contractWrapper, value, listing.currencyContractAddress, overrides);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"buyFromListing\",\n      args: [listingId, buyFor, quantity, listing.currencyContractAddress, value],\n      overrides\n    });\n  });\n\n  /**\n   * Approve buyer for a reserved direct listing\n   *\n   * @remarks Approve a buyer to buy from a reserved listing.\n   *\n   * @example\n   * ```javascript\n   * // The listing ID of the direct listing you want to approve buyer for\n   * const listingId = \"0\";\n   *\n   * await contract.directListings.approveBuyerForReservedListing(listingId, \"{{wallet_address}}\");\n   * ```\n   *\n   * @param listingId - The listing id to buy\n   * @param buyer - Address of buyer being approved\n   * @twfeature DirectListings\n   */\n  approveBuyerForReservedListing = /* @__PURE__ */buildTransactionFunction(async (listingId, buyer) => {\n    const isApproved = await this.isBuyerApprovedForListing(listingId, buyer);\n    if (!isApproved) {\n      return Transaction.fromContractWrapper({\n        contractWrapper: this.contractWrapper,\n        method: \"approveBuyerForListing\",\n        args: [listingId, buyer, true]\n      });\n    } else {\n      throw new Error(`Buyer ${buyer} already approved for listing ${listingId}.`);\n    }\n  });\n\n  /**\n   * Revoke approval of a buyer for a reserved direct listing\n   *\n   * @example\n   * ```javascript\n   * // The listing ID of the direct listing you want to approve buyer for\n   * const listingId = \"0\";\n   *\n   * await contract.directListings.revokeBuyerApprovalForReservedListing(listingId, \"{{wallet_address}}\");\n   * ```\n   *\n   * @param listingId - The listing id to buy\n   * @param buyer - Address of buyer being approved\n   */\n  revokeBuyerApprovalForReservedListing = /* @__PURE__ */buildTransactionFunction(async (listingId, buyer) => {\n    const isApproved = await this.isBuyerApprovedForListing(listingId, buyer);\n    if (isApproved) {\n      return Transaction.fromContractWrapper({\n        contractWrapper: this.contractWrapper,\n        method: \"approveBuyerForListing\",\n        args: [listingId, buyer, false]\n      });\n    } else {\n      throw new Error(`Buyer ${buyer} not approved for listing ${listingId}.`);\n    }\n  });\n\n  /**\n   * Approve a currency for a direct listing\n   *\n   *\n   * @example\n   * ```javascript\n   * // The listing ID of the direct listing you want to approve currency for\n   * const listingId = \"0\";\n   *\n   * await contract.directListings.approveCurrencyForListing(listingId, currencyContractAddress, pricePerTokenInCurrency);\n   * ```\n   *\n   * @param listingId - The listing id to buy\n   * @param currencyContractAddress - Address of currency being approved\n   * @param pricePerTokenInCurrency - Price per token in the currency\n   * @twfeature DirectListings\n   */\n  approveCurrencyForListing = /* @__PURE__ */buildTransactionFunction(async (listingId, currencyContractAddress, pricePerTokenInCurrency) => {\n    const listing = await this.validateListing(BigNumber.from(listingId));\n    const resolvedCurrencyAddress = await resolveAddress(currencyContractAddress);\n    if (resolvedCurrencyAddress === listing.currencyContractAddress) {\n      invariant(pricePerTokenInCurrency === listing.pricePerToken, \"Approving listing currency with a different price.\");\n    }\n    const currencyPrice = await this.contractWrapper.read(\"currencyPriceForListing\", [listingId, resolvedCurrencyAddress]);\n    invariant(pricePerTokenInCurrency === currencyPrice, \"Currency already approved with this price.\");\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"approveCurrencyForListing\",\n      args: [listingId, resolvedCurrencyAddress, pricePerTokenInCurrency]\n    });\n  });\n\n  /**\n   * Revoke approval of a currency for a direct listing\n   *\n   *\n   * @example\n   * ```javascript\n   * // The listing ID of the direct listing you want to revoke currency for\n   * const listingId = \"0\";\n   *\n   * await contract.directListings.revokeCurrencyApprovalForListing(listingId, currencyContractAddress);\n   * ```\n   *\n   * @param listingId - The listing id to buy\n   * @param currencyContractAddress - Address of currency\n   * @twfeature DirectListings\n   */\n  revokeCurrencyApprovalForListing = /* @__PURE__ */buildTransactionFunction(async (listingId, currencyContractAddress) => {\n    const listing = await this.validateListing(BigNumber.from(listingId));\n    const resolvedCurrencyAddress = await resolveAddress(currencyContractAddress);\n    if (resolvedCurrencyAddress === listing.currencyContractAddress) {\n      throw new Error(`Can't revoke approval for main listing currency.`);\n    }\n    const currencyPrice = await this.contractWrapper.read(\"currencyPriceForListing\", [listingId, resolvedCurrencyAddress]);\n    invariant(!currencyPrice.isZero(), \"Currency not approved.\");\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"approveCurrencyForListing\",\n      args: [listingId, resolvedCurrencyAddress, BigNumber.from(0)]\n    });\n  });\n\n  /** ******************************\n   * PRIVATE FUNCTIONS\n   *******************************/\n\n  /**\n   * Throws error if listing could not be found\n   *\n   * @param listingId - Listing to check for\n   */\n  async validateListing(listingId) {\n    try {\n      return await this.getListing(listingId);\n    } catch (err) {\n      console.error(`Error getting the listing with id ${listingId}`);\n      throw err;\n    }\n  }\n\n  /**\n   * Helper method maps the auction listing to the direct listing interface.\n   *\n   * @internal\n   * @param listing - The listing to map, as returned from the contract.\n   * @returns - The mapped interface.\n   */\n  async mapListing(listing) {\n    let status = Status.UNSET;\n    const block = await this.contractWrapper.getProvider().getBlock(\"latest\");\n    const blockTime = block.timestamp;\n    switch (listing.status) {\n      case 1:\n        status = BigNumber.from(listing.startTimestamp).gt(blockTime) ? Status.Created : BigNumber.from(listing.endTimestamp).lt(blockTime) ? Status.Expired : Status.Active;\n        break;\n      case 2:\n        status = Status.Completed;\n        break;\n      case 3:\n        status = Status.Cancelled;\n        break;\n    }\n    return {\n      assetContractAddress: listing.assetContract,\n      currencyContractAddress: listing.currency,\n      pricePerToken: listing.pricePerToken.toString(),\n      currencyValuePerToken: await fetchCurrencyValue(this.contractWrapper.getProvider(), listing.currency, listing.pricePerToken),\n      id: listing.listingId.toString(),\n      tokenId: listing.tokenId.toString(),\n      quantity: listing.quantity.toString(),\n      startTimeInSeconds: BigNumber.from(listing.startTimestamp).toNumber(),\n      asset: await fetchTokenMetadataForContract(listing.assetContract, this.contractWrapper.getProvider(), listing.tokenId, this.storage),\n      endTimeInSeconds: BigNumber.from(listing.endTimestamp).toNumber(),\n      creatorAddress: listing.listingCreator,\n      isReservedListing: listing.reserved,\n      status: status\n    };\n  }\n\n  /**\n   * Use this method to check if a direct listing is still valid.\n   *\n   * Ways a direct listing can become invalid:\n   * 1. The asset holder transferred the asset to another wallet\n   * 2. The asset holder burned the asset\n   * 3. The asset holder removed the approval on the marketplace\n   *\n   * @internal\n   * @param listing - The listing to check.\n   * @returns - True if the listing is valid, false otherwise.\n   */\n  async isStillValidListing(listing, quantity) {\n    const approved = await isTokenApprovedForTransfer(this.contractWrapper.getProvider(), this.getAddress(), listing.assetContractAddress, listing.tokenId, listing.creatorAddress);\n    if (!approved) {\n      return {\n        valid: false,\n        error: `Token '${listing.tokenId}' from contract '${listing.assetContractAddress}' is not approved for transfer`\n      };\n    }\n    const provider = this.contractWrapper.getProvider();\n    const erc165 = new Contract(listing.assetContractAddress, ERC165Abi, provider);\n    const isERC721 = await erc165.supportsInterface(InterfaceId_IERC721);\n    const isERC1155 = await erc165.supportsInterface(InterfaceId_IERC1155);\n    if (isERC721) {\n      const asset = new Contract(listing.assetContractAddress, Erc721Abi, provider);\n\n      // Handle reverts in case of non-existent tokens\n      let owner;\n      try {\n        owner = await asset.ownerOf(listing.tokenId);\n      } catch (e) {}\n      const valid = owner?.toLowerCase() === listing.creatorAddress.toLowerCase();\n      return {\n        valid,\n        error: valid ? undefined : `Seller is not the owner of Token '${listing.tokenId}' from contract '${listing.assetContractAddress} anymore'`\n      };\n    } else if (isERC1155) {\n      const asset = new Contract(listing.assetContractAddress, Erc1155Abi, provider);\n      const balance = await asset.balanceOf(listing.creatorAddress, listing.tokenId);\n      const valid = balance.gte(quantity || listing.quantity);\n      return {\n        valid,\n        error: valid ? undefined : `Seller does not have enough balance of Token '${listing.tokenId}' from contract '${listing.assetContractAddress} to fulfill the listing`\n      };\n    } else {\n      return {\n        valid: false,\n        error: \"Contract does not implement ERC 1155 or ERC 721.\"\n      };\n    }\n  }\n  async applyFilter(listings, filter) {\n    let rawListings = [...listings];\n    if (filter) {\n      if (filter.seller) {\n        const resolvedSeller = await resolveAddress(filter.seller);\n        rawListings = rawListings.filter(seller => seller.listingCreator.toString().toLowerCase() === resolvedSeller?.toString().toLowerCase());\n      }\n      if (filter.tokenContract) {\n        const resolvedToken = await resolveAddress(filter.tokenContract);\n        rawListings = rawListings.filter(tokenContract => tokenContract.assetContract.toString().toLowerCase() === resolvedToken?.toString().toLowerCase());\n      }\n      if (filter.tokenId !== undefined) {\n        rawListings = rawListings.filter(tokenContract => tokenContract.tokenId.toString() === filter?.tokenId?.toString());\n      }\n    }\n    return filter?.count && filter.count < rawListings.length ? rawListings.slice(0, filter.count) : rawListings;\n  }\n}\n\n/**\n * @internal\n */\nconst EnglishAuctionInputParamsSchema = /* @__PURE__ */(() => z.object({\n  /**\n   * The address of the asset being auctioned.\n   */\n  assetContractAddress: AddressOrEnsSchema,\n  /**\n   * The ID of the token to auction.\n   */\n  tokenId: BigNumberishSchema,\n  /**\n   * The quantity of tokens to include in the listing.\n   *\n   * For ERC721s, this value should always be 1 (and will be forced internally regardless of what is passed here).\n   */\n  quantity: BigNumberishSchema.default(1),\n  /**\n   * The address of the currency to accept for the listing.\n   */\n  currencyContractAddress: AddressOrEnsSchema.default(NATIVE_TOKEN_ADDRESS),\n  /**\n   * The minimum price that a bid must be in order to be accepted.\n   */\n  minimumBidAmount: AmountSchema,\n  /**\n   * The buyout price of the auction.\n   */\n  buyoutBidAmount: AmountSchema,\n  /**\n   * This is a buffer e.g. x seconds.\n   *\n   * If a new winning bid is made less than x seconds before expirationTimestamp, the\n   * expirationTimestamp is increased by x seconds.\n   */\n  timeBufferInSeconds: BigNumberishSchema.default(900),\n  // 15 minutes by default\n\n  /**\n   * This is a buffer in basis points e.g. x%.\n   *\n   * To be considered as a new winning bid, a bid must be at least x% greater than\n   * the current winning bid.\n   */\n  bidBufferBps: BigNumberishSchema.default(500),\n  // 5% by default\n\n  /**\n   * The start time of the auction.\n   */\n  startTimestamp: RawDateSchema.default(new Date()),\n  /**\n   * The end time of the auction.\n   */\n  endTimestamp: EndDateSchema\n}))();\n\n/**\n * @public\n */\n\n/**\n * Handles auctions\n * @public\n */\nclass MarketplaceV3EnglishAuctions {\n  featureName = FEATURE_ENGLISH_AUCTIONS.name;\n\n  // utilities\n\n  constructor(contractWrapper, storage) {\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n    this.events = new ContractEvents(this.contractWrapper);\n    this.encoder = new ContractEncoder(this.contractWrapper);\n    this.interceptor = new ContractInterceptor(this.contractWrapper);\n    this.estimator = new GasCostEstimator(this.contractWrapper);\n  }\n  getAddress() {\n    return this.contractWrapper.address;\n  }\n\n  /** ******************************\n   * READ FUNCTIONS\n   *******************************/\n\n  /**\n   * Get the total number of english auctions\n   *\n   * @returns Returns the total number of auctions created.\n   * @public\n   *\n   * @example\n   * ```javascript\n   * const totalAuctions = await contract.englishAuctions.getTotalCount();\n   * ```\n   * @twfeature EnglishAuctions\n   */\n  async getTotalCount() {\n    return await this.contractWrapper.read(\"totalAuctions\", []);\n  }\n\n  /**\n   * Get all english auctions\n   *\n   * @example\n   * ```javascript\n   * const auctions = await contract.englishAuctions.getAll();\n   * ```\n   *\n   * @param filter - optional filter parameters\n   * @returns the Auction object array\n   * @twfeature EnglishAuctions\n   */\n  async getAll(filter) {\n    const totalAuctions = await this.getTotalCount();\n    const start = BigNumber.from(filter?.start || 0).toNumber();\n    const end = totalAuctions.toNumber();\n    if (end === 0) {\n      throw new Error(`No auctions exist on the contract.`);\n    }\n    let rawAuctions = [];\n    const batches = await getAllInBatches(start, end, (startId, endId) => this.contractWrapper.read(\"getAllAuctions\", [startId, endId]));\n    rawAuctions = batches.flat();\n    const filteredAuctions = await this.applyFilter(rawAuctions, filter);\n    return await Promise.all(filteredAuctions.map(auction => this.mapAuction(auction)));\n  }\n\n  /**\n   * Get all valid english auctions\n   *\n   * @example\n   * ```javascript\n   * const auctions = await contract.englishAuctions.getAllValid();\n   * ```\n   *\n   * @param filter - optional filter parameters\n   * @returns the Auction object array\n   * @twfeature EnglishAuctions\n   */\n  async getAllValid(filter) {\n    const totalAuctions = await this.getTotalCount();\n    const start = BigNumber.from(filter?.start || 0).toNumber();\n    const end = totalAuctions.toNumber();\n    if (end === 0) {\n      throw new Error(`No auctions exist on the contract.`);\n    }\n    let rawAuctions = [];\n    const batches = await getAllInBatches(start, end, (startId, endId) => this.contractWrapper.read(\"getAllValidAuctions\", [startId, endId]));\n    rawAuctions = batches.flat();\n    const filteredAuctions = await this.applyFilter(rawAuctions, filter);\n    return await Promise.all(filteredAuctions.map(auction => this.mapAuction(auction)));\n  }\n\n  /**\n   * Get a single english auction\n   *\n   * @example\n   * ```javascript\n   * const auctionId = 0;\n   * const auction = await contract.englishAuctions.getAuction(auctionId);\n   * ```\n   *\n   * @param auctionId - the auction Id\n   * @returns the Auction object\n   * @twfeature EnglishAuctions\n   */\n  async getAuction(auctionId) {\n    const auction = await this.contractWrapper.read(\"getAuction\", [auctionId]);\n    return await this.mapAuction(auction);\n  }\n\n  /**\n   * Get winning bid of an english auction\n   *\n   * @remarks Get the current highest bid of an active auction.\n   *\n   * @example\n   * ```javascript\n   * // The ID of the auction\n   * const auctionId = 0;\n   * const winningBid = await contract.englishAuctions.getWinningBid(auctionId);\n   * ```\n   * @param auctionId - the auction Id\n   * @twfeature EnglishAuctions\n   */\n  async getWinningBid(auctionId) {\n    await this.validateAuction(BigNumber.from(auctionId));\n    const bid = await this.contractWrapper.read(\"getWinningBid\", [auctionId]);\n    if (bid._bidder === constants.AddressZero) {\n      return undefined;\n    }\n    return await this.mapBid(auctionId.toString(), bid._bidder, bid._currency, bid._bidAmount.toString());\n  }\n\n  /**\n   * Check if a bid is or will be a winning bid\n   *\n   * @example\n   * ```javascript\n   * const auctionId = 0;\n   * const bidAmount = 100;\n   * const isWinningBid = await contract.englishAuctions.isWinningBid(auctionId, bidAmount);\n   * ```\n   *\n   * @param auctionId - Auction Id\n   * @param bidAmount - Amount to bid\n   * @returns true if the bid is or will be a winning bid\n   * @twfeature EnglishAuctions\n   */\n  async isWinningBid(auctionId, bidAmount) {\n    return await this.contractWrapper.read(\"isNewWinningBid\", [auctionId, bidAmount]);\n  }\n\n  /**\n   * Get the winner for a specific english auction\n   *\n   * @remarks Get the winner of the auction after an auction ends.\n   *\n   * @example\n   * ```javascript\n   * // The auction ID of a closed english auction\n   * const auctionId = 0;\n   * const auctionWinner = await contract.englishAuctions.getWinner(auctionId);\n   * ```\n   * @param auctionId - the auction Id\n   * @returns the address of the auction winner\n   * @twfeature EnglishAuctions\n   */\n  async getWinner(auctionId) {\n    const auction = await this.validateAuction(BigNumber.from(auctionId));\n    const bid = await this.contractWrapper.read(\"getWinningBid\", [auctionId]);\n    const now = BigNumber.from(Math.floor(Date.now() / 1000));\n    const endTime = BigNumber.from(auction.endTimeInSeconds);\n\n    // if we have a winner in the map and the current time is past the endtime of the auction return the address of the winner\n    if (now.gt(endTime) && bid._bidder !== constants.AddressZero) {\n      return bid._bidder;\n    }\n    // otherwise fall back to query filter things\n\n    // TODO this should be via indexer or direct contract call\n    const contractEvent = new ContractEvents(this.contractWrapper);\n    const closedAuctions = await contractEvent.getEvents(\"AuctionClosed\");\n    const closed = closedAuctions.find(a => a.data.auctionId.eq(BigNumber.from(auctionId)));\n    if (!closed) {\n      throw new Error(`Could not find auction with ID ${auctionId} in closed auctions`);\n    }\n    return closed.data.winningBidder;\n  }\n\n  /** ******************************\n   * WRITE FUNCTIONS\n   *******************************/\n\n  /**\n   * Create an english auction\n   *\n   * @remarks Create a new auction where people can bid on an asset.\n   *\n   * @example\n   * ```javascript\n   * // Data of the auction you want to create\n   * const auction = {\n   *   // address of the contract of the asset you want to auction\n   *   assetContractAddress: \"0x...\",\n   *   // token ID of the asset you want to auction\n   *   tokenId: \"0\",\n   *   // how many of the asset you want to auction\n   *   quantity: 1,\n   *   // address of the currency contract that will be used to pay for the auctioned tokens\n   *   currencyContractAddress: NATIVE_TOKEN_ADDRESS,\n   *   // the minimum bid that will be accepted for the token\n   *   minimumBidAmount: \"1.5\",\n   *   // how much people would have to bid to instantly buy the asset\n   *   buyoutBidAmount: \"10\",\n   *   // If a bid is made less than these many seconds before expiration, the expiration time is increased by this.\n   *   timeBufferInSeconds: \"900\", // 15 minutes by default\n   *   // A bid must be at least this much bps greater than the current winning bid\n   *   bidBufferBps: \"500\", // 5% by default\n   *   // when should the auction open up for bidding\n   *   startTimestamp: new Date(Date.now()),\n   *   // end time of auction\n   *   endTimestamp: new Date(Date.now() + 5 * 24 * 60 * 60 * 1000),\n   * }\n   *\n   * const tx = await contract.englishAuctions.createAuction(auction);\n   * const receipt = tx.receipt; // the transaction receipt\n   * const id = tx.id; // the id of the newly created auction\n   * ```\n   * @param auction - the auction data\n   * @returns the transaction hash and the auction id\n   * @twfeature EnglishAuctions\n   */\n  createAuction = /* @__PURE__ */buildTransactionFunction(async auction => {\n    const parsedAuction = EnglishAuctionInputParamsSchema.parse(auction);\n    await handleTokenApproval(this.contractWrapper, this.getAddress(), parsedAuction.assetContractAddress, parsedAuction.tokenId, await this.contractWrapper.getSignerAddress());\n    const normalizedBuyoutAmount = await normalizePriceValue(this.contractWrapper.getProvider(), parsedAuction.buyoutBidAmount, parsedAuction.currencyContractAddress);\n    const normalizedMinBidAmount = await normalizePriceValue(this.contractWrapper.getProvider(), parsedAuction.minimumBidAmount, parsedAuction.currencyContractAddress);\n    const block = await this.contractWrapper.getProvider().getBlock(\"latest\");\n    const blockTime = block.timestamp;\n    if (parsedAuction.startTimestamp.lt(blockTime)) {\n      parsedAuction.startTimestamp = BigNumber.from(blockTime);\n    }\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"createAuction\",\n      args: [{\n        assetContract: parsedAuction.assetContractAddress,\n        tokenId: parsedAuction.tokenId,\n        quantity: parsedAuction.quantity,\n        currency: cleanCurrencyAddress(parsedAuction.currencyContractAddress),\n        minimumBidAmount: normalizedMinBidAmount,\n        buyoutBidAmount: normalizedBuyoutAmount,\n        timeBufferInSeconds: parsedAuction.timeBufferInSeconds,\n        bidBufferBps: parsedAuction.bidBufferBps,\n        startTimestamp: parsedAuction.startTimestamp,\n        endTimestamp: parsedAuction.endTimestamp\n      }],\n      parse: receipt => {\n        const event = this.contractWrapper.parseLogs(\"NewAuction\", receipt.logs)[0];\n        return {\n          id: event.args.auctionId,\n          receipt\n        };\n      }\n    });\n  });\n\n  /**\n   * Create a batch of new auctions\n   *\n   * @remarks Create a batch of new auctions on the marketplace\n   *\n   * @example\n   * ```javascript\n   * const auctions = [...];\n   * const tx = await contract.englishAuctions.createAuctionsBatch(auctions);\n   * ```\n   */\n  createAuctionsBatch = /* @__PURE__ */buildTransactionFunction(async listings => {\n    const data = await Promise.all(listings.map(async listing => {\n      const tx = await this.createAuction.prepare(listing);\n      return tx.encode();\n    }));\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"multicall\",\n      args: [data],\n      parse: receipt => {\n        const events = this.contractWrapper.parseLogs(\"NewAuction\", receipt?.logs);\n        return events.map(event => {\n          return {\n            id: event.args.auctionId,\n            receipt\n          };\n        });\n      }\n    });\n  });\n\n  /**\n   * Buyout an english auction\n   *\n   * @remarks Buy a specific auction from the marketplace.\n   *\n   * @example\n   * ```javascript\n   * // The auction ID you want to buy\n   * const auctionId = 0;\n   *\n   * await contract.englishAuctions.buyoutAuction(auctionId);\n   * ```\n   * @param auctionId - the auction id\n   * @returns the transaction result\n   * @twfeature EnglishAuctions\n   */\n  buyoutAuction = /* @__PURE__ */buildTransactionFunction(async auctionId => {\n    const auction = await this.validateAuction(BigNumber.from(auctionId));\n    const currencyMetadata = await fetchCurrencyMetadata(this.contractWrapper.getProvider(), auction.currencyContractAddress);\n    return this.makeBid.prepare(auctionId, utils.formatUnits(auction.buyoutBidAmount, currencyMetadata.decimals));\n  });\n\n  /**\n   * Bid on an english auction\n   *\n   * @remarks Make a bid on an auction\n   *\n   * @example\n   * ```javascript\n   * // The auction ID of the asset you want to bid on\n   * const auctionId = 0;\n   * // The total amount you are willing to bid for auctioned tokens\n   * const bidAmount = 1;\n   *\n   * await contract.englishAuctions.makeBid(auctionId, bidAmount);\n   * ```\n   * @param auctionId - the auction id\n   * @param bidAmount - the amount you are willing to bid\n   * @returns the transaction result\n   * @twfeature EnglishAuctions\n   */\n  makeBid = /* @__PURE__ */buildTransactionFunction(async (auctionId, bidAmount) => {\n    const auction = await this.validateAuction(BigNumber.from(auctionId));\n    const normalizedBidAmount = await normalizePriceValue(this.contractWrapper.getProvider(), bidAmount, auction.currencyContractAddress);\n    if (normalizedBidAmount.eq(BigNumber.from(0))) {\n      throw new Error(\"Cannot make a bid with 0 value\");\n    }\n    if (BigNumber.from(auction.buyoutBidAmount).gt(0) && normalizedBidAmount.gt(auction.buyoutBidAmount)) {\n      throw new Error(\"Bid amount must be less than or equal to buyoutBidAmount\");\n    }\n    const winningBid = await this.getWinningBid(auctionId);\n    if (winningBid) {\n      const isWinnner = await this.isWinningBid(auctionId, normalizedBidAmount);\n      invariant(isWinnner, \"Bid price is too low based on the current winning bid and the bid buffer\");\n    } else {\n      const tokenPrice = normalizedBidAmount;\n      const minimumBidAmount = BigNumber.from(auction.minimumBidAmount);\n      invariant(tokenPrice.gte(minimumBidAmount), \"Bid price is too low based on minimum bid amount\");\n    }\n    const overrides = (await this.contractWrapper.getCallOverrides()) || {};\n    await setErc20Allowance(this.contractWrapper, normalizedBidAmount, auction.currencyContractAddress, overrides);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"bidInAuction\",\n      args: [auctionId, normalizedBidAmount],\n      overrides\n    });\n  });\n\n  /**\n   * Cancel an english auction\n   *\n   * @remarks Cancel an auction on the marketplace\n   *\n   * @example\n   * ```javascript\n   * // The ID of the auction you want to cancel\n   * const auctionId = \"0\";\n   *\n   * await contract.englishAuctions.cancelAuction(auctionId);\n   * ```\n   * @param auctionId - the auction id\n   * @returns the transaction result\n   * @twfeature EnglishAuctions\n   */\n  cancelAuction = /* @__PURE__ */buildTransactionFunction(async auctionId => {\n    const winningBid = await this.getWinningBid(auctionId);\n    if (winningBid) {\n      throw new Error(`Bids already made.`);\n    }\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"cancelAuction\",\n      args: [auctionId]\n    });\n  });\n\n  /**\n   * Close the english auction for the bidder\n   *\n   * @remarks Closes the Auction and executes the sale for the buyer.\n   *\n   * @example\n   * ```javascript\n   * // The ID of the auction you want to close\n   * const auction = \"0\";\n   * await contract.englishAuctions.closeAuctionForBidder(auctionId);\n   * ```\n   *\n   * @param auctionId - the auction id to close\n   * @param closeFor - optionally pass the winning bid offeror address to close the auction on their behalf\n   * @returns the transaction result\n   * @twfeature EnglishAuctions\n   */\n  closeAuctionForBidder = /* @__PURE__ */buildTransactionFunction(async (auctionId, closeFor) => {\n    if (!closeFor) {\n      closeFor = await this.contractWrapper.getSignerAddress();\n    }\n    const auction = await this.validateAuction(BigNumber.from(auctionId));\n    try {\n      return Transaction.fromContractWrapper({\n        contractWrapper: this.contractWrapper,\n        method: \"collectAuctionTokens\",\n        args: [BigNumber.from(auctionId)]\n      });\n    } catch (err) {\n      if (err.message.includes(\"Marketplace: auction still active.\")) {\n        throw new AuctionHasNotEndedError(auctionId.toString(), auction.endTimeInSeconds.toString());\n      } else {\n        throw err;\n      }\n    }\n  });\n\n  /**\n   * Close the english auction for the seller\n   *\n   * @remarks Closes the Auction and executes the sale for the seller.\n   *\n   * @example\n   * ```javascript\n   * // The ID of the auction you want to close\n   * const auctionId = \"0\";\n   * await contract.englishAuctions.closeAuctionForSeller(auctionId);\n   * ```\n   *\n   * @param auctionId - the auction id to close\n   * @returns the transaction result\n   * @twfeature EnglishAuctions\n   */\n  closeAuctionForSeller = /* @__PURE__ */buildTransactionFunction(async auctionId => {\n    const auction = await this.validateAuction(BigNumber.from(auctionId));\n    try {\n      return Transaction.fromContractWrapper({\n        contractWrapper: this.contractWrapper,\n        method: \"collectAuctionPayout\",\n        args: [BigNumber.from(auctionId)]\n      });\n    } catch (err) {\n      if (err.message.includes(\"Marketplace: auction still active.\")) {\n        throw new AuctionHasNotEndedError(auctionId.toString(), auction.endTimeInSeconds.toString());\n      } else {\n        throw err;\n      }\n    }\n  });\n\n  /**\n   * Close the english auction for both the seller and the bidder\n   *\n   * @remarks Closes the Auction and executes the sale for both parties.\n   *\n   * @example\n   * ```javascript\n   * // The ID of the auction you want to close\n   * const auction = \"0\";\n   * await contract.englishAuctions.executeSale(auctionId);\n   * ```\n   *\n   * @param auctionId - the auction to close\n   * @returns the transaction result\n   * @twfeature EnglishAuctions\n   */\n  executeSale = /* @__PURE__ */buildTransactionFunction(async auctionId => {\n    const auction = await this.validateAuction(BigNumber.from(auctionId));\n    try {\n      const winningBid = await this.getWinningBid(auctionId);\n      invariant(winningBid, \"No winning bid found\");\n      const closeForSeller = this.encoder.encode(\"collectAuctionPayout\", [auctionId]);\n      const closeForBuyer = this.encoder.encode(\"collectAuctionTokens\", [auctionId]);\n      return Transaction.fromContractWrapper({\n        contractWrapper: this.contractWrapper,\n        method: \"multicall\",\n        args: [[closeForSeller, closeForBuyer]]\n      });\n    } catch (err) {\n      if (err.message.includes(\"Marketplace: auction still active.\")) {\n        throw new AuctionHasNotEndedError(auctionId.toString(), auction.endTimeInSeconds.toString());\n      } else {\n        throw err;\n      }\n    }\n  });\n\n  /**\n   * Get the buffer for an english auction\n   *\n   * @example\n   * ```javascript\n   * // The ID of the auction you want to get the buffer for\n   * const auctionId = \"0\";\n   * const buffer = await contract.englishAuctions.getBidBufferBps(auctionId);\n   * ```\n   *\n   * @param auctionId - id of the auction\n   * @returns the buffer in basis points\n   * @twfeature EnglishAuctions\n   */\n  async getBidBufferBps(auctionId) {\n    return (await this.getAuction(auctionId)).bidBufferBps;\n  }\n\n  /**\n   * Get the minimum next bid for an english auction\n   *\n   * @example\n   * ```javascript\n   * // The ID of the auction you want to get the minimum next bid for\n   * const auctionId = \"0\";\n   * const minimumNextBid = await contract.englishAuctions.getMinimumNextBid(auctionId);\n   * ```\n   *\n   * @returns the minimum bid a user can place to outbid the previous highest bid\n   * @param auctionId - id of the auction\n   * @twfeature EnglishAuctions\n   */\n  async getMinimumNextBid(auctionId) {\n    // we can fetch all of these at the same time using promise.all\n    const [currentBidBufferBps, winningBid, auction] = await Promise.all([this.getBidBufferBps(auctionId), this.getWinningBid(auctionId), this.validateAuction(BigNumber.from(auctionId))]);\n    const currentBidOrReservePrice = winningBid ?\n    // if there is a winning bid use the value of it\n    BigNumber.from(winningBid.bidAmount) :\n    // if there is no winning bid use the reserve price\n    BigNumber.from(auction.minimumBidAmount);\n    const minimumNextBid = currentBidOrReservePrice.add(\n    // the addition of the current bid and the buffer\n    // (have to divide by 10000 to get the fraction of the buffer (since it's in basis points))\n    currentBidOrReservePrice.mul(currentBidBufferBps).div(10000));\n\n    // it's more useful to return a currency value here\n    return fetchCurrencyValue(this.contractWrapper.getProvider(), auction.currencyContractAddress, minimumNextBid);\n  }\n\n  /** ******************************\n   * PRIVATE FUNCTIONS\n   *******************************/\n\n  /**\n   * Throws error if auction could not be found\n   *\n   * @param auctionId - Auction to check for\n   */\n  async validateAuction(auctionId) {\n    try {\n      return await this.getAuction(auctionId);\n    } catch (err) {\n      console.error(`Error getting the auction with id ${auctionId}`);\n      throw err;\n    }\n  }\n\n  /**\n   * Helper method maps the auction to the auction interface.\n   *\n   * @internal\n   * @param auction - The auction to map, as returned from the contract.\n   * @returns - The mapped interface.\n   */\n  async mapAuction(auction) {\n    let status = Status.UNSET;\n    const block = await this.contractWrapper.getProvider().getBlock(\"latest\");\n    const blockTime = block.timestamp;\n    switch (auction.status) {\n      case 1:\n        status = BigNumber.from(auction.startTimestamp).gt(blockTime) ? Status.Created : BigNumber.from(auction.endTimestamp).lt(blockTime) ? Status.Expired : Status.Active;\n        break;\n      case 2:\n        status = Status.Completed;\n        break;\n      case 3:\n        status = Status.Cancelled;\n        break;\n    }\n    return {\n      id: auction.auctionId.toString(),\n      creatorAddress: auction.auctionCreator,\n      assetContractAddress: auction.assetContract,\n      tokenId: auction.tokenId.toString(),\n      quantity: auction.quantity.toString(),\n      currencyContractAddress: auction.currency,\n      minimumBidAmount: auction.minimumBidAmount.toString(),\n      minimumBidCurrencyValue: await fetchCurrencyValue(this.contractWrapper.getProvider(), auction.currency, auction.minimumBidAmount),\n      buyoutBidAmount: auction.buyoutBidAmount.toString(),\n      buyoutCurrencyValue: await fetchCurrencyValue(this.contractWrapper.getProvider(), auction.currency, auction.buyoutBidAmount),\n      timeBufferInSeconds: BigNumber.from(auction.timeBufferInSeconds).toNumber(),\n      bidBufferBps: BigNumber.from(auction.bidBufferBps).toNumber(),\n      startTimeInSeconds: BigNumber.from(auction.startTimestamp).toNumber(),\n      endTimeInSeconds: BigNumber.from(auction.endTimestamp).toNumber(),\n      asset: await fetchTokenMetadataForContract(auction.assetContract, this.contractWrapper.getProvider(), auction.tokenId, this.storage),\n      status: status\n    };\n  }\n\n  /**\n   * Maps an auction-bid to the strict interface\n   *\n   * @internal\n   * @param bid\n   * @returns - A `Bid` object\n   */\n  async mapBid(auctionId, bidderAddress, currencyContractAddress, bidAmount) {\n    const resolvedBidderAddress = await resolveAddress(bidderAddress);\n    const resolvedCurrencyAddress = await resolveAddress(currencyContractAddress);\n    return {\n      auctionId,\n      bidderAddress: resolvedBidderAddress,\n      currencyContractAddress: resolvedCurrencyAddress,\n      bidAmount,\n      bidAmountCurrencyValue: await fetchCurrencyValue(this.contractWrapper.getProvider(), resolvedCurrencyAddress, bidAmount)\n    };\n  }\n  async applyFilter(auctions, filter) {\n    let rawAuctions = [...auctions];\n    if (filter) {\n      if (filter.seller) {\n        const resolvedSeller = await resolveAddress(filter.seller);\n        rawAuctions = rawAuctions.filter(seller => seller.auctionCreator.toString().toLowerCase() === resolvedSeller?.toString().toLowerCase());\n      }\n      if (filter.tokenContract) {\n        const resolvedToken = await resolveAddress(filter.tokenContract);\n        rawAuctions = rawAuctions.filter(tokenContract => tokenContract.assetContract.toString().toLowerCase() === resolvedToken?.toString().toLowerCase());\n      }\n      if (filter.tokenId !== undefined) {\n        rawAuctions = rawAuctions.filter(tokenContract => tokenContract.tokenId.toString() === filter?.tokenId?.toString());\n      }\n    }\n    return filter?.count && filter.count < rawAuctions.length ? rawAuctions.slice(0, filter.count) : rawAuctions;\n  }\n}\n\n/**\n * @internal\n */\nconst OfferInputParamsSchema = /* @__PURE__ */(() => z.object({\n  /**\n   * The address of the asset being sought.\n   */\n  assetContractAddress: AddressOrEnsSchema,\n  /**\n   * The ID of the token.\n   */\n  tokenId: BigNumberishSchema,\n  /**\n   * The quantity of tokens to buy.\n   *\n   * For ERC721s, this value should always be 1 (and will be forced internally regardless of what is passed here).\n   */\n  quantity: BigNumberishSchema.default(1),\n  /**\n   * The address of the currency offered for the NFTs.\n   */\n  currencyContractAddress: AddressOrEnsSchema.default(NATIVE_TOKEN_ADDRESS),\n  /**\n   * The total offer amount for the NFTs.\n   */\n  totalPrice: AmountSchema,\n  /**\n   * The end time of the offer.\n   */\n  endTimestamp: EndDateSchema\n}))();\n\n/**\n * @public\n */\n\n/**\n * Handles marketplace offers\n * @public\n */\nclass MarketplaceV3Offers {\n  featureName = FEATURE_OFFERS.name;\n\n  // utilities\n\n  constructor(contractWrapper, storage) {\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n    this.events = new ContractEvents(this.contractWrapper);\n    this.encoder = new ContractEncoder(this.contractWrapper);\n    this.interceptor = new ContractInterceptor(this.contractWrapper);\n    this.estimator = new GasCostEstimator(this.contractWrapper);\n  }\n  getAddress() {\n    return this.contractWrapper.address;\n  }\n\n  /** ******************************\n   * READ FUNCTIONS\n   *******************************/\n\n  /**\n   * Get the total number of offers\n   *\n   * @returns Returns the total number of offers created.\n   * @public\n   *\n   * @example\n   * ```javascript\n   * const totalOffers = await contract.offers.getTotalCount();\n   * ```\n   * @twfeature Offers\n   */\n  async getTotalCount() {\n    return await this.contractWrapper.read(\"totalOffers\", []);\n  }\n\n  /**\n   * Get all offers\n   *\n   * @example\n   * ```javascript\n   * const offers = await contract.offers.getAll();\n   * ```\n   *\n   * @param filter - optional filter parameters\n   * @returns the Offer object array\n   * @twfeature Offers\n   */\n  async getAll(filter) {\n    const totalOffers = await this.getTotalCount();\n    const start = BigNumber.from(filter?.start || 0).toNumber();\n    const end = totalOffers.toNumber();\n    if (end === 0) {\n      throw new Error(`No offers exist on the contract.`);\n    }\n    let rawOffers = [];\n    const batches = await getAllInBatches(start, end, (startId, endId) => this.contractWrapper.read(\"getAllOffers\", [startId, endId]));\n    rawOffers = batches.flat();\n    const filteredOffers = await this.applyFilter(rawOffers, filter);\n    return await Promise.all(filteredOffers.map(offer => this.mapOffer(offer)));\n  }\n\n  /**\n   * Get all valid offers\n   *\n   * @example\n   * ```javascript\n   * const offers = await contract.offers.getAllValid();\n   * ```\n   *\n   * @param filter - optional filter parameters\n   * @returns the Offer object array\n   * @twfeature Offers\n   */\n  async getAllValid(filter) {\n    const totalOffers = await this.getTotalCount();\n    const start = BigNumber.from(filter?.start || 0).toNumber();\n    const end = totalOffers.toNumber();\n    if (end === 0) {\n      throw new Error(`No offers exist on the contract.`);\n    }\n    let rawOffers = [];\n    const batches = await getAllInBatches(start, end, (startId, endId) => this.contractWrapper.read(\"getAllValidOffers\", [startId, endId]));\n    rawOffers = batches.flat();\n    const filteredOffers = await this.applyFilter(rawOffers, filter);\n    return await Promise.all(filteredOffers.map(offer => this.mapOffer(offer)));\n  }\n\n  /**\n   * Get a single offer\n   *\n   * @example\n   * ```javascript\n   * const offerId = 0;\n   * const offer = await contract.offers.getOffer(offerId);\n   * ```\n   *\n   * @param offerId - the listing id\n   * @returns the Direct listing object\n   * @twfeature Offers\n   */\n  async getOffer(offerId) {\n    const offer = await this.contractWrapper.read(\"getOffer\", [offerId]);\n    return await this.mapOffer(offer);\n  }\n\n  /** ******************************\n   * WRITE FUNCTIONS\n   *******************************/\n\n  /**\n   * Make an offer\n   *\n   * @remarks Make an offer on the marketplace for an asset.\n   *\n   * @example\n   * ```javascript\n   * // Data of the offer you want to make\n   * const offer = {\n   *   // address of the contract the asset you want to make an offer for\n   *   assetContractAddress: \"0x...\",\n   *   // token ID of the asset you want to buy\n   *   tokenId: \"0\",\n   *   // how many of the asset you want to buy\n   *   quantity: 1,\n   *   // address of the currency contract that you offer to pay in\n   *   currencyContractAddress: NATIVE_TOKEN_ADDRESS,\n   *   // Total price you offer to pay for the mentioned token(s)\n   *   totalPrice: \"1.5\",\n   *   // Offer valid until\n   *   endTimestamp: new Date(),\n   * }\n   *\n   * const tx = await contract.offers.makeOffer(offer);\n   * const receipt = tx.receipt; // the transaction receipt\n   * const id = tx.id; // the id of the newly created offer\n   * ```\n   * @param offer - the offer data\n   * @returns the transaction receipt and the id of the newly created offer\n   * @twfeature Offers\n   */\n  makeOffer = /* @__PURE__ */buildTransactionFunction(async offer => {\n    const parsedOffer = await OfferInputParamsSchema.parseAsync(offer);\n    const chainId = await this.contractWrapper.getChainID();\n    const currency = isNativeToken(parsedOffer.currencyContractAddress) ? NATIVE_TOKENS[chainId].wrapped.address : parsedOffer.currencyContractAddress;\n    const normalizedTotalPrice = await normalizePriceValue(this.contractWrapper.getProvider(), parsedOffer.totalPrice, currency);\n    const overrides = await this.contractWrapper.getCallOverrides();\n    await setErc20Allowance(this.contractWrapper, normalizedTotalPrice, currency, overrides);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"makeOffer\",\n      args: [{\n        assetContract: parsedOffer.assetContractAddress,\n        tokenId: parsedOffer.tokenId,\n        quantity: parsedOffer.quantity,\n        currency: currency,\n        totalPrice: normalizedTotalPrice,\n        expirationTimestamp: parsedOffer.endTimestamp\n      }],\n      parse: receipt => {\n        const event = this.contractWrapper.parseLogs(\"NewOffer\", receipt?.logs);\n        return {\n          id: event[0].args.offerId,\n          receipt\n        };\n      }\n    });\n  });\n\n  /**\n   * Cancel an offer\n   *\n   * @remarks Cancel an offer on the marketplace\n   *\n   * @example\n   * ```javascript\n   * // The ID of the offer you want to cancel\n   * const offerId = \"0\";\n   *\n   * await contract.offers.cancelOffer(offerId);\n   * ```\n   * @param offerId - the offer id\n   * @returns the transaction receipt\n   * @twfeature Offers\n   */\n  cancelOffer = /* @__PURE__ */buildTransactionFunction(async offerId => {\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"cancelOffer\",\n      args: [offerId]\n    });\n  });\n\n  /**\n   * Accept an offer\n   *\n   * @example\n   * ```javascript\n   * // The ID of the offer you want to accept\n   * const offerId = 0;\n   *\n   * await contract.offers.acceptOffer(offerId);\n   * ```\n   *\n   * @param offerId - The offer id\n   * @returns the transaction receipt\n   * @twfeature Offers\n   */\n  acceptOffer = /* @__PURE__ */buildTransactionFunction(async offerId => {\n    const offer = await this.validateOffer(BigNumber.from(offerId));\n    const {\n      valid,\n      error\n    } = await this.isStillValidOffer(offer);\n    if (!valid) {\n      throw new Error(`Offer ${offerId} is no longer valid. ${error}`);\n    }\n    const overrides = (await this.contractWrapper.getCallOverrides()) || {};\n    await handleTokenApproval(this.contractWrapper, this.getAddress(), offer.assetContractAddress, offer.tokenId, await this.contractWrapper.getSignerAddress());\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"acceptOffer\",\n      args: [offerId],\n      overrides\n    });\n  });\n\n  /** ******************************\n   * PRIVATE FUNCTIONS\n   *******************************/\n\n  /**\n   * Throws error if offer could not be found\n   *\n   * @param offerId - offer to check for\n   */\n  async validateOffer(offerId) {\n    try {\n      return await this.getOffer(offerId);\n    } catch (err) {\n      console.error(`Error getting the offer with id ${offerId}`);\n      throw err;\n    }\n  }\n\n  /**\n   * Helper method maps the offer to the offer interface.\n   *\n   * @internal\n   * @param offer - The offer to map, as returned from the contract.\n   * @returns - The mapped interface.\n   */\n  async mapOffer(offer) {\n    let status = Status.UNSET;\n    const block = await this.contractWrapper.getProvider().getBlock(\"latest\");\n    const blockTime = block.timestamp;\n    switch (offer.status) {\n      case 1:\n        status = BigNumber.from(offer.expirationTimestamp).lt(blockTime) ? Status.Expired : Status.Active;\n        break;\n      case 2:\n        status = Status.Completed;\n        break;\n      case 3:\n        status = Status.Cancelled;\n        break;\n    }\n    return {\n      id: offer.offerId.toString(),\n      offerorAddress: offer.offeror,\n      assetContractAddress: offer.assetContract,\n      currencyContractAddress: offer.currency,\n      tokenId: offer.tokenId.toString(),\n      quantity: offer.quantity.toString(),\n      totalPrice: offer.totalPrice.toString(),\n      currencyValue: await fetchCurrencyValue(this.contractWrapper.getProvider(), offer.currency, offer.totalPrice),\n      asset: await fetchTokenMetadataForContract(offer.assetContract, this.contractWrapper.getProvider(), offer.tokenId, this.storage),\n      endTimeInSeconds: BigNumber.from(offer.expirationTimestamp).toNumber(),\n      status: status\n    };\n  }\n\n  /**\n   * Use this method to check if an offer is still valid.\n   *\n   * Ways an offer can become invalid:\n   * 1. The offer has expired\n   * 2. The offeror doesn't have enough balance of currency tokens\n   * 3. The offeror removed the approval of currency tokens on the marketplace\n   *\n   * @internal\n   * @param offer - The offer to check.\n   * @returns - True if the offer is valid, false otherwise.\n   */\n  async isStillValidOffer(offer) {\n    const now = BigNumber.from(Math.floor(Date.now() / 1000));\n    if (now.gt(offer.endTimeInSeconds)) {\n      return {\n        valid: false,\n        error: `Offer with ID ${offer.id} has expired`\n      };\n    }\n    const chainId = await this.contractWrapper.getChainID();\n    const currency = isNativeToken(offer.currencyContractAddress) ? NATIVE_TOKENS[chainId].wrapped.address : offer.currencyContractAddress;\n    const provider = this.contractWrapper.getProvider();\n    const erc20 = new ContractWrapper(provider, currency, ERC20Abi, {}, this.storage);\n    const offerorBalance = await erc20.read(\"balanceOf\", [offer.offerorAddress]);\n    if (offerorBalance.lt(offer.totalPrice)) {\n      return {\n        valid: false,\n        error: `Offeror ${offer.offerorAddress} doesn't have enough balance of token ${currency}`\n      };\n    }\n    const offerorAllowance = await erc20.read(\"allowance\", [offer.offerorAddress, this.getAddress()]);\n    if (offerorAllowance.lt(offer.totalPrice)) {\n      return {\n        valid: false,\n        error: `Offeror ${offer.offerorAddress} hasn't approved enough amount of token ${currency}`\n      };\n    }\n    return {\n      valid: true,\n      error: \"\"\n    };\n  }\n  async applyFilter(offers, filter) {\n    let rawOffers = [...offers];\n    if (filter) {\n      if (filter.offeror) {\n        const resolvedOfferor = await resolveAddress(filter.offeror);\n        rawOffers = rawOffers.filter(offeror => offeror.offeror.toString().toLowerCase() === resolvedOfferor?.toString().toLowerCase());\n      }\n      if (filter.tokenContract) {\n        const resolvedToken = await resolveAddress(filter.tokenContract);\n        rawOffers = rawOffers.filter(tokenContract => tokenContract.assetContract.toString().toLowerCase() === resolvedToken?.toString().toLowerCase());\n      }\n      if (filter.tokenId !== undefined) {\n        rawOffers = rawOffers.filter(tokenContract => tokenContract.tokenId.toString() === filter?.tokenId?.toString());\n      }\n    }\n    return filter?.count && filter.count < rawOffers.length ? rawOffers.slice(0, filter.count) : rawOffers;\n  }\n}\n\n/**\n * Handle platform fees and recipients\n * @remarks Configure platform fees for a contract, which can be applied on certain paid transactions\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * const feeInfo = await contract.platformFees.get();\n * await contract.platformFees.set({\n *   platform_fee_basis_points: 100, // 1% fee\n *   platform_fee_recipient: \"0x...\" // the fee recipient\n * })\n * ```\n * @public\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars -- TO BE REMOVED IN V4\nclass ContractPlatformFee {\n  featureName = FEATURE_PLATFORM_FEE.name;\n  constructor(contractWrapper) {\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * Get the platform fee recipient and basis points\n   *\n   * @example\n   * ```javascript\n   * const feeInfo = await contract.platformFees.get();\n   * console.log(feeInfo.platform_fee_recipient);\n   * console.log(feeInfo.platform_fee_basis_points);\n   * ```\n   * @twfeature PlatformFee\n   */\n  async get() {\n    const [platformFeeRecipient, platformFeeBps] = await this.contractWrapper.read(\"getPlatformFeeInfo\", []);\n    return CommonPlatformFeeSchema.parseAsync({\n      platform_fee_recipient: platformFeeRecipient,\n      platform_fee_basis_points: platformFeeBps\n    });\n  }\n\n  /**\n   * Set the platform fee recipient and basis points\n   *\n   * @example\n   * ```javascript\n   * await contract.platformFees.set({\n   *   platform_fee_basis_points: 100, // 1% fee\n   *   platform_fee_recipient: \"0x...\" // the fee recipient\n   * })\n   * ```\n   *\n   * @param platformFeeInfo - the platform fee information\n   * @twfeature PlatformFee\n   */\n  set = /* @__PURE__ */buildTransactionFunction(async platformFeeInfo => {\n    const parsed = await CommonPlatformFeeSchema.parseAsync(platformFeeInfo);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"setPlatformFeeInfo\",\n      args: [parsed.platform_fee_recipient, parsed.platform_fee_basis_points]\n    });\n  });\n}\n\n/**\n * @internal\n * @param abi\n * @param metadata\n */\nfunction extractEventsFromAbi(abi, metadata) {\n  const parsedAbi = AbiSchema.parse(abi || []);\n  const events = parsedAbi.filter(el => el.type === \"event\");\n  const parsed = [];\n  for (const e of events) {\n    const doc = extractCommentFromMetadata(e.name, metadata, \"events\");\n    parsed.push({\n      inputs: e.inputs || [],\n      outputs: e.outputs || [],\n      name: e.name || \"unknown\",\n      comment: doc\n    });\n  }\n  return parsed;\n}\n\n/**\n * Handles publish metadata for a contract\n * @internal\n */ // eslint-disable-next-line @typescript-eslint/no-unused-vars -- TO BE REMOVED IN V4\nclass ContractPublishedMetadata {\n  constructor(contractWrapper, storage) {\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n  }\n\n  /**\n   * Get the published metadata for this contract\n   * @public\n   */\n  async get() {\n    if (this._cachedMetadata) {\n      return this._cachedMetadata;\n    }\n    this._cachedMetadata = await fetchContractMetadataFromAddress(this.contractWrapper.address, this.contractWrapper.getProvider(), this.storage, this.contractWrapper.options);\n    return this._cachedMetadata;\n  }\n\n  /**\n   * @public\n   */\n  async extractFunctions() {\n    let publishedMetadata;\n    try {\n      publishedMetadata = await this.get();\n    } catch (e) {\n      // ignore for built-in contracts\n    }\n    // to construct a contract we already **have** to have the abi on the contract wrapper, so there is no reason to look fetch it again (means this function can become synchronous as well!)\n    return extractFunctionsFromAbi(AbiSchema.parse(this.contractWrapper.abi), publishedMetadata?.metadata);\n  }\n\n  /**\n   * @public\n   */\n  async extractEvents() {\n    let publishedMetadata;\n    try {\n      publishedMetadata = await this.get();\n    } catch (e) {\n      // ignore for built-in contracts\n    }\n    // to construct a contract we already **have** to have the abi on the contract wrapper, so there is no reason to look fetch it again (means this function can become synchronous as well!)\n    return extractEventsFromAbi(AbiSchema.parse(this.contractWrapper.abi), publishedMetadata?.metadata);\n  }\n}\n\n/**\n * Encodes and decodes Contract functions\n * @public\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars -- TO BE REMOVED IN V4\nclass ContractOwner {\n  featureName = FEATURE_OWNER.name;\n  constructor(contractWrapper) {\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * Get the current owner of the contract\n   * @example\n   * ```javascript\n   * await contract.owner.get();\n   * console.log(\"Owner address: \", ownerAddress);\n   * ```\n   * @returns the owner address\n   * @twfeature Ownable\n   */\n  async get() {\n    return this.contractWrapper.read(\"owner\", []);\n  }\n\n  /**\n   * Set the new owner of the contract\n   * @remarks Can only be called by the current owner.\n   *\n   * @param address - the address of the new owner\n   *\n   * @example\n   * ```javascript\n   * const newOwnerAddress = \"{{wallet_address}}\";\n   * await contract.owner.set(newOwnerAddress);\n   * ```\n   * @twfeature Ownable\n   */\n  set = /* @__PURE__ */buildTransactionFunction(async address => {\n    const resolvedAddress = await resolveAddress(address);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"setOwner\",\n      args: [resolvedAddress]\n    });\n  });\n}\n\n/**\n * Have an official Application URI for this contract.\n * @remarks Configure an official Application URI for this contract.\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * const appURI = await contract.app.get();\n * appURI = \"ipfs://some_ipfs_hash\";\n *\n * await contract.app.set(appURI)\n * ```\n * @public\n */\nclass ContractAppURI {\n  featureName = FEATURE_APPURI.name;\n  constructor(contractWrapper, metadata, storage) {\n    this.contractWrapper = contractWrapper;\n    this.metadata = metadata;\n    this.storage = storage;\n  }\n\n  /**\n   * Get App URI\n   * @returns the appURI (typically an IPFS hash)\n   * @example\n   * ```javascript\n   * const appURI = await contract.app.get();\n   * console.log(appURI) // \"ipfs://some_ipfs_hash\";\n   * ```\n   * @twfeature AppURI\n   */\n  async get() {\n    if (detectContractFeature(this.contractWrapper, \"AppURI\")) {\n      return await this.contractWrapper.read(\"appURI\", []);\n    }\n    return replaceGatewayUrlWithScheme((await this.metadata.get()).app_uri || \"\", this.storage.getGatewayUrls());\n  }\n\n  /**\n   * Set App URI\n   * @param appURI - the uri to set (typically an IPFS hash)\n   * @example\n   * ```javascript\n   * const appURI = \"ipfs://some_ipfs_hash\";\n   * await contract.app.set(appURI);\n   * ```\n   * @twfeature AppURI\n   */\n  set = /* @__PURE__ */buildTransactionFunction(async appURI => {\n    if (detectContractFeature(this.contractWrapper, \"AppURI\")) {\n      return Transaction.fromContractWrapper({\n        contractWrapper: this.contractWrapper,\n        method: \"setAppURI\",\n        args: [appURI]\n      });\n    }\n    return await this.metadata.update.prepare({\n      app_uri: appURI\n    });\n  });\n}\n\n/**\n * @internal\n */\nasync function extractConstructorParams(predeployMetadataUri, storage) {\n  const meta = await fetchPreDeployMetadata(predeployMetadataUri, storage);\n  return extractConstructorParamsFromAbi(meta.abi);\n}\n\n/**\n * @internal\n * @param predeployMetadataUri\n * @param storage\n */\nasync function extractFunctions(predeployMetadataUri, storage) {\n  const metadata = await fetchPreDeployMetadata(predeployMetadataUri, storage);\n  return extractFunctionsFromAbi(metadata.abi, metadata.metadata);\n}\n\nfunction getFunctionSignature(fnInputs) {\n  return \"(\" + fnInputs.map(i => {\n    return i.type === \"tuple\" ? getFunctionSignature(i.components) : i.type === \"tuple[]\" ? getFunctionSignature(i.components) + `[]` : i.type;\n  }).join(\",\") + \")\";\n}\nfunction generatePluginFunctions(pluginAddress, pluginAbi) {\n  const pluginInterface = new utils.Interface(pluginAbi);\n  const pluginFunctions = [];\n  // TODO - filter out common functions like _msgSender(), contractType(), etc.\n  for (const fnFragment of Object.values(pluginInterface.functions)) {\n    const fn = pluginInterface.getFunction(pluginInterface.getSighash(fnFragment));\n    if (fn.name.includes(\"_\")) {\n      continue;\n    }\n    pluginFunctions.push({\n      functionSelector: pluginInterface.getSighash(fn),\n      functionSignature: fn.name + getFunctionSignature(fn.inputs),\n      pluginAddress: pluginAddress\n    });\n  }\n  return pluginFunctions;\n}\nfunction generateExtensionFunctions(extensionAbi) {\n  const extensionInterface = new utils.Interface(extensionAbi);\n  const extensionFunctions = [];\n  // TODO - filter out common functions like _msgSender(), contractType(), etc.\n\n  for (const fnFragment of Object.values(extensionInterface.functions)) {\n    const fn = extensionInterface.getFunction(extensionInterface.getSighash(fnFragment));\n    if (fn.name.startsWith(\"_\")) {\n      continue;\n    }\n    extensionFunctions.push({\n      functionSelector: extensionInterface.getSighash(fn),\n      functionSignature: fn.name + getFunctionSignature(fn.inputs)\n    });\n  }\n  return extensionFunctions;\n}\n\n/**\n *\n * Returns txn data for keyless deploys as well as signer deploys.\n * Also provides a list of infra contracts to deploy.\n *\n * @internal\n *\n * @param metadataUri\n * @param storage\n * @param provider\n * @param create2Factory\n */\nasync function getDeploymentInfo(metadataUri, storage, provider, create2Factory, clientId, secretKey) {\n  caches.deploymentPresets = {};\n  const create2FactoryAddress = create2Factory ? create2Factory : await getCreate2FactoryAddress(provider);\n  const customParams = {};\n  const finalDeploymentInfo = [];\n  const {\n    compilerMetadata,\n    extendedMetadata\n  } = await fetchAndCacheDeployMetadata(metadataUri, storage);\n  const defaultExtensions = extendedMetadata?.defaultExtensions;\n  if (extendedMetadata?.routerType === \"plugin\" && defaultExtensions) {\n    invariant(clientId || secretKey, \"Require Client Id / Secret Key\");\n    const publishedExtensions = await Promise.all(defaultExtensions.map(e => {\n      return fetchPublishedContractFromPolygon(e.publisherAddress, e.extensionName, e.extensionVersion, storage, clientId, secretKey);\n    }));\n    const pluginMetadata = (await Promise.all(publishedExtensions.map(async c => {\n      return fetchAndCacheDeployMetadata(c.metadataUri, storage);\n    }))).map(fetchedMetadata => fetchedMetadata.compilerMetadata);\n\n    // get deployment info for all plugins\n    const pluginDeploymentInfo = await Promise.all(pluginMetadata.map(async metadata => {\n      const info = await computeDeploymentInfo(\"plugin\", provider, storage, create2FactoryAddress, {\n        metadata: metadata\n      }, clientId, secretKey);\n      return info;\n    }));\n\n    // create constructor param input for PluginMap\n    const mapInput = [];\n    pluginMetadata.forEach((metadata, index) => {\n      const input = generatePluginFunctions(pluginDeploymentInfo[index].transaction.predictedAddress, metadata.abi);\n      mapInput.push(...input);\n    });\n\n    // get PluginMap deployment transaction\n    const pluginMapTransaction = await computeDeploymentInfo(\"plugin\", provider, storage, create2FactoryAddress, {\n      contractName: \"PluginMap\",\n      constructorParams: {\n        _pluginsToAdd: {\n          value: mapInput\n        }\n      }\n    }, clientId, secretKey);\n\n    // address of PluginMap is input for MarketplaceV3's constructor\n    customParams[\"_pluginMap\"] = {\n      value: pluginMapTransaction.transaction.predictedAddress\n    };\n    finalDeploymentInfo.push(...pluginDeploymentInfo, pluginMapTransaction);\n  } else if (extendedMetadata?.routerType === \"dynamic\" && defaultExtensions) {\n    invariant(clientId || secretKey, \"Require Client Id / Secret Key\");\n    const publishedExtensions = await Promise.all(defaultExtensions.map(e => {\n      return fetchPublishedContractFromPolygon(e.publisherAddress, e.extensionName, e.extensionVersion, storage, clientId, secretKey);\n    }));\n    const extensionMetadata = (await Promise.all(publishedExtensions.map(async c => {\n      return fetchAndCacheDeployMetadata(c.metadataUri, storage);\n    }))).map(fetchedMetadata => fetchedMetadata.compilerMetadata);\n\n    // get deployment info for all extensions\n    const extensionDeploymentInfo = await Promise.all(extensionMetadata.map(async metadata => {\n      const info = await computeDeploymentInfo(\"extension\", provider, storage, create2FactoryAddress, {\n        metadata: metadata\n      }, clientId, secretKey);\n      return info;\n    }));\n\n    // create constructor param input for BaseRouter\n    const routerInput = [];\n    extensionMetadata.forEach((metadata, index) => {\n      const extensionFunctions = generateExtensionFunctions(metadata.abi);\n      routerInput.push({\n        metadata: {\n          name: metadata.name,\n          metadataURI: \"\",\n          implementation: extensionDeploymentInfo[index].transaction.predictedAddress\n        },\n        functions: extensionFunctions\n      });\n    });\n\n    // routerInput as constructor param for BaseRouter\n    customParams[\"_extensions\"] = {\n      value: routerInput\n    };\n    finalDeploymentInfo.push(...extensionDeploymentInfo);\n  }\n  const implementationDeployInfo = await computeDeploymentInfo(\"implementation\", provider, storage, create2FactoryAddress, {\n    metadata: compilerMetadata,\n    constructorParams: customParams\n  }, clientId, secretKey);\n\n  // get clone factory\n  const factoryInfo = await computeDeploymentInfo(\"infra\", provider, storage, create2FactoryAddress, {\n    contractName: \"TWCloneFactory\"\n  }, clientId, secretKey);\n  finalDeploymentInfo.push(factoryInfo);\n  finalDeploymentInfo.push(...Object.values(caches.deploymentPresets));\n  finalDeploymentInfo.push(implementationDeployInfo);\n  return finalDeploymentInfo;\n}\n\n/**\n * Deploy a contract at a deterministic address, using Create2 method\n * Address depends on the Create2 factory address.\n *\n * @public\n *\n * @param signer\n * @param bytecode\n * @param encodedArgs\n * @param create2FactoryAddress\n */\nasync function deployContractDeterministic(signer, transaction, options) {\n  let gasLimit = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 7000000;\n  // Check if the implementation contract is already deployed\n  invariant(signer.provider, \"Provider required\");\n  const contractDeployed = await isContractDeployed(transaction.predictedAddress, signer.provider);\n  if (!contractDeployed) {\n    console.debug(`deploying contract via create2 factory at: ${transaction.predictedAddress}`);\n    const tx = {\n      to: transaction.to,\n      data: transaction.data\n    };\n    try {\n      await signer.estimateGas(tx);\n    } catch (e) {\n      console.debug(\"error estimating gas while deploying prebuilt: \", e);\n      tx.gasLimit = BigNumber.from(gasLimit);\n    }\n    options?.notifier?.(\"deploying\", \"preset\");\n    await (await signer.sendTransaction(tx)).wait();\n    options?.notifier?.(\"deployed\", \"preset\");\n  }\n}\n\nfunction estimateGasForDeploy(initCode) {\n  let gasLimit = utils.arrayify(initCode).map(x => x === 0 ? 4 : 16).reduce((sum, x) => sum + x) + 200 * initCode.length / 2 + 6 * Math.ceil(initCode.length / 64) + 32000 + 21000;\n  gasLimit = Math.floor(gasLimit * 64 / 63);\n  return gasLimit;\n}\n\nfunction createTransactionBatches(transactions) {\n  let upperGasLimit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : GAS_LIMIT_FOR_DEPLOYER;\n  transactions = transactions.filter(tx => {\n    return tx.data.length > 0;\n  });\n  if (transactions.length === 0) {\n    return [];\n  }\n  const transactionBatches = [];\n  let sum = 0;\n  let batch = [];\n  transactions.forEach(tx => {\n    const gas = estimateGasForDeploy(tx.data);\n    if (sum + gas > upperGasLimit) {\n      if (batch.length === 0) {\n        transactionBatches.push([tx]);\n      } else {\n        transactionBatches.push(batch);\n        sum = gas;\n        batch = [tx];\n      }\n    } else {\n      sum += gas;\n      batch.push(tx);\n    }\n  });\n  if (batch.length > 0) {\n    transactionBatches.push(batch);\n  }\n  return transactionBatches;\n}\n\nasync function deployWithThrowawayDeployer(signer, transactions, options) {\n  const transactionBatches = createTransactionBatches(transactions);\n  if (transactionBatches.length === 0) {\n    return;\n  }\n  options?.notifier?.(\"deploying\", \"infra\");\n  const deployTxns = await Promise.all(transactionBatches.map(txBatch => {\n    // Using the deployer contract, send the deploy transactions to common factory with a signer\n    const deployer = new ContractFactory(DEPLOYER_ABI, DEPLOYER_BYTECODE).connect(signer).deploy(txBatch);\n    return deployer;\n  }));\n  await Promise.all(deployTxns.map(tx => {\n    return tx.deployed();\n  }));\n  options?.notifier?.(\"deployed\", \"infra\");\n}\n\nasync function getCompositeABIfromRelease(publishMetadataUri, storage) {\n  const {\n    extendedMetadata\n  } = await fetchAndCacheDeployMetadata(publishMetadataUri, storage);\n  const compositeAbi = extendedMetadata?.compositeAbi || [];\n  return compositeAbi;\n}\n\n/**\n * @internal\n */\nasync function getPluginABI(addresses, provider, storage) {\n  return (await Promise.all(addresses.map(address => fetchContractMetadataFromAddress(address, provider, storage).catch(err => {\n    console.error(`Failed to fetch plug-in for ${address}`, err);\n    return {\n      abi: []\n    };\n  })))).map(metadata => metadata.abi);\n}\n\n/**\n * @internal\n */\nasync function getCompositePluginABI(address, abi, provider, options, storage) {\n  let pluginABIs = [];\n  try {\n    // check if contract is plugin-pattern\n    const isPluginRouter = isFeatureEnabled(AbiSchema.parse(abi), \"PluginRouter\");\n    const isbaseRouter = isFeatureEnabled(AbiSchema.parse(abi), \"DynamicContract\");\n    if (isbaseRouter) {\n      const contract = new ContractWrapper(provider, address, getAllExtensionsAbi, options, storage);\n      const plugins = await contract.call(\"getAllExtensions\");\n\n      // get extension addresses\n      const pluginAddresses = plugins.map(item => item.metadata.implementation);\n\n      // get ABIs of extension contracts --\n      pluginABIs = await getPluginABI(pluginAddresses, provider, storage);\n    } else if (isPluginRouter) {\n      const contract = new ContractWrapper(provider, address, getAllPluginsAbi, options, storage);\n      const pluginMap = await contract.call(\"getAllPlugins\");\n\n      // get extension addresses\n      const allPlugins = pluginMap.map(item => item.pluginAddress);\n      const plugins = Array.from(new Set(allPlugins));\n\n      // get ABIs of extension contracts\n      pluginABIs = await getPluginABI(plugins, provider, storage);\n    }\n  } catch (err) {}\n  return pluginABIs.length > 0 ? joinABIs([abi, ...pluginABIs]) : abi;\n}\n\nconst DropErc20ContractInput = /* @__PURE__ */CommonContractSchema.merge(MerkleSchema).merge(CommonSymbolSchema);\nconst DropErc20ContractOutput = /* @__PURE__ */CommonContractOutputSchema.merge(MerkleSchema).merge(CommonSymbolSchema);\nconst DropErc20ContractDeploy = /* @__PURE__ */DropErc20ContractInput.merge(CommonPlatformFeeSchema).merge(CommonPrimarySaleSchema).merge(CommonTrustedForwarderSchema);\nconst DropErc20ContractSchema = {\n  deploy: DropErc20ContractDeploy,\n  output: DropErc20ContractOutput,\n  input: DropErc20ContractInput\n};\n\nconst MultiwrapContractInput = /* @__PURE__ */CommonContractSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema);\nconst MultiwrapContractOutput = /* @__PURE__ */CommonContractOutputSchema.merge(CommonRoyaltySchema).merge(CommonSymbolSchema);\nconst MultiwrapContractDeploy = /* @__PURE__ */MultiwrapContractInput.merge(CommonTrustedForwarderSchema);\nconst MultiwrapContractSchema = {\n  deploy: MultiwrapContractDeploy,\n  output: MultiwrapContractOutput,\n  input: MultiwrapContractInput\n};\n\nconst ADMIN_ROLE = [\"admin\"];\nconst NFT_BASE_CONTRACT_ROLES = [\"admin\", \"minter\", \"transfer\"];\nconst MARKETPLACE_CONTRACT_ROLES = [\"admin\", \"lister\", \"asset\"];\nconst PACK_CONTRACT_ROLES = [\"admin\", \"minter\", \"asset\", \"transfer\"];\nconst TOKEN_DROP_CONTRACT_ROLES = [\"admin\", \"transfer\"];\nconst MULTIWRAP_CONTRACT_ROLES = [\"admin\", \"transfer\", \"minter\", \"unwrap\", \"asset\"];\n\nconst prebuiltContractTypes = {\n  vote: \"vote\",\n  token: \"token\",\n  \"edition-drop\": \"edition-drop\",\n  edition: \"edition\",\n  marketplace: \"marketplace\",\n  \"marketplace-v3\": \"marketplace-v3\",\n  multiwrap: \"multiwrap\",\n  \"nft-collection\": \"nft-collection\",\n  \"nft-drop\": \"nft-drop\",\n  pack: \"pack\",\n  \"signature-drop\": \"signature-drop\",\n  split: \"split\",\n  \"token-drop\": \"token-drop\"\n};\nconst EditionDropInitializer = {\n  name: \"DropERC1155\",\n  contractType: prebuiltContractTypes[\"edition-drop\"],\n  schema: DropErc1155ContractSchema,\n  roles: NFT_BASE_CONTRACT_ROLES,\n  initialize: async function () {\n    for (var _len = arguments.length, _ref = new Array(_len), _key = 0; _key < _len; _key++) {\n      _ref[_key] = arguments[_key];\n    }\n    let [network, address, storage, options] = _ref;\n    const [, provider] = getSignerAndProvider(network, options);\n    const [abi, contract, _network] = await Promise.all([EditionDropInitializer.getAbi(address, provider, storage), import('./edition-drop-24708d00.browser.esm.js'), provider.getNetwork()]);\n    return new contract.EditionDrop(network, address, storage, options, abi, _network.chainId);\n  },\n  getAbi: async (address, provider, storage) => {\n    const abi = await fetchAbiFromAddress(address, provider, storage);\n    if (abi) {\n      return abi;\n    }\n    // Deprecated - only needed for backwards compatibility with non-published contracts - should remove in v4\n    const contractInfo = await getContractInfo(address, provider);\n    return !contractInfo || contractInfo.version > 2 ? (await import('@thirdweb-dev/contracts-js/dist/abis/DropERC1155.json')).default : (await import('@thirdweb-dev/contracts-js/dist/abis/DropERC1155_V2.json')).default;\n  }\n};\nconst EditionInitializer = {\n  name: \"TokenERC1155\",\n  contractType: prebuiltContractTypes[\"edition\"],\n  schema: TokenErc1155ContractSchema,\n  roles: NFT_BASE_CONTRACT_ROLES,\n  initialize: async function () {\n    for (var _len2 = arguments.length, _ref2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      _ref2[_key2] = arguments[_key2];\n    }\n    let [network, address, storage, options] = _ref2;\n    const [, provider] = getSignerAndProvider(network, options);\n    const [abi, contract, _network] = await Promise.all([EditionInitializer.getAbi(address, provider, storage), import('./edition-b3122b64.browser.esm.js'), provider.getNetwork()]);\n    return new contract.Edition(network, address, storage, options, abi, _network.chainId);\n  },\n  getAbi: async (address, provider, storage) => {\n    const abi = await fetchAbiFromAddress(address, provider, storage);\n    if (abi) {\n      return abi;\n    }\n    // Deprecated - only needed for backwards compatibility with non-published contracts - should remove in v4\n    return (await import('@thirdweb-dev/contracts-js/dist/abis/TokenERC1155.json')).default;\n  }\n};\nconst MarketplaceInitializer = {\n  name: \"Marketplace\",\n  contractType: prebuiltContractTypes.marketplace,\n  schema: MarketplaceContractSchema,\n  roles: MARKETPLACE_CONTRACT_ROLES,\n  initialize: async function () {\n    for (var _len3 = arguments.length, _ref3 = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      _ref3[_key3] = arguments[_key3];\n    }\n    let [network, address, storage, options] = _ref3;\n    const [, provider] = getSignerAndProvider(network, options);\n    const [abi, contract, _network] = await Promise.all([MarketplaceInitializer.getAbi(address, provider, storage), import('./marketplace-5b738c1b.browser.esm.js'), provider.getNetwork()]);\n    return new contract.Marketplace(network, address, storage, options, abi, _network.chainId);\n  },\n  getAbi: async (address, provider, storage) => {\n    const abi = await fetchAbiFromAddress(address, provider, storage);\n    if (abi) {\n      return abi;\n    }\n\n    // Deprecated - only needed for backwards compatibility with non-published contracts - should remove in v4\n    return (await import('@thirdweb-dev/contracts-js/dist/abis/Marketplace.json')).default;\n  }\n};\nconst MarketplaceV3Initializer = {\n  name: \"MarketplaceV3\",\n  contractType: prebuiltContractTypes[\"marketplace-v3\"],\n  schema: MarketplaceContractSchema,\n  roles: MARKETPLACE_CONTRACT_ROLES,\n  initialize: async function () {\n    for (var _len4 = arguments.length, _ref4 = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      _ref4[_key4] = arguments[_key4];\n    }\n    let [network, address, storage, options] = _ref4;\n    const [, provider] = getSignerAndProvider(network, options);\n    const [abi, contract, _network] = await Promise.all([MarketplaceV3Initializer.getAbi(address, provider, storage, options), import('./marketplacev3-e02b24ac.browser.esm.js'), provider.getNetwork()]);\n    return new contract.MarketplaceV3(network, address, storage, options, abi, _network.chainId);\n  },\n  getAbi: async (address, provider, storage, options) => {\n    const chainId = (await provider.getNetwork()).chainId;\n    const isZkSync = chainId === 280 || chainId === 324;\n\n    // Can't resolve IPFS hash from plugin bytecode on ZkSync\n    // Thus, pull the composite ABI from the release page\n    if (isZkSync) {\n      const publishedContract = await fetchPublishedContractFromPolygon(THIRDWEB_DEPLOYER, \"MarketplaceV3\", \"latest\", storage, options?.clientId, options?.secretKey);\n      const uri = publishedContract.metadataUri;\n      const compositeAbi = await getCompositeABIfromRelease(uri, storage);\n      return compositeAbi;\n    }\n    const abi = await fetchAbiFromAddress(address, provider, storage);\n    if (abi) {\n      return await getCompositePluginABI(address, abi, provider, {}, storage);\n    }\n\n    // Deprecated - only needed for backwards compatibility with non-published contracts - should remove in v4\n    const localAbi = (await import('@thirdweb-dev/contracts-js/dist/abis/MarketplaceV3.json')).default;\n    return await getCompositePluginABI(address, AbiSchema.parse(localAbi || []), provider, {}, storage);\n  }\n};\nconst MultiwrapInitializer = {\n  name: \"Multiwrap\",\n  contractType: prebuiltContractTypes.multiwrap,\n  schema: MultiwrapContractSchema,\n  roles: MULTIWRAP_CONTRACT_ROLES,\n  initialize: async function () {\n    for (var _len5 = arguments.length, _ref5 = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      _ref5[_key5] = arguments[_key5];\n    }\n    let [network, address, storage, options] = _ref5;\n    const [, provider] = getSignerAndProvider(network, options);\n    const [abi, contract, _network] = await Promise.all([MultiwrapInitializer.getAbi(address, provider, storage), import('./multiwrap-18fab528.browser.esm.js'), provider.getNetwork()]);\n    return new contract.Multiwrap(network, address, storage, options, abi, _network.chainId);\n  },\n  getAbi: async (address, provider, storage) => {\n    const abi = await fetchAbiFromAddress(address, provider, storage);\n    if (abi) {\n      return abi;\n    }\n    // Deprecated - only needed for backwards compatibility with non-published contracts - should remove in v4\n    return (await import('@thirdweb-dev/contracts-js/dist/abis/Multiwrap.json')).default;\n  }\n};\nconst NFTCollectionInitializer = {\n  name: \"TokenERC721\",\n  contractType: prebuiltContractTypes[\"nft-collection\"],\n  schema: TokenErc721ContractSchema,\n  roles: NFT_BASE_CONTRACT_ROLES,\n  initialize: async function () {\n    for (var _len6 = arguments.length, _ref6 = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n      _ref6[_key6] = arguments[_key6];\n    }\n    let [network, address, storage, options] = _ref6;\n    const [, provider] = getSignerAndProvider(network, options);\n    const [abi, contract, _network] = await Promise.all([NFTCollectionInitializer.getAbi(address, provider, storage), import('./nft-collection-0cf43f4d.browser.esm.js'), provider.getNetwork()]);\n    return new contract.NFTCollection(network, address, storage, options, abi, _network.chainId);\n  },\n  getAbi: async (address, provider, storage) => {\n    const abi = await fetchAbiFromAddress(address, provider, storage);\n    if (abi) {\n      return abi;\n    }\n    // Deprecated - only needed for backwards compatibility with non-published contracts - should remove in v4\n    return (await import('@thirdweb-dev/contracts-js/dist/abis/TokenERC721.json')).default;\n  }\n};\nconst NFTDropInitializer = {\n  name: \"DropERC721\",\n  contractType: prebuiltContractTypes[\"nft-drop\"],\n  schema: DropErc721ContractSchema,\n  roles: NFT_BASE_CONTRACT_ROLES,\n  initialize: async function () {\n    for (var _len7 = arguments.length, _ref7 = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n      _ref7[_key7] = arguments[_key7];\n    }\n    let [network, address, storage, options] = _ref7;\n    const [, provider] = getSignerAndProvider(network, options);\n    const [abi, contract, _network] = await Promise.all([NFTDropInitializer.getAbi(address, provider, storage), import('./nft-drop-399edfe0.browser.esm.js'), provider.getNetwork()]);\n    return new contract.NFTDrop(network, address, storage, options, abi, _network.chainId);\n  },\n  getAbi: async (address, provider, storage) => {\n    const abi = await fetchAbiFromAddress(address, provider, storage);\n    if (abi) {\n      return abi;\n    }\n    // Deprecated - only needed for backwards compatibility with non-published contracts - should remove in v4\n    const contractInfo = await getContractInfo(address, provider);\n    return !contractInfo || contractInfo.version > 3 ? (await import('@thirdweb-dev/contracts-js/dist/abis/DropERC721.json')).default : (await import('@thirdweb-dev/contracts-js/dist/abis/DropERC721_V3.json')).default;\n  }\n};\nconst PackInitializer = {\n  name: \"Pack\",\n  contractType: prebuiltContractTypes[\"pack\"],\n  schema: PackContractSchema,\n  roles: PACK_CONTRACT_ROLES,\n  initialize: async function () {\n    for (var _len8 = arguments.length, _ref8 = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n      _ref8[_key8] = arguments[_key8];\n    }\n    let [network, address, storage, options] = _ref8;\n    const [, provider] = getSignerAndProvider(network, options);\n    const [abi, contract, _network] = await Promise.all([PackInitializer.getAbi(address, provider, storage), import('./pack-bd61f578.browser.esm.js'), provider.getNetwork()]);\n    return new contract.Pack(network, address, storage, options, abi, _network.chainId);\n  },\n  getAbi: async (address, provider, storage) => {\n    const abi = await fetchAbiFromAddress(address, provider, storage);\n    if (abi) {\n      return abi;\n    }\n    // Deprecated - only needed for backwards compatibility with non-published contracts - should remove in v4\n    return AbiSchema.parse((await import('@thirdweb-dev/contracts-js/dist/abis/Pack.json')).default || []);\n  }\n};\nconst SignatureDropInitializer = {\n  name: \"SignatureDrop\",\n  contractType: prebuiltContractTypes[\"signature-drop\"],\n  schema: DropErc721ContractSchema,\n  roles: NFT_BASE_CONTRACT_ROLES,\n  initialize: async function () {\n    for (var _len9 = arguments.length, _ref9 = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n      _ref9[_key9] = arguments[_key9];\n    }\n    let [network, address, storage, options] = _ref9;\n    const [, provider] = getSignerAndProvider(network, options);\n    const [abi, contract, _network] = await Promise.all([SignatureDropInitializer.getAbi(address, provider, storage), import('./signature-drop-224b723c.browser.esm.js'), provider.getNetwork()]);\n    return new contract.SignatureDrop(network, address, storage, options, abi, _network.chainId);\n  },\n  getAbi: async (address, provider, storage) => {\n    const abi = await fetchAbiFromAddress(address, provider, storage);\n    if (abi) {\n      return abi;\n    }\n    // Deprecated - only needed for backwards compatibility with non-published contracts - should remove in v4\n    const contractInfo = await getContractInfo(address, provider);\n    return !contractInfo || contractInfo.version > 4 ? (await import('@thirdweb-dev/contracts-js/dist/abis/SignatureDrop.json')).default : (await import('@thirdweb-dev/contracts-js/dist/abis/SignatureDrop_V4.json')).default;\n  }\n};\nconst SplitInitializer = {\n  name: \"Split\",\n  contractType: prebuiltContractTypes[\"split\"],\n  schema: SplitsContractSchema,\n  roles: ADMIN_ROLE,\n  initialize: async function () {\n    for (var _len10 = arguments.length, _ref10 = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n      _ref10[_key10] = arguments[_key10];\n    }\n    let [network, address, storage, options] = _ref10;\n    const [, provider] = getSignerAndProvider(network, options);\n    const [abi, contract, _network] = await Promise.all([SplitInitializer.getAbi(address, provider, storage), import('./split-8c412664.browser.esm.js'), provider.getNetwork()]);\n    return new contract.Split(network, address, storage, options, abi, _network.chainId);\n  },\n  getAbi: async (address, provider, storage) => {\n    const abi = await fetchAbiFromAddress(address, provider, storage);\n    if (abi) {\n      return abi;\n    }\n    // Deprecated - only needed for backwards compatibility with non-published contracts - should remove in v4\n    return (await import('@thirdweb-dev/contracts-js/dist/abis/Split.json')).default;\n  }\n};\nconst TokenDropInitializer = {\n  name: \"DropERC20\",\n  contractType: prebuiltContractTypes[\"token-drop\"],\n  schema: DropErc20ContractSchema,\n  roles: TOKEN_DROP_CONTRACT_ROLES,\n  initialize: async function () {\n    for (var _len11 = arguments.length, _ref11 = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {\n      _ref11[_key11] = arguments[_key11];\n    }\n    let [network, address, storage, options] = _ref11;\n    const [, provider] = getSignerAndProvider(network, options);\n    const [abi, contract, _network] = await Promise.all([TokenDropInitializer.getAbi(address, provider, storage), import('./token-drop-90cb00e6.browser.esm.js'), provider.getNetwork()]);\n    return new contract.TokenDrop(network, address, storage, options, abi, _network.chainId);\n  },\n  getAbi: async (address, provider, storage) => {\n    const abi = await fetchAbiFromAddress(address, provider, storage);\n    if (abi) {\n      return abi;\n    }\n    // Deprecated - only needed for backwards compatibility with non-published contracts - should remove in v4\n    const contractInfo = await getContractInfo(address, provider);\n    return !contractInfo || contractInfo.version > 2 ? (await import('@thirdweb-dev/contracts-js/dist/abis/DropERC20.json')).default : (await import('@thirdweb-dev/contracts-js/dist/abis/DropERC20_V2.json')).default;\n  }\n};\nconst TokenInitializer = {\n  name: \"TokenERC20\",\n  contractType: prebuiltContractTypes.token,\n  schema: TokenErc20ContractSchema,\n  roles: NFT_BASE_CONTRACT_ROLES,\n  initialize: async function () {\n    for (var _len12 = arguments.length, _ref12 = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {\n      _ref12[_key12] = arguments[_key12];\n    }\n    let [network, address, storage, options] = _ref12;\n    const [, provider] = getSignerAndProvider(network, options);\n    const [abi, contract, _network] = await Promise.all([TokenInitializer.getAbi(address, provider, storage), import('./token-1023bf9c.browser.esm.js'), provider.getNetwork()]);\n    return new contract.Token(network, address, storage, options, abi, _network.chainId);\n  },\n  getAbi: async (address, provider, storage) => {\n    const abi = await fetchAbiFromAddress(address, provider, storage);\n    if (abi) {\n      return abi;\n    }\n    // Deprecated - only needed for backwards compatibility with non-published contracts - should remove in v4\n    return (await import('@thirdweb-dev/contracts-js/dist/abis/TokenERC20.json')).default;\n  }\n};\nconst VoteInitializer = {\n  name: \"VoteERC20\",\n  contractType: prebuiltContractTypes.vote,\n  schema: VoteContractSchema,\n  roles: [],\n  initialize: async function () {\n    for (var _len13 = arguments.length, _ref13 = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {\n      _ref13[_key13] = arguments[_key13];\n    }\n    let [network, address, storage, options] = _ref13;\n    const [, provider] = getSignerAndProvider(network, options);\n    const [abi, contract, _network] = await Promise.all([VoteInitializer.getAbi(address, provider, storage), import('./vote-8af4ac9b.browser.esm.js'), provider.getNetwork()]);\n    return new contract.Vote(network, address, storage, options, abi, _network.chainId);\n  },\n  getAbi: async (address, provider, storage) => {\n    const abi = await fetchAbiFromAddress(address, provider, storage);\n    if (abi) {\n      return abi;\n    }\n    // Deprecated - only needed for backwards compatibility with non-published contracts - should remove in v4\n    return (await import('@thirdweb-dev/contracts-js/dist/abis/VoteERC20.json')).default;\n  }\n};\nasync function getContractInfo(address, provider) {\n  try {\n    return await getPrebuiltInfo(address, provider);\n  } catch (e) {\n    return undefined;\n  }\n}\n\n/**\n * a map from contractType -> contract metadata\n * @internal\n */\nconst PREBUILT_CONTRACTS_MAP = {\n  [prebuiltContractTypes[\"edition-drop\"]]: EditionDropInitializer,\n  [prebuiltContractTypes.edition]: EditionInitializer,\n  [prebuiltContractTypes.marketplace]: MarketplaceInitializer,\n  [prebuiltContractTypes[\"marketplace-v3\"]]: MarketplaceV3Initializer,\n  [prebuiltContractTypes.multiwrap]: MultiwrapInitializer,\n  [prebuiltContractTypes[\"nft-collection\"]]: NFTCollectionInitializer,\n  [prebuiltContractTypes[\"nft-drop\"]]: NFTDropInitializer,\n  [prebuiltContractTypes.pack]: PackInitializer,\n  [prebuiltContractTypes[\"signature-drop\"]]: SignatureDropInitializer,\n  [prebuiltContractTypes.split]: SplitInitializer,\n  [prebuiltContractTypes[\"token-drop\"]]: TokenDropInitializer,\n  [prebuiltContractTypes.token]: TokenInitializer,\n  [prebuiltContractTypes.vote]: VoteInitializer\n};\nconst PREBUILT_CONTRACTS_APPURI_MAP = {\n  [prebuiltContractTypes[\"edition-drop\"]]: \"ipfs://QmNm3wRzpKYWo1SRtJfgfxtvudp5p2nXD6EttcsQJHwTmk\",\n  [prebuiltContractTypes.edition]: \"\",\n  [prebuiltContractTypes.marketplace]: \"ipfs://QmbAgC8YwY36n8H2kuvSWsRisxDZ15QZw3xGZyk9aDvcv7/marketplace.html\",\n  [prebuiltContractTypes[\"marketplace-v3\"]]: \"ipfs://QmbAgC8YwY36n8H2kuvSWsRisxDZ15QZw3xGZyk9aDvcv7/marketplace-v3.html\",\n  [prebuiltContractTypes.multiwrap]: \"\",\n  [prebuiltContractTypes[\"nft-collection\"]]: \"\",\n  [prebuiltContractTypes[\"nft-drop\"]]: \"ipfs://QmZptmVipc6SGFbKAyXcxGgohzTwYRXZ9LauRX5ite1xDK\",\n  [prebuiltContractTypes.pack]: \"\",\n  [prebuiltContractTypes[\"signature-drop\"]]: \"ipfs://QmZptmVipc6SGFbKAyXcxGgohzTwYRXZ9LauRX5ite1xDK\",\n  [prebuiltContractTypes.split]: \"\",\n  [prebuiltContractTypes[\"token-drop\"]]: \"ipfs://QmbAgC8YwY36n8H2kuvSWsRisxDZ15QZw3xGZyk9aDvcv7/erc20.html\",\n  [prebuiltContractTypes.token]: \"\",\n  [prebuiltContractTypes.vote]: \"\"\n};\nconst SmartContract$1 = {\n  name: \"SmartContract\",\n  contractType: \"custom\",\n  schema: {},\n  roles: ALL_ROLES\n};\nconst CONTRACTS_MAP = {\n  ...PREBUILT_CONTRACTS_MAP,\n  [SmartContract$1.contractType]: SmartContract$1\n};\n\n/**\n * @internal\n */\nfunction getContractTypeForRemoteName(name) {\n  return Object.values(CONTRACTS_MAP).find(contract => contract.name === name)?.contractType || \"custom\";\n}\nfunction getContractName(type) {\n  return Object.values(CONTRACTS_MAP).find(contract => contract.contractType === type)?.name;\n}\n\nconst SignerPermissionsSchema = /* @__PURE__ */z.object({\n  startDate: StartDateSchema,\n  expirationDate: EndDateSchema,\n  nativeTokenLimitPerTransaction: /* @__PURE__ */AmountSchema.default(0),\n  approvedCallTargets: /* @__PURE__ */z.array(AddressOrEnsSchema)\n});\nconst PermissionSnapshotSchema = /* @__PURE__ */z.array( /* @__PURE__ */z.object({\n  signer: AddressOrEnsSchema,\n  makeAdmin: /* @__PURE__ */z.boolean(),\n  permissions: SignerPermissionsSchema\n}));\nconst SignerPermissionRequest = [{\n  name: \"signer\",\n  type: \"address\"\n}, {\n  name: \"approvedTargets\",\n  type: \"address[]\"\n}, {\n  name: \"nativeTokenLimitPerTransaction\",\n  type: \"uint256\"\n}, {\n  name: \"permissionStartTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"permissionEndTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"reqValidityStartTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"reqValidityEndTimestamp\",\n  type: \"uint128\"\n}, {\n  name: \"uid\",\n  type: \"bytes32\"\n}];\n\nclass AccountPermissions {\n  featureName = FEATURE_ACCOUNT_PERMISSIONS.name;\n  constructor(contractWrapper) {\n    this.contractWrapper = contractWrapper;\n  }\n  getAddress() {\n    return this.contractWrapper.address;\n  }\n\n  /*********************************\n   * HELPER FUNCTIONS\n   ********************************/\n\n  hasDuplicateSigners(snapshot) {\n    const checkedSigner = {};\n    const signers = snapshot.map(item => item.signer);\n    for (const signer of signers) {\n      if (!checkedSigner[signer]) {\n        checkedSigner[signer] = true;\n      } else {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Format the access restrictions for a given role\n   *\n   * @param restrictions - The access restrictions for a given role\n   * @returns formatted role restrictions\n   *\n   */\n  parseSignerPermissionsStruct(permissions) {\n    return {\n      startDate: new Date(parseInt(permissions.startTimestamp.toString()) * 1000),\n      expirationDate: new Date(parseInt(permissions.endTimestamp.toString()) * 1000),\n      nativeTokenLimitPerTransaction: BigNumber.from(permissions.nativeTokenLimitPerTransaction),\n      approvedCallTargets: permissions.approvedTargets\n    };\n  }\n  async sendSignerPermissionRequest(signerAddress, permissions) {\n    const {\n      payload,\n      signature\n    } = await this.generatePayload(signerAddress, permissions);\n    const [success] = await this.contractWrapper.read(\"verifySignerPermissionRequest\", [payload, signature]);\n    if (!success) {\n      throw new Error(`Invalid signature.`);\n    }\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"setPermissionsForSigner\",\n      args: [payload, signature]\n    });\n  }\n  async buildSignerPermissionRequest(signerAddress, permissions) {\n    const {\n      payload,\n      signature\n    } = await this.generatePayload(signerAddress, permissions);\n    const isValidSigner = await this.contractWrapper.read(\"verifySignerPermissionRequest\", [payload, signature]);\n    if (!isValidSigner) {\n      throw new Error(`Invalid signature.`);\n    }\n    return this.contractWrapper.writeContract.interface.encodeFunctionData(\"setPermissionsForSigner\", [payload, signature]);\n  }\n\n  /**\n   * Generate and sign a payload to grant or revoke a signer's access to the account.\n   *\n   * @param signer - The address of the signer\n   * @param roleAction - The address of the signer\n   * @returns The generated payload and signature produced on signing that payload.\n   *\n   */\n  async generatePayload(signerAddress, permissions) {\n    // Get payload struct.\n    const payload = {\n      signer: signerAddress,\n      approvedTargets: permissions.approvedCallTargets,\n      nativeTokenLimitPerTransaction: utils.parseEther(permissions.nativeTokenLimitPerTransaction),\n      permissionStartTimestamp: permissions.startDate,\n      permissionEndTimestamp: permissions.expirationDate,\n      reqValidityStartTimestamp: 0,\n      // Req validity ends 10 years from now.\n      reqValidityEndTimestamp: BigNumber.from(Math.floor(new Date(Date.now() + 1000 * 60 * 60 * 24 * 365 * 10).getTime() / 1000)),\n      uid: resolveOrGenerateId(undefined)\n    };\n\n    // Generate signature\n    const chainId = await this.contractWrapper.getChainID();\n    const connectedSigner = this.contractWrapper.getSigner();\n    invariant(connectedSigner, \"No signer available\");\n    const signature = await this.contractWrapper.signTypedData(connectedSigner, {\n      name: \"Account\",\n      version: \"1\",\n      chainId,\n      verifyingContract: this.getAddress()\n    }, {\n      SignerPermissionRequest\n    }, payload);\n    return {\n      payload,\n      signature\n    };\n  }\n\n  /*********************************\n   * READ FUNCTIONS\n   ********************************/\n\n  /**\n   * Get whether a signer is an admin on the account.\n   *\n   * @example\n   * ```javascript\n   * const isAdmin = await contract.account.isAdmin(signer);\n   * ```\n   * @param signer - The address of a signer of the account.\n   * @returns whether a signer is an admin on the account.\n   *\n   * @twfeature AccountPermissions\n   */\n  async isAdmin(signerAddress) {\n    const resolvedSignerAddress = await resolveAddress(signerAddress);\n    return await this.contractWrapper.read(\"isAdmin\", [resolvedSignerAddress]);\n  }\n\n  /**\n   * Get whether a signer has permissions to use the account.\n   *\n   * @example\n   * ```javascript\n   * const isAdmin = await contract.account.isSigner(signer);\n   * ```\n   * @param signer - The address of a signer of the account.\n   * @returns whether a signer has permissions to use the account.\n   *\n   * @twfeature AccountPermissions\n   */\n  async isSigner(signerAddress) {\n    const resolvedSignerAddress = await resolveAddress(signerAddress);\n    return await this.contractWrapper.read(\"isActiveSigner\", [resolvedSignerAddress]);\n  }\n\n  /**\n   * Get all admins of the account.\n   *\n   * @example\n   * ```javascript\n   * const allAdmins = await contract.account.getAllAdmins();\n   * ```\n   *\n   * @returns all admins of the account.\n   *\n   * @twfeature AccountPermissions\n   */\n  async getAllAdmins() {\n    return await this.contractWrapper.read(\"getAllAdmins\", []);\n  }\n\n  /**\n   * Get all (non-admin) signers with permissions to use the account.\n   *\n   * @example\n   * ```javascript\n   * const allSigners = await contract.account.getAllSigners();\n   * ```\n   *\n   * @returns all (non-admin) signers with permissions to use the account.\n   *\n   * @twfeature AccountPermissions\n   */\n  async getAllSigners() {\n    const activeSignersWithPerms = await this.contractWrapper.read(\"getAllActiveSigners\", []);\n    return await Promise.all(activeSignersWithPerms.map(async signerWithPermissions => {\n      const signer = signerWithPermissions.signer;\n      const permissions = this.parseSignerPermissionsStruct(signerWithPermissions);\n      return {\n        signer,\n        permissions\n      };\n    }));\n  }\n\n  /**\n   * Get all admins and non-admin signers with permissions to use the account.\n   *\n   * @example\n   * ```javascript\n   * const allAdminsAndSigners = await contract.account.getAllAdminsAndSigners();\n   * ```\n   *\n   * @returns all admins and non-admin signers with permissions to use the account.\n   *\n   * @twfeature AccountPermissions\n   */\n  async getAllAdminsAndSigners() {\n    const allAdmins = await this.getAllAdmins();\n    const transformedAdmins = allAdmins.map(admin => {\n      return {\n        isAdmin: true,\n        signer: admin,\n        permissions: {\n          startDate: new Date(0),\n          expirationDate: new Date(0),\n          nativeTokenLimitPerTransaction: BigNumber.from(0),\n          approvedCallTargets: []\n        }\n      };\n    });\n    const allSigners = await this.getAllSigners();\n    return [...transformedAdmins, ...allSigners];\n  }\n\n  /*********************************\n   * WRITE FUNCTIONS\n   ********************************/\n\n  /**\n   * Grant an address admin access to the account.\n   *\n   * @remarks Grants an address admin access to the account. The admin will have complete authority over the account.\n   *\n   * @param signer - The address to be granted admin access to the account.\n   *\n   * @example\n   * ```javascript\n   * const tx = await contract.account.grantAdminAccess(signer);\n   * const receipt = tx.receipt();\n   * ```\n   *\n   * @twfeature AccountPermissions\n   */\n  grantAdminPermissions = /* @__PURE__ */buildTransactionFunction(async signerAddress => {\n    const resolvedSignerAddress = await resolveAddress(signerAddress);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"setAdmin\",\n      args: [resolvedSignerAddress, true]\n    });\n  });\n\n  /**\n   * Revoke an address' admin access to the account.\n   *\n   * @remarks Revokes an address' admin access to the account.\n   *\n   * @param signer - The address of an admin of the account.\n   *\n   * @example\n   * ```javascript\n   * const tx = await contract.account.revokeAdminAccess(signer);\n   * const receipt = tx.receipt();\n   * ```\n   *\n   * @twfeature AccountPermissions\n   */\n  revokeAdminPermissions = /* @__PURE__ */buildTransactionFunction(async signerAddress => {\n    const resolvedSignerAddress = await resolveAddress(signerAddress);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"setAdmin\",\n      args: [resolvedSignerAddress, false]\n    });\n  });\n\n  /**\n   * Grant a signer permissions to use the account.\n   *\n   * @remarks Grants a signer permissions to use the account.\n   *\n   * @param signer - The signer to be granted permissions to use the account.\n   * @param permissions - The permissions to be applied to the signer's use of the account.\n   *\n   * @example\n   * ```javascript\n   * const tx = await contract.account.grantPermissions(signer, permissions);\n   * const receipt = tx.receipt();\n   * ```\n   *\n   * @twfeature AccountPermissions\n   */\n  grantPermissions = /* @__PURE__ */buildTransactionFunction(async (signerAddress, permissions) => {\n    const resolvedSignerAddress = await resolveAddress(signerAddress);\n    const resolvedPermissions = await SignerPermissionsSchema.parseAsync(permissions);\n    if (await this.isAdmin(resolvedSignerAddress)) {\n      throw new Error(\"Signer is already an admin. Cannot grant permissions to an existing admin.\");\n    }\n    if (await this.isSigner(resolvedSignerAddress)) {\n      throw new Error(\"Signer already has permissions. Cannot grant permissions to an existing signer. You can update permissions using `updatePermissions`.\");\n    }\n    return await this.sendSignerPermissionRequest(resolvedSignerAddress, resolvedPermissions);\n  });\n\n  /**\n   * Update the permissions of a signer for using the account.\n   *\n   * @remarks Updates the permissions of a signer for using the account.\n   *\n   * @param signer - The signer whose permissions to use the account are to be updated.\n   * @param permissions - The permissions to be applied to the signer's use of the account.\n   *\n   * @example\n   * ```javascript\n   * const tx = await contract.account.updatePermissions(signer, permissions);\n   * const receipt = tx.receipt();\n   * ```\n   *\n   * @twfeature AccountPermissions\n   */\n  updatePermissions = /* @__PURE__ */buildTransactionFunction(async (signerAddress, permissions) => {\n    const resolvedSignerAddress = await resolveAddress(signerAddress);\n    const resolvedPermissions = await SignerPermissionsSchema.parseAsync(permissions);\n    if (await this.isAdmin(resolvedSignerAddress)) {\n      throw new Error(\"Signer is already an admin. Cannot update permissions of an existing admin.\");\n    }\n    if (!(await this.isSigner(resolvedSignerAddress))) {\n      throw new Error(\"Signer does not already have permissions. You can grant permissions using `grantPermissions`.\");\n    }\n    return await this.sendSignerPermissionRequest(resolvedSignerAddress, resolvedPermissions);\n  });\n\n  /**\n   * Revoke a scoped access address to the account\n   *\n   * @remarks Revokes an address' access to the account.\n   *\n   * @param signer - The address whose access to the account is to be revoked.\n   *\n   * @example\n   * ```javascript\n   * const tx = await contract.account.revokeAccess(signer);\n   * const receipt = tx.receipt();\n   * ```\n   *\n   * @twfeature AccountPermissions\n   */\n  revokeAccess = /* @__PURE__ */buildTransactionFunction(async signerAddress => {\n    const resolvedSignerAddress = await resolveAddress(signerAddress);\n    if (await this.isAdmin(resolvedSignerAddress)) {\n      throw new Error(\"Signer is already an admin. Cannot revoke permissions of an admin.\");\n    }\n    if (!(await this.isSigner(resolvedSignerAddress))) {\n      throw new Error(\"Signer does not already have permissions. You can grant permissions using `grantPermissions`.\");\n    }\n    return await this.sendSignerPermissionRequest(resolvedSignerAddress, {\n      startDate: BigNumber.from(0),\n      expirationDate: BigNumber.from(0),\n      approvedCallTargets: [],\n      nativeTokenLimitPerTransaction: \"0\"\n    });\n  });\n\n  /**\n   * Approve an address as a call target for a given signer on the account\n   *\n   * @remarks Approves an address as a call target for a given signer on the account.\n   *\n   * @param signer - A signer with restricted access to the account.\n   * @param target - The address to approve as a call target for the signer.\n   *\n   * @example\n   * ```javascript\n   * const tx = await contract.account.approveTargetForSigner(signer, target);\n   * const receipt = tx.receipt();\n   * ```\n   *\n   * @twfeature AccountPermissions\n   */\n  approveTargetForSigner = /* @__PURE__ */buildTransactionFunction(async (signerAddress, target) => {\n    const resolvedSignerAddress = await resolveAddress(signerAddress);\n    const resolvedTarget = await resolveAddress(target);\n    if (await this.isAdmin(resolvedSignerAddress)) {\n      throw new Error(\"Signer is already an admin. Cannot approve targets for an admin.\");\n    }\n    if (!(await this.isSigner(resolvedSignerAddress))) {\n      throw new Error(\"Signer does not already have permissions. You can grant permissions using `grantPermissions`.\");\n    }\n    const permissions = await this.contractWrapper.read(\"getPermissionsForSigner\", [resolvedSignerAddress]);\n    if (permissions.approvedTargets.includes(target)) {\n      throw new Error(\"Target is already approved\");\n    }\n    const newTargets = [...permissions.approvedTargets, resolvedTarget];\n    return await this.sendSignerPermissionRequest(resolvedSignerAddress, {\n      startDate: BigNumber.from(permissions.startTimestamp),\n      expirationDate: BigNumber.from(permissions.endTimestamp),\n      approvedCallTargets: newTargets,\n      nativeTokenLimitPerTransaction: permissions.nativeTokenLimitPerTransaction.toString()\n    });\n  });\n\n  /**\n   * Disapprove an address as a call target for a given signer on the account\n   *\n   * @remarks Disapprove an address as a call target for a given signer on the account.\n   *\n   * @param signer - A signer with restricted access to the account.\n   * @param target - The address to disapprove as a call target for the signer.\n   *\n   * @example\n   * ```javascript\n   * const tx = await contract.account.disapproveTargetForSigner(signer, target);\n   * const receipt = tx.receipt();\n   * ```\n   *\n   * @twfeature AccountPermissions\n   */\n  disapproveTargetForSigner = /* @__PURE__ */buildTransactionFunction(async (signerAddress, target) => {\n    const resolvedSignerAddress = await resolveAddress(signerAddress);\n    const resolvedTarget = await resolveAddress(target);\n    if (await this.isAdmin(resolvedSignerAddress)) {\n      throw new Error(\"Signer is already an admin. Cannot approve targets for an admin.\");\n    }\n    if (!(await this.isSigner(resolvedSignerAddress))) {\n      throw new Error(\"Signer does not already have permissions. You can grant permissions using `grantPermissions`.\");\n    }\n    const permissions = await this.contractWrapper.read(\"getPermissionsForSigner\", [resolvedSignerAddress]);\n    if (!permissions.approvedTargets.includes(resolvedTarget)) {\n      throw new Error(\"Target is currently not approved\");\n    }\n    const newTargets = permissions.approvedTargets.filter(approvedTarget => utils.getAddress(approvedTarget) !== utils.getAddress(resolvedTarget));\n    return await this.sendSignerPermissionRequest(resolvedSignerAddress, {\n      startDate: BigNumber.from(permissions.startTimestamp),\n      expirationDate: BigNumber.from(permissions.endTimestamp),\n      approvedCallTargets: newTargets,\n      nativeTokenLimitPerTransaction: permissions.nativeTokenLimitPerTransaction.toString()\n    });\n  });\n\n  /**\n   * Set the account's entire snapshot of permissions.\n   *\n   * @remarks Sets the account's entire snapshot of permissions.\n   *\n   * @param permissionSnapshot - the snapshot to set as the account's entire permission snapshot.\n   *\n   * @example\n   * ```javascript\n   * const tx = await contract.account.setAccess(permissionSnapshot);\n   * const receipt = tx.receipt();\n   * ```\n   *\n   * @twfeature AccountPermissions\n   */\n  resetAllPermissions = /* @__PURE__ */buildTransactionFunction(async permissionSnapshot => {\n    const resolvedSnapshot = await PermissionSnapshotSchema.parseAsync(permissionSnapshot);\n\n    /**\n     * All cases\n     *\n     * - Add new admin :check:\n     * - Remove current admin :check:\n     * - Add new scoped :check:\n     * - Remove current scoped :check:\n     * - Update current scoped :check:\n     * - Current admin -> new scoped :check:\n     * - Current scoped -> new admin :check:\n     **/\n\n    // No duplicate signers in input!\n    if (this.hasDuplicateSigners(resolvedSnapshot)) {\n      throw new Error(\"Duplicate signers found in input.\");\n    }\n    const addAdminData = [];\n    const removeAdminData = [];\n    const addOrUpdateSignerData = [];\n    const removeSignerData = [];\n\n    // Remove all existing admins not included in the passed snapshot.\n    const allAdmins = await this.getAllAdmins();\n    const allToMakeAdmin = resolvedSnapshot.filter(item => item.makeAdmin).map(item => item.signer);\n    allAdmins.forEach(admin => {\n      if (!allToMakeAdmin.includes(admin)) {\n        removeAdminData.push(this.contractWrapper.writeContract.interface.encodeFunctionData(\"setAdmin\", [admin, false]));\n      }\n    });\n\n    // Remove all existing signers not included in the passed snapshot.\n    const allSigners = await this.getAllSigners();\n    const allToMakeSigners = resolvedSnapshot.filter(item => {\n      return !item.makeAdmin;\n    }).map(item => item.signer);\n    await Promise.all(allSigners.map(async item => {\n      if (!allToMakeSigners.includes(item.signer)) {\n        const data = await this.buildSignerPermissionRequest(item.signer, {\n          startDate: BigNumber.from(0),\n          expirationDate: BigNumber.from(0),\n          approvedCallTargets: [],\n          nativeTokenLimitPerTransaction: \"0\"\n        });\n        removeSignerData.push(data);\n      }\n    }));\n    for (const member of resolvedSnapshot) {\n      // Add new admin\n      if (member.makeAdmin) {\n        addAdminData.push(this.contractWrapper.writeContract.interface.encodeFunctionData(\"setAdmin\", [member.signer, true]));\n      } else {\n        // Add new scoped\n        const data = await this.buildSignerPermissionRequest(member.signer, member.permissions);\n        addOrUpdateSignerData.push(data);\n      }\n    }\n    const data = [];\n    removeAdminData.forEach(item => {\n      data.push(item);\n    });\n    removeSignerData.forEach(item => {\n      data.push(item);\n    });\n    addOrUpdateSignerData.forEach(item => {\n      data.push(item);\n    });\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"multicall\",\n      args: [data]\n    });\n  });\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars -- TO BE REMOVED IN V4\nclass Account {\n  featureName = FEATURE_ACCOUNT.name;\n  constructor(contractWrapper) {\n    this.contractWrapper = contractWrapper;\n    this.accountPermissions = this.detectAccountPermissions();\n  }\n  detectAccountPermissions() {\n    if (detectContractFeature(this.contractWrapper, \"AccountPermissions\")) {\n      return new AccountPermissions(this.contractWrapper);\n    }\n    return undefined;\n  }\n  getAddress() {\n    return this.contractWrapper.address;\n  }\n\n  /*********************************\n   * READ FUNCTIONS\n   ********************************/\n\n  /**\n   * Get whether a signer is an admin on the account.\n   *\n   * @example\n   * ```javascript\n   * const isAdmin = await contract.account.isAdmin(signer);\n   * ```\n   * @param signer - The address of a signer of the account.\n   * @returns whether a signer is an admin on the account.\n   *\n   * @twfeature AccountPermissions\n   */\n  async isAdmin(signerAddress) {\n    return assertEnabled(this.accountPermissions, FEATURE_ACCOUNT_PERMISSIONS).isAdmin(signerAddress);\n  }\n\n  /**\n   * Get whether a signer has permissions to use the account.\n   *\n   * @example\n   * ```javascript\n   * const isAdmin = await contract.account.isSigner(signer);\n   * ```\n   * @param signer - The address of a signer of the account.\n   * @returns whether a signer has permissions to use the account.\n   *\n   * @twfeature AccountPermissions\n   */\n  async isSigner(signerAddress) {\n    return assertEnabled(this.accountPermissions, FEATURE_ACCOUNT_PERMISSIONS).isSigner(signerAddress);\n  }\n\n  /**\n   * Get all admins of the account.\n   *\n   * @example\n   * ```javascript\n   * const allAdmins = await contract.account.getAllAdmins();\n   * ```\n   *\n   * @returns all admins of the account.\n   *\n   * @twfeature AccountPermissions\n   */\n  async getAllAdmins() {\n    return assertEnabled(this.accountPermissions, FEATURE_ACCOUNT_PERMISSIONS).getAllAdmins();\n  }\n\n  /**\n   * Get all (non-admin) signers with permissions to use the account.\n   *\n   * @example\n   * ```javascript\n   * const allSigners = await contract.account.getAllSigners();\n   * ```\n   *\n   * @returns all (non-admin) signers with permissions to use the account.\n   *\n   * @twfeature AccountPermissions\n   */\n  async getAllSigners() {\n    return assertEnabled(this.accountPermissions, FEATURE_ACCOUNT_PERMISSIONS).getAllSigners();\n  }\n\n  /**\n   * Get all admins and non-admin signers with permissions to use the account.\n   *\n   * @example\n   * ```javascript\n   * const allAdminsAndSigners = await contract.account.getAllAdminsAndSigners();\n   * ```\n   *\n   * @returns all admins and non-admin signers with permissions to use the account.\n   *\n   * @twfeature AccountPermissions\n   */\n  async getAllAdminsAndSigners() {\n    return assertEnabled(this.accountPermissions, FEATURE_ACCOUNT_PERMISSIONS).getAllAdminsAndSigners();\n  }\n\n  /*********************************\n   * WRITE FUNCTIONS\n   ********************************/\n\n  /**\n   * Grant an address admin access to the account.\n   *\n   * @remarks Grants an address admin access to the account. The admin will have complete authority over the account.\n   *\n   * @param signer - The address to be granted admin access to the account.\n   *\n   * @example\n   * ```javascript\n   * const tx = await contract.account.grantAdminAccess(signer);\n   * const receipt = tx.receipt();\n   * ```\n   *\n   * @twfeature AccountPermissions\n   */\n  grantAdminPermissions = /* @__PURE__ */buildTransactionFunction(async signerAddress => {\n    return assertEnabled(this.accountPermissions, FEATURE_ACCOUNT_PERMISSIONS).grantAdminPermissions.prepare(signerAddress);\n  });\n\n  /**\n   * Revoke an address' admin access to the account.\n   *\n   * @remarks Revokes an address' admin access to the account.\n   *\n   * @param signer - The address of an admin of the account.\n   *\n   * @example\n   * ```javascript\n   * const tx = await contract.account.revokeAdminAccess(signer);\n   * const receipt = tx.receipt();\n   * ```\n   *\n   * @twfeature AccountPermissions\n   */\n  revokeAdminPermissions = /* @__PURE__ */buildTransactionFunction(async signerAddress => {\n    return assertEnabled(this.accountPermissions, FEATURE_ACCOUNT_PERMISSIONS).revokeAdminPermissions.prepare(signerAddress);\n  });\n\n  /**\n   * Grant a signer permissions to use the account.\n   *\n   * @remarks Grants a signer permissions to use the account.\n   *\n   * @param signer - The signer to be granted permissions to use the account.\n   * @param permissions - The permissions to be applied to the signer's use of the account.\n   *\n   * @example\n   * ```javascript\n   * const tx = await contract.account.grantPermissions(signer, permissions);\n   * const receipt = tx.receipt();\n   * ```\n   *\n   * @twfeature AccountPermissions\n   */\n  grantPermissions = /* @__PURE__ */buildTransactionFunction(async (signerAddress, permissions) => {\n    return assertEnabled(this.accountPermissions, FEATURE_ACCOUNT_PERMISSIONS).grantPermissions.prepare(signerAddress, permissions);\n  });\n\n  /**\n   * Update the permissions of a signer for using the account.\n   *\n   * @remarks Updates the permissions of a signer for using the account.\n   *\n   * @param signer - The signer whose permissions to use the account are to be updated.\n   * @param permissions - The permissions to be applied to the signer's use of the account.\n   *\n   * @example\n   * ```javascript\n   * const tx = await contract.account.updateAccess(signer, restrictions);\n   * const receipt = tx.receipt();\n   * ```\n   *\n   * @twfeature AccountPermissions\n   */\n  updatePermissions = /* @__PURE__ */buildTransactionFunction(async (signerAddress, permissions) => {\n    return assertEnabled(this.accountPermissions, FEATURE_ACCOUNT_PERMISSIONS).updatePermissions.prepare(signerAddress, permissions);\n  });\n\n  /**\n   * Revoke a scoped access address to the account\n   *\n   * @remarks Revokes an address' access to the account.\n   *\n   * @param signer - The address whose access to the account is to be revoked.\n   *\n   * @example\n   * ```javascript\n   * const tx = await contract.account.revokeAccess(signer);\n   * const receipt = tx.receipt();\n   * ```\n   *\n   * @twfeature AccountPermissions\n   */\n  revokeAccess = /* @__PURE__ */buildTransactionFunction(async signerAddress => {\n    return assertEnabled(this.accountPermissions, FEATURE_ACCOUNT_PERMISSIONS).revokeAccess.prepare(signerAddress);\n  });\n\n  /**\n   * Approve an address as a call target for a given signer on the account\n   *\n   * @remarks Approves an address as a call target for a given signer on the account.\n   *\n   * @param signer - A signer with restricted access to the account.\n   * @param target - The address to approve as a call target for the signer.\n   *\n   * @example\n   * ```javascript\n   * const tx = await contract.account.approveTargetForSigner(signer, target);\n   * const receipt = tx.receipt();\n   * ```\n   *\n   * @twfeature AccountPermissions\n   */\n  approveTargetForSigner = /* @__PURE__ */buildTransactionFunction(async (signerAddress, target) => {\n    return assertEnabled(this.accountPermissions, FEATURE_ACCOUNT_PERMISSIONS).approveTargetForSigner.prepare(signerAddress, target);\n  });\n\n  /**\n   * Disapprove an address as a call target for a given signer on the account\n   *\n   * @remarks Disapprove an address as a call target for a given signer on the account.\n   *\n   * @param signer - A signer with restricted access to the account.\n   * @param target - The address to disapprove as a call target for the signer.\n   *\n   * @example\n   * ```javascript\n   * const tx = await contract.account.disapproveTargetForSigner(signer, target);\n   * const receipt = tx.receipt();\n   * ```\n   *\n   * @twfeature AccountPermissions\n   */\n  disapproveTargetForSigner = /* @__PURE__ */buildTransactionFunction(async (signerAddress, target) => {\n    return assertEnabled(this.accountPermissions, FEATURE_ACCOUNT_PERMISSIONS).disapproveTargetForSigner.prepare(signerAddress, target);\n  });\n\n  /**\n   * Set the account's entire snapshot of permissions.\n   *\n   * @remarks Sets the account's entire snapshot of permissions.\n   *\n   * @param permissionSnapshot - the snapshot to set as the account's entire permission snapshot.\n   *\n   * @example\n   * ```javascript\n   * const tx = await contract.account.setAccess(permissionSnapshot);\n   * const receipt = tx.receipt();\n   * ```\n   *\n   * @twfeature AccountPermissions\n   */\n  resetAllPermissions = /* @__PURE__ */buildTransactionFunction(async permissionSnapshot => {\n    return assertEnabled(this.accountPermissions, FEATURE_ACCOUNT_PERMISSIONS).resetAllPermissions.prepare(permissionSnapshot);\n  });\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars -- TO BE REMOVED IN V4\nclass AccountFactory {\n  featureName = FEATURE_ACCOUNT_FACTORY.name;\n\n  // utilities\n\n  constructor(contractWrapper) {\n    this.contractWrapper = contractWrapper;\n    this.events = new ContractEvents(this.contractWrapper);\n  }\n  getAddress() {\n    return this.contractWrapper.address;\n  }\n\n  /*********************************\n   * READ FUNCTIONS\n   *******************************/\n\n  /**\n   * Get the deterministic address of the account that will be created\n   *\n   * @example\n   * ```javascript\n   * const accountAddress = await contract.accountFactory.predictAccountAddress(admin);\n   * ```\n   * @param admin - The admin of the account.\n   * @param extraData - (Optional) Extra data to be passed to the account on creation.\n   * @returns the deterministic address of the account that will be created for the given admin.\n   *\n   * @twfeature AccountFactory\n   */\n  async predictAccountAddress(admin, extraData) {\n    let data = utils.toUtf8Bytes(\"\");\n    if (extraData) {\n      data = extraData;\n    }\n    return this.contractWrapper.read(\"getAddress\", [admin, data]);\n  }\n\n  /**\n   * Get all accounts on which the given signer has authority\n   *\n   * @example\n   * ```javascript\n   * const allAccounts = await contract.accountFactory.getAssociatedAccounts(admin);\n   * ```\n   * @param signer - The account address.\n   * @returns all accounts on which the given signer has authority.\n   *\n   * @twfeature AccountFactory\n   */\n  async getAssociatedAccounts(signer) {\n    return this.contractWrapper.read(\"getAccountsOfSigner\", [signer]);\n  }\n\n  /**\n   * Get all accounts\n   *\n   * @example\n   * ```javascript\n   * const allAccounts = await contract.accountFactory.getAllAccounts();\n   * ```\n   *\n   * @returns all accounts created via the account factory.\n   *\n   * @twfeature AccountFactory\n   */\n  async getAllAccounts() {\n    return await this.contractWrapper.read(\"getAllAccounts\", []);\n  }\n\n  /**\n   * Check if a account has been deployed for the given admin\n   *\n   * @param admin - The admin of the account.\n   * @param extraData - (Optional) Extra data to be passed to the account on creation.\n   * @returns whether the account has been deployed for the given admin.\n   */\n  async isAccountDeployed(admin, extraData) {\n    const addr = await this.predictAccountAddress(admin, extraData);\n    return isContractDeployed(addr, this.contractWrapper.getProvider());\n  }\n\n  /*********************************\n   * WRITE FUNCTIONS\n   *******************************/\n\n  /**\n   * Create a account\n   *\n   * @remarks Create a account for an admin. The admin will have complete authority over the account.\n   *\n   * @param admin - The admin of the account.\n   * @param extraData - (Optional) Extra data to be passed to the account on creation.\n   *\n   * @example\n   *  ```javascript\n   * const tx = await contract.accountFactory.createAccount(admin, extraData);\n   * const receipt = tx.receipt();\n   * const accountAddress = tx.address;\n   * ```\n   *\n   * @twfeature AccountFactory\n   */\n  createAccount = /* @__PURE__ */buildTransactionFunction(async (accountAdmin, extraData) => {\n    if (await this.isAccountDeployed(accountAdmin, extraData)) {\n      throw new Error(`Account already deployed for admin: ${accountAdmin}`);\n    }\n    let data = utils.toUtf8Bytes(\"\");\n    if (extraData) {\n      data = extraData;\n    }\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"createAccount\",\n      args: [accountAdmin, data],\n      parse: receipt => {\n        const event = this.contractWrapper.parseLogs(\"AccountCreated\", receipt?.logs);\n        return {\n          address: event[0].args.account,\n          receipt\n        };\n      }\n    });\n  });\n}\n\n/**\n * @public\n */\nclass Airdrop1155 {\n  featureName = FEATURE_AIRDROP_ERC1155.name;\n  constructor(contractWrapper) {\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * @internal\n   */\n  getAddress() {\n    return this.contractWrapper.address;\n  }\n\n  /** ******************************\n   * WRITE FUNCTIONS\n   *******************************/\n\n  /**\n   * Perform airdrop of ERC1155 tokens\n   *\n   * @example\n   * ```javascript\n   * // Airdrop content array, with recipients and tokenIds\n   * const contents = [\n   *      {\n   *        recipient: \"0xabc...\", // first recipient address\n   *        tokenId: 0,\n   *        amount: \"10\" // number of tokens\n   *      },\n   *      {\n   *        recipient: \"0x123...\", // second recipient address\n   *        tokenId: 0\n   *        amount: \"20\" // number of tokens\n   *      }\n   *   ]\n   *\n   * const tokenAddress = \"0x...\" // Address of the ERC1155 token being airdropped\n   * const tokenOwner = \"0x...\" // Address of the owner of the tokens being airdropped\n   *\n   * const output = await contract.airdrop1155.drop(tokenAddress, tokenOwner, contents);\n   *\n   * // the `output` return value above contains:\n   * //     - count of successful and failed drops\n   * //     - array containing failed drops, if any\n   *\n   * ```\n   * @param tokenAddress\n   * @param tokenOwner\n   * @param contents\n   *\n   * @returns an array of recipients for who the airdrop failed (empty means all transfers were successful)\n   * @twfeature AirdropERC1155\n   */\n  drop = /* @__PURE__ */buildTransactionFunction(async (tokenAddress, tokenOwner, contents) => {\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"airdropERC1155\",\n      args: [tokenAddress, tokenOwner, contents],\n      parse: receipt => {\n        const events = this.contractWrapper.parseLogs(\"AirdropFailed\", receipt.logs);\n        const failedDrops = events.map(e => {\n          return {\n            recipient: e.args.recipient,\n            tokenId: e.args.tokenId.toNumber(),\n            amount: e.args.amount.toString()\n          };\n        });\n        return {\n          successfulDropCount: contents.length - failedDrops.length,\n          failedDropCount: failedDrops.length,\n          failedDrops\n        };\n      }\n    });\n  });\n}\n\n/**\n * @public\n */\nclass Airdrop20 {\n  featureName = FEATURE_AIRDROP_ERC20.name;\n  constructor(contractWrapper) {\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * @internal\n   */\n  getAddress() {\n    return this.contractWrapper.address;\n  }\n\n  /** ******************************\n   * WRITE FUNCTIONS\n   *******************************/\n\n  /**\n   * Perform airdrop of ERC20 tokens\n   *\n   * @example\n   * ```javascript\n   * // Airdrop content array, with recipients and token amounts\n   * const contents = [\n   *      {\n   *        recipient: \"0xabc...\", // first recipient address\n   *        amount: \"10\" // number of tokens in wei units\n   *      },\n   *      {\n   *        recipient: \"0x123...\", // second recipient address\n   *        amount: \"20\" // number of tokens in wei units\n   *      }\n   *   ]\n   *\n   * const tokenAddress = \"0x...\" // Address of the ERC20 token being airdropped\n   * const tokenOwner = \"0x...\" // Address of the owner of the tokens being airdropped\n   *\n   * const output = await contract.airdrop20.drop(tokenAddress, tokenOwner, contents);\n   *\n   * // the `output` return value above contains:\n   * //     - count of successful and failed drops\n   * //     - array containing failed drops, if any\n   *\n   * ```\n   * @param tokenAddress\n   * @param tokenOwner\n   * @param contents\n   *\n   * @returns an array of recipients for who the airdrop failed (empty means all transfers were successful)\n   * @twfeature AirdropERC20\n   */\n  drop = /* @__PURE__ */buildTransactionFunction(async (tokenAddress, tokenOwner, contents) => {\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"airdropERC20\",\n      args: [tokenAddress, tokenOwner, contents],\n      parse: receipt => {\n        const events = this.contractWrapper.parseLogs(\"AirdropFailed\", receipt.logs);\n        const failedDrops = events.map(e => {\n          return {\n            recipient: e.args.recipient,\n            amount: e.args.amount.toString()\n          };\n        });\n        return {\n          successfulDropCount: contents.length - failedDrops.length,\n          failedDropCount: failedDrops.length,\n          failedDrops\n        };\n      }\n    });\n  });\n}\n\n/**\n * @public\n */\nclass Airdrop721 {\n  featureName = FEATURE_AIRDROP_ERC721.name;\n  constructor(contractWrapper) {\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * @internal\n   */\n  getAddress() {\n    return this.contractWrapper.address;\n  }\n\n  /** ******************************\n   * WRITE FUNCTIONS\n   *******************************/\n\n  /**\n   * Perform airdrop of ERC721 tokens\n   *\n   * @example\n   * ```javascript\n   * // Airdrop content array, with recipients and tokenIds\n   * const contents = [\n   *      {\n   *        recipient: \"0xabc...\", // first recipient address\n   *        tokenId: 0\n   *      },\n   *      {\n   *        recipient: \"0x123...\", // second recipient address\n   *        tokenId: 2\n   *      }\n   *   ]\n   *\n   * const tokenAddress = \"0x...\" // Address of the ERC721 token being airdropped\n   * const tokenOwner = \"0x...\" // Address of the owner of the tokens being airdropped\n   *\n   * const output = await contract.airdrop721.drop(tokenAddress, tokenOwner, contents);\n   *\n   * // the `output` return value above contains:\n   * //     - count of successful and failed drops\n   * //     - array containing failed drops, if any\n   *\n   * ```\n   * @param tokenAddress\n   * @param tokenOwner\n   * @param contents\n   *\n   * @returns an array of recipients for who the airdrop failed (empty means all transfers were successful)\n   * @twfeature AirdropERC721\n   */\n  drop = /* @__PURE__ */buildTransactionFunction(async (tokenAddress, tokenOwner, contents) => {\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"airdropERC721\",\n      args: [tokenAddress, tokenOwner, contents],\n      parse: receipt => {\n        const events = this.contractWrapper.parseLogs(\"AirdropFailed\", receipt.logs);\n        const failedDrops = events.map(e => {\n          return {\n            recipient: e.args.recipient,\n            tokenId: e.args.tokenId.toNumber()\n          };\n        });\n        return {\n          successfulDropCount: contents.length - failedDrops.length,\n          failedDropCount: failedDrops.length,\n          failedDrops\n        };\n      }\n    });\n  });\n}\n\nclass ExtensionManager {\n  featureName = FEATURE_DYNAMIC_CONTRACT.name;\n  constructor(contractWrapper) {\n    this.contractWrapper = contractWrapper;\n  }\n  getAddress() {\n    return this.contractWrapper.readContract.address;\n  }\n\n  /** ******************************\n   * READ FUNCTIONS\n   *******************************/\n\n  async getAll() {\n    const extensions = await this.contractWrapper.readContract.getAllExtensions();\n    return extensions;\n  }\n  async get(extensionName) {\n    const extension = await this.contractWrapper.readContract.getExtension(extensionName);\n    return extension;\n  }\n  async getExtensionAddress(extensionName) {\n    const extension = await this.get(extensionName);\n    return extension.metadata.implementation;\n  }\n  async getAllFunctions(extensionName) {\n    const extension = await this.get(extensionName);\n    return extension.functions;\n  }\n  async getExtensionForFunction(functionInput) {\n    let selector = functionInput.functionSelector;\n    if (!selector) {\n      invariant(functionInput.functionSignature, \"Atleast one of function selector and signature must be provided\");\n      selector = utils.id(functionInput.functionSignature).substring(0, 10);\n    }\n    const extensionMetadata = await this.contractWrapper.readContract.getMetadataForFunction(selector);\n    return extensionMetadata;\n  }\n  async getExtensionAddressForFunction(functionInput) {\n    const extensionMetadata = await this.getExtensionForFunction(functionInput);\n    return extensionMetadata.implementation;\n  }\n\n  /** ******************************\n   * WRITE FUNCTIONS\n   *******************************/\n\n  /**\n   * Adds an extension to the contract\n   */\n  add = /* @__PURE__ */buildTransactionFunction(async inputArgs => {\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"addExtension\",\n      args: [inputArgs.extension],\n      parse: async receipt => {\n        const events = this.contractWrapper.parseLogs(\"ExtensionAdded\", receipt.logs);\n        if (events.length < 1) {\n          throw new Error(\"No ExtensionAdded event found\");\n        }\n        const extensionAbi = inputArgs.extensionAbi ? AbiSchema.parse(inputArgs.extensionAbi) : (await fetchContractMetadataFromAddress(inputArgs.extension.metadata.implementation, this.contractWrapper.getProvider(), this.contractWrapper.storage)).abi;\n        const abiToAdd = this.filterAbiForAdd(extensionAbi, inputArgs.extension);\n        const updatedAbi = joinABIs([AbiSchema.parse(this.contractWrapper.abi), abiToAdd]);\n        this.contractWrapper.updateAbi(updatedAbi);\n        return receipt;\n      }\n    });\n  });\n\n  /**\n   * Adds a deployed extension to the contract\n   */\n  addDeployed = /* @__PURE__ */buildTransactionFunction(async inputArgs => {\n    let extensionAbi = inputArgs.extensionAbi;\n    if (!extensionAbi) {\n      const metadata = await fetchContractMetadataFromAddress(inputArgs.extensionAddress, this.contractWrapper.getProvider(), this.contractWrapper.storage, this.contractWrapper.options);\n      extensionAbi = metadata.abi;\n    }\n    invariant(extensionAbi, \"Require extension ABI\");\n    let extensionMetadataUri = \"\";\n    if (inputArgs.extensionMetadata) {\n      if (typeof inputArgs.extensionMetadata === \"string\") {\n        extensionMetadataUri = inputArgs.extensionMetadata;\n      } else {\n        const parsedMetadata = await CommonContractSchema.parseAsync(inputArgs.extensionMetadata);\n        extensionMetadataUri = await this.contractWrapper.storage.upload(parsedMetadata);\n      }\n    }\n    const extensionFunctions = generateExtensionFunctions(AbiSchema.parse(extensionAbi));\n    const extension = {\n      metadata: {\n        name: inputArgs.extensionName,\n        metadataURI: extensionMetadataUri,\n        implementation: inputArgs.extensionAddress\n      },\n      functions: extensionFunctions\n    };\n    return this.add.prepare({\n      extension,\n      extensionAbi\n    });\n  });\n\n  /**\n   * Adds a published extension to the contract, and deploys it deterministically if necessary\n   */\n  addPublished = /* @__PURE__ */buildTransactionFunction(async inputArgs => {\n    const version = inputArgs.version || \"latest\";\n    const {\n      deployedExtensionAddress,\n      extensionMetadata\n    } = await this.deployExtension(inputArgs.extensionName, inputArgs.publisherAddress || THIRDWEB_DEPLOYER, version);\n    return this.addDeployed.prepare({\n      extensionName: inputArgs.extensionName,\n      extensionAddress: deployedExtensionAddress,\n      extensionMetadata: inputArgs.extensionMetadataOverride || extensionMetadata\n    });\n  });\n  replace = /* @__PURE__ */buildTransactionFunction(async inputArgs => {\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"replaceExtension\",\n      args: [inputArgs.extension],\n      parse: async receipt => {\n        const events = this.contractWrapper.parseLogs(\"ExtensionReplaced\", receipt.logs);\n        if (events.length < 1) {\n          throw new Error(\"No ExtensionReplaced event found\");\n        }\n        const extensionAbi = inputArgs.extensionAbi ? AbiSchema.parse(inputArgs.extensionAbi) : (await fetchContractMetadataFromAddress(inputArgs.extension.metadata.implementation, this.contractWrapper.getProvider(), this.contractWrapper.storage)).abi;\n        const contractAbi = this.filterAbiForRemove(AbiSchema.parse(this.contractWrapper.abi), extensionAbi);\n        const abiToAdd = this.filterAbiForAdd(extensionAbi, inputArgs.extension);\n        const updatedAbi = joinABIs([contractAbi, abiToAdd]);\n        this.contractWrapper.updateAbi(updatedAbi);\n        return receipt;\n      }\n    });\n  });\n  replaceDeployed = /* @__PURE__ */buildTransactionFunction(async inputArgs => {\n    let extensionAbi = inputArgs.extensionAbi;\n    if (!extensionAbi) {\n      const metadata = await fetchContractMetadataFromAddress(inputArgs.extensionAddress, this.contractWrapper.getProvider(), this.contractWrapper.storage, this.contractWrapper.options);\n      extensionAbi = metadata.abi;\n    }\n    invariant(extensionAbi, \"Require extension ABI\");\n    let extensionMetadataUri = \"\";\n    if (inputArgs.extensionMetadata) {\n      if (typeof inputArgs.extensionMetadata === \"string\") {\n        extensionMetadataUri = inputArgs.extensionMetadata;\n      } else {\n        const parsedMetadata = await CommonContractSchema.parseAsync(inputArgs.extensionMetadata);\n        extensionMetadataUri = await this.contractWrapper.storage.upload(parsedMetadata);\n      }\n    }\n    const extensionFunctions = generateExtensionFunctions(AbiSchema.parse(extensionAbi));\n    const extension = {\n      metadata: {\n        name: inputArgs.extensionName,\n        metadataURI: extensionMetadataUri,\n        implementation: inputArgs.extensionAddress\n      },\n      functions: extensionFunctions\n    };\n    return this.replace.prepare({\n      extension,\n      extensionAbi\n    });\n  });\n  replacePublished = /* @__PURE__ */buildTransactionFunction(async inputArgs => {\n    const version = inputArgs.version || \"latest\";\n    const {\n      deployedExtensionAddress,\n      extensionMetadata\n    } = await this.deployExtension(inputArgs.extensionName, inputArgs.publisherAddress || THIRDWEB_DEPLOYER, version);\n    return this.replaceDeployed.prepare({\n      extensionName: inputArgs.extensionName,\n      extensionAddress: deployedExtensionAddress,\n      extensionMetadata: inputArgs.extensionMetadataOverride || extensionMetadata\n    });\n  });\n  remove = /* @__PURE__ */buildTransactionFunction(async inputArgs => {\n    const extensionAddress = await this.getExtensionAddress(inputArgs.extensionName);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"removeExtension\",\n      args: [inputArgs.extensionName],\n      parse: async receipt => {\n        const events = this.contractWrapper.parseLogs(\"ExtensionRemoved\", receipt.logs);\n        if (events.length < 1) {\n          throw new Error(\"No ExtensionRemoved event found\");\n        }\n        const extensionAbi = (await fetchContractMetadataFromAddress(extensionAddress, this.contractWrapper.getProvider(), this.contractWrapper.storage)).abi;\n        const updatedAbi = this.filterAbiForRemove(AbiSchema.parse(this.contractWrapper.abi), extensionAbi);\n        this.contractWrapper.updateAbi(updatedAbi);\n        return receipt;\n      }\n    });\n  });\n\n  /** ******************************\n   * Internal / private\n   *******************************/\n\n  filterAbiForAdd(extensionAbi, extension) {\n    const extensionAbiInterface = new utils.Interface(extensionAbi);\n    const extensionFunctionSelectors = extension.functions.map(fn => fn.functionSelector);\n    const filtered = extensionAbi.filter(item => {\n      const fnFragment = Object.values(new utils.Interface([item]).functions);\n      if (fnFragment.length === 0) {\n        return false;\n      }\n      const fnSigHash = extensionAbiInterface.getSighash(fnFragment[0]);\n      return extensionFunctionSelectors.includes(fnSigHash);\n    });\n    return filtered;\n  }\n  filterAbiForRemove(fullAbi, abiToRemove) {\n    const fullAbiInterface = new utils.Interface(fullAbi);\n    const interfaceToRemove = new utils.Interface(abiToRemove);\n    const functionsToRemove = Object.values(interfaceToRemove.functions).map(fn => interfaceToRemove.getSighash(fn));\n    const filtered = fullAbi.filter(item => {\n      const fnFragment = Object.values(new utils.Interface([item]).functions);\n      if (fnFragment.length === 0) {\n        return false;\n      }\n      const fnSigHash = fullAbiInterface.getSighash(fnFragment[0]);\n      return !functionsToRemove.includes(fnSigHash);\n    });\n    return filtered;\n  }\n  async deployExtension(extensionName, publisherAddress) {\n    let version = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"latest\";\n    const published = await fetchPublishedContractFromPolygon(publisherAddress, extensionName, version, this.contractWrapper.storage, this.contractWrapper.options.clientId, this.contractWrapper.options.secretKey);\n    const deploymentInfo = await getDeploymentInfo(published.metadataUri, this.contractWrapper.storage, this.contractWrapper.getProvider(), \"\", this.contractWrapper.options.clientId, this.contractWrapper.options.secretKey);\n    const implementationAddress = deploymentInfo.find(i => i.type === \"implementation\")?.transaction.predictedAddress;\n\n    // deploy infra + plugins + implementation using a throwaway Deployer contract\n\n    // filter out already deployed contracts (data is empty)\n    const transactionsToSend = deploymentInfo.filter(i => i.transaction.data && i.transaction.data.length > 0);\n    const transactionsforDirectDeploy = transactionsToSend.filter(i => {\n      return i.type !== \"infra\";\n    }).map(i => i.transaction);\n    const transactionsForThrowawayDeployer = transactionsToSend.filter(i => {\n      return i.type === \"infra\";\n    }).map(i => i.transaction);\n    const signer = this.contractWrapper.getSigner();\n    invariant(signer, \"Signer is required\");\n\n    // deploy via throwaway deployer, multiple infra contracts in one transaction\n    await deployWithThrowawayDeployer(signer, transactionsForThrowawayDeployer, {});\n\n    // send each transaction directly to Create2 factory\n    // process txns one at a time\n    for (const tx of transactionsforDirectDeploy) {\n      try {\n        await deployContractDeterministic(signer, tx);\n      } catch (e) {\n        console.debug(`Error deploying contract at ${tx.predictedAddress}`, e?.message);\n      }\n    }\n    return {\n      deployedExtensionAddress: implementationAddress,\n      extensionMetadata: published.metadataUri\n    };\n  }\n}\n\n/**\n * Custom contract dynamic class with feature detection\n *\n * @example\n *\n * ```javascript\n * import { ThirdwebSDK } from \"@thirdweb-dev/sdk\";\n *\n * const sdk = new ThirdwebSDK(provider);\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n *\n * // call any function in your contract\n * await contract.call(\"myCustomFunction\", [param1, param2]);\n *\n * // if your contract follows the ERC721 standard, contract.nft will be present\n * const allNFTs = await contract.erc721.query.all()\n *\n * // if your contract extends IMintableERC721, contract.nft.mint() will be available\n * const tx = await contract.erc721.mint({\n *     name: \"Cool NFT\",\n *     image: readFileSync(\"some_image.png\"),\n *   });\n * ```\n *\n * @beta\n */\nclass SmartContract {\n  // utilities\n\n  get abi() {\n    return AbiSchema.parse(this.contractWrapper.abi || []);\n  }\n\n  /**\n   * Handle royalties\n   */\n  get royalties() {\n    return assertEnabled(this.detectRoyalties(), FEATURE_ROYALTY);\n  }\n\n  /**\n   * Handle permissions\n   */\n  get roles() {\n    return assertEnabled(this.detectRoles(), FEATURE_PERMISSIONS);\n  }\n\n  /**\n   * Handle primary sales\n   */\n  get sales() {\n    return assertEnabled(this.detectPrimarySales(), FEATURE_PRIMARY_SALE);\n  }\n\n  /**\n   * Handle platform fees\n   */\n  get platformFees() {\n    return assertEnabled(this.detectPlatformFees(), FEATURE_PLATFORM_FEE);\n  }\n\n  /**\n   * Set and get the owner of the contract\n   */\n  get owner() {\n    return assertEnabled(this.detectOwnable(), FEATURE_OWNER);\n  }\n\n  /**\n   * Auto-detects ERC20 standard functions.\n   */\n  get erc20() {\n    return assertEnabled(this.detectErc20(), FEATURE_TOKEN);\n  }\n\n  /**\n   * Auto-detects ERC721 standard functions.\n   */\n  get erc721() {\n    return assertEnabled(this.detectErc721(), FEATURE_NFT);\n  }\n\n  /**\n   * Auto-detects ERC1155 standard functions.\n   */\n  get erc1155() {\n    return assertEnabled(this.detectErc1155(), FEATURE_EDITION);\n  }\n\n  /**\n   * Auto-detects AppURI standard functions.\n   */\n  get app() {\n    return assertEnabled(this.detectApp(), FEATURE_APPURI);\n  }\n\n  /**\n   * Direct listings\n   * @remarks Create and manage direct listings in your marketplace.\n   * ```javascript\n   * // Data of the listing you want to create\n   * const listing = {\n   *   // address of the contract the asset you want to list is on\n   *   assetContractAddress: \"0x...\",\n   *   // token ID of the asset you want to list\n   *   tokenId: \"0\",\n   *   // how many of the asset you want to list\n   *   quantity: 1,\n   *   // address of the currency contract that will be used to pay for the listing\n   *   currencyContractAddress: NATIVE_TOKEN_ADDRESS,\n   *   // The price to pay per unit of NFTs listed.\n   *   pricePerToken: 1.5,\n   *   // when should the listing open up for offers\n   *   startTimestamp: new Date(Date.now()),\n   *   // how long the listing will be open for\n   *   endTimestamp: new Date(Date.now() + 5 * 24 * 60 * 60 * 1000),\n   *   // Whether the listing is reserved for a specific set of buyers.\n   *   isReservedListing: false\n   * }\n   *\n   * const tx = await contract.directListings.createListing(listing);\n   * const receipt = tx.receipt; // the transaction receipt\n   * const id = tx.id; // the id of the newly created listing\n   *\n   * // And on the buyers side:\n   * // The ID of the listing you want to buy from\n   * const listingId = 0;\n   * // Quantity of the asset you want to buy\n   * const quantityDesired = 1;\n   *\n   * await contract.directListings.buyFromListing(listingId, quantityDesired);\n   * ```\n   */\n  get directListings() {\n    return assertEnabled(this.detectDirectListings(), FEATURE_DIRECT_LISTINGS);\n  }\n  /**\n   * Auctions\n   * @remarks Create and manage auctions in your marketplace.\n   * @example\n   * ```javascript\n   * // Data of the auction you want to create\n   * const auction = {\n   *   // address of the contract of the asset you want to auction\n   *   assetContractAddress: \"0x...\",\n   *   // token ID of the asset you want to auction\n   *   tokenId: \"0\",\n   *   // how many of the asset you want to auction\n   *   quantity: 1,\n   *   // address of the currency contract that will be used to pay for the auctioned tokens\n   *   currencyContractAddress: NATIVE_TOKEN_ADDRESS,\n   *   // the minimum bid that will be accepted for the token\n   *   minimumBidAmount: \"1.5\",\n   *   // how much people would have to bid to instantly buy the asset\n   *   buyoutBidAmount: \"10\",\n   *   // If a bid is made less than these many seconds before expiration, the expiration time is increased by this.\n   *   timeBufferInSeconds: \"1000\",\n   *   // A bid must be at least this much bps greater than the current winning bid\n   *   bidBufferBps: \"100\", // 100 bps stands for 1%\n   *   // when should the auction open up for bidding\n   *   startTimestamp: new Date(Date.now()),\n   *   // end time of auction\n   *   endTimestamp: new Date(Date.now() + 5 * 24 * 60 * 60 * 1000),\n   * }\n   *\n   * const tx = await contract.englishAuctions.createAuction(auction);\n   * const receipt = tx.receipt; // the transaction receipt\n   * const id = tx.id; // the id of the newly created auction\n   *\n   * // And on the buyers side:\n   * // The auction ID of the asset you want to bid on\n   * const auctionId = 0;\n   * // The total amount you are willing to bid for auctioned tokens\n   * const bidAmount = 1;\n   *\n   * await contract.englishAuctions.makeBid(auctionId, bidAmount);\n   * ```\n   */\n  get englishAuctions() {\n    return assertEnabled(this.detectEnglishAuctions(), FEATURE_ENGLISH_AUCTIONS);\n  }\n\n  /**\n   * Offers\n   * @remarks Make and manage offers.\n   * @example\n   * ```javascript\n   * // Data of the offer you want to make\n   * const offer = {\n   *   // address of the contract the asset you want to make an offer for\n   *   assetContractAddress: \"0x...\",\n   *   // token ID of the asset you want to buy\n   *   tokenId: \"0\",\n   *   // how many of the asset you want to buy\n   *   quantity: 1,\n   *   // address of the currency contract that you offer to pay in\n   *   currencyContractAddress: NATIVE_TOKEN_ADDRESS,\n   *   // Total price you offer to pay for the mentioned token(s)\n   *   totalPrice: \"1.5\",\n   *   // Offer valid until\n   *   endTimestamp: new Date(),\n   * }\n   *\n   * const tx = await contract.offers.makeOffer(offer);\n   * const receipt = tx.receipt; // the transaction receipt\n   * const id = tx.id; // the id of the newly created offer\n   *\n   * // And on the seller's side:\n   * // The ID of the offer you want to accept\n   * const offerId = 0;\n   * await contract.offers.acceptOffer(offerId);\n   * ```\n   */\n  get offers() {\n    return assertEnabled(this.detectOffers(), FEATURE_OFFERS);\n  }\n  get airdrop20() {\n    return assertEnabled(this.detectAirdrop20(), FEATURE_AIRDROP_ERC20);\n  }\n  get airdrop721() {\n    return assertEnabled(this.detectAirdrop721(), FEATURE_AIRDROP_ERC721);\n  }\n  get airdrop1155() {\n    return assertEnabled(this.detectAirdrop1155(), FEATURE_AIRDROP_ERC1155);\n  }\n\n  /**\n   * Account Factory\n   *\n   * @remarks Create accounts and fetch data about them.\n   * @example\n   * ```javascript\n   *\n   * // Predict the address of the account that will be created for an admin.\n   * const deterministicAddress = await contract.accountFactory.predictAccountAddress(admin, extraData);\n   *\n   * // Create accounts\n   * const tx = await contract.accountFactory.createAccount(admin, extraData);\n   * // the same as `deterministicAddress`\n   * const accountAddress = tx.address;\n   *\n   * // Get all accounts created by the factory\n   * const allAccounts = await contract.accountFactory.getAllAccounts();\n   *\n   * // Get all accounts on which a signer has been given authority.\n   * const associatedAccounts = await contract.accountFactory.getAssociatedAccounts(signer);\n   *\n   * // Get all signers who have been given authority on a account.\n   * const associatedSigners = await contract.accountFactory.getAssociatedSigners(accountAddress);\n   *\n   * // Check whether a account has already been created for a given admin.\n   * const isAccountDeployed = await contract.accountFactory.isAccountDeployed(admin, extraData);\n   * ```\n   */\n  get accountFactory() {\n    return assertEnabled(this.detectAccountFactory(), FEATURE_ACCOUNT_FACTORY);\n  }\n\n  // TODO documentation\n  get account() {\n    return assertEnabled(this.detectAccount(), FEATURE_ACCOUNT);\n  }\n  get extensions() {\n    return assertEnabled(this.detectBaseRouter(), FEATURE_DYNAMIC_CONTRACT);\n  }\n  get chainId() {\n    return this._chainId;\n  }\n  constructor(network, address, abi, storage) {\n    let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    let chainId = arguments.length > 5 ? arguments[5] : undefined;\n    let contractWrapper = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : new ContractWrapper(network, address, abi, options, storage);\n    this._chainId = chainId;\n    this.storage = storage;\n    this.contractWrapper = contractWrapper;\n    this.events = new ContractEvents(this.contractWrapper);\n    this.encoder = new ContractEncoder(this.contractWrapper);\n    this.interceptor = new ContractInterceptor(this.contractWrapper);\n    this.estimator = new GasCostEstimator(this.contractWrapper);\n    this.publishedMetadata = new ContractPublishedMetadata(this.contractWrapper, this.storage);\n    this.metadata = new ContractMetadata(this.contractWrapper, CustomContractSchema, this.storage);\n  }\n  onNetworkUpdated(network) {\n    this.contractWrapper.updateSignerOrProvider(network);\n  }\n  getAddress() {\n    return this.contractWrapper.address;\n  }\n\n  /**\n   * Prepare a transaction for sending\n   */\n  prepare(method, args, overrides) {\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method,\n      args,\n      overrides\n    });\n  }\n\n  /**\n   * Call any function on this contract\n   * @example\n   * ```javascript\n   * // read functions will return the data from the contract\n   * const myValue = await contract.call(\"myReadFunction\");\n   * console.log(myValue);\n   *\n   * // write functions will return the transaction receipt\n   * const tx = await contract.call(\"myWriteFunction\", [arg1, arg2]);\n   * const receipt = tx.receipt;\n   *\n   * // Optionally override transaction options\n   * await contract.call(\"myWriteFunction\", [arg1, arg2], {\n   *  gasLimit: 1000000, // override default gas limit\n   *  value: ethers.utils.parseEther(\"0.1\"), // send 0.1 ether with the contract call\n   * };\n   * ```\n   * @param functionName - the name of the function to call\n   * @param args - the arguments of the function\n   */\n  async call(functionName, args, overrides) {\n    return this.contractWrapper.call(functionName, args, overrides);\n  }\n\n  /** ********************\n   * FEATURE DETECTION\n   * ********************/\n\n  detectRoyalties() {\n    if (detectContractFeature(this.contractWrapper, \"Royalty\")) {\n      // ContractMetadata is stateless, it's fine to create a new one here\n      // This also makes it not order dependent in the feature detection process\n      const metadata = new ContractMetadata(this.contractWrapper, CustomContractSchema, this.storage);\n      return new ContractRoyalty(this.contractWrapper, metadata);\n    }\n    return undefined;\n  }\n  detectRoles() {\n    if (detectContractFeature(this.contractWrapper, \"Permissions\")) {\n      return new ContractRoles(this.contractWrapper, ALL_ROLES);\n    }\n    return undefined;\n  }\n  detectPrimarySales() {\n    if (detectContractFeature(this.contractWrapper, \"PrimarySale\")) {\n      return new ContractPrimarySale(this.contractWrapper);\n    }\n    return undefined;\n  }\n  detectPlatformFees() {\n    if (detectContractFeature(this.contractWrapper, \"PlatformFee\")) {\n      return new ContractPlatformFee(this.contractWrapper);\n    }\n    return undefined;\n  }\n  detectErc20() {\n    if (detectContractFeature(this.contractWrapper, \"ERC20\")) {\n      return new Erc20(this.contractWrapper, this.storage, this.chainId);\n    }\n    return undefined;\n  }\n  detectErc721() {\n    if (detectContractFeature(this.contractWrapper, \"ERC721\")) {\n      return new Erc721(this.contractWrapper, this.storage, this.chainId);\n    }\n    return undefined;\n  }\n  detectErc1155() {\n    if (detectContractFeature(this.contractWrapper, \"ERC1155\")) {\n      return new Erc1155(this.contractWrapper, this.storage, this.chainId);\n    }\n    return undefined;\n  }\n  detectOwnable() {\n    if (detectContractFeature(this.contractWrapper, \"Ownable\")) {\n      return new ContractOwner(this.contractWrapper);\n    }\n    return undefined;\n  }\n  detectApp() {\n    const metadata = new ContractMetadata(this.contractWrapper, CustomContractSchema, this.storage);\n    if (detectContractFeature(this.contractWrapper, \"AppURI\")) {\n      return new ContractAppURI(this.contractWrapper, metadata, this.storage);\n    } else if (detectContractFeature(this.contractWrapper, \"ContractMetadata\")) {\n      return new ContractAppURI(this.contractWrapper, metadata, this.storage);\n    }\n    return undefined;\n  }\n  detectDirectListings() {\n    if (detectContractFeature(this.contractWrapper, \"DirectListings\")) {\n      return new MarketplaceV3DirectListings(this.contractWrapper, this.storage);\n    }\n    return undefined;\n  }\n  detectEnglishAuctions() {\n    if (detectContractFeature(this.contractWrapper, \"EnglishAuctions\")) {\n      return new MarketplaceV3EnglishAuctions(this.contractWrapper, this.storage);\n    }\n    return undefined;\n  }\n  detectOffers() {\n    if (detectContractFeature(this.contractWrapper, \"Offers\")) {\n      return new MarketplaceV3Offers(this.contractWrapper, this.storage);\n    }\n    return undefined;\n  }\n  detectBaseRouter() {\n    if (detectContractFeature(this.contractWrapper, FEATURE_DYNAMIC_CONTRACT.name)) {\n      return new ExtensionManager(this.contractWrapper);\n    }\n    return undefined;\n  }\n  detectAirdrop20() {\n    if (detectContractFeature(this.contractWrapper, \"AirdropERC20\")) {\n      return new Airdrop20(this.contractWrapper);\n    }\n    return undefined;\n  }\n  detectAirdrop721() {\n    if (detectContractFeature(this.contractWrapper, \"AirdropERC721\")) {\n      return new Airdrop721(this.contractWrapper);\n    }\n    return undefined;\n  }\n  detectAirdrop1155() {\n    if (detectContractFeature(this.contractWrapper, \"AirdropERC1155\")) {\n      return new Airdrop1155(this.contractWrapper);\n    }\n    return undefined;\n  }\n\n  // ========== Account features ==========\n\n  detectAccountFactory() {\n    if (detectContractFeature(this.contractWrapper, FEATURE_ACCOUNT_FACTORY.name)) {\n      return new AccountFactory(this.contractWrapper);\n    }\n    return undefined;\n  }\n  detectAccount() {\n    if (detectContractFeature(this.contractWrapper, FEATURE_ACCOUNT.name)) {\n      return new Account(this.contractWrapper);\n    }\n    return undefined;\n  }\n}\n\n/**\n * Handles publishing contracts (EXPERIMENTAL)\n * @internal\n */\nclass ContractPublisher extends RPCConnectionHandler {\n  constructor(network, options, storage) {\n    super(network, options);\n    this.storage = storage;\n    this.publisher = new ContractWrapper(network, getContractPublisherAddress(), ContractPublisherAbi, options, storage);\n  }\n  updateSignerOrProvider(network) {\n    super.updateSignerOrProvider(network);\n    this.publisher.updateSignerOrProvider(network);\n  }\n\n  /**\n   * @internal\n   * @param metadataUri\n   */\n  async extractConstructorParams(metadataUri) {\n    return extractConstructorParams(metadataUri, this.storage);\n  }\n\n  /**\n   * @internal\n   * @param predeployMetadataUri\n   */\n  async extractFunctions(predeployMetadataUri) {\n    return extractFunctions(predeployMetadataUri, this.storage);\n  }\n\n  /**\n   * @internal\n   * @param predeployUri\n   */\n  async fetchCompilerMetadataFromPredeployURI(predeployUri) {\n    return fetchPreDeployMetadata(predeployUri, this.storage);\n  }\n\n  /**\n   * @internal\n   * @param prepublishUri\n   * @param publisherAddress\n   */\n  async fetchPrePublishMetadata(prepublishUri, publisherAddress) {\n    const preDeployMetadataFetched = await fetchPreDeployMetadata(prepublishUri, this.storage);\n    const latestPublishedContract = publisherAddress ? await this.getLatest(publisherAddress, preDeployMetadataFetched.name) : undefined;\n    const latestPublishedContractMetadata = latestPublishedContract ? await this.fetchPublishedContractInfo(latestPublishedContract) : undefined;\n    return {\n      preDeployMetadata: preDeployMetadataFetched,\n      latestPublishedContractMetadata\n    };\n  }\n\n  /**\n   * @internal\n   * @param address\n   */\n  async fetchCompilerMetadataFromAddress(address) {\n    const resolvedAddress = await resolveAddress(address);\n    return fetchContractMetadataFromAddress(resolvedAddress, this.getProvider(), this.storage, this.options);\n  }\n\n  /**\n   * @internal\n   * Get the full information about a published contract\n   * @param contract\n   */\n  async fetchPublishedContractInfo(contract) {\n    return {\n      name: contract.id,\n      publishedTimestamp: contract.timestamp,\n      publishedMetadata: await this.fetchFullPublishMetadata(contract.metadataUri)\n    };\n  }\n\n  /**\n   * @internal\n   * @param publishedMetadataUri\n   */\n  async fetchFullPublishMetadata(publishedMetadataUri) {\n    return fetchExtendedReleaseMetadata(publishedMetadataUri, this.storage);\n  }\n\n  /**\n   * @internal\n   * // TODO expose a resolvePublishMetadata(contractAddress, chainId) that handles the dual chain case\n   * // TODO will be easy to do with the multichain pattern of 3.0\n   * @param compilerMetadataUri\n   */\n  async resolvePublishMetadataFromCompilerMetadata(compilerMetadataUri) {\n    const publishedMetadataUri = await this.publisher.read(\"getPublishedUriFromCompilerUri\", [compilerMetadataUri]);\n    if (publishedMetadataUri.length === 0) {\n      throw Error(`Could not resolve published metadata URI from ${compilerMetadataUri}`);\n    }\n    return await Promise.all(publishedMetadataUri.filter(uri => uri.length > 0).map(uri => this.fetchFullPublishMetadata(uri)));\n  }\n\n  /**\n   * @internal\n   * TODO clean this up (see method above, too)\n   */\n  async resolveContractUriFromAddress(address) {\n    const resolvedAddress = await resolveAddress(address);\n    const contractUri = await resolveContractUriFromAddress(resolvedAddress, this.getProvider());\n    invariant(contractUri, \"Could not resolve contract URI from address\");\n    return contractUri;\n  }\n\n  /**\n   * @internal\n   * @param address\n   */\n  async fetchContractSourcesFromAddress(address) {\n    const resolvedAddress = await resolveAddress(address);\n    const metadata = await this.fetchCompilerMetadataFromAddress(resolvedAddress);\n    return await fetchSourceFilesFromMetadata(metadata, this.storage);\n  }\n\n  /**\n   * @internal\n   * @param profileMetadata\n   */\n  updatePublisherProfile = /* @__PURE__ */buildTransactionFunction(async profileMetadata => {\n    const signer = this.getSigner();\n    invariant(signer, \"A signer is required\");\n    const publisher = await signer.getAddress();\n    const profileUri = await this.storage.upload(profileMetadata);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.publisher,\n      method: \"setPublisherProfileUri\",\n      args: [publisher, profileUri]\n    });\n  });\n\n  /**\n   * @internal\n   * @param publisherAddress\n   */\n  async getPublisherProfile(publisherAddress) {\n    const resolvedPublisherAddress = await resolveAddress(publisherAddress);\n    const profileUri = await this.publisher.read(\"getPublisherProfileUri\", [resolvedPublisherAddress]);\n    if (!profileUri || profileUri.length === 0) {\n      return {};\n    }\n    return ProfileSchemaOutput.parse(await this.storage.downloadJSON(profileUri));\n  }\n\n  /**\n   * @internal\n   * @param publisherAddress\n   */\n  async getAll(publisherAddress) {\n    const resolvedPublisherAddress = await resolveAddress(publisherAddress);\n    const data = await this.publisher.read(\"getAllPublishedContracts\", [resolvedPublisherAddress]);\n    // since we can fetch from multiple publisher contracts, just keep the latest one in the list\n    const map = data.reduce((acc, curr) => {\n      // replaces the previous contract with the latest one\n      acc[curr.contractId] = curr;\n      return acc;\n    }, {});\n    return Object.entries(map).map(_ref => {\n      let [, struct] = _ref;\n      return this.toPublishedContract(struct);\n    });\n  }\n\n  /**\n   * @internal\n   * @param publisherAddress\n   * @param contractId\n   */\n  async getAllVersions(publisherAddress, contractId) {\n    const resolvedPublisherAddress = await resolveAddress(publisherAddress);\n    const contractStructs = await this.publisher.read(\"getPublishedContractVersions\", [resolvedPublisherAddress, contractId]);\n    if (contractStructs.length === 0) {\n      throw Error(\"Not found\");\n    }\n    return contractStructs.map(d => this.toPublishedContract(d));\n  }\n  async getVersion(publisherAddress, contractId) {\n    let version = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"latest\";\n    const resolvedPublisherAddress = await resolveAddress(publisherAddress);\n    if (version === \"latest\") {\n      return this.getLatest(resolvedPublisherAddress, contractId);\n    }\n    const allVersions = await this.getAllVersions(resolvedPublisherAddress, contractId);\n    // get the metadata for each version\n    const versionMetadata = await Promise.all(allVersions.map(contract => this.fetchPublishedContractInfo(contract)));\n    // find the version that matches the version string\n    const versionMatch = versionMetadata.find(metadata => metadata.publishedMetadata.version === version);\n    invariant(versionMatch, \"Contract version not found\");\n    // match the version back to the contract based on the published timestamp\n    return allVersions.find(contract => contract.timestamp === versionMatch.publishedTimestamp);\n  }\n  async getLatest(publisherAddress, contractId) {\n    const resolvedPublisherAddress = await resolveAddress(publisherAddress);\n    const model = await this.publisher.read(\"getPublishedContract\", [resolvedPublisherAddress, contractId]);\n    if (model && model.publishMetadataUri) {\n      return this.toPublishedContract(model);\n    }\n    return undefined;\n  }\n  publish = /* @__PURE__ */buildTransactionFunction(async (predeployUri, extraMetadata) => {\n    const signer = this.getSigner();\n    invariant(signer, \"A signer is required\");\n    const publisher = await signer.getAddress();\n    const predeployMetadata = await fetchRawPredeployMetadata(predeployUri, this.storage);\n    const compilerMetadata = await fetchContractMetadata(predeployMetadata.metadataUri, this.storage);\n    const isPlugin = isFeatureEnabled(AbiSchema.parse(compilerMetadata.abi), \"PluginRouter\");\n    const isDynamic = isFeatureEnabled(AbiSchema.parse(compilerMetadata.abi), \"DynamicContract\");\n    extraMetadata.routerType = isPlugin ? \"plugin\" : isDynamic ? \"dynamic\" : \"none\";\n\n    // For a dynamic contract Router, try to fetch plugin/extension metadata\n    if (isDynamic || isPlugin) {\n      const defaultExtensions = extraMetadata.defaultExtensions;\n      if (defaultExtensions && defaultExtensions.length > 0) {\n        try {\n          const publishedExtensions = await Promise.all(defaultExtensions.map(e => {\n            return fetchPublishedContractFromPolygon(e.publisherAddress, e.extensionName, e.extensionVersion, this.storage, this.options.clientId, this.options.secretKey);\n          }));\n          const publishedExtensionUris = publishedExtensions.map(ext => ext.metadataUri);\n          const extensionABIs = (await Promise.all(publishedExtensionUris.map(async uri => {\n            return fetchAndCacheDeployMetadata(uri, this.storage);\n          }))).map(fetchedMetadata => fetchedMetadata.compilerMetadata.abi);\n          const composite = joinABIs([compilerMetadata.abi, ...extensionABIs]);\n          extraMetadata.compositeAbi = AbiSchema.parse(composite);\n        } catch {}\n      }\n    }\n\n    // ensure version is incremental\n    const latestContract = await this.getLatest(publisher, predeployMetadata.name);\n    if (latestContract && latestContract.metadataUri) {\n      const latestMetadata = await this.fetchPublishedContractInfo(latestContract);\n      const latestVersion = latestMetadata.publishedMetadata.version;\n      if (!isIncrementalVersion(latestVersion, extraMetadata.version)) {\n        throw Error(`Version ${extraMetadata.version} is not greater than ${latestVersion}`);\n      }\n    }\n    const fetchedBytecode = await (await this.storage.download(predeployMetadata.bytecodeUri)).text();\n    const bytecode = fetchedBytecode.startsWith(\"0x\") ? fetchedBytecode : `0x${fetchedBytecode}`;\n    const bytecodeHash = utils.solidityKeccak256([\"bytes\"], [bytecode]);\n    const contractId = predeployMetadata.name;\n    const fullMetadata = await FullPublishMetadataSchemaInput.parseAsync({\n      ...extraMetadata,\n      metadataUri: predeployMetadata.metadataUri,\n      bytecodeUri: predeployMetadata.bytecodeUri,\n      name: predeployMetadata.name,\n      analytics: predeployMetadata.analytics,\n      publisher\n    });\n    const fullMetadataUri = await this.storage.upload(fullMetadata);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.publisher,\n      method: \"publishContract\",\n      args: [publisher, contractId, fullMetadataUri, predeployMetadata.metadataUri, bytecodeHash, constants.AddressZero],\n      parse: receipt => {\n        const events = this.publisher.parseLogs(\"ContractPublished\", receipt.logs);\n        if (events.length < 1) {\n          throw new Error(\"No ContractPublished event found\");\n        }\n        const contract = events[0].args.publishedContract;\n        return {\n          receipt,\n          data: async () => this.toPublishedContract(contract)\n        };\n      }\n    });\n  });\n  unpublish = /* @__PURE__ */buildTransactionFunction(async (publisher, contractId) => {\n    const resolvedPublisher = await resolveAddress(publisher);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.publisher,\n      method: \"unpublishContract\",\n      args: [resolvedPublisher, contractId]\n    });\n  });\n  toPublishedContract(contractModel) {\n    return PublishedContractSchema.parse({\n      id: contractModel.contractId,\n      timestamp: contractModel.publishTimestamp,\n      metadataUri: contractModel.publishMetadataUri\n    });\n  }\n}\n\nexport { MintRequest721withQuantity as $, AbiTypeSchema as A, BYOCContractMetadataSchema as B, CustomContractInput as C, DeployTypeInput as D, ExtraPublishMetadataSchemaInput as E, FactoryDeploymentSchema as F, CommonPlatformFeeSchema as G, CommonTrustedForwarderSchema as H, CommonSymbolSchema as I, CurrencySchema as J, CurrencyValueSchema as K, BaseSignaturePayloadInput as L, Signature20PayloadInput as M, Signature20PayloadOutput as N, Signature721PayloadInput as O, PreDeployMetadata as P, Signature721PayloadOutput as Q, RouterTypeInput as R, StaticJsonRpcBatchProvider as S, Signature1155PayloadInput as T, Signature1155PayloadInputWithTokenId as U, Signature1155PayloadOutput as V, Signature721WithQuantityInput as W, Signature721WithQuantityOutput as X, MintRequest20 as Y, MintRequest721 as Z, MintRequest1155 as _, CustomContractOutput as a, prepareGaslessRequest as a$, GenericRequest as a0, MerkleSchema as a1, SnapshotEntryInput as a2, SnapshotInputSchema as a3, SnapshotEntryWithProofSchema as a4, SnapshotSchema as a5, SnapshotInfoSchema as a6, BigNumberSchema as a7, BigNumberishSchema as a8, BigNumberTransformSchema as a9, Erc721Supply as aA, Erc721Enumerable as aB, Erc721TieredDrop as aC, Erc721 as aD, Erc721WithQuantitySignatureMintable as aE, Erc721Burnable as aF, Erc1155BatchMintable as aG, Erc1155Burnable as aH, Erc1155Enumerable as aI, Erc1155LazyMintable as aJ, Erc1155Mintable as aK, Erc1155 as aL, Erc1155SignatureMintable as aM, MarketplaceV3DirectListings as aN, MarketplaceV3EnglishAuctions as aO, MarketplaceV3Offers as aP, GasCostEstimator as aQ, ContractEvents as aR, ContractInterceptor as aS, ContractPlatformFee as aT, ContractPublishedMetadata as aU, ContractOwner as aV, Transaction as aW, DeployTransaction as aX, defaultGaslessSendFunction as aY, biconomySendFunction as aZ, defenderSendFunction as a_, AddressSchema as aa, AddressOrEnsSchema as ab, RawDateSchema as ac, StartDateSchema as ad, EndDateSchema as ae, CallOverrideSchema as af, ContractEncoder as ag, ContractMetadata as ah, ContractRoles as ai, ContractRoyalty as aj, ContractPrimarySale as ak, DelayedReveal as al, DropClaimConditions as am, DropErc1155ClaimConditions as an, Erc20BatchMintable as ao, Erc20Burnable as ap, Erc20ClaimableWithConditions as aq, Erc20Droppable as ar, Erc20Mintable as as, Erc20SignatureMintable as at, Erc20 as au, Erc721BatchMintable as av, Erc721ClaimableWithConditions as aw, Erc721Claimable as ax, Erc721LazyMintable as ay, Erc721Mintable as az, CustomContractDeploy as b, resolveImplementation as b$, ContractAppURI as b0, Account as b1, AccountFactory as b2, SignerPermissionsSchema as b3, PermissionSnapshotSchema as b4, SignerPermissionRequest as b5, Status as b6, ClaimEligibility as b7, isNativeToken as b8, cleanCurrencyAddress as b9, AdminRoleMissingError as bA, AuctionHasNotEndedError as bB, ExtensionNotImplementedError as bC, TransactionError as bD, parseRevertReason as bE, includesErrorMessage as bF, createSnapshot as bG, ALL_ROLES as bH, getRoleHash as bI, fetchContractMetadataFromAddress as bJ, fetchAbiFromAddress as bK, getDefaultGasOverrides as bL, getDynamicFeeData as bM, getGasPrice as bN, getPolygonGasPriorityFee as bO, fetchContractMetadata as bP, hasMatchingAbi as bQ, matchesAbiFromBytecode as bR, extractConstructorParams as bS, extractFunctions as bT, extractCommentFromMetadata as bU, extractConstructorParamsFromAbi as bV, extractFunctionsFromAbi as bW, extractEventsFromAbi as bX, extractMinimalProxyImplementationAddress as bY, resolveContractUriFromAddress as bZ, resolveContractUriAndBytecode as b_, normalizePriceValue as ba, fetchCurrencyMetadata as bb, fetchCurrencyValue as bc, setErc20Allowance as bd, approveErc20Allowance as be, normalizeAmount as bf, toWei as bg, convertToReadableQuantity as bh, fetchSnapshotEntryForAddress as bi, NotFoundError as bj, InvalidAddressError as bk, MissingRoleError as bl, AssetNotFoundError as bm, UploadError as bn, FileNameMissingError as bo, DuplicateFileNameError as bp, NotEnoughTokensError as bq, MissingOwnerRoleError as br, QuantityAboveLimitError as bs, FetchError as bt, DuplicateLeafsError as bu, AuctionAlreadyStartedError as bv, FunctionDeprecatedError as bw, ListingNotFoundError as bx, WrongListingTypeError as by, RestrictedTransferError as bz, CustomContractSchema as c, getChainProvider as c$, extractIPFSHashFromBytecode as c0, fetchRawPredeployMetadata as c1, fetchPreDeployMetadata as c2, fetchExtendedReleaseMetadata as c3, detectFeatures as c4, detectFeaturesFromBytecode as c5, getAllDetectedFeatures as c6, getAllDetectedExtensionsFromBytecode as c7, constructAbiFromBytecode as c8, getAllDetectedExtensions as c9, getDeploymentInfo as cA, deployWithThrowawayDeployer as cB, computeDeploymentInfo as cC, encodeConstructorParamsForImplementation as cD, getCreate2FactoryDeploymentInfo as cE, THIRDWEB_DEPLOYER as cF, fetchPublishedContractFromPolygon as cG, fetchAndCacheDeployMetadata as cH, estimateGasForDeploy as cI, createTransactionBatches as cJ, resolveEns as cK, resolveAddress as cL, OZ_DEFENDER_FORWARDER_ADDRESS as cM, CONTRACT_ADDRESSES as cN, getContractAddressByChainId as cO, getContractPublisherAddress as cP, getMultichainRegistryAddress as cQ, ChainId as cR, setSupportedChains as cS, getSupportedChains as cT, InterfaceId_IERC721 as cU, InterfaceId_IERC1155 as cV, NATIVE_TOKEN_ADDRESS as cW, NATIVE_TOKENS as cX, getNativeTokenByChainId as cY, LINK_TOKEN_ADDRESS as cZ, EventType as c_, isFeatureEnabled as ca, isExtensionEnabled as cb, assertEnabled as cc, detectContractFeature as cd, hasFunction as ce, joinABIs as cf, toSemver as cg, isIncrementalVersion as ch, isDowngradeVersion as ci, fetchSourceFilesFromMetadata as cj, CREATE2_FACTORY_BYTECODE as ck, SIGNATURE as cl, COMMON_FACTORY as cm, GAS_LIMIT_FOR_DEPLOYER as cn, DEPLOYER_BYTECODE as co, DEPLOYER_ABI as cp, isContractDeployed as cq, isEIP155Enforced as cr, getCreate2FactoryAddress as cs, getSaltHash as ct, getInitBytecodeWithSalt as cu, computeDeploymentAddress as cv, computeEOAForwarderAddress as cw, computeForwarderAddress as cx, getKeylessTxn as cy, deployContractDeterministic as cz, AbiObjectSchema as d, SplitsContractSchema as d$, getChainIdFromNetwork as d0, getChainIdOrName as d1, isChainConfig as d2, getProviderFromRpcUrl as d3, getSignerAndProvider as d4, SUPPORTED_FEATURES as d5, EditionDropInitializer as d6, EditionInitializer as d7, MarketplaceInitializer as d8, MarketplaceV3Initializer as d9, getCompositePluginABI as dA, buildDeployTransactionFunction as dB, getProcessEnv as dC, DropErc721ContractSchema as dD, mapOffer as dE, fetchTokenMetadataForContract as dF, isTokenApprovedForTransfer as dG, validateNewListingParam as dH, handleTokenApproval as dI, isWinningBid as dJ, NFT_BASE_CONTRACT_ROLES as dK, DropErc1155ContractSchema as dL, TokenErc1155ContractSchema as dM, MARKETPLACE_CONTRACT_ROLES as dN, MarketplaceContractSchema as dO, FEATURE_DIRECT_LISTINGS as dP, FEATURE_ENGLISH_AUCTIONS as dQ, FEATURE_OFFERS as dR, MULTIWRAP_CONTRACT_ROLES as dS, MultiwrapContractSchema as dT, uploadOrExtractURI as dU, TokenErc721ContractSchema as dV, FEATURE_NFT_REVEALABLE as dW, FEATURE_PACK_VRF as dX, PACK_CONTRACT_ROLES as dY, PackContractSchema as dZ, ADMIN_ROLE as d_, MultiwrapInitializer as da, NFTCollectionInitializer as db, NFTDropInitializer as dc, PackInitializer as dd, SignatureDropInitializer as de, SplitInitializer as df, TokenDropInitializer as dg, TokenInitializer as dh, VoteInitializer as di, PREBUILT_CONTRACTS_MAP as dj, PREBUILT_CONTRACTS_APPURI_MAP as dk, CONTRACTS_MAP as dl, getContractTypeForRemoteName as dm, getContractName as dn, isProvider as dp, isSigner as dq, AddressZero as dr, extractFeatures as ds, CUSTOM_GAS_FOR_CHAIN as dt, RPCConnectionHandler as du, signTypedDataInternal as dv, ContractWrapper as dw, buildTransactionFunction as dx, ContractPublisher as dy, SmartContract as dz, AbiSchema as e, TOKEN_DROP_CONTRACT_ROLES as e0, DropErc20ContractSchema as e1, TokenErc20ContractSchema as e2, VoteContractSchema as e3, ChainIdToAddressSchema as f, CustomFactoryInput as g, DeploymentNetworkInput as h, ExtraPublishMetadataSchemaOutput as i, FullPublishMetadataSchemaInput as j, FullPublishMetadataSchemaOutput as k, ProfileSchemaInput as l, ProfileSchemaOutput as m, PublishedContractSchema as n, ContractInfoSchema as o, CompilerMetadataFetchedSchema as p, PreDeployMetadataFetchedSchema as q, ClaimConditionMetadataSchema as r, ClaimConditionInputSchema as s, ClaimConditionInputArray as t, PartialClaimConditionInputSchema as u, ClaimConditionOutputSchema as v, CommonContractSchema as w, CommonContractOutputSchema as x, CommonRoyaltySchema as y, CommonPrimarySaleSchema as z };\n"],"mappings":"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,OAAO,CAAC+M,GAAG,CAAC,CAAC,IAAI,CAACm6C,iBAAiB,CAAC,CAAC,EAAE,IAAI,CAACgB,kBAAkB,CAAC,CAAC,CAAC,CAAC;IACxH,OAAOhB,iBAAiB,CAAC5J,GAAG,CAAC4K,kBAAkB,CAAC;EAClD;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAIzF,eAAeA,CAAA,EAAG;IACpB,OAAOqC,aAAa,CAAC,IAAI,CAACkH,mBAAmB,EAAE9tC,+BAA+B,CAAC,CAACihC,UAAU;EAC5F;;EAEA;;EAEA;AACF;AACA;AACA;AACA;EACE,IAAIuO,UAAUA,CAAA,EAAG;IACf,OAAO5I,aAAa,CAAC,IAAI,CAAC+G,cAAc,EAAE7tC,uBAAuB,CAAC;EACpE;;EAEA;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAIiF,SAASA,CAAA,EAAG;IACd,OAAO6hC,aAAa,CAAC,IAAI,CAACS,iBAAiB,EAAE7mC,iCAAiC,CAAC;EACjF;;EAEA;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAIqoC,QAAQA,CAAA,EAAG;IACb,OAAOjC,aAAa,CAAC,IAAI,CAAC6G,YAAY,EAAE5E,QAAQ,EAAEhpC,sBAAsB,CAAC;EAC3E;;EAEA;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAI4vC,cAAcA,CAAA,EAAG;IACnB,OAAO7I,aAAa,CAAC,IAAI,CAACwH,oBAAoB,EAAEvtC,2BAA2B,CAAC;EAC9E;;EAEA;AACF;AACA;;EAEE;AACF;AACA;EACE,MAAMooC,gBAAgBA,CAACh3C,OAAO,EAAE;IAC9B,MAAMkgC,QAAQ,GAAG,MAAM,IAAI,CAACr4B,eAAe,CAAC2Q,IAAI,CAAC,UAAU,EAAE,CAACxY,OAAO,CAAC,CAAC;IACvE,IAAI,CAACkgC,QAAQ,EAAE;MACb,MAAM,IAAI33B,aAAa,CAAC,CAAC;IAC3B;IACA,OAAO03B,kBAAkB,CAACjgC,OAAO,EAAEkgC,QAAQ,EAAE,IAAI,CAACle,OAAO,CAAC;EAC5D;;EAEA;AACF;AACA;AACA;EACE,MAAM+0B,iBAAiBA,CAAA,EAAG;IACxB,IAAI9hC,WAAW,CAAC,mBAAmB,EAAE,IAAI,CAACpN,eAAe,CAAC,EAAE;MAC1D,IAAIkvC,iBAAiB,GAAG,MAAM,IAAI,CAAClvC,eAAe,CAAC2Q,IAAI,CAAC,mBAAmB,EAAE,EAAE,CAAC;MAChF;MACA,IAAIvD,WAAW,CAAC,cAAc,EAAE,IAAI,CAACpN,eAAe,CAAC,EAAE;QACrDkvC,iBAAiB,GAAGA,iBAAiB,CAAC5J,GAAG,CAAC,MAAM,IAAI,CAACtlC,eAAe,CAAC2Q,IAAI,CAAC,cAAc,EAAE,EAAE,CAAC,CAAC;MAChG;MACA,OAAOu+B,iBAAiB;IAC1B,CAAC,MAAM,IAAI9hC,WAAW,CAAC,aAAa,EAAE,IAAI,CAACpN,eAAe,CAAC,EAAE;MAC3D,OAAO,MAAM,IAAI,CAACA,eAAe,CAAC2Q,IAAI,CAAC,aAAa,EAAE,EAAE,CAAC;IAC3D,CAAC,MAAM;MACL,MAAM,IAAIpuB,KAAK,CAAC,yHAAyH,CAAC;IAC5I;EACF;EACAixD,sBAAsBA,CAAA,EAAG;IACvB,IAAIrmC,qBAAqB,CAAC,IAAI,CAACnN,eAAe,EAAE,cAAc,CAAC,IAAIoN,WAAW,CAAC,mBAAmB,EAAE,IAAI,CAACpN,eAAe,CAAC,EAAE;MACzH,OAAO,IAAI0vC,YAAY,CAAC,IAAI,EAAE,IAAI,CAAC1vC,eAAe,CAAC;IACrD;IACA,OAAOxa,SAAS;EAClB;EACAiuD,oBAAoBA,CAAA,EAAG;IACrB,IAAItmC,qBAAqB,CAAC,IAAI,CAACnN,eAAe,EAAE,gBAAgB,CAAC,EAAE;MACjE,OAAO,IAAIovC,cAAc,CAAC,IAAI,EAAE,IAAI,CAACpvC,eAAe,EAAE,IAAI,CAACma,OAAO,CAAC;IACrE;IACA,OAAO30B,SAAS;EAClB;EACAkuD,oBAAoBA,CAAA,EAAG;IACrB,IAAIvmC,qBAAqB,CAAC,IAAI,CAACnN,eAAe,EAAE,gBAAgB,CAAC,EAAE;MACjE,OAAO,IAAI8xC,cAAc,CAAC,IAAI,CAAC9xC,eAAe,CAAC;IACjD;IACA,OAAOxa,SAAS;EAClB;EACAouD,wBAAwBA,CAAA,EAAG;IACzB,IAAIzmC,qBAAqB,CAAC,IAAI,CAACnN,eAAe,EAAE,oBAAoB,CAAC,EAAE;MACrE,OAAO,IAAI8uC,kBAAkB,CAAC,IAAI,EAAE,IAAI,CAAC9uC,eAAe,EAAE,IAAI,CAACma,OAAO,CAAC;IACzE;IACA,OAAO30B,SAAS;EAClB;EACAsuD,sBAAsBA,CAAA,EAAG;IACvB,IAAI3mC,qBAAqB,CAAC,IAAI,CAACnN,eAAe,EAAE,kBAAkB,CAAC,EAAE;MACnE,OAAO,IAAIwwC,gBAAgB,CAAC,IAAI,EAAE,IAAI,CAACxwC,eAAe,EAAE,IAAI,CAACma,OAAO,CAAC;IACvE;IACA,OAAO30B,SAAS;EAClB;EACAuuD,6BAA6BA,CAAA,EAAG;IAC9B,IAAI5mC,qBAAqB,CAAC,IAAI,CAACnN,eAAe,EAAE,uBAAuB,CAAC,IAAImN,qBAAqB,CAAC,IAAI,CAACnN,eAAe,EAAE,uBAAuB,CAAC,EAAE;MAChJ,OAAO,IAAIkzC,mCAAmC,CAAC,IAAI,CAAClzC,eAAe,EAAE,IAAI,CAACma,OAAO,CAAC;IACpF;IACA,OAAO30B,SAAS;EAClB;EACAyuD,mCAAmCA,CAAA,EAAG;IACpC,IAAI9mC,qBAAqB,CAAC,IAAI,CAACnN,eAAe,EAAE,yBAAyB,CAAC,IAAImN,qBAAqB,CAAC,IAAI,CAACnN,eAAe,EAAE,yBAAyB,CAAC,IAAImN,qBAAqB,CAAC,IAAI,CAACnN,eAAe,EAAE,qBAAqB,CAAC,IAAImN,qBAAqB,CAAC,IAAI,CAACnN,eAAe,EAAE,qBAAqB,CAAC,EAAE;MAChS,OAAO,IAAIyuC,6BAA6B,CAAC,IAAI,EAAE,IAAI,CAACzuC,eAAe,EAAE,IAAI,CAACma,OAAO,CAAC;IACpF;IACA,OAAO30B,SAAS;EAClB;EACA2uD,qBAAqBA,CAAA,EAAG;IACtB,IAAIhnC,qBAAqB,CAAC,IAAI,CAACnN,eAAe,EAAE,mBAAmB,CAAC,EAAE;MACpE,OAAO,IAAI6uC,eAAe,CAAC,IAAI,EAAE,IAAI,CAAC7uC,eAAe,CAAC;IACxD;IACA,OAAOxa,SAAS;EAClB;EACA6uD,yBAAyBA,CAAA,EAAG;IAC1B,IAAIlnC,qBAAqB,CAAC,IAAI,CAACnN,eAAe,EAAE,iBAAiB,CAAC,EAAE;MAClE,OAAO,IAAIiyC,mBAAmB,CAAC,IAAI,EAAE,IAAI,CAACjyC,eAAe,CAAC;IAC5D;IACA,OAAOxa,SAAS;EAClB;EACA+uD,0BAA0BA,CAAA,EAAG;IAC3B,IAAIpnC,qBAAqB,CAAC,IAAI,CAACnN,eAAe,EAAE,sBAAsB,CAAC,EAAE;MACvE,OAAO,IAAI0yC,oBAAoB,CAAC,IAAI,CAAC1yC,eAAe,EAAE,IAAI,CAACma,OAAO,CAAC;IACrE;IACA,OAAO30B,SAAS;EAClB;EACAivD,uBAAuBA,CAAA,EAAG;IACxB,IAAItnC,qBAAqB,CAAC,IAAI,CAACnN,eAAe,EAAE,mBAAmB,CAAC,EAAE;MACpE,OAAO,IAAIuyC,iBAAiB,CAAC,IAAI,CAACvyC,eAAe,CAAC;IACpD;IACA,OAAOxa,SAAS;EAClB;EACAmvD,6BAA6BA,CAAA,EAAG;IAC9B,IAAIxnC,qBAAqB,CAAC,IAAI,CAACnN,eAAe,EAAE,yBAAyB,CAAC,EAAE;MAC1E,OAAO,IAAIyyC,uBAAuB,CAAC,IAAI,CAACzyC,eAAe,EAAE,IAAI,CAACma,OAAO,CAAC;IACxE;IACA,OAAO30B,SAAS;EAClB;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMowD,oBAAoB,CAAC;EACzB9oC,WAAW,GAAG/E,8BAA8B,CAACtf,IAAI;EACjDtD,WAAWA,CAAC8zC,OAAO,EAAEj5B,eAAe,EAAEma,OAAO,EAAE;IAC7C,IAAI,CAAC8e,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACj5B,eAAe,GAAGA,eAAe;IACtC,IAAI,CAACma,OAAO,GAAGA,OAAO;EACxB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE/iB,EAAE,GAAG,eAAegmB,wBAAwB,CAAC,OAAOhmB,EAAE,EAAEy+C,kBAAkB,KAAK;IAC7E,MAAMzc,SAAS,GAAGyc,kBAAkB,CAAC3vD,GAAG,CAAC5K,CAAC,IAAIA,CAAC,CAAC8a,QAAQ,CAAC;IACzD,MAAM0/C,QAAQ,GAAGD,kBAAkB,CAAC3vD,GAAG,CAAC5K,CAAC,IAAIA,CAAC,CAACs5D,MAAM,CAAC;IACtD,MAAMpb,IAAI,GAAG,MAAML,mBAAmB,CAACC,SAAS,EAAE,IAAI,CAACjf,OAAO,CAAC;IAC/D,MAAM+c,eAAe,GAAG,MAAM7Q,cAAc,CAACjvB,EAAE,CAAC;IAChD,MAAMi/B,eAAe,GAAG,IAAIt2B,eAAe,CAAC,IAAI,CAACC,eAAe,CAAC;IACjE,MAAMu2B,OAAO,GAAG,MAAMvuC,OAAO,CAAC+M,GAAG,CAACykC,IAAI,CAACtzC,GAAG,CAAC,OAAO8R,GAAG,EAAE/Q,KAAK,KAAKovC,eAAe,CAACp2B,MAAM,CAAC,QAAQ,EAAE,CAACi3B,eAAe,EAAEx6C,SAAS,CAACqxC,UAAU,EAAE/1B,GAAG,EAAE89C,QAAQ,CAAC7uD,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;IAClK,OAAOmpC,WAAW,CAACC,mBAAmB,CAAC;MACrCrwB,eAAe,EAAE,IAAI,CAACA,eAAe;MACrCvY,MAAM,EAAE,WAAW;MACnB0Y,IAAI,EAAE,CAACo2B,OAAO,CAAC;MACf7oC,KAAK,EAAEkkC,OAAO,IAAI;QAChB,MAAMmB,MAAM,GAAG,IAAI,CAAC/yB,eAAe,CAACg7B,SAAS,CAAC,cAAc,EAAEpJ,OAAO,CAACqJ,IAAI,CAAC;QAC3E,IAAIlI,MAAM,CAACzwC,MAAM,KAAK,CAAC,IAAIywC,MAAM,CAACzwC,MAAM,GAAG82C,SAAS,CAAC92C,MAAM,EAAE;UAC3D,MAAM,IAAIC,KAAK,CAAC,6CAA6C,CAAC;QAChE;QACA,OAAOwwC,MAAM,CAAC7sC,GAAG,CAAC6H,CAAC,IAAI;UACrB,MAAMpG,EAAE,GAAGoG,CAAC,CAACoS,IAAI,CAACquC,aAAa;UAC/B,OAAO;YACL7mD,EAAE;YACFiqC,OAAO;YACP7tC,IAAI,EAAEA,CAAA,KAAM,IAAI,CAACk1C,OAAO,CAAC/oC,GAAG,CAACvI,EAAE;UACjC,CAAC;QACH,CAAC,CAAC;MACJ;IACF,CAAC,CAAC;EACJ,CAAC,CAAC;AACJ;AAEA,MAAMouD,eAAe,CAAC;EACpBjpC,WAAW,GAAGzF,wBAAwB,CAAC5e,IAAI;EAC3CtD,WAAWA,CAAC6a,eAAe,EAAE;IAC3B,IAAI,CAACA,eAAe,GAAGA,eAAe;EACxC;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEmrC,MAAM,GAAG,eAAe/tB,wBAAwB,CAAC,OAAOjlB,OAAO,EAAE07B,MAAM,KAAK;IAC1E,MAAMmiB,OAAO,GAAG,MAAM,IAAI,CAACh2C,eAAe,CAACkwB,gBAAgB,CAAC,CAAC;IAC7D,OAAO,IAAI,CAAC/rC,IAAI,CAACg5B,OAAO,CAAC64B,OAAO,EAAE79C,OAAO,EAAE07B,MAAM,CAAC;EACpD,CAAC,CAAC;;EAEF;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE1vC,IAAI,GAAG,eAAei5B,wBAAwB,CAAC,OAAO44B,OAAO,EAAE79C,OAAO,EAAE07B,MAAM,KAAK;IACjF,OAAOzD,WAAW,CAACC,mBAAmB,CAAC;MACrCrwB,eAAe,EAAE,IAAI,CAACA,eAAe;MACrCvY,MAAM,EAAE,MAAM;MACd0Y,IAAI,EAAE,CAAC,MAAMkmB,cAAc,CAAC2vB,OAAO,CAAC,EAAE79C,OAAO,EAAE07B,MAAM;IACvD,CAAC,CAAC;EACJ,CAAC,CAAC;;EAEF;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE7tC,KAAK,GAAG,eAAeo3B,wBAAwB,CAAC,OAAOmyB,QAAQ,EAAE0G,OAAO,KAAK;IAC3E,MAAMD,OAAO,GAAG,MAAM,IAAI,CAACh2C,eAAe,CAACkwB,gBAAgB,CAAC,CAAC;IAC7D,OAAO,IAAI,CAACgmB,SAAS,CAAC/4B,OAAO,CAAC64B,OAAO,EAAEzG,QAAQ,EAAE0G,OAAO,CAAC;EAC3D,CAAC,CAAC;;EAEF;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,SAAS,GAAG,eAAe94B,wBAAwB,CAAC,OAAO44B,OAAO,EAAEzG,QAAQ,EAAE0G,OAAO,KAAK;IACxF,OAAO7lB,WAAW,CAACC,mBAAmB,CAAC;MACrCrwB,eAAe,EAAE,IAAI,CAACA,eAAe;MACrCvY,MAAM,EAAE,WAAW;MACnB0Y,IAAI,EAAE,CAAC,MAAMkmB,cAAc,CAAC2vB,OAAO,CAAC,EAAEzG,QAAQ,EAAE0G,OAAO;IACzD,CAAC,CAAC;EACJ,CAAC,CAAC;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAME,iBAAiB,CAAC;EACtBrpC,WAAW,GAAG7E,0BAA0B,CAACxf,IAAI;EAC7CtD,WAAWA,CAAC8zC,OAAO,EAAEj5B,eAAe,EAAE;IACpC,IAAI,CAACi5B,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACj5B,eAAe,GAAGA,eAAe;EACxC;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,MAAMjL,GAAGA,CAAC86C,WAAW,EAAE;IACrB,MAAM/7B,KAAK,GAAGv3B,SAAS,CAAC4H,IAAI,CAAC0rD,WAAW,EAAE/7B,KAAK,IAAI,CAAC,CAAC,CAACld,QAAQ,CAAC,CAAC;IAChE,MAAMs/B,KAAK,GAAG35C,SAAS,CAAC4H,IAAI,CAAC0rD,WAAW,EAAE3Z,KAAK,IAAIj6C,uBAAuB,CAAC,CAAC2a,QAAQ,CAAC,CAAC;IACtF,MAAMm5C,KAAK,GAAGl8C,IAAI,CAACtK,GAAG,CAAC,CAAC,MAAM,IAAI,CAAC0mD,UAAU,CAAC,CAAC,EAAEr5C,QAAQ,CAAC,CAAC,EAAEkd,KAAK,GAAGoiB,KAAK,CAAC;IAC3E,OAAO,MAAMluC,OAAO,CAAC+M,GAAG,CAAC,CAAC,GAAGwP,KAAK,CAACwrC,KAAK,GAAGj8B,KAAK,CAAC,CAACvJ,IAAI,CAAC,CAAC,CAAC,CAACrkB,GAAG,CAAC0N,CAAC,IAAI,IAAI,CAACqlC,OAAO,CAAC/oC,GAAG,CAAC,CAAC4jB,KAAK,GAAGlgB,CAAC,EAAEvP,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;EAC/G;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACE,MAAM4rD,UAAUA,CAAA,EAAG;IACjB,OAAO,MAAM,IAAI,CAACjwC,eAAe,CAAC2Q,IAAI,CAAC,mBAAmB,EAAE,EAAE,CAAC;EACjE;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACE,MAAM0/B,sBAAsBA,CAACl4C,OAAO,EAAE;IACpC,OAAO,MAAM,IAAI,CAAC6H,eAAe,CAAC2Q,IAAI,CAAC,aAAa,EAAE,CAACxY,OAAO,CAAC,CAAC;EAClE;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,MAAMw3C,KAAKA,CAAClG,aAAa,EAAE;IACzB,MAAM,CAACt4C,OAAO,EAAE4+C,KAAK,CAAC,GAAG,MAAM/nD,OAAO,CAAC+M,GAAG,CAAC,CAACsxB,cAAc,CAACojB,aAAa,KAAK,MAAM,IAAI,CAACzpC,eAAe,CAACkwB,gBAAgB,CAAC,CAAC,CAAC,CAAC,EAAE,IAAI,CAAClwB,eAAe,CAAC2Q,IAAI,CAAC,mBAAmB,EAAE,EAAE,CAAC,CAAC,CAAC;IAClL,MAAMylC,QAAQ,GAAG,MAAM,IAAI,CAACp2C,eAAe,CAAC2Q,IAAI,CAAC,gBAAgB,EAAE,CAACpM,KAAK,CAACwrC,KAAK,CAACn5C,QAAQ,CAAC,CAAC,CAAC,CAAC4N,IAAI,CAACrT,OAAO,CAAC,EAAEoT,KAAK,CAACpgB,IAAI,CAACogB,KAAK,CAACwrC,KAAK,CAACn5C,QAAQ,CAAC,CAAC,CAAC,CAAC2T,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;IACvJ,MAAM8rC,aAAa,GAAGD,QAAQ,CAAClwD,GAAG,CAAC,CAACpK,CAAC,EAAE8X,CAAC,KAAK;MAC3C,OAAO;QACLuE,OAAO,EAAEvE,CAAC;QACVu1C,OAAO,EAAErtD;MACX,CAAC;IACH,CAAC,CAAC,CAAC8R,MAAM,CAAC9R,CAAC,IAAIA,CAAC,CAACqtD,OAAO,CAAChmC,EAAE,CAAC,CAAC,CAAC,CAAC;IAC/B,MAAM2tC,IAAI,GAAG,CAAC,MAAM9oD,OAAO,CAAC+M,GAAG,CAACshD,aAAa,CAACnwD,GAAG,CAACq1B,IAAI,IAAI,IAAI,CAAC0d,OAAO,CAAC/oC,GAAG,CAACqrB,IAAI,CAACpjB,OAAO,CAAC9T,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE6B,GAAG,CAAC,CAACowD,eAAe,EAAErvD,KAAK,MAAM;MACtI,GAAGqvD,eAAe;MAClB3oB,KAAK,EAAEx8B,OAAO;MACdolD,aAAa,EAAEF,aAAa,CAACpvD,KAAK,CAAC,CAACkiD,OAAO,CAAC9kD,QAAQ,CAAC;IACvD,CAAC,CAAC,CAAC;IACH,OAAOysD,IAAI;EACb;AACF;AAEA,eAAe0F,eAAeA,CAACrlD,OAAO,EAAE5K,QAAQ,EAAE;EAChD,IAAI;IACF,MAAM4hC,QAAQ,GAAG,IAAIxrC,QAAQ,CAACwU,OAAO,EAAEzT,oBAAoB,EAAE6I,QAAQ,CAAC;IACtE,MAAM,CAACiS,IAAI,EAAEnW,OAAO,CAAC,GAAG,MAAM2F,OAAO,CAAC+M,GAAG,CAAC,CAACtY,KAAK,CAACg6D,YAAY,CAAC,MAAMtuB,QAAQ,CAACre,YAAY,CAAC,CAAC,CAAC,CAAC;IAAA,CAC5F9F,OAAO,CAAC,OAAO,EAAE,EAAE,CAAC,EAAE,MAAMmkB,QAAQ,CAACuuB,eAAe,CAAC,CAAC,CAAC,CAAC;IACzD,OAAO;MACLl+C,IAAI;MACJnW;IACF,CAAC;EACH,CAAC,CAAC,OAAO0L,CAAC,EAAE;IACV,OAAOvI,SAAS;EAClB;AACF;AAEA,MAAMmxD,mBAAmB,CAAC;EACxB7pC,WAAW,GAAGlF,gCAAgC,CAACnf,IAAI;;EAEnD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEEtD,WAAWA,CAAC8zC,OAAO,EAAEj5B,eAAe,EAAEma,OAAO,EAAE;IAC7C,IAAI,CAAC8e,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACj5B,eAAe,GAAGA,eAAe;IACtC,IAAI,CAACma,OAAO,GAAGA,OAAO;IACtB,IAAI,CAAC40B,QAAQ,GAAG,IAAI,CAAC6H,uBAAuB,CAAC,CAAC;EAChD;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE3H,QAAQ,GAAG,eAAe7xB,wBAAwB,CAAC,OAAOgc,SAAS,EAAElsC,OAAO,KAAK;IAC/E,MAAMqtC,eAAe,GAAG,MAAM,IAAI,CAACtB,OAAO,CAACiW,iBAAiB,CAAC,CAAC;IAC9D,MAAMlpD,KAAK,GAAG,MAAMmzC,mBAAmB,CAACC,SAAS,EAAE,IAAI,CAACjf,OAAO,EAAEogB,eAAe,CAAC3jC,QAAQ,CAAC,CAAC,EAAE1J,OAAO,CAAC;IACrG;IACA,MAAM4sC,OAAO,GAAG9zC,KAAK,CAAC,CAAC,CAAC,CAACy6B,SAAS,CAAC,CAAC,EAAEz6B,KAAK,CAAC,CAAC,CAAC,CAAC+zC,WAAW,CAAC,GAAG,CAAC,CAAC;IAChE,KAAK,IAAInmC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG5N,KAAK,CAAC1D,MAAM,EAAEsR,CAAC,EAAE,EAAE;MACrC,MAAMoE,GAAG,GAAGhS,KAAK,CAAC4N,CAAC,CAAC,CAAC6sB,SAAS,CAAC,CAAC,EAAEz6B,KAAK,CAAC4N,CAAC,CAAC,CAACmmC,WAAW,CAAC,GAAG,CAAC,CAAC;MAC5D,IAAID,OAAO,KAAK9hC,GAAG,EAAE;QACnB,MAAM,IAAIzV,KAAK,CAAE,0FAAyFu3C,OAAQ,cAAa9hC,GAAI,GAAE,CAAC;MACxI;IACF;IACA,MAAMtK,KAAK,GAAGkkC,OAAO,IAAI;MACvB,MAAM8c,KAAK,GAAG,IAAI,CAAC1uC,eAAe,CAACg7B,SAAS,CAAC,kBAAkB,EAAEpJ,OAAO,EAAEqJ,IAAI,CAAC;MAC/E,MAAMC,aAAa,GAAGwT,KAAK,CAAC,CAAC,CAAC,CAACvuC,IAAI,CAACg7B,YAAY;MAChD,MAAMC,WAAW,GAAGsT,KAAK,CAAC,CAAC,CAAC,CAACvuC,IAAI,CAACk7B,UAAU;MAC5C,MAAM9uB,OAAO,GAAG,EAAE;MAClB,KAAK,IAAI5kB,EAAE,GAAGuzC,aAAa,EAAEvzC,EAAE,CAAC2zC,GAAG,CAACF,WAAW,CAAC,EAAEzzC,EAAE,GAAGA,EAAE,CAACw2B,GAAG,CAAC,CAAC,CAAC,EAAE;QAChE5R,OAAO,CAACtkB,IAAI,CAAC;UACXN,EAAE;UACFiqC,OAAO;UACP7tC,IAAI,EAAEA,CAAA,KAAM,IAAI,CAACk1C,OAAO,CAACkW,gBAAgB,CAACxnD,EAAE;QAC9C,CAAC,CAAC;MACJ;MACA,OAAO4kB,OAAO;IAChB,CAAC;IACD,MAAMsqC,YAAY,GAAG,MAAML,eAAe,CAAC,IAAI,CAACx2C,eAAe,CAAC7O,OAAO,EAAE,IAAI,CAAC6O,eAAe,CAACquB,WAAW,CAAC,CAAC,CAAC;IAC5G,IAAI,IAAI,CAACyoB,2BAA2B,CAAC,IAAI,CAAC92C,eAAe,EAAE62C,YAAY,CAAC,EAAE;MACxE,OAAOzmB,WAAW,CAACC,mBAAmB,CAAC;QACrCrwB,eAAe,EAAE,IAAI,CAACA,eAAe;QACrCvY,MAAM,EAAE,UAAU;QAClB0Y,IAAI,EAAE,CAACna,KAAK,CAAC1D,MAAM,EAAG,GAAEw3C,OAAO,CAACrpC,QAAQ,CAAC,GAAG,CAAC,GAAGqpC,OAAO,GAAI,GAAEA,OAAQ,GAAG,EAAC,CAAC;QAC1EpsC;MACF,CAAC,CAAC;IACJ,CAAC,MAAM;MACL;MACA,OAAO0iC,WAAW,CAACC,mBAAmB,CAAC;QACrCrwB,eAAe,EAAE,IAAI,CAACA,eAAe;QACrCvY,MAAM,EAAE,UAAU;QAClB0Y,IAAI,EAAE,CAACna,KAAK,CAAC1D,MAAM,EAAG,GAAEw3C,OAAO,CAACrpC,QAAQ,CAAC,GAAG,CAAC,GAAGqpC,OAAO,GAAI,GAAEA,OAAQ,GAAG,EAAC,EAAEr9C,KAAK,CAACya,WAAW,CAAC,EAAE,CAAC,CAAC;QACjGxJ;MACF,CAAC,CAAC;IACJ;EACF,CAAC,CAAC;;EAEF;AACF;AACA;EACEkpD,uBAAuBA,CAAA,EAAG;IACxB,IAAIzpC,qBAAqB,CAAC,IAAI,CAACnN,eAAe,EAAE,mBAAmB,CAAC,EAAE;MACpE,OAAO,IAAIg6B,aAAa,CAAC,IAAI,CAACh6B,eAAe,EAAE,IAAI,CAACma,OAAO,EAAExS,0BAA0B,CAAClf,IAAI,EAAE,MAAM,IAAI,CAACwwC,OAAO,CAACiW,iBAAiB,CAAC,CAAC,CAAC;IACvI;IACA,OAAO1pD,SAAS;EAClB;EACAsxD,2BAA2BA,CAAC92C,eAAe,EAAEd,IAAI,EAAE;IACjD,OAAOA,IAAI,IAAIA,IAAI,CAAC1G,IAAI,KAAK,aAAa,IAAI0G,IAAI,CAAC7c,OAAO,GAAG,CAAC,IAAI,KAAK;EACzE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAM00D,eAAe,CAAC;EACpBjqC,WAAW,GAAG9E,wBAAwB,CAACvf,IAAI;;EAE3C;AACF;AACA;;EAEEtD,WAAWA,CAAC8zC,OAAO,EAAEj5B,eAAe,EAAEma,OAAO,EAAE;IAC7C,IAAI,CAAC8e,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACj5B,eAAe,GAAGA,eAAe;IACtC,IAAI,CAACma,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACn0B,KAAK,GAAG,IAAI,CAACgxD,0BAA0B,CAAC,CAAC;EAChD;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE5/C,EAAE,GAAG,eAAegmB,wBAAwB,CAAC,OAAOhmB,EAAE,EAAEy+C,kBAAkB,KAAK;IAC7E,MAAM54B,EAAE,GAAG,MAAM,IAAI,CAACwuB,kBAAkB,CAACr0C,EAAE,EAAEy+C,kBAAkB,CAAC;IAChE54B,EAAE,CAAC6T,QAAQ,CAACc,OAAO,IAAI;MACrB,MAAM8c,KAAK,GAAG,IAAI,CAAC1uC,eAAe,CAACg7B,SAAS,CAAC,gBAAgB,EAAEpJ,OAAO,EAAEqJ,IAAI,CAAC;MAC7E,IAAIyT,KAAK,CAACpsD,MAAM,KAAK,CAAC,EAAE;QACtB,MAAM,IAAIC,KAAK,CAAC,qCAAqC,CAAC;MACxD;MACA,MAAMoF,EAAE,GAAG+mD,KAAK,CAAC,CAAC,CAAC,CAACvuC,IAAI,CAACxY,EAAE;MAC3B,OAAO;QACLA,EAAE;QACFiqC,OAAO;QACP7tC,IAAI,EAAEA,CAAA,KAAM,IAAI,CAACk1C,OAAO,CAAC/oC,GAAG,CAACvI,EAAE,CAACtD,QAAQ,CAAC,CAAC;MAC5C,CAAC;IACH,CAAC,CAAC;IACF,OAAO44B,EAAE;EACX,CAAC,CAAC;;EAEF;AACF;AACA;EACE,MAAMwuB,kBAAkBA,CAACr0C,EAAE,EAAEy+C,kBAAkB,EAAE;IAC/C,MAAM79C,GAAG,GAAG,MAAMkhC,kBAAkB,CAAC2c,kBAAkB,CAACz/C,QAAQ,EAAE,IAAI,CAAC+jB,OAAO,CAAC;IAC/E,OAAOiW,WAAW,CAACC,mBAAmB,CAAC;MACrCrwB,eAAe,EAAE,IAAI,CAACA,eAAe;MACrCvY,MAAM,EAAE,QAAQ;MAChB0Y,IAAI,EAAE,CAAC,MAAMkmB,cAAc,CAACjvB,EAAE,CAAC,EAAE1a,SAAS,CAACqxC,UAAU,EAAE/1B,GAAG,EAAE69C,kBAAkB,CAACjB,MAAM;IACvF,CAAC,CAAC;EACJ;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEqC,kBAAkB,GAAG,eAAe75B,wBAAwB,CAAC,OAAOhmB,EAAE,EAAEe,OAAO,EAAE++C,gBAAgB,KAAK;IACpG,MAAM9gD,QAAQ,GAAG,MAAM,IAAI,CAAC6iC,OAAO,CAACkW,gBAAgB,CAACh3C,OAAO,CAAC;IAC7D,OAAOi4B,WAAW,CAACC,mBAAmB,CAAC;MACrCrwB,eAAe,EAAE,IAAI,CAACA,eAAe;MACrCvY,MAAM,EAAE,QAAQ;MAChB0Y,IAAI,EAAE,CAAC,MAAMkmB,cAAc,CAACjvB,EAAE,CAAC,EAAEe,OAAO,EAAE/B,QAAQ,CAAC4B,GAAG,EAAEk/C,gBAAgB,CAAC;MACzExpD,KAAK,EAAEkkC,OAAO,IAAI;QAChB,OAAO;UACLjqC,EAAE,EAAEpL,SAAS,CAAC4H,IAAI,CAACgU,OAAO,CAAC;UAC3By5B,OAAO;UACP7tC,IAAI,EAAEA,CAAA,KAAM,IAAI,CAACk1C,OAAO,CAAC/oC,GAAG,CAACiI,OAAO;QACtC,CAAC;MACH;IACF,CAAC,CAAC;EACJ,CAAC,CAAC;EACF6+C,0BAA0BA,CAAA,EAAG;IAC3B,IAAI7pC,qBAAqB,CAAC,IAAI,CAACnN,eAAe,EAAE,sBAAsB,CAAC,EAAE;MACvE,OAAO,IAAI41C,oBAAoB,CAAC,IAAI,CAAC3c,OAAO,EAAE,IAAI,CAACj5B,eAAe,EAAE,IAAI,CAACma,OAAO,CAAC;IACnF;EACF;AACF;;AAEA;AACA;AACA;AACA,MAAMg9B,mBAAmB,GAAG,eAAe,CAAC,MAAM76D,CAAC,CAAC8L,MAAM,CAAC;EACzD+I,OAAO,EAAEW,kBAAkB;EAC3B4F,QAAQ,EAAEzc,YAAY,CAAC8N,OAAO,CAAC,CAAC;AAClC,CAAC,CAAC,EAAE,CAAC;;AAEL;AACA;AACA;AACA,MAAMquD,kBAAkB,GAAG,eAAe,CAAC,MAAM96D,CAAC,CAACoH,KAAK,CAAC,CAACpH,CAAC,CAACgM,KAAK,CAAChM,CAAC,CAACqH,MAAM,CAAC,CAAC,CAAC,CAACM,SAAS,CAAC,MAAM6Q,OAAO,IAAI,MAAM9M,OAAO,CAAC+M,GAAG,CAACD,OAAO,CAAC5O,GAAG,CAACiL,OAAO,IAAIgmD,mBAAmB,CAACniD,UAAU,CAAC;EAC/K7D;AACF,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE7U,CAAC,CAACgM,KAAK,CAAC6uD,mBAAmB,CAAC,CAAC,CAAC,EAAE,CAAC;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAME,gBAAgB,CAAC;EACrBvqC,WAAW,GAAGpF,4BAA4B,CAACjf,IAAI;EAC/CtD,WAAWA,CAAC6a,eAAe,EAAE;IAC3B,IAAI,CAACA,eAAe,GAAGA,eAAe;EACxC;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,MAAMqqC,mBAAmBA,CAACD,kBAAkB,EAAEjyC,OAAO,EAAET,QAAQ,EAAExK,OAAO,EAAE;IACxE,IAAIghC,SAAS,GAAG,CAAC,CAAC;IAClB,IAAIhhC,OAAO,IAAIA,OAAO,CAAC0vC,aAAa,EAAE;MACpC1O,SAAS,GAAG,MAAMygB,kBAAkB,CAAC,IAAI,CAAC3uC,eAAe,EAAE9S,OAAO,CAAC0vC,aAAa,EAAEllC,QAAQ,EAAExK,OAAO,CAAC0H,eAAe,EAAE1H,OAAO,CAACm2C,mBAAmB,CAAC;IACnJ;IACA,OAAOjT,WAAW,CAACC,mBAAmB,CAAC;MACrCrwB,eAAe,EAAE,IAAI,CAACA,eAAe;MACrCvY,MAAM,EAAE,OAAO;MACf0Y,IAAI,EAAE,CAAC,MAAMkmB,cAAc,CAAC+jB,kBAAkB,CAAC,EAAEjyC,OAAO,EAAET,QAAQ,CAAC;MACnEw2B;IACF,CAAC,CAAC;EACJ;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE92B,EAAE,GAAG,eAAegmB,wBAAwB,CAAC,OAAOgtB,kBAAkB,EAAEjyC,OAAO,EAAET,QAAQ,EAAExK,OAAO,KAAK;IACrG,OAAO,MAAM,IAAI,CAACm9C,mBAAmB,CAACD,kBAAkB,EAAEjyC,OAAO,EAAET,QAAQ,EAAExK,OAAO,CAAC;EACvF,CAAC,CAAC;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMoqD,8BAA8B,CAAC;EACnCxqC,WAAW,GAAGvF,mCAAmC,CAAC9e,IAAI;EACtDtD,WAAWA,CAAC6a,eAAe,EAAEma,OAAO,EAAE;IACpC,IAAI,CAACna,eAAe,GAAGA,eAAe;IACtC,IAAI,CAACma,OAAO,GAAGA,OAAO;IACtB,MAAM/jB,QAAQ,GAAG,IAAIs+B,gBAAgB,CAAC,IAAI,CAAC10B,eAAe,EAAE5F,oBAAoB,EAAE,IAAI,CAAC+f,OAAO,CAAC;IAC/F,IAAI,CAACgtB,UAAU,GAAG,IAAImD,0BAA0B,CAACtqC,eAAe,EAAE5J,QAAQ,EAAE,IAAI,CAAC+jB,OAAO,CAAC;EAC3F;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE/iB,EAAE,GAAG,eAAegmB,wBAAwB,CAAC,OAAOgtB,kBAAkB,EAAEjyC,OAAO,EAAET,QAAQ,EAAExK,OAAO,KAAK;IACrG,OAAO,MAAM,IAAI,CAACi6C,UAAU,CAACkD,mBAAmB,CAACD,kBAAkB,EAAEjyC,OAAO,EAAET,QAAQ,EAAExK,OAAO,CAAC;EAClG,CAAC,CAAC;AACJ;;AAEA;AACA;AACA;AACA;AACA,MAAMqqD,wBAAwB,CAAC;EAC7BzqC,WAAW,GAAGhF,kCAAkC,CAACrf,IAAI;EACrDtD,WAAWA,CAAC6a,eAAe,EAAEma,OAAO,EAAE4b,KAAK,EAAE;IAC3C,IAAI,CAAC/1B,eAAe,GAAGA,eAAe;IACtC,IAAI,CAACma,OAAO,GAAGA,OAAO;IACtB,IAAI,CAAC4b,KAAK,GAAGA,KAAK;EACpB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE6V,IAAI,GAAG,eAAexuB,wBAAwB,CAAC,MAAMyuB,aAAa,IAAI;IACpE,MAAMC,WAAW,GAAGD,aAAa,CAAC3kD,OAAO;IACzC,MAAM+jB,SAAS,GAAG4gC,aAAa,CAAC5gC,SAAS;IACzC,MAAM7jB,OAAO,GAAG,MAAM,IAAI,CAAC2kD,0BAA0B,CAACD,WAAW,CAAC;IAClE,MAAM5d,SAAS,GAAG,MAAM,IAAI,CAACluB,eAAe,CAACmhC,gBAAgB,CAAC,CAAC;IAC/D;IACA,MAAMuK,iBAAiB,CAAC,IAAI,CAAC1rC,eAAe,EAAE5Y,OAAO,CAACw1C,aAAa,CAAC1e,GAAG,CAAC92B,OAAO,CAACsQ,QAAQ,CAAC,EAAEo0C,WAAW,CAACl3C,eAAe,EAAEs5B,SAAS,CAAC;IAClI,OAAOkC,WAAW,CAACC,mBAAmB,CAAC;MACrCrwB,eAAe,EAAE,IAAI,CAACA,eAAe;MACrCvY,MAAM,EAAE,mBAAmB;MAC3B0Y,IAAI,EAAE,CAAC/Y,OAAO,EAAE6jB,SAAS,CAAC;MAC1BijB,SAAS;MACTxgC,KAAK,EAAEkkC,OAAO,IAAI;QAChB,MAAMif,CAAC,GAAG,IAAI,CAAC7wC,eAAe,CAACg7B,SAAS,CAAC,2BAA2B,EAAEpJ,OAAO,CAACqJ,IAAI,CAAC;QACnF,IAAI4V,CAAC,CAACvuD,MAAM,KAAK,CAAC,EAAE;UAClB,MAAM,IAAIC,KAAK,CAAC,kCAAkC,CAAC;QACrD;QACA,MAAMoF,EAAE,GAAGkpD,CAAC,CAAC,CAAC,CAAC,CAAC1wC,IAAI,CAACquC,aAAa;QAClC,OAAO;UACL7mD,EAAE;UACFiqC;QACF,CAAC;MACH;IACF,CAAC,CAAC;EACJ,CAAC,CAAC;;EAEF;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEoa,SAAS,GAAG,eAAe5uB,wBAAwB,CAAC,MAAM6uB,cAAc,IAAI;IAC1E,MAAMC,gBAAgB,GAAG,MAAMlkD,OAAO,CAAC+M,GAAG,CAACk3C,cAAc,CAAC/lD,GAAG,CAAC,MAAM86B,CAAC,IAAI;MACvE,MAAM55B,OAAO,GAAG,MAAM,IAAI,CAAC2kD,0BAA0B,CAAC/qB,CAAC,CAAC95B,OAAO,CAAC;MAChE,MAAM+jB,SAAS,GAAG+V,CAAC,CAAC/V,SAAS;MAC7B,MAAMtW,KAAK,GAAGqsB,CAAC,CAAC95B,OAAO,CAACyN,KAAK;MAC7B,IAAIpY,SAAS,CAAC4H,IAAI,CAACwQ,KAAK,CAAC,CAACwO,EAAE,CAAC,CAAC,CAAC,EAAE;QAC/B,MAAM,IAAI5gB,KAAK,CAAC,uEAAuE,CAAC;MAC1F;MACA,OAAO;QACL6E,OAAO;QACP6jB;MACF,CAAC;IACH,CAAC,CAAC,CAAC;IACH,MAAMorB,eAAe,GAAG,IAAIt2B,eAAe,CAAC,IAAI,CAACC,eAAe,CAAC;IACjE,MAAMu2B,OAAO,GAAG2V,gBAAgB,CAAChmD,GAAG,CAACukC,CAAC,IAAI;MACxC,OAAO4L,eAAe,CAACp2B,MAAM,CAAC,mBAAmB,EAAE,CAACwqB,CAAC,CAACrjC,OAAO,EAAEqjC,CAAC,CAACxf,SAAS,CAAC,CAAC;IAC9E,CAAC,CAAC;IACF,IAAImC,WAAW,CAAC,WAAW,EAAE,IAAI,CAACpN,eAAe,CAAC,EAAE;MAClD,OAAOowB,WAAW,CAACC,mBAAmB,CAAC;QACrCrwB,eAAe,EAAE,IAAI,CAACA,eAAe;QACrCvY,MAAM,EAAE,WAAW;QACnB0Y,IAAI,EAAE,CAACo2B,OAAO,CAAC;QACf7oC,KAAK,EAAEkkC,OAAO,IAAI;UAChB,MAAMmB,MAAM,GAAG,IAAI,CAAC/yB,eAAe,CAACg7B,SAAS,CAAC,2BAA2B,EAAEpJ,OAAO,CAACqJ,IAAI,CAAC;UACxF,IAAIlI,MAAM,CAACzwC,MAAM,KAAK,CAAC,EAAE;YACvB,MAAM,IAAIC,KAAK,CAAC,kCAAkC,CAAC;UACrD;UACA,OAAOwwC,MAAM,CAAC7sC,GAAG,CAACqvB,GAAG,KAAK;YACxB5tB,EAAE,EAAE4tB,GAAG,CAACpV,IAAI,CAACquC,aAAa;YAC1B5c;UACF,CAAC,CAAC,CAAC;QACL;MACF,CAAC,CAAC;IACJ,CAAC,MAAM;MACL,MAAM,IAAIrvC,KAAK,CAAC,2CAA2C,CAAC;IAC9D;EACF,CAAC,CAAC;;EAEF;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,MAAMy0C,MAAMA,CAAC6U,aAAa,EAAE;IAC1B,MAAMC,WAAW,GAAGD,aAAa,CAAC3kD,OAAO;IACzC,MAAM+jB,SAAS,GAAG4gC,aAAa,CAAC5gC,SAAS;IACzC,MAAM7jB,OAAO,GAAG,MAAM,IAAI,CAAC2kD,0BAA0B,CAACD,WAAW,CAAC;IAClE,MAAMK,YAAY,GAAG,MAAM,IAAI,CAACnsC,eAAe,CAAC2Q,IAAI,CAAC,QAAQ,EAAE,CAACvpB,OAAO,EAAE6jB,SAAS,CAAC,CAAC;IACpF,OAAOkhC,YAAY,CAAC,CAAC,CAAC;EACxB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,MAAMC,QAAQA,CAACqF,aAAa,EAAE;IAC5B,MAAMvqD,OAAO,GAAG;MACd,GAAGuqD,aAAa;MAChBt5C,OAAO,EAAEzb,SAAS,CAACqxC;IACrB,CAAC;IACD,OAAO,IAAI,CAACypB,mBAAmB,CAACtwD,OAAO,CAAC;EAC1C;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,MAAMswD,mBAAmBA,CAA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A;EACE,IAAIsuD,YAAYA,CAAA,EAAG;IACjB,OAAOhqB,aAAa,CAAC,IAAI,CAACiqB,kBAAkB,CAAC,CAAC,EAAEtuD,oBAAoB,CAAC;EACvE;;EAEA;AACF;AACA;EACE,IAAIklB,KAAKA,CAAA,EAAG;IACV,OAAOmf,aAAa,CAAC,IAAI,CAACkqB,aAAa,CAAC,CAAC,EAAEluD,aAAa,CAAC;EAC3D;;EAEA;AACF;AACA;EACE,IAAI00B,KAAKA,CAAA,EAAG;IACV,OAAOsP,aAAa,CAAC,IAAI,CAACmqB,WAAW,CAAC,CAAC,EAAEpxD,aAAa,CAAC;EACzD;;EAEA;AACF;AACA;EACE,IAAIkzB,MAAMA,CAAA,EAAG;IACX,OAAO+T,aAAa,CAAC,IAAI,CAACoqB,YAAY,CAAC,CAAC,EAAEhwD,WAAW,CAAC;EACxD;;EAEA;AACF;AACA;EACE,IAAI+xB,OAAOA,CAAA,EAAG;IACZ,OAAO6T,aAAa,CAAC,IAAI,CAACqqB,aAAa,CAAC,CAAC,EAAE/uD,eAAe,CAAC;EAC7D;;EAEA;AACF;AACA;EACE,IAAIgvD,GAAGA,CAAA,EAAG;IACR,OAAOtqB,aAAa,CAAC,IAAI,CAACuqB,SAAS,CAAC,CAAC,EAAExuD,cAAc,CAAC;EACxD;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAIyuD,cAAcA,CAAA,EAAG;IACnB,OAAOxqB,aAAa,CAAC,IAAI,CAACyqB,oBAAoB,CAAC,CAAC,EAAEpuD,uBAAuB,CAAC;EAC5E;EACA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC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"},"metadata":{},"sourceType":"module","externalDependencies":[]}