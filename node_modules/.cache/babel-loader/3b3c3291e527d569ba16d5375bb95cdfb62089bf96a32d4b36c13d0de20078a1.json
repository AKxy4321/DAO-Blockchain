{"ast":null,"code":"import { _ as _classPrivateMethodInitSpec, a as _classPrivateMethodGet } from '../../../../dist/classPrivateMethodGet-ea199cc3.browser.esm.js';\nimport { _ as _defineProperty } from '../../../../dist/defineProperty-c8ecdc07.browser.esm.js';\nimport { _ as _classPrivateFieldInitSpec, a as _classPrivateFieldSet, b as _classPrivateFieldGet } from '../../../../dist/classPrivateFieldSet-a5db7c83.browser.esm.js';\nimport { w as walletIds } from '../../../../dist/walletIds-a64268ca.browser.esm.js';\nimport { a as AbstractClientWallet, c as createAsyncLocalStorage } from '../../../../dist/base-402f7b12.browser.esm.js';\nimport { defaultChains, Ethereum } from '@thirdweb-dev/chains';\nimport { utils, Wallet } from 'ethers';\nimport '../../abstract/dist/thirdweb-dev-wallets-evm-wallets-abstract.browser.esm.js';\nimport 'eventemitter3';\nimport '@thirdweb-dev/sdk';\n\n// eslint-disable-next-line @typescript-eslint/ban-types\n\nconst STORAGE_KEY_WALLET_DATA = \"localWalletData\";\nvar _storage2 = /*#__PURE__*/new WeakMap();\nvar _saveData = /*#__PURE__*/new WeakSet();\nclass LocalWallet extends AbstractClientWallet {\n  get walletName() {\n    return \"Local Wallet\";\n  }\n  constructor(options) {\n    super(LocalWallet.id, options);\n    /**\n     * store the wallet data to storage\n     */\n    _classPrivateMethodInitSpec(this, _saveData);\n    _classPrivateFieldInitSpec(this, _storage2, {\n      writable: true,\n      value: void 0\n    });\n    this.options = options || {};\n    _classPrivateFieldSet(this, _storage2, options?.storage || createAsyncLocalStorage(walletIds.localWallet));\n  }\n  async getConnector() {\n    if (!this.connector) {\n      const {\n        LocalWalletConnector: LocalWalletConnector\n      } = await import('../../../connectors/local-wallet/dist/thirdweb-dev-wallets-evm-connectors-local-wallet.browser.esm.js');\n      if (!this.ethersWallet) {\n        throw new Error(\"wallet is not initialized\");\n      }\n      const defaults = this.options.chain ? [...defaultChains, this.options.chain] : defaultChains;\n      this.connector = new LocalWalletConnector({\n        chain: this.options.chain || Ethereum,\n        ethersWallet: this.ethersWallet,\n        chains: this.options.chains || defaults,\n        clientId: this.options.clientId,\n        secretKey: this.options.secretKey\n      });\n    }\n    return this.connector;\n  }\n\n  /**\n   * load saved wallet data from storage or generate a new one and save it.\n   */\n  async loadOrCreate(options) {\n    if (await this.getSavedData(options.storage)) {\n      await this.load(options);\n    } else {\n      await this.generate();\n      await this.save(options);\n    }\n  }\n\n  /**\n   * creates a new random wallet\n   * @returns the address of the newly created wallet\n   */\n  async generate() {\n    if (this.ethersWallet) {\n      throw new Error(\"wallet is already initialized\");\n    }\n    const random = utils.randomBytes(32);\n    this.ethersWallet = new Wallet(random);\n    return this.ethersWallet.address;\n  }\n\n  /**\n   * create local wallet from an \"encryptedJson\", \"privateKey\" or \"mnemonic\"\n   * @returns\n   */\n  async import(options) {\n    if (this.ethersWallet) {\n      throw new Error(\"wallet is already initialized\");\n    }\n    if (\"encryptedJson\" in options) {\n      this.ethersWallet = await Wallet.fromEncryptedJson(options.encryptedJson, options.password);\n      return this.ethersWallet.address;\n    }\n    if (\"privateKey\" in options) {\n      if (!options.encryption && !isValidPrivateKey(options.privateKey)) {\n        throw new Error(\"invalid private key\");\n      }\n      const privateKey = await getDecryptor(options.encryption)(options.privateKey);\n      if (options.encryption && (privateKey === \"\" || !isValidPrivateKey(privateKey))) {\n        throw new Error(\"invalid password\");\n      }\n      this.ethersWallet = new Wallet(privateKey);\n      return this.ethersWallet.address;\n    }\n    if (\"mnemonic\" in options) {\n      if (!options.encryption && !utils.isValidMnemonic(options.mnemonic)) {\n        throw new Error(\"invalid mnemonic\");\n      }\n      const mnemonic = await getDecryptor(options.encryption)(options.mnemonic);\n      if (options.encryption && (mnemonic === \"\" || !utils.isValidMnemonic(mnemonic))) {\n        throw new Error(\"invalid password\");\n      }\n      this.ethersWallet = Wallet.fromMnemonic(mnemonic);\n      return this.ethersWallet.address;\n    }\n    throw new Error(\"invalid import strategy\");\n  }\n\n  /**\n   * initialize the wallet from saved data on storage\n   * @param password - password used for encrypting the wallet\n   */\n  async load(options) {\n    if (this.ethersWallet) {\n      throw new Error(\"wallet is already initialized\");\n    }\n    const walletData = await this.getSavedData(options.storage);\n    if (!walletData) {\n      throw new Error(\"No Saved wallet found in storage\");\n    }\n\n    // strategy mismatch\n    if (walletData.strategy !== options.strategy) {\n      throw new Error(`Saved wallet data is not ${options.strategy}, it is ${walletData.strategy}`);\n    }\n    if (options.strategy === \"encryptedJson\") {\n      return this.import({\n        encryptedJson: walletData.data,\n        password: options.password\n      });\n    }\n\n    // encryption mismatch\n    if (walletData.isEncrypted && !options.encryption) {\n      throw new Error(\"Saved wallet data is encrypted, but no password is provided\");\n    }\n    if (!walletData.isEncrypted && options.encryption) {\n      throw new Error(\"Saved wallet data is not encrypted, but encryption config is provided\");\n    }\n    if (options.strategy === \"privateKey\") {\n      return this.import({\n        privateKey: walletData.data,\n        encryption: options.encryption\n      });\n    }\n    if (options.strategy === \"mnemonic\") {\n      return this.import({\n        mnemonic: walletData.data,\n        encryption: options.encryption\n      });\n    }\n    throw new Error(\"invalid load strategy\");\n  }\n\n  /**\n   * Save the wallet data to storage\n   */\n  async save(options) {\n    const wallet = this.ethersWallet;\n    if (!wallet) {\n      throw new Error(\"Wallet is not initialized\");\n    }\n    if (options.strategy === \"encryptedJson\") {\n      const encryptedData = await wallet.encrypt(options.password, {\n        scrypt: {\n          N: 1 << 32\n        }\n      });\n      await _classPrivateMethodGet(this, _saveData, _saveData2).call(this, {\n        address: wallet.address,\n        data: encryptedData,\n        strategy: \"encryptedJson\",\n        isEncrypted: true\n      }, options.storage);\n    }\n    if (options.strategy === \"privateKey\") {\n      const privateKey = await getEncryptor(options.encryption)(wallet.privateKey);\n      await _classPrivateMethodGet(this, _saveData, _saveData2).call(this, {\n        address: wallet.address,\n        data: privateKey,\n        strategy: \"privateKey\",\n        isEncrypted: !!options.encryption\n      }, options.storage);\n    }\n    if (options.strategy === \"mnemonic\") {\n      if (!wallet.mnemonic) {\n        throw new Error(\"mnemonic can not be computed if wallet is created from a private key or generated using generate()\");\n      }\n      const mnemonic = await getEncryptor(options.encryption)(wallet.mnemonic.phrase);\n      await _classPrivateMethodGet(this, _saveData, _saveData2).call(this, {\n        address: wallet.address,\n        data: mnemonic,\n        strategy: \"mnemonic\",\n        isEncrypted: !!options.encryption\n      }, options.storage);\n    }\n  }\n\n  /**\n   * @returns true if initialized wallet's data is saved in storage\n   */\n  async isSaved() {\n    try {\n      const data = await this.getSavedData();\n      const address = await this.getAddress();\n      if (data?.address === address) {\n        return true;\n      }\n      return false;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  /**\n   * deletes the saved wallet data from storage\n   */\n  async deleteSaved() {\n    await _classPrivateFieldGet(this, _storage2).removeItem(STORAGE_KEY_WALLET_DATA);\n  }\n\n  /**\n   * encrypts the wallet with given password and returns the encrypted wallet\n   * @param password - password for encrypting the wallet data\n   */\n  async export(options) {\n    const wallet = this.ethersWallet;\n    if (!wallet) {\n      throw new Error(\"Wallet is not initialized\");\n    }\n    if (options.strategy === \"encryptedJson\") {\n      return wallet.encrypt(options.password, {\n        scrypt: {\n          N: 1 << 32\n        }\n      });\n    }\n    if (options.strategy === \"privateKey\") {\n      return getEncryptor(options.encryption)(wallet.privateKey);\n    }\n    if (options.strategy === \"mnemonic\") {\n      if (!wallet.mnemonic) {\n        throw new Error(\"mnemonic can not be computed if wallet is created from a private key or generated using generate()\");\n      }\n      return getEncryptor(options.encryption)(wallet.mnemonic.phrase);\n    }\n    throw new Error(\"Invalid export strategy\");\n  }\n\n  /**\n   * Get the saved wallet data from storage\n   */\n  async getSavedData(storage) {\n    const _storage = storage || _classPrivateFieldGet(this, _storage2);\n    try {\n      const savedDataStr = await _storage.getItem(STORAGE_KEY_WALLET_DATA);\n      if (!savedDataStr) {\n        return null;\n      }\n      const savedData = JSON.parse(savedDataStr);\n      if (!savedData) {\n        return null;\n      }\n      return savedData;\n    } catch (e) {\n      return null;\n    }\n  }\n  async disconnect() {\n    await super.disconnect();\n    this.ethersWallet = undefined;\n  }\n}\nasync function _saveData2(data, storage) {\n  const _storage = storage || _classPrivateFieldGet(this, _storage2);\n  await _storage.setItem(STORAGE_KEY_WALLET_DATA, JSON.stringify(data));\n}\n_defineProperty(LocalWallet, \"id\", walletIds.localWallet);\n_defineProperty(LocalWallet, \"meta\", {\n  name: \"Local Wallet\",\n  iconURL: \"ipfs://QmbQzSNGvmNYZzem9jZRuYeLe9K2W4pqbdnVUp7Y6edQ8Y/local-wallet.svg\"\n}); // omit the mnemonic strategy option from LoadOptions\nasync function defaultEncrypt(message, password) {\n  const cryptoJS = (await import('crypto-js')).default;\n  return cryptoJS.AES.encrypt(message, password).toString();\n}\nasync function defaultDecrypt(message, password) {\n  const cryptoJS = (await import('crypto-js')).default;\n  return cryptoJS.AES.decrypt(message, password).toString(cryptoJS.enc.Utf8);\n}\n\n/**\n * if encryption object is provided\n *  - return the encryption.decrypt function if given, else return the default decrypt function\n * if encryption object is not provided\n * - return a noop function\n * @returns\n */\nfunction getDecryptor(encryption) {\n  const noop = async msg => msg;\n  return encryption ? msg => (encryption.decrypt || defaultDecrypt)(msg, encryption.password) : noop;\n}\n\n/**\n * if encryption object is provided\n *  - return the encryption.encrypt function if given, else return the default encrypt function\n * if encryption object is not provided\n * - return a noop function\n * @returns\n */\nfunction getEncryptor(encryption) {\n  const noop = async msg => msg;\n  return encryption ? msg => (encryption.encrypt || defaultEncrypt)(msg, encryption.password) : noop;\n}\nfunction isValidPrivateKey(value) {\n  return !!value.match(/^(0x)?[0-9a-f]{64}$/i);\n}\nexport { LocalWallet, isValidPrivateKey };","map":{"version":3,"names":["_","_classPrivateMethodInitSpec","a","_classPrivateMethodGet","_defineProperty","_classPrivateFieldInitSpec","_classPrivateFieldSet","b","_classPrivateFieldGet","w","walletIds","AbstractClientWallet","c","createAsyncLocalStorage","defaultChains","Ethereum","utils","Wallet","STORAGE_KEY_WALLET_DATA","_storage2","WeakMap","_saveData","WeakSet","LocalWallet","walletName","constructor","options","id","writable","value","storage","localWallet","getConnector","connector","LocalWalletConnector","ethersWallet","Error","defaults","chain","chains","clientId","secretKey","loadOrCreate","getSavedData","load","generate","save","random","randomBytes","address","import","fromEncryptedJson","encryptedJson","password","encryption","isValidPrivateKey","privateKey","getDecryptor","isValidMnemonic","mnemonic","fromMnemonic","walletData","strategy","data","isEncrypted","wallet","encryptedData","encrypt","scrypt","N","_saveData2","call","getEncryptor","phrase","isSaved","getAddress","e","deleteSaved","removeItem","export","_storage","savedDataStr","getItem","savedData","JSON","parse","disconnect","undefined","setItem","stringify","name","iconURL","defaultEncrypt","message","cryptoJS","default","AES","toString","defaultDecrypt","decrypt","enc","Utf8","noop","msg","match"],"sources":["C:/Misc/Documents/Career/FinTech/BlockChain/FrontEnd/buildspace-dao-starter/node_modules/@thirdweb-dev/react/node_modules/@thirdweb-dev/wallets/evm/wallets/local-wallet/dist/thirdweb-dev-wallets-evm-wallets-local-wallet.browser.esm.js"],"sourcesContent":["import { _ as _classPrivateMethodInitSpec, a as _classPrivateMethodGet } from '../../../../dist/classPrivateMethodGet-ea199cc3.browser.esm.js';\nimport { _ as _defineProperty } from '../../../../dist/defineProperty-c8ecdc07.browser.esm.js';\nimport { _ as _classPrivateFieldInitSpec, a as _classPrivateFieldSet, b as _classPrivateFieldGet } from '../../../../dist/classPrivateFieldSet-a5db7c83.browser.esm.js';\nimport { w as walletIds } from '../../../../dist/walletIds-a64268ca.browser.esm.js';\nimport { a as AbstractClientWallet, c as createAsyncLocalStorage } from '../../../../dist/base-402f7b12.browser.esm.js';\nimport { defaultChains, Ethereum } from '@thirdweb-dev/chains';\nimport { utils, Wallet } from 'ethers';\nimport '../../abstract/dist/thirdweb-dev-wallets-evm-wallets-abstract.browser.esm.js';\nimport 'eventemitter3';\nimport '@thirdweb-dev/sdk';\n\n// eslint-disable-next-line @typescript-eslint/ban-types\n\nconst STORAGE_KEY_WALLET_DATA = \"localWalletData\";\nvar _storage2 = /*#__PURE__*/new WeakMap();\nvar _saveData = /*#__PURE__*/new WeakSet();\nclass LocalWallet extends AbstractClientWallet {\n  get walletName() {\n    return \"Local Wallet\";\n  }\n  constructor(options) {\n    super(LocalWallet.id, options);\n    /**\n     * store the wallet data to storage\n     */\n    _classPrivateMethodInitSpec(this, _saveData);\n    _classPrivateFieldInitSpec(this, _storage2, {\n      writable: true,\n      value: void 0\n    });\n    this.options = options || {};\n    _classPrivateFieldSet(this, _storage2, options?.storage || createAsyncLocalStorage(walletIds.localWallet));\n  }\n  async getConnector() {\n    if (!this.connector) {\n      const {\n        LocalWalletConnector: LocalWalletConnector\n      } = await import('../../../connectors/local-wallet/dist/thirdweb-dev-wallets-evm-connectors-local-wallet.browser.esm.js');\n      if (!this.ethersWallet) {\n        throw new Error(\"wallet is not initialized\");\n      }\n      const defaults = this.options.chain ? [...defaultChains, this.options.chain] : defaultChains;\n      this.connector = new LocalWalletConnector({\n        chain: this.options.chain || Ethereum,\n        ethersWallet: this.ethersWallet,\n        chains: this.options.chains || defaults,\n        clientId: this.options.clientId,\n        secretKey: this.options.secretKey\n      });\n    }\n    return this.connector;\n  }\n\n  /**\n   * load saved wallet data from storage or generate a new one and save it.\n   */\n  async loadOrCreate(options) {\n    if (await this.getSavedData(options.storage)) {\n      await this.load(options);\n    } else {\n      await this.generate();\n      await this.save(options);\n    }\n  }\n\n  /**\n   * creates a new random wallet\n   * @returns the address of the newly created wallet\n   */\n  async generate() {\n    if (this.ethersWallet) {\n      throw new Error(\"wallet is already initialized\");\n    }\n    const random = utils.randomBytes(32);\n    this.ethersWallet = new Wallet(random);\n    return this.ethersWallet.address;\n  }\n\n  /**\n   * create local wallet from an \"encryptedJson\", \"privateKey\" or \"mnemonic\"\n   * @returns\n   */\n  async import(options) {\n    if (this.ethersWallet) {\n      throw new Error(\"wallet is already initialized\");\n    }\n    if (\"encryptedJson\" in options) {\n      this.ethersWallet = await Wallet.fromEncryptedJson(options.encryptedJson, options.password);\n      return this.ethersWallet.address;\n    }\n    if (\"privateKey\" in options) {\n      if (!options.encryption && !isValidPrivateKey(options.privateKey)) {\n        throw new Error(\"invalid private key\");\n      }\n      const privateKey = await getDecryptor(options.encryption)(options.privateKey);\n      if (options.encryption && (privateKey === \"\" || !isValidPrivateKey(privateKey))) {\n        throw new Error(\"invalid password\");\n      }\n      this.ethersWallet = new Wallet(privateKey);\n      return this.ethersWallet.address;\n    }\n    if (\"mnemonic\" in options) {\n      if (!options.encryption && !utils.isValidMnemonic(options.mnemonic)) {\n        throw new Error(\"invalid mnemonic\");\n      }\n      const mnemonic = await getDecryptor(options.encryption)(options.mnemonic);\n      if (options.encryption && (mnemonic === \"\" || !utils.isValidMnemonic(mnemonic))) {\n        throw new Error(\"invalid password\");\n      }\n      this.ethersWallet = Wallet.fromMnemonic(mnemonic);\n      return this.ethersWallet.address;\n    }\n    throw new Error(\"invalid import strategy\");\n  }\n\n  /**\n   * initialize the wallet from saved data on storage\n   * @param password - password used for encrypting the wallet\n   */\n  async load(options) {\n    if (this.ethersWallet) {\n      throw new Error(\"wallet is already initialized\");\n    }\n    const walletData = await this.getSavedData(options.storage);\n    if (!walletData) {\n      throw new Error(\"No Saved wallet found in storage\");\n    }\n\n    // strategy mismatch\n    if (walletData.strategy !== options.strategy) {\n      throw new Error(`Saved wallet data is not ${options.strategy}, it is ${walletData.strategy}`);\n    }\n    if (options.strategy === \"encryptedJson\") {\n      return this.import({\n        encryptedJson: walletData.data,\n        password: options.password\n      });\n    }\n\n    // encryption mismatch\n    if (walletData.isEncrypted && !options.encryption) {\n      throw new Error(\"Saved wallet data is encrypted, but no password is provided\");\n    }\n    if (!walletData.isEncrypted && options.encryption) {\n      throw new Error(\"Saved wallet data is not encrypted, but encryption config is provided\");\n    }\n    if (options.strategy === \"privateKey\") {\n      return this.import({\n        privateKey: walletData.data,\n        encryption: options.encryption\n      });\n    }\n    if (options.strategy === \"mnemonic\") {\n      return this.import({\n        mnemonic: walletData.data,\n        encryption: options.encryption\n      });\n    }\n    throw new Error(\"invalid load strategy\");\n  }\n\n  /**\n   * Save the wallet data to storage\n   */\n  async save(options) {\n    const wallet = this.ethersWallet;\n    if (!wallet) {\n      throw new Error(\"Wallet is not initialized\");\n    }\n    if (options.strategy === \"encryptedJson\") {\n      const encryptedData = await wallet.encrypt(options.password, {\n        scrypt: {\n          N: 1 << 32\n        }\n      });\n      await _classPrivateMethodGet(this, _saveData, _saveData2).call(this, {\n        address: wallet.address,\n        data: encryptedData,\n        strategy: \"encryptedJson\",\n        isEncrypted: true\n      }, options.storage);\n    }\n    if (options.strategy === \"privateKey\") {\n      const privateKey = await getEncryptor(options.encryption)(wallet.privateKey);\n      await _classPrivateMethodGet(this, _saveData, _saveData2).call(this, {\n        address: wallet.address,\n        data: privateKey,\n        strategy: \"privateKey\",\n        isEncrypted: !!options.encryption\n      }, options.storage);\n    }\n    if (options.strategy === \"mnemonic\") {\n      if (!wallet.mnemonic) {\n        throw new Error(\"mnemonic can not be computed if wallet is created from a private key or generated using generate()\");\n      }\n      const mnemonic = await getEncryptor(options.encryption)(wallet.mnemonic.phrase);\n      await _classPrivateMethodGet(this, _saveData, _saveData2).call(this, {\n        address: wallet.address,\n        data: mnemonic,\n        strategy: \"mnemonic\",\n        isEncrypted: !!options.encryption\n      }, options.storage);\n    }\n  }\n\n  /**\n   * @returns true if initialized wallet's data is saved in storage\n   */\n  async isSaved() {\n    try {\n      const data = await this.getSavedData();\n      const address = await this.getAddress();\n      if (data?.address === address) {\n        return true;\n      }\n      return false;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  /**\n   * deletes the saved wallet data from storage\n   */\n  async deleteSaved() {\n    await _classPrivateFieldGet(this, _storage2).removeItem(STORAGE_KEY_WALLET_DATA);\n  }\n\n  /**\n   * encrypts the wallet with given password and returns the encrypted wallet\n   * @param password - password for encrypting the wallet data\n   */\n  async export(options) {\n    const wallet = this.ethersWallet;\n    if (!wallet) {\n      throw new Error(\"Wallet is not initialized\");\n    }\n    if (options.strategy === \"encryptedJson\") {\n      return wallet.encrypt(options.password, {\n        scrypt: {\n          N: 1 << 32\n        }\n      });\n    }\n    if (options.strategy === \"privateKey\") {\n      return getEncryptor(options.encryption)(wallet.privateKey);\n    }\n    if (options.strategy === \"mnemonic\") {\n      if (!wallet.mnemonic) {\n        throw new Error(\"mnemonic can not be computed if wallet is created from a private key or generated using generate()\");\n      }\n      return getEncryptor(options.encryption)(wallet.mnemonic.phrase);\n    }\n    throw new Error(\"Invalid export strategy\");\n  }\n\n  /**\n   * Get the saved wallet data from storage\n   */\n  async getSavedData(storage) {\n    const _storage = storage || _classPrivateFieldGet(this, _storage2);\n    try {\n      const savedDataStr = await _storage.getItem(STORAGE_KEY_WALLET_DATA);\n      if (!savedDataStr) {\n        return null;\n      }\n      const savedData = JSON.parse(savedDataStr);\n      if (!savedData) {\n        return null;\n      }\n      return savedData;\n    } catch (e) {\n      return null;\n    }\n  }\n  async disconnect() {\n    await super.disconnect();\n    this.ethersWallet = undefined;\n  }\n}\nasync function _saveData2(data, storage) {\n  const _storage = storage || _classPrivateFieldGet(this, _storage2);\n  await _storage.setItem(STORAGE_KEY_WALLET_DATA, JSON.stringify(data));\n}\n_defineProperty(LocalWallet, \"id\", walletIds.localWallet);\n_defineProperty(LocalWallet, \"meta\", {\n  name: \"Local Wallet\",\n  iconURL: \"ipfs://QmbQzSNGvmNYZzem9jZRuYeLe9K2W4pqbdnVUp7Y6edQ8Y/local-wallet.svg\"\n}); // omit the mnemonic strategy option from LoadOptions\nasync function defaultEncrypt(message, password) {\n  const cryptoJS = (await import('crypto-js')).default;\n  return cryptoJS.AES.encrypt(message, password).toString();\n}\nasync function defaultDecrypt(message, password) {\n  const cryptoJS = (await import('crypto-js')).default;\n  return cryptoJS.AES.decrypt(message, password).toString(cryptoJS.enc.Utf8);\n}\n\n/**\n * if encryption object is provided\n *  - return the encryption.decrypt function if given, else return the default decrypt function\n * if encryption object is not provided\n * - return a noop function\n * @returns\n */\nfunction getDecryptor(encryption) {\n  const noop = async msg => msg;\n  return encryption ? msg => (encryption.decrypt || defaultDecrypt)(msg, encryption.password) : noop;\n}\n\n/**\n * if encryption object is provided\n *  - return the encryption.encrypt function if given, else return the default encrypt function\n * if encryption object is not provided\n * - return a noop function\n * @returns\n */\nfunction getEncryptor(encryption) {\n  const noop = async msg => msg;\n  return encryption ? msg => (encryption.encrypt || defaultEncrypt)(msg, encryption.password) : noop;\n}\nfunction isValidPrivateKey(value) {\n  return !!value.match(/^(0x)?[0-9a-f]{64}$/i);\n}\n\nexport { LocalWallet, isValidPrivateKey };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}