{"ast":null,"code":"'use strict';\n\nconst CID = require('cids');\nconst bases = require('./bases');\nconst codecs = require('./codecs');\n// @ts-ignore no types\nconst explain = require('explain-error');\nconst multibase = require('multibase');\nconst multihash = require('multihashes');\nconst uint8ArrayToString = require('uint8arrays/to-string');\n\n/**\n * @typedef {import('multibase').BaseName} BaseName\n * @typedef {import('multibase').BaseNameOrCode} BaseNameOrCode\n */\n\n/**\n * @param {CID | string | Uint8Array} cid\n * @param {import('./types').FormatOptions} options\n */\nmodule.exports = function format(cid, options) {\n  options = options || {};\n  let formatStr = options.format || '%s';\n  if (formatStr === 'prefix') {\n    formatStr = '%P';\n  }\n  if (!isString(formatStr) || formatStr.indexOf('%') === -1) {\n    throw new Error(\"invalid format string: \".concat(formatStr));\n  }\n  const originalCid = cid;\n  try {\n    cid = new CID(cid);\n  } catch (err) {\n    throw explain(err, \"invalid cid: \".concat(cid));\n  }\n  if (options.cidVersion != null && cid.version !== options.cidVersion) {\n    if (options.cidVersion === 0) {\n      cid = cid.toV0();\n    } else if (options.cidVersion === 1) {\n      cid = cid.toV1();\n    } else {\n      throw new Error(\"invalid cid version: \".concat(options.cidVersion));\n    }\n  }\n\n  /**\n   * @type {BaseName}\n   */\n  let base = 'base58btc';\n  if (options.base) {\n    // Validate passed base name/code\n    base = findBase(options.base).name;\n  } else if (isString(originalCid)) {\n    // Use base of input CID if string\n    base = multibase.isEncoded(originalCid) || base;\n  }\n  return formatStr.replace(/%([a-zA-Z%])/g, replacer(cid, base));\n};\n\n/**\n * @param {*} obj\n * @returns {obj is String}\n */\nfunction isString(obj) {\n  return Object.prototype.toString.call(obj) === '[object String]';\n}\n\n/**\n * @param {CID} cid\n * @param {BaseName} base\n * @returns {(match: any, specifier: string) => string}\n */\nfunction replacer(cid, base) {\n  /**\n   * @param {*} match\n   * @param {string} specifier\n   */\n  const replace = (match, specifier) => {\n    switch (specifier) {\n      case '%':\n        return '%';\n      case 'b':\n        // base name\n        return base;\n      case 'B':\n        // base code\n        return findBase(base).code;\n      case 'v':\n        // version string\n        return \"cidv\".concat(cid.version);\n      case 'V':\n        // version num\n        return cid.version.toString();\n      case 'c':\n        // codec name\n        return cid.codec;\n      case 'C':\n        // codec code\n        return findCodec(cid).toString();\n      case 'h':\n        // hash fun name\n        return multihash.decode(cid.multihash).name;\n      case 'H':\n        // hash fun code\n        return multihash.decode(cid.multihash).code.toString();\n      case 'L':\n        // hash length\n        return multihash.decode(cid.multihash).length.toString();\n      case 'm':\n        // multihash encoded in base %b\n        return uint8ArrayToString(multibase.encode(base, cid.multihash));\n      case 'M':\n        // multihash encoded in base %b without base prefix\n        return uint8ArrayToString(cid.multihash, base);\n      case 'd':\n        // hash digest encoded in base %b\n        return uint8ArrayToString(multibase.encode(base, multihash.decode(cid.multihash).digest));\n      case 'D':\n        // hash digest encoded in base %b without base prefix\n        return uint8ArrayToString(multihash.decode(cid.multihash).digest, base);\n      case 's':\n        // cid string encoded in base %b\n        return cid.toString(base);\n      case 'S':\n        // cid string without base prefix\n        return cid.version === 1 ? cid.toString(base).slice(1) : uint8ArrayToString(cid.bytes, base);\n      case 'P':\n        // prefix\n        return prefix(cid);\n      default:\n        throw new Error(\"unrecognized specifier in format string: \".concat(specifier));\n    }\n  };\n  return replace;\n}\n\n/**\n * @param {BaseNameOrCode} nameOrCode\n */\nfunction findBase(nameOrCode) {\n  const baseNameCode = bases().find(b => b.code === nameOrCode || b.name === nameOrCode);\n  if (!baseNameCode) {\n    throw new Error(\"invalid multibase: \".concat(nameOrCode));\n  }\n  return baseNameCode;\n}\n\n/**\n * @param {CID} cid\n */\nfunction findCodec(cid) {\n  const codec = codecs().find(c => c.name === cid.codec);\n  if (!codec) {\n    throw new Error(\"invalid codec: \".concat(cid.codec));\n  }\n  return codec.code;\n}\n\n/**\n * @param {CID} cid\n */\nfunction prefix(cid) {\n  const {\n    name,\n    length\n  } = multihash.decode(cid.multihash);\n  return \"cidv\".concat(cid.version, \"-\").concat(cid.codec, \"-\").concat(name, \"-\").concat(length);\n}","map":{"version":3,"names":["CID","require","bases","codecs","explain","multibase","multihash","uint8ArrayToString","module","exports","format","cid","options","formatStr","isString","indexOf","Error","concat","originalCid","err","cidVersion","version","toV0","toV1","base","findBase","name","isEncoded","replace","replacer","obj","Object","prototype","toString","call","match","specifier","code","codec","findCodec","decode","length","encode","digest","slice","bytes","prefix","nameOrCode","baseNameCode","find","b","c"],"sources":["C:/Misc/Documents/Career/FinTech/BlockChain/FrontEnd/buildspace-dao-starter/node_modules/cid-tool/src/core/format.js"],"sourcesContent":["'use strict'\n\nconst CID = require('cids')\nconst bases = require('./bases')\nconst codecs = require('./codecs')\n// @ts-ignore no types\nconst explain = require('explain-error')\nconst multibase = require('multibase')\nconst multihash = require('multihashes')\nconst uint8ArrayToString = require('uint8arrays/to-string')\n\n/**\n * @typedef {import('multibase').BaseName} BaseName\n * @typedef {import('multibase').BaseNameOrCode} BaseNameOrCode\n */\n\n/**\n * @param {CID | string | Uint8Array} cid\n * @param {import('./types').FormatOptions} options\n */\nmodule.exports = function format (cid, options) {\n  options = options || {}\n\n  let formatStr = options.format || '%s'\n\n  if (formatStr === 'prefix') {\n    formatStr = '%P'\n  }\n\n  if (!isString(formatStr) || formatStr.indexOf('%') === -1) {\n    throw new Error(`invalid format string: ${formatStr}`)\n  }\n\n  const originalCid = cid\n\n  try {\n    cid = new CID(cid)\n  } catch (err) {\n    throw explain(err, `invalid cid: ${cid}`)\n  }\n\n  if (options.cidVersion != null && cid.version !== options.cidVersion) {\n    if (options.cidVersion === 0) {\n      cid = cid.toV0()\n    } else if (options.cidVersion === 1) {\n      cid = cid.toV1()\n    } else {\n      throw new Error(`invalid cid version: ${options.cidVersion}`)\n    }\n  }\n\n  /**\n   * @type {BaseName}\n   */\n  let base = 'base58btc'\n\n  if (options.base) {\n    // Validate passed base name/code\n    base = findBase(options.base).name\n  } else if (isString(originalCid)) {\n    // Use base of input CID if string\n    base = multibase.isEncoded(originalCid) || base\n  }\n\n  return formatStr.replace(/%([a-zA-Z%])/g, replacer(cid, base))\n}\n\n/**\n * @param {*} obj\n * @returns {obj is String}\n */\nfunction isString (obj) {\n  return Object.prototype.toString.call(obj) === '[object String]'\n}\n\n/**\n * @param {CID} cid\n * @param {BaseName} base\n * @returns {(match: any, specifier: string) => string}\n */\nfunction replacer (cid, base) {\n  /**\n   * @param {*} match\n   * @param {string} specifier\n   */\n  const replace = (match, specifier) => {\n    switch (specifier) {\n      case '%':\n        return '%'\n      case 'b': // base name\n        return base\n      case 'B': // base code\n        return findBase(base).code\n      case 'v': // version string\n        return `cidv${cid.version}`\n      case 'V': // version num\n        return cid.version.toString()\n      case 'c': // codec name\n        return cid.codec\n      case 'C': // codec code\n        return findCodec(cid).toString()\n      case 'h': // hash fun name\n        return multihash.decode(cid.multihash).name\n      case 'H': // hash fun code\n        return multihash.decode(cid.multihash).code.toString()\n      case 'L': // hash length\n        return multihash.decode(cid.multihash).length.toString()\n      case 'm': // multihash encoded in base %b\n        return uint8ArrayToString(multibase.encode(base, cid.multihash))\n      case 'M': // multihash encoded in base %b without base prefix\n        return uint8ArrayToString(cid.multihash, base)\n      case 'd': // hash digest encoded in base %b\n        return uint8ArrayToString(multibase.encode(base, multihash.decode(cid.multihash).digest))\n      case 'D': // hash digest encoded in base %b without base prefix\n        return uint8ArrayToString(multihash.decode(cid.multihash).digest, base)\n      case 's': // cid string encoded in base %b\n        return cid.toString(base)\n      case 'S': // cid string without base prefix\n        return cid.version === 1\n          ? cid.toString(base).slice(1)\n          : uint8ArrayToString(cid.bytes, base)\n      case 'P': // prefix\n        return prefix(cid)\n\n      default:\n        throw new Error(`unrecognized specifier in format string: ${specifier}`)\n    }\n  }\n\n  return replace\n}\n\n/**\n * @param {BaseNameOrCode} nameOrCode\n */\nfunction findBase (nameOrCode) {\n  const baseNameCode = bases().find(b => (b.code === nameOrCode) || b.name === nameOrCode)\n\n  if (!baseNameCode) {\n    throw new Error(`invalid multibase: ${nameOrCode}`)\n  }\n\n  return baseNameCode\n}\n\n/**\n * @param {CID} cid\n */\nfunction findCodec (cid) {\n  const codec = codecs().find(c => c.name === cid.codec)\n\n  if (!codec) {\n    throw new Error(`invalid codec: ${cid.codec}`)\n  }\n\n  return codec.code\n}\n\n/**\n * @param {CID} cid\n */\nfunction prefix (cid) {\n  const { name, length } = multihash.decode(cid.multihash)\n  return `cidv${cid.version}-${cid.codec}-${name}-${length}`\n}\n"],"mappings":"AAAA,YAAY;;AAEZ,MAAMA,GAAG,GAAGC,OAAO,CAAC,MAAM,CAAC;AAC3B,MAAMC,KAAK,GAAGD,OAAO,CAAC,SAAS,CAAC;AAChC,MAAME,MAAM,GAAGF,OAAO,CAAC,UAAU,CAAC;AAClC;AACA,MAAMG,OAAO,GAAGH,OAAO,CAAC,eAAe,CAAC;AACxC,MAAMI,SAAS,GAAGJ,OAAO,CAAC,WAAW,CAAC;AACtC,MAAMK,SAAS,GAAGL,OAAO,CAAC,aAAa,CAAC;AACxC,MAAMM,kBAAkB,GAAGN,OAAO,CAAC,uBAAuB,CAAC;;AAE3D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACAO,MAAM,CAACC,OAAO,GAAG,SAASC,MAAMA,CAAEC,GAAG,EAAEC,OAAO,EAAE;EAC9CA,OAAO,GAAGA,OAAO,IAAI,CAAC,CAAC;EAEvB,IAAIC,SAAS,GAAGD,OAAO,CAACF,MAAM,IAAI,IAAI;EAEtC,IAAIG,SAAS,KAAK,QAAQ,EAAE;IAC1BA,SAAS,GAAG,IAAI;EAClB;EAEA,IAAI,CAACC,QAAQ,CAACD,SAAS,CAAC,IAAIA,SAAS,CAACE,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE;IACzD,MAAM,IAAIC,KAAK,2BAAAC,MAAA,CAA2BJ,SAAS,CAAE,CAAC;EACxD;EAEA,MAAMK,WAAW,GAAGP,GAAG;EAEvB,IAAI;IACFA,GAAG,GAAG,IAAIX,GAAG,CAACW,GAAG,CAAC;EACpB,CAAC,CAAC,OAAOQ,GAAG,EAAE;IACZ,MAAMf,OAAO,CAACe,GAAG,kBAAAF,MAAA,CAAkBN,GAAG,CAAE,CAAC;EAC3C;EAEA,IAAIC,OAAO,CAACQ,UAAU,IAAI,IAAI,IAAIT,GAAG,CAACU,OAAO,KAAKT,OAAO,CAACQ,UAAU,EAAE;IACpE,IAAIR,OAAO,CAACQ,UAAU,KAAK,CAAC,EAAE;MAC5BT,GAAG,GAAGA,GAAG,CAACW,IAAI,CAAC,CAAC;IAClB,CAAC,MAAM,IAAIV,OAAO,CAACQ,UAAU,KAAK,CAAC,EAAE;MACnCT,GAAG,GAAGA,GAAG,CAACY,IAAI,CAAC,CAAC;IAClB,CAAC,MAAM;MACL,MAAM,IAAIP,KAAK,yBAAAC,MAAA,CAAyBL,OAAO,CAACQ,UAAU,CAAE,CAAC;IAC/D;EACF;;EAEA;AACF;AACA;EACE,IAAII,IAAI,GAAG,WAAW;EAEtB,IAAIZ,OAAO,CAACY,IAAI,EAAE;IAChB;IACAA,IAAI,GAAGC,QAAQ,CAACb,OAAO,CAACY,IAAI,CAAC,CAACE,IAAI;EACpC,CAAC,MAAM,IAAIZ,QAAQ,CAACI,WAAW,CAAC,EAAE;IAChC;IACAM,IAAI,GAAGnB,SAAS,CAACsB,SAAS,CAACT,WAAW,CAAC,IAAIM,IAAI;EACjD;EAEA,OAAOX,SAAS,CAACe,OAAO,CAAC,eAAe,EAAEC,QAAQ,CAAClB,GAAG,EAAEa,IAAI,CAAC,CAAC;AAChE,CAAC;;AAED;AACA;AACA;AACA;AACA,SAASV,QAAQA,CAAEgB,GAAG,EAAE;EACtB,OAAOC,MAAM,CAACC,SAAS,CAACC,QAAQ,CAACC,IAAI,CAACJ,GAAG,CAAC,KAAK,iBAAiB;AAClE;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASD,QAAQA,CAAElB,GAAG,EAAEa,IAAI,EAAE;EAC5B;AACF;AACA;AACA;EACE,MAAMI,OAAO,GAAGA,CAACO,KAAK,EAAEC,SAAS,KAAK;IACpC,QAAQA,SAAS;MACf,KAAK,GAAG;QACN,OAAO,GAAG;MACZ,KAAK,GAAG;QAAE;QACR,OAAOZ,IAAI;MACb,KAAK,GAAG;QAAE;QACR,OAAOC,QAAQ,CAACD,IAAI,CAAC,CAACa,IAAI;MAC5B,KAAK,GAAG;QAAE;QACR,cAAApB,MAAA,CAAcN,GAAG,CAACU,OAAO;MAC3B,KAAK,GAAG;QAAE;QACR,OAAOV,GAAG,CAACU,OAAO,CAACY,QAAQ,CAAC,CAAC;MAC/B,KAAK,GAAG;QAAE;QACR,OAAOtB,GAAG,CAAC2B,KAAK;MAClB,KAAK,GAAG;QAAE;QACR,OAAOC,SAAS,CAAC5B,GAAG,CAAC,CAACsB,QAAQ,CAAC,CAAC;MAClC,KAAK,GAAG;QAAE;QACR,OAAO3B,SAAS,CAACkC,MAAM,CAAC7B,GAAG,CAACL,SAAS,CAAC,CAACoB,IAAI;MAC7C,KAAK,GAAG;QAAE;QACR,OAAOpB,SAAS,CAACkC,MAAM,CAAC7B,GAAG,CAACL,SAAS,CAAC,CAAC+B,IAAI,CAACJ,QAAQ,CAAC,CAAC;MACxD,KAAK,GAAG;QAAE;QACR,OAAO3B,SAAS,CAACkC,MAAM,CAAC7B,GAAG,CAACL,SAAS,CAAC,CAACmC,MAAM,CAACR,QAAQ,CAAC,CAAC;MAC1D,KAAK,GAAG;QAAE;QACR,OAAO1B,kBAAkB,CAACF,SAAS,CAACqC,MAAM,CAAClB,IAAI,EAAEb,GAAG,CAACL,SAAS,CAAC,CAAC;MAClE,KAAK,GAAG;QAAE;QACR,OAAOC,kBAAkB,CAACI,GAAG,CAACL,SAAS,EAAEkB,IAAI,CAAC;MAChD,KAAK,GAAG;QAAE;QACR,OAAOjB,kBAAkB,CAACF,SAAS,CAACqC,MAAM,CAAClB,IAAI,EAAElB,SAAS,CAACkC,MAAM,CAAC7B,GAAG,CAACL,SAAS,CAAC,CAACqC,MAAM,CAAC,CAAC;MAC3F,KAAK,GAAG;QAAE;QACR,OAAOpC,kBAAkB,CAACD,SAAS,CAACkC,MAAM,CAAC7B,GAAG,CAACL,SAAS,CAAC,CAACqC,MAAM,EAAEnB,IAAI,CAAC;MACzE,KAAK,GAAG;QAAE;QACR,OAAOb,GAAG,CAACsB,QAAQ,CAACT,IAAI,CAAC;MAC3B,KAAK,GAAG;QAAE;QACR,OAAOb,GAAG,CAACU,OAAO,KAAK,CAAC,GACpBV,GAAG,CAACsB,QAAQ,CAACT,IAAI,CAAC,CAACoB,KAAK,CAAC,CAAC,CAAC,GAC3BrC,kBAAkB,CAACI,GAAG,CAACkC,KAAK,EAAErB,IAAI,CAAC;MACzC,KAAK,GAAG;QAAE;QACR,OAAOsB,MAAM,CAACnC,GAAG,CAAC;MAEpB;QACE,MAAM,IAAIK,KAAK,6CAAAC,MAAA,CAA6CmB,SAAS,CAAE,CAAC;IAC5E;EACF,CAAC;EAED,OAAOR,OAAO;AAChB;;AAEA;AACA;AACA;AACA,SAASH,QAAQA,CAAEsB,UAAU,EAAE;EAC7B,MAAMC,YAAY,GAAG9C,KAAK,CAAC,CAAC,CAAC+C,IAAI,CAACC,CAAC,IAAKA,CAAC,CAACb,IAAI,KAAKU,UAAU,IAAKG,CAAC,CAACxB,IAAI,KAAKqB,UAAU,CAAC;EAExF,IAAI,CAACC,YAAY,EAAE;IACjB,MAAM,IAAIhC,KAAK,uBAAAC,MAAA,CAAuB8B,UAAU,CAAE,CAAC;EACrD;EAEA,OAAOC,YAAY;AACrB;;AAEA;AACA;AACA;AACA,SAAST,SAASA,CAAE5B,GAAG,EAAE;EACvB,MAAM2B,KAAK,GAAGnC,MAAM,CAAC,CAAC,CAAC8C,IAAI,CAACE,CAAC,IAAIA,CAAC,CAACzB,IAAI,KAAKf,GAAG,CAAC2B,KAAK,CAAC;EAEtD,IAAI,CAACA,KAAK,EAAE;IACV,MAAM,IAAItB,KAAK,mBAAAC,MAAA,CAAmBN,GAAG,CAAC2B,KAAK,CAAE,CAAC;EAChD;EAEA,OAAOA,KAAK,CAACD,IAAI;AACnB;;AAEA;AACA;AACA;AACA,SAASS,MAAMA,CAAEnC,GAAG,EAAE;EACpB,MAAM;IAAEe,IAAI;IAAEe;EAAO,CAAC,GAAGnC,SAAS,CAACkC,MAAM,CAAC7B,GAAG,CAACL,SAAS,CAAC;EACxD,cAAAW,MAAA,CAAcN,GAAG,CAACU,OAAO,OAAAJ,MAAA,CAAIN,GAAG,CAAC2B,KAAK,OAAArB,MAAA,CAAIS,IAAI,OAAAT,MAAA,CAAIwB,MAAM;AAC1D"},"metadata":{},"sourceType":"script","externalDependencies":[]}