{"ast":null,"code":"/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { EventDispatcher, Matrix4, PerspectiveCamera, Vector3 } from 'three';\nimport { XREstimatedLight } from 'three/examples/jsm/webxr/XREstimatedLight.js';\nimport { $currentBackground, $currentEnvironmentMap } from '../features/environment.js';\nimport { $onResize } from '../model-viewer-base.js';\nimport { assertIsArCandidate } from '../utilities.js';\nimport { Damper } from './Damper.js';\nimport { PlacementBox } from './PlacementBox.js';\n// number of initial null pose XRFrames allowed before we post not-tracking\nconst INIT_FRAMES = 30;\n// AR shadow is not user-configurable. This is to pave the way for AR lighting\n// estimation, which will be used once available in WebXR.\nconst AR_SHADOW_INTENSITY = 0.8;\nconst ROTATION_RATE = 1.5;\n// Angle down (towards bottom of screen) from camera center ray to use for hit\n// testing against the floor. This makes placement faster and more intuitive\n// assuming the phone is in portrait mode. This seems to be a reasonable\n// assumption for the start of the session and UI will lack landscape mode to\n// encourage upright use.\nconst HIT_ANGLE_DEG = 20;\nconst SCALE_SNAP_HIGH = 1.3;\nconst SCALE_SNAP_LOW = 1 / SCALE_SNAP_HIGH;\n// For automatic dynamic viewport scaling, don't let the scale drop below this\n// limit.\nconst MIN_VIEWPORT_SCALE = 0.25;\n// Furthest away you can move an object (meters).\nconst MAX_DISTANCE = 10;\nexport const ARStatus = {\n  NOT_PRESENTING: 'not-presenting',\n  SESSION_STARTED: 'session-started',\n  OBJECT_PLACED: 'object-placed',\n  FAILED: 'failed'\n};\nexport const ARTracking = {\n  TRACKING: 'tracking',\n  NOT_TRACKING: 'not-tracking'\n};\nconst vector3 = new Vector3();\nconst matrix4 = new Matrix4();\nconst hitPosition = new Vector3();\nconst camera = new PerspectiveCamera(45, 1, 0.1, 100);\nexport class ARRenderer extends EventDispatcher {\n  constructor(renderer) {\n    super();\n    this.renderer = renderer;\n    this.currentSession = null;\n    this.placeOnWall = false;\n    this.placementBox = null;\n    this.lastTick = null;\n    this.turntableRotation = null;\n    this.oldShadowIntensity = null;\n    this.frame = null;\n    this.initialHitSource = null;\n    this.transientHitTestSource = null;\n    this.inputSource = null;\n    this._presentedScene = null;\n    this.resolveCleanup = null;\n    this.exitWebXRButtonContainer = null;\n    this.overlay = null;\n    this.xrLight = null;\n    this.tracking = true;\n    this.frames = 0;\n    this.initialized = false;\n    this.oldTarget = new Vector3();\n    this.placementComplete = false;\n    this.isTranslating = false;\n    this.isRotating = false;\n    this.isTwoFingering = false;\n    this.lastDragPosition = new Vector3();\n    this.firstRatio = 0;\n    this.lastAngle = 0;\n    this.goalPosition = new Vector3();\n    this.goalYaw = 0;\n    this.goalScale = 1;\n    this.xDamper = new Damper();\n    this.yDamper = new Damper();\n    this.zDamper = new Damper();\n    this.yawDamper = new Damper();\n    this.scaleDamper = new Damper();\n    this.onExitWebXRButtonContainerClick = () => this.stopPresenting();\n    this.onUpdateScene = () => {\n      if (this.placementBox != null && this.isPresenting) {\n        this.placementBox.dispose();\n        this.placementBox = new PlacementBox(this.presentedScene, this.placeOnWall ? 'back' : 'bottom');\n      }\n    };\n    this.onSelectStart = event => {\n      const hitSource = this.transientHitTestSource;\n      if (hitSource == null) {\n        return;\n      }\n      const fingers = this.frame.getHitTestResultsForTransientInput(hitSource);\n      const scene = this.presentedScene;\n      const box = this.placementBox;\n      if (fingers.length === 1) {\n        this.inputSource = event.inputSource;\n        const {\n          axes\n        } = this.inputSource.gamepad;\n        const hitPosition = box.getHit(this.presentedScene, axes[0], axes[1]);\n        box.show = true;\n        if (hitPosition != null) {\n          this.isTranslating = true;\n          this.lastDragPosition.copy(hitPosition);\n        } else if (this.placeOnWall === false) {\n          this.isRotating = true;\n          this.lastAngle = axes[0] * ROTATION_RATE;\n        }\n      } else if (fingers.length === 2) {\n        box.show = true;\n        this.isTwoFingering = true;\n        const {\n          separation\n        } = this.fingerPolar(fingers);\n        this.firstRatio = separation / scene.scale.x;\n      }\n    };\n    this.onSelectEnd = () => {\n      this.isTranslating = false;\n      this.isRotating = false;\n      this.isTwoFingering = false;\n      this.inputSource = null;\n      this.goalPosition.y += this.placementBox.offsetHeight * this.presentedScene.scale.x;\n      this.placementBox.show = false;\n    };\n    this.threeRenderer = renderer.threeRenderer;\n    this.threeRenderer.xr.enabled = true;\n  }\n  async resolveARSession() {\n    assertIsArCandidate();\n    const session = await navigator.xr.requestSession('immersive-ar', {\n      requiredFeatures: ['hit-test'],\n      optionalFeatures: ['dom-overlay', 'light-estimation'],\n      domOverlay: this.overlay ? {\n        root: this.overlay\n      } : undefined\n    });\n    this.threeRenderer.xr.setReferenceSpaceType('local');\n    await this.threeRenderer.xr.setSession(session);\n    this.threeRenderer.xr.cameraAutoUpdate = false;\n    return session;\n  }\n  /**\n   * The currently presented scene, if any\n   */\n  get presentedScene() {\n    return this._presentedScene;\n  }\n  /**\n   * Resolves to true if the renderer has detected all the necessary qualities\n   * to support presentation in AR.\n   */\n  async supportsPresentation() {\n    try {\n      assertIsArCandidate();\n      return await navigator.xr.isSessionSupported('immersive-ar');\n    } catch (error) {\n      console.warn('Request to present in WebXR denied:');\n      console.warn(error);\n      console.warn('Falling back to next ar-mode');\n      return false;\n    }\n  }\n  /**\n   * Present a scene in AR\n   */\n  async present(scene) {\n    let environmentEstimation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (this.isPresenting) {\n      console.warn('Cannot present while a model is already presenting');\n    }\n    let waitForAnimationFrame = new Promise((resolve, _reject) => {\n      requestAnimationFrame(() => resolve());\n    });\n    scene.setHotspotsVisibility(false);\n    scene.queueRender();\n    // Render a frame to turn off the hotspots\n    await waitForAnimationFrame;\n    // This sets isPresenting to true\n    this._presentedScene = scene;\n    this.overlay = scene.element.shadowRoot.querySelector('div.default');\n    if (environmentEstimation === true) {\n      this.xrLight = new XREstimatedLight(this.threeRenderer);\n      this.xrLight.addEventListener('estimationstart', () => {\n        if (!this.isPresenting || this.xrLight == null) {\n          return;\n        }\n        const scene = this.presentedScene;\n        scene.add(this.xrLight);\n        scene.environment = this.xrLight.environment;\n      });\n    }\n    const currentSession = await this.resolveARSession();\n    currentSession.addEventListener('end', () => {\n      this.postSessionCleanup();\n    }, {\n      once: true\n    });\n    const exitButton = scene.element.shadowRoot.querySelector('.slot.exit-webxr-ar-button');\n    exitButton.classList.add('enabled');\n    exitButton.addEventListener('click', this.onExitWebXRButtonContainerClick);\n    this.exitWebXRButtonContainer = exitButton;\n    const viewerRefSpace = await currentSession.requestReferenceSpace('viewer');\n    this.tracking = true;\n    this.frames = 0;\n    this.initialized = false;\n    this.turntableRotation = scene.yaw;\n    this.goalYaw = scene.yaw;\n    this.goalScale = 1;\n    scene.background = null;\n    this.oldShadowIntensity = scene.shadowIntensity;\n    scene.setShadowIntensity(0.01); // invisible, but not changing the shader\n    this.oldTarget.copy(scene.getTarget());\n    scene.element.addEventListener('load', this.onUpdateScene);\n    const radians = HIT_ANGLE_DEG * Math.PI / 180;\n    const ray = this.placeOnWall === true ? undefined : new XRRay(new DOMPoint(0, 0, 0), {\n      x: 0,\n      y: -Math.sin(radians),\n      z: -Math.cos(radians)\n    });\n    currentSession.requestHitTestSource({\n      space: viewerRefSpace,\n      offsetRay: ray\n    }).then(hitTestSource => {\n      this.initialHitSource = hitTestSource;\n    });\n    this.currentSession = currentSession;\n    this.placementBox = new PlacementBox(scene, this.placeOnWall ? 'back' : 'bottom');\n    this.placementComplete = false;\n    this.lastTick = performance.now();\n    this.dispatchEvent({\n      type: 'status',\n      status: ARStatus.SESSION_STARTED\n    });\n  }\n  /**\n   * If currently presenting a scene in AR, stops presentation and exits AR.\n   */\n  async stopPresenting() {\n    if (!this.isPresenting) {\n      return;\n    }\n    const cleanupPromise = new Promise(resolve => {\n      this.resolveCleanup = resolve;\n    });\n    try {\n      await this.currentSession.end();\n      await cleanupPromise;\n    } catch (error) {\n      console.warn('Error while trying to end WebXR AR session');\n      console.warn(error);\n      this.postSessionCleanup();\n    }\n  }\n  /**\n   * True if a scene is currently in the process of being presented in AR\n   */\n  get isPresenting() {\n    return this.presentedScene != null;\n  }\n  get target() {\n    return this.oldTarget;\n  }\n  updateTarget() {\n    const scene = this.presentedScene;\n    if (scene != null) {\n      const target = scene.getTarget();\n      this.oldTarget.copy(target);\n      if (this.placeOnWall) {\n        // Move the scene's target to the center of the back of the model's\n        // bounding box.\n        target.z = scene.boundingBox.min.z;\n      } else {\n        // Move the scene's target to the model's floor height.\n        target.y = scene.boundingBox.min.y;\n      }\n      scene.setTarget(target.x, target.y, target.z);\n    }\n  }\n  postSessionCleanup() {\n    const session = this.currentSession;\n    if (session != null) {\n      session.removeEventListener('selectstart', this.onSelectStart);\n      session.removeEventListener('selectend', this.onSelectEnd);\n      this.currentSession = null;\n    }\n    const scene = this.presentedScene;\n    this._presentedScene = null;\n    if (scene != null) {\n      const {\n        element\n      } = scene;\n      if (this.xrLight != null) {\n        scene.remove(this.xrLight);\n        this.xrLight.dispose();\n        this.xrLight = null;\n      }\n      scene.position.set(0, 0, 0);\n      scene.scale.set(1, 1, 1);\n      scene.setShadowOffset(0);\n      const yaw = this.turntableRotation;\n      if (yaw != null) {\n        scene.yaw = yaw;\n      }\n      const intensity = this.oldShadowIntensity;\n      if (intensity != null) {\n        scene.setShadowIntensity(intensity);\n      }\n      scene.setEnvironmentAndSkybox(element[$currentEnvironmentMap], element[$currentBackground]);\n      const point = this.oldTarget;\n      scene.setTarget(point.x, point.y, point.z);\n      scene.xrCamera = null;\n      scene.element.removeEventListener('load', this.onUpdateScene);\n      scene.orientHotspots(0);\n      element.requestUpdate('cameraTarget');\n      element.requestUpdate('maxCameraOrbit');\n      element[$onResize](element.getBoundingClientRect());\n    }\n    // Force the Renderer to update its size\n    this.renderer.height = 0;\n    const exitButton = this.exitWebXRButtonContainer;\n    if (exitButton != null) {\n      exitButton.classList.remove('enabled');\n      exitButton.removeEventListener('click', this.onExitWebXRButtonContainerClick);\n      this.exitWebXRButtonContainer = null;\n    }\n    const hitSource = this.transientHitTestSource;\n    if (hitSource != null) {\n      hitSource.cancel();\n      this.transientHitTestSource = null;\n    }\n    const hitSourceInitial = this.initialHitSource;\n    if (hitSourceInitial != null) {\n      hitSourceInitial.cancel();\n      this.initialHitSource = null;\n    }\n    if (this.placementBox != null) {\n      this.placementBox.dispose();\n      this.placementBox = null;\n    }\n    this.lastTick = null;\n    this.turntableRotation = null;\n    this.oldShadowIntensity = null;\n    this.frame = null;\n    this.inputSource = null;\n    this.overlay = null;\n    if (this.resolveCleanup != null) {\n      this.resolveCleanup();\n    }\n    this.dispatchEvent({\n      type: 'status',\n      status: ARStatus.NOT_PRESENTING\n    });\n  }\n  updateView(view) {\n    const scene = this.presentedScene;\n    const xr = this.threeRenderer.xr;\n    xr.updateCamera(camera);\n    scene.xrCamera = xr.getCamera();\n    const {\n      elements\n    } = scene.getCamera().matrixWorld;\n    scene.orientHotspots(Math.atan2(elements[1], elements[5]));\n    if (!this.initialized) {\n      this.placeInitially();\n      this.initialized = true;\n    }\n    // Use automatic dynamic viewport scaling if supported.\n    if (view.requestViewportScale && view.recommendedViewportScale) {\n      const scale = view.recommendedViewportScale;\n      view.requestViewportScale(Math.max(scale, MIN_VIEWPORT_SCALE));\n    }\n    const layer = this.currentSession.renderState.baseLayer;\n    const viewport = layer.getViewport(view);\n    this.threeRenderer.setViewport(viewport.x, viewport.y, viewport.width, viewport.height);\n  }\n  placeInitially() {\n    const scene = this.presentedScene;\n    const {\n      position,\n      element\n    } = scene;\n    const xrCamera = scene.getCamera();\n    const {\n      width,\n      height\n    } = this.overlay.getBoundingClientRect();\n    scene.setSize(width, height);\n    xrCamera.projectionMatrixInverse.copy(xrCamera.projectionMatrix).invert();\n    const {\n      theta,\n      radius\n    } = element.getCameraOrbit();\n    // Orient model to match the 3D camera view\n    const cameraDirection = xrCamera.getWorldDirection(vector3);\n    scene.yaw = Math.atan2(-cameraDirection.x, -cameraDirection.z) - theta;\n    this.goalYaw = scene.yaw;\n    position.copy(xrCamera.position).add(cameraDirection.multiplyScalar(radius));\n    this.updateTarget();\n    const target = scene.getTarget();\n    position.add(target).sub(this.oldTarget);\n    this.goalPosition.copy(position);\n    scene.setHotspotsVisibility(true);\n    const {\n      session\n    } = this.frame;\n    session.addEventListener('selectstart', this.onSelectStart);\n    session.addEventListener('selectend', this.onSelectEnd);\n    session.requestHitTestSourceForTransientInput({\n      profile: 'generic-touchscreen'\n    }).then(hitTestSource => {\n      this.transientHitTestSource = hitTestSource;\n    });\n  }\n  getTouchLocation() {\n    const {\n      axes\n    } = this.inputSource.gamepad;\n    let location = this.placementBox.getExpandedHit(this.presentedScene, axes[0], axes[1]);\n    if (location != null) {\n      vector3.copy(location).sub(this.presentedScene.getCamera().position);\n      if (vector3.length() > MAX_DISTANCE) return null;\n    }\n    return location;\n  }\n  getHitPoint(hitResult) {\n    const refSpace = this.threeRenderer.xr.getReferenceSpace();\n    const pose = hitResult.getPose(refSpace);\n    if (pose == null) {\n      return null;\n    }\n    const hitMatrix = matrix4.fromArray(pose.transform.matrix);\n    if (this.placeOnWall === true) {\n      // Orient the model to the wall's normal vector.\n      this.goalYaw = Math.atan2(hitMatrix.elements[4], hitMatrix.elements[6]);\n    }\n    // Check that the y-coordinate of the normal is large enough that the normal\n    // is pointing up for floor placement; opposite for wall placement.\n    return hitMatrix.elements[5] > 0.75 !== this.placeOnWall ? hitPosition.setFromMatrixPosition(hitMatrix) : null;\n  }\n  moveToFloor(frame) {\n    const hitSource = this.initialHitSource;\n    if (hitSource == null) {\n      return;\n    }\n    const hitTestResults = frame.getHitTestResults(hitSource);\n    if (hitTestResults.length == 0) {\n      return;\n    }\n    const hit = hitTestResults[0];\n    const hitPoint = this.getHitPoint(hit);\n    if (hitPoint == null) {\n      return;\n    }\n    this.placementBox.show = true;\n    // If the user is translating, let the finger hit-ray take precedence and\n    // ignore this hit result.\n    if (!this.isTranslating) {\n      if (this.placeOnWall) {\n        this.goalPosition.copy(hitPoint);\n      } else {\n        this.goalPosition.y = hitPoint.y;\n      }\n    }\n    hitSource.cancel();\n    this.initialHitSource = null;\n    this.dispatchEvent({\n      type: 'status',\n      status: ARStatus.OBJECT_PLACED\n    });\n  }\n  fingerPolar(fingers) {\n    const fingerOne = fingers[0].inputSource.gamepad.axes;\n    const fingerTwo = fingers[1].inputSource.gamepad.axes;\n    const deltaX = fingerTwo[0] - fingerOne[0];\n    const deltaY = fingerTwo[1] - fingerOne[1];\n    const angle = Math.atan2(deltaY, deltaX);\n    let deltaYaw = this.lastAngle - angle;\n    if (deltaYaw > Math.PI) {\n      deltaYaw -= 2 * Math.PI;\n    } else if (deltaYaw < -Math.PI) {\n      deltaYaw += 2 * Math.PI;\n    }\n    this.lastAngle = angle;\n    return {\n      separation: Math.sqrt(deltaX * deltaX + deltaY * deltaY),\n      deltaYaw: deltaYaw\n    };\n  }\n  processInput(frame) {\n    const hitSource = this.transientHitTestSource;\n    if (hitSource == null) {\n      return;\n    }\n    if (!this.isTranslating && !this.isTwoFingering && !this.isRotating) {\n      return;\n    }\n    const fingers = frame.getHitTestResultsForTransientInput(hitSource);\n    const scene = this.presentedScene;\n    const scale = scene.scale.x;\n    // Rotating, translating and scaling are mutually exclusive operations; only\n    // one can happen at a time, but we can switch during a gesture.\n    if (this.isTwoFingering) {\n      if (fingers.length < 2) {\n        // If we lose the second finger, stop scaling (in fact, stop processing\n        // input altogether until a new gesture starts).\n        this.isTwoFingering = false;\n      } else {\n        const {\n          separation,\n          deltaYaw\n        } = this.fingerPolar(fingers);\n        if (this.placeOnWall === false) {\n          this.goalYaw += deltaYaw;\n        }\n        if (scene.canScale) {\n          const scale = separation / this.firstRatio;\n          this.goalScale = scale < SCALE_SNAP_HIGH && scale > SCALE_SNAP_LOW ? 1 : scale;\n        }\n      }\n      return;\n    } else if (fingers.length === 2) {\n      // If we were rotating or translating and we get a second finger, switch\n      // to scaling instead.\n      this.isTranslating = false;\n      this.isRotating = false;\n      this.isTwoFingering = true;\n      const {\n        separation\n      } = this.fingerPolar(fingers);\n      this.firstRatio = separation / scale;\n      return;\n    }\n    if (this.isRotating) {\n      const angle = this.inputSource.gamepad.axes[0] * ROTATION_RATE;\n      this.goalYaw += angle - this.lastAngle;\n      this.lastAngle = angle;\n    } else if (this.isTranslating) {\n      fingers.forEach(finger => {\n        if (finger.inputSource !== this.inputSource) {\n          return;\n        }\n        let hit = null;\n        if (finger.results.length > 0) {\n          hit = this.getHitPoint(finger.results[0]);\n        }\n        if (hit == null) {\n          hit = this.getTouchLocation();\n        }\n        if (hit == null) {\n          return;\n        }\n        this.goalPosition.sub(this.lastDragPosition);\n        if (this.placeOnWall === false) {\n          const offset = hit.y - this.lastDragPosition.y;\n          // When a lower floor is found, keep the model at the same height, but\n          // drop the placement box to the floor. The model falls on select end.\n          if (offset < 0) {\n            this.placementBox.offsetHeight = offset / scale;\n            this.presentedScene.setShadowOffset(offset);\n            // Interpolate hit ray up to drag plane\n            const cameraPosition = vector3.copy(scene.getCamera().position);\n            const alpha = -offset / (cameraPosition.y - hit.y);\n            cameraPosition.multiplyScalar(alpha);\n            hit.multiplyScalar(1 - alpha).add(cameraPosition);\n          }\n        }\n        this.goalPosition.add(hit);\n        this.lastDragPosition.copy(hit);\n      });\n    }\n  }\n  moveScene(delta) {\n    const scene = this.presentedScene;\n    const {\n      position,\n      yaw\n    } = scene;\n    const boundingRadius = scene.boundingSphere.radius;\n    const goal = this.goalPosition;\n    const oldScale = scene.scale.x;\n    const box = this.placementBox;\n    if (!goal.equals(position) || this.goalScale !== oldScale) {\n      let {\n        x,\n        y,\n        z\n      } = position;\n      x = this.xDamper.update(x, goal.x, delta, boundingRadius);\n      y = this.yDamper.update(y, goal.y, delta, boundingRadius);\n      z = this.zDamper.update(z, goal.z, delta, boundingRadius);\n      position.set(x, y, z);\n      const newScale = this.scaleDamper.update(oldScale, this.goalScale, delta, 1);\n      scene.scale.set(newScale, newScale, newScale);\n      if (!this.isTranslating) {\n        const offset = goal.y - y;\n        if (this.placementComplete && this.placeOnWall === false) {\n          box.offsetHeight = offset / newScale;\n          scene.setShadowOffset(offset);\n        } else if (offset === 0) {\n          this.placementComplete = true;\n          box.show = false;\n          scene.setShadowIntensity(AR_SHADOW_INTENSITY);\n        }\n      }\n    }\n    box.updateOpacity(delta);\n    scene.updateTarget(delta);\n    // yaw must be updated last, since this also updates the shadow position.\n    scene.yaw = this.yawDamper.update(yaw, this.goalYaw, delta, Math.PI);\n  }\n  /**\n   * Only public to make it testable.\n   */\n  onWebXRFrame(time, frame) {\n    this.frame = frame;\n    ++this.frames;\n    const refSpace = this.threeRenderer.xr.getReferenceSpace();\n    const pose = frame.getViewerPose(refSpace);\n    if (pose == null && this.tracking === true && this.frames > INIT_FRAMES) {\n      this.tracking = false;\n      this.dispatchEvent({\n        type: 'tracking',\n        status: ARTracking.NOT_TRACKING\n      });\n    }\n    const scene = this.presentedScene;\n    if (pose == null || scene == null || !scene.element.loaded) {\n      this.threeRenderer.clear();\n      return;\n    }\n    if (this.tracking === false) {\n      this.tracking = true;\n      this.dispatchEvent({\n        type: 'tracking',\n        status: ARTracking.TRACKING\n      });\n    }\n    // WebXR may return multiple views, i.e. for headset AR. This\n    // isn't really supported at this point, but make a best-effort\n    // attempt to render other views also, using the first view\n    // as the main viewpoint.\n    let isFirstView = true;\n    for (const view of pose.views) {\n      this.updateView(view);\n      if (isFirstView) {\n        this.moveToFloor(frame);\n        this.processInput(frame);\n        const delta = time - this.lastTick;\n        this.moveScene(delta);\n        this.renderer.preRender(scene, time, delta);\n        this.lastTick = time;\n        scene.renderShadow(this.threeRenderer);\n      }\n      this.threeRenderer.render(scene, scene.getCamera());\n      isFirstView = false;\n    }\n  }\n}","map":{"version":3,"names":["EventDispatcher","Matrix4","PerspectiveCamera","Vector3","XREstimatedLight","$currentBackground","$currentEnvironmentMap","$onResize","assertIsArCandidate","Damper","PlacementBox","INIT_FRAMES","AR_SHADOW_INTENSITY","ROTATION_RATE","HIT_ANGLE_DEG","SCALE_SNAP_HIGH","SCALE_SNAP_LOW","MIN_VIEWPORT_SCALE","MAX_DISTANCE","ARStatus","NOT_PRESENTING","SESSION_STARTED","OBJECT_PLACED","FAILED","ARTracking","TRACKING","NOT_TRACKING","vector3","matrix4","hitPosition","camera","ARRenderer","constructor","renderer","currentSession","placeOnWall","placementBox","lastTick","turntableRotation","oldShadowIntensity","frame","initialHitSource","transientHitTestSource","inputSource","_presentedScene","resolveCleanup","exitWebXRButtonContainer","overlay","xrLight","tracking","frames","initialized","oldTarget","placementComplete","isTranslating","isRotating","isTwoFingering","lastDragPosition","firstRatio","lastAngle","goalPosition","goalYaw","goalScale","xDamper","yDamper","zDamper","yawDamper","scaleDamper","onExitWebXRButtonContainerClick","stopPresenting","onUpdateScene","isPresenting","dispose","presentedScene","onSelectStart","event","hitSource","fingers","getHitTestResultsForTransientInput","scene","box","length","axes","gamepad","getHit","show","copy","separation","fingerPolar","scale","x","onSelectEnd","y","offsetHeight","threeRenderer","xr","enabled","resolveARSession","session","navigator","requestSession","requiredFeatures","optionalFeatures","domOverlay","root","undefined","setReferenceSpaceType","setSession","cameraAutoUpdate","supportsPresentation","isSessionSupported","error","console","warn","present","environmentEstimation","arguments","waitForAnimationFrame","Promise","resolve","_reject","requestAnimationFrame","setHotspotsVisibility","queueRender","element","shadowRoot","querySelector","addEventListener","add","environment","postSessionCleanup","once","exitButton","classList","viewerRefSpace","requestReferenceSpace","yaw","background","shadowIntensity","setShadowIntensity","getTarget","radians","Math","PI","ray","XRRay","DOMPoint","sin","z","cos","requestHitTestSource","space","offsetRay","then","hitTestSource","performance","now","dispatchEvent","type","status","cleanupPromise","end","target","updateTarget","boundingBox","min","setTarget","removeEventListener","remove","position","set","setShadowOffset","intensity","setEnvironmentAndSkybox","point","xrCamera","orientHotspots","requestUpdate","getBoundingClientRect","height","cancel","hitSourceInitial","updateView","view","updateCamera","getCamera","elements","matrixWorld","atan2","placeInitially","requestViewportScale","recommendedViewportScale","max","layer","renderState","baseLayer","viewport","getViewport","setViewport","width","setSize","projectionMatrixInverse","projectionMatrix","invert","theta","radius","getCameraOrbit","cameraDirection","getWorldDirection","multiplyScalar","sub","requestHitTestSourceForTransientInput","profile","getTouchLocation","location","getExpandedHit","getHitPoint","hitResult","refSpace","getReferenceSpace","pose","getPose","hitMatrix","fromArray","transform","matrix","setFromMatrixPosition","moveToFloor","hitTestResults","getHitTestResults","hit","hitPoint","fingerOne","fingerTwo","deltaX","deltaY","angle","deltaYaw","sqrt","processInput","canScale","forEach","finger","results","offset","cameraPosition","alpha","moveScene","delta","boundingRadius","boundingSphere","goal","oldScale","equals","update","newScale","updateOpacity","onWebXRFrame","time","getViewerPose","loaded","clear","isFirstView","views","preRender","renderShadow","render"],"sources":["C:\\Misc\\Documents\\Career\\FinTech\\BlockChain\\FrontEnd\\buildspace-dao-starter\\node_modules\\@google\\model-viewer\\src\\three-components\\ARRenderer.ts"],"sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {Event as ThreeEvent, EventDispatcher, Matrix4, PerspectiveCamera, Vector3, WebGLRenderer} from 'three';\nimport {XREstimatedLight} from 'three/examples/jsm/webxr/XREstimatedLight.js';\n\nimport {ControlsInterface} from '../features/controls.js';\nimport {$currentBackground, $currentEnvironmentMap} from '../features/environment.js';\nimport ModelViewerElementBase, {$onResize} from '../model-viewer-base.js';\nimport {assertIsArCandidate} from '../utilities.js';\n\nimport {Damper} from './Damper.js';\nimport {ModelScene} from './ModelScene.js';\nimport {PlacementBox} from './PlacementBox.js';\nimport {Renderer} from './Renderer.js';\n\n// number of initial null pose XRFrames allowed before we post not-tracking\nconst INIT_FRAMES = 30;\n// AR shadow is not user-configurable. This is to pave the way for AR lighting\n// estimation, which will be used once available in WebXR.\nconst AR_SHADOW_INTENSITY = 0.8;\nconst ROTATION_RATE = 1.5;\n// Angle down (towards bottom of screen) from camera center ray to use for hit\n// testing against the floor. This makes placement faster and more intuitive\n// assuming the phone is in portrait mode. This seems to be a reasonable\n// assumption for the start of the session and UI will lack landscape mode to\n// encourage upright use.\nconst HIT_ANGLE_DEG = 20;\nconst SCALE_SNAP_HIGH = 1.3;\nconst SCALE_SNAP_LOW = 1 / SCALE_SNAP_HIGH;\n// For automatic dynamic viewport scaling, don't let the scale drop below this\n// limit.\nconst MIN_VIEWPORT_SCALE = 0.25;\n// Furthest away you can move an object (meters).\nconst MAX_DISTANCE = 10;\n\nexport type ARStatus =\n    'not-presenting'|'session-started'|'object-placed'|'failed';\n\nexport const ARStatus: {[index: string]: ARStatus} = {\n  NOT_PRESENTING: 'not-presenting',\n  SESSION_STARTED: 'session-started',\n  OBJECT_PLACED: 'object-placed',\n  FAILED: 'failed'\n};\n\nexport interface ARStatusEvent extends ThreeEvent {\n  status: ARStatus,\n}\n\nexport type ARTracking = 'tracking'|'not-tracking';\n\nexport const ARTracking: {[index: string]: ARTracking} = {\n  TRACKING: 'tracking',\n  NOT_TRACKING: 'not-tracking'\n};\n\nexport interface ARTrackingEvent extends ThreeEvent {\n  status: ARTracking,\n}\n\nconst vector3 = new Vector3();\nconst matrix4 = new Matrix4();\nconst hitPosition = new Vector3();\nconst camera = new PerspectiveCamera(45, 1, 0.1, 100);\n\nexport class ARRenderer extends EventDispatcher {\n  public threeRenderer: WebGLRenderer;\n  public currentSession: XRSession|null = null;\n  public placeOnWall = false;\n\n  private placementBox: PlacementBox|null = null;\n  private lastTick: number|null = null;\n  private turntableRotation: number|null = null;\n  private oldShadowIntensity: number|null = null;\n  private frame: XRFrame|null = null;\n  private initialHitSource: XRHitTestSource|null = null;\n  private transientHitTestSource: XRTransientInputHitTestSource|null = null;\n  private inputSource: XRInputSource|null = null;\n  private _presentedScene: ModelScene|null = null;\n  private resolveCleanup: ((...args: any[]) => void)|null = null;\n  private exitWebXRButtonContainer: HTMLElement|null = null;\n  private overlay: HTMLElement|null = null;\n  private xrLight: XREstimatedLight|null = null;\n\n  private tracking = true;\n  private frames = 0;\n  private initialized = false;\n  private oldTarget = new Vector3();\n  private placementComplete = false;\n  private isTranslating = false;\n  private isRotating = false;\n  private isTwoFingering = false;\n  private lastDragPosition = new Vector3();\n  private firstRatio = 0;\n  private lastAngle = 0;\n  private goalPosition = new Vector3();\n  private goalYaw = 0;\n  private goalScale = 1;\n  private xDamper = new Damper();\n  private yDamper = new Damper();\n  private zDamper = new Damper();\n  private yawDamper = new Damper();\n  private scaleDamper = new Damper();\n\n  private onExitWebXRButtonContainerClick = () => this.stopPresenting();\n\n  constructor(private renderer: Renderer) {\n    super();\n    this.threeRenderer = renderer.threeRenderer;\n    this.threeRenderer.xr.enabled = true;\n  }\n\n  async resolveARSession(): Promise<XRSession> {\n    assertIsArCandidate();\n\n    const session: XRSession =\n        await navigator.xr!.requestSession!('immersive-ar', {\n          requiredFeatures: ['hit-test'],\n          optionalFeatures: ['dom-overlay', 'light-estimation'],\n          domOverlay: this.overlay ? {root: this.overlay} : undefined\n        });\n\n    this.threeRenderer.xr.setReferenceSpaceType('local');\n\n    await this.threeRenderer.xr.setSession(session);\n\n    this.threeRenderer.xr.cameraAutoUpdate = false;\n\n    return session;\n  }\n\n  /**\n   * The currently presented scene, if any\n   */\n  get presentedScene() {\n    return this._presentedScene;\n  }\n\n  /**\n   * Resolves to true if the renderer has detected all the necessary qualities\n   * to support presentation in AR.\n   */\n  async supportsPresentation(): Promise<boolean> {\n    try {\n      assertIsArCandidate();\n      return await navigator.xr!.isSessionSupported('immersive-ar');\n    } catch (error) {\n      console.warn('Request to present in WebXR denied:');\n      console.warn(error);\n      console.warn('Falling back to next ar-mode');\n      return false;\n    }\n  }\n\n  /**\n   * Present a scene in AR\n   */\n  async present(scene: ModelScene, environmentEstimation: boolean = false):\n      Promise<void> {\n    if (this.isPresenting) {\n      console.warn('Cannot present while a model is already presenting');\n    }\n\n    let waitForAnimationFrame = new Promise<void>((resolve, _reject) => {\n      requestAnimationFrame(() => resolve());\n    });\n\n    scene.setHotspotsVisibility(false);\n    scene.queueRender();\n    // Render a frame to turn off the hotspots\n    await waitForAnimationFrame;\n\n    // This sets isPresenting to true\n    this._presentedScene = scene;\n    this.overlay = scene.element.shadowRoot!.querySelector('div.default');\n\n    if (environmentEstimation === true) {\n      this.xrLight = new XREstimatedLight(this.threeRenderer);\n\n      this.xrLight.addEventListener('estimationstart', () => {\n        if (!this.isPresenting || this.xrLight == null) {\n          return;\n        }\n\n        const scene = this.presentedScene!;\n        scene.add(this.xrLight);\n\n        scene.environment = this.xrLight.environment;\n      });\n    }\n\n    const currentSession = await this.resolveARSession();\n\n    currentSession.addEventListener('end', () => {\n      this.postSessionCleanup();\n    }, {once: true});\n\n    const exitButton = scene.element.shadowRoot!.querySelector(\n                           '.slot.exit-webxr-ar-button') as HTMLElement;\n    exitButton.classList.add('enabled');\n    exitButton.addEventListener('click', this.onExitWebXRButtonContainerClick);\n    this.exitWebXRButtonContainer = exitButton;\n\n    const viewerRefSpace = await currentSession.requestReferenceSpace('viewer');\n\n    this.tracking = true;\n    this.frames = 0;\n    this.initialized = false;\n\n    this.turntableRotation = scene.yaw;\n    this.goalYaw = scene.yaw;\n    this.goalScale = 1;\n\n    scene.background = null;\n\n    this.oldShadowIntensity = scene.shadowIntensity;\n    scene.setShadowIntensity(0.01);  // invisible, but not changing the shader\n\n    this.oldTarget.copy(scene.getTarget());\n\n    scene.element.addEventListener('load', this.onUpdateScene);\n\n    const radians = HIT_ANGLE_DEG * Math.PI / 180;\n    const ray = this.placeOnWall === true ?\n        undefined :\n        new XRRay(\n            new DOMPoint(0, 0, 0),\n            {x: 0, y: -Math.sin(radians), z: -Math.cos(radians)});\n    currentSession\n        .requestHitTestSource!\n        ({space: viewerRefSpace, offsetRay: ray})!.then(hitTestSource => {\n          this.initialHitSource = hitTestSource;\n        });\n\n    this.currentSession = currentSession;\n    this.placementBox =\n        new PlacementBox(scene, this.placeOnWall ? 'back' : 'bottom');\n    this.placementComplete = false;\n\n    this.lastTick = performance.now();\n    this.dispatchEvent({type: 'status', status: ARStatus.SESSION_STARTED});\n  }\n\n  /**\n   * If currently presenting a scene in AR, stops presentation and exits AR.\n   */\n  async stopPresenting() {\n    if (!this.isPresenting) {\n      return;\n    }\n\n    const cleanupPromise = new Promise((resolve) => {\n      this.resolveCleanup = resolve;\n    });\n\n    try {\n      await this.currentSession!.end();\n      await cleanupPromise;\n    } catch (error) {\n      console.warn('Error while trying to end WebXR AR session');\n      console.warn(error);\n\n      this.postSessionCleanup();\n    }\n  }\n\n  /**\n   * True if a scene is currently in the process of being presented in AR\n   */\n  get isPresenting(): boolean {\n    return this.presentedScene != null;\n  }\n\n  get target(): Vector3 {\n    return this.oldTarget;\n  }\n\n  updateTarget() {\n    const scene = this.presentedScene;\n    if (scene != null) {\n      const target = scene.getTarget();\n      this.oldTarget.copy(target);\n      if (this.placeOnWall) {\n        // Move the scene's target to the center of the back of the model's\n        // bounding box.\n        target.z = scene.boundingBox.min.z;\n      } else {\n        // Move the scene's target to the model's floor height.\n        target.y = scene.boundingBox.min.y;\n      }\n      scene.setTarget(target.x, target.y, target.z);\n    }\n  }\n\n  onUpdateScene = () => {\n    if (this.placementBox != null && this.isPresenting) {\n      this.placementBox!.dispose();\n      this.placementBox = new PlacementBox(\n          this.presentedScene!, this.placeOnWall ? 'back' : 'bottom');\n    }\n  };\n\n  private postSessionCleanup() {\n    const session = this.currentSession;\n    if (session != null) {\n      session.removeEventListener('selectstart', this.onSelectStart);\n      session.removeEventListener('selectend', this.onSelectEnd);\n      this.currentSession = null;\n    }\n\n    const scene = this.presentedScene;\n    this._presentedScene = null;\n    if (scene != null) {\n      const {element} = scene;\n\n      if (this.xrLight != null) {\n        scene.remove(this.xrLight);\n        (this.xrLight as any).dispose();\n        this.xrLight = null;\n      }\n\n      scene.position.set(0, 0, 0);\n      scene.scale.set(1, 1, 1);\n      scene.setShadowOffset(0);\n      const yaw = this.turntableRotation;\n      if (yaw != null) {\n        scene.yaw = yaw;\n      }\n      const intensity = this.oldShadowIntensity;\n      if (intensity != null) {\n        scene.setShadowIntensity(intensity);\n      }\n      scene.setEnvironmentAndSkybox(\n          (element as any)[$currentEnvironmentMap],\n          (element as any)[$currentBackground]);\n      const point = this.oldTarget;\n      scene.setTarget(point.x, point.y, point.z);\n      scene.xrCamera = null;\n\n      scene.element.removeEventListener('load', this.onUpdateScene);\n      scene.orientHotspots(0);\n      element.requestUpdate('cameraTarget');\n      element.requestUpdate('maxCameraOrbit');\n      element[$onResize](element.getBoundingClientRect());\n    }\n\n    // Force the Renderer to update its size\n    this.renderer.height = 0;\n\n    const exitButton = this.exitWebXRButtonContainer;\n    if (exitButton != null) {\n      exitButton.classList.remove('enabled');\n      exitButton.removeEventListener(\n          'click', this.onExitWebXRButtonContainerClick);\n      this.exitWebXRButtonContainer = null;\n    }\n\n    const hitSource = this.transientHitTestSource;\n    if (hitSource != null) {\n      hitSource.cancel();\n      this.transientHitTestSource = null;\n    }\n\n    const hitSourceInitial = this.initialHitSource;\n    if (hitSourceInitial != null) {\n      hitSourceInitial.cancel();\n      this.initialHitSource = null;\n    }\n\n    if (this.placementBox != null) {\n      this.placementBox!.dispose();\n      this.placementBox = null;\n    }\n\n    this.lastTick = null;\n    this.turntableRotation = null;\n    this.oldShadowIntensity = null;\n    this.frame = null;\n    this.inputSource = null;\n    this.overlay = null;\n\n    if (this.resolveCleanup != null) {\n      this.resolveCleanup!();\n    }\n\n    this.dispatchEvent({type: 'status', status: ARStatus.NOT_PRESENTING});\n  }\n\n  private updateView(view: XRView) {\n    const scene = this.presentedScene!;\n    const xr = this.threeRenderer.xr as any;\n\n    xr.updateCamera(camera);\n    scene.xrCamera = xr.getCamera();\n    const {elements} = scene.getCamera().matrixWorld;\n    scene.orientHotspots(Math.atan2(elements[1], elements[5]));\n\n    if (!this.initialized) {\n      this.placeInitially();\n      this.initialized = true;\n    }\n\n    // Use automatic dynamic viewport scaling if supported.\n    if (view.requestViewportScale && view.recommendedViewportScale) {\n      const scale = view.recommendedViewportScale;\n      view.requestViewportScale(Math.max(scale, MIN_VIEWPORT_SCALE));\n    }\n    const layer = this.currentSession!.renderState.baseLayer;\n    const viewport = layer!.getViewport(view)!;\n    this.threeRenderer.setViewport(\n        viewport.x, viewport.y, viewport.width, viewport.height);\n  }\n\n  private placeInitially() {\n    const scene = this.presentedScene!;\n    const {position, element} = scene;\n    const xrCamera = scene.getCamera();\n\n    const {width, height} = this.overlay!.getBoundingClientRect();\n    scene.setSize(width, height);\n\n    xrCamera.projectionMatrixInverse.copy(xrCamera.projectionMatrix).invert();\n\n    const {theta, radius} =\n        (element as ModelViewerElementBase & ControlsInterface)\n            .getCameraOrbit();\n    // Orient model to match the 3D camera view\n    const cameraDirection = xrCamera.getWorldDirection(vector3);\n    scene.yaw = Math.atan2(-cameraDirection.x, -cameraDirection.z) - theta;\n    this.goalYaw = scene.yaw;\n\n    position.copy(xrCamera.position)\n        .add(cameraDirection.multiplyScalar(radius));\n\n    this.updateTarget();\n    const target = scene.getTarget();\n    position.add(target).sub(this.oldTarget);\n\n    this.goalPosition.copy(position);\n\n    scene.setHotspotsVisibility(true);\n\n    const {session} = this.frame!;\n    session.addEventListener('selectstart', this.onSelectStart);\n    session.addEventListener('selectend', this.onSelectEnd);\n    session\n        .requestHitTestSourceForTransientInput!\n        ({profile: 'generic-touchscreen'})!.then(hitTestSource => {\n          this.transientHitTestSource = hitTestSource;\n        });\n  }\n\n  private getTouchLocation(): Vector3|null {\n    const {axes} = this.inputSource!.gamepad!;\n    let location = this.placementBox!.getExpandedHit(\n        this.presentedScene!, axes[0], axes[1]);\n    if (location != null) {\n      vector3.copy(location).sub(this.presentedScene!.getCamera().position);\n      if (vector3.length() > MAX_DISTANCE)\n        return null;\n    }\n    return location;\n  }\n\n  private getHitPoint(hitResult: XRHitTestResult): Vector3|null {\n    const refSpace = this.threeRenderer.xr.getReferenceSpace()!;\n    const pose = hitResult.getPose(refSpace);\n    if (pose == null) {\n      return null;\n    }\n\n    const hitMatrix = matrix4.fromArray(pose.transform.matrix);\n\n    if (this.placeOnWall === true) {\n      // Orient the model to the wall's normal vector.\n      this.goalYaw = Math.atan2(hitMatrix.elements[4], hitMatrix.elements[6]);\n    }\n    // Check that the y-coordinate of the normal is large enough that the normal\n    // is pointing up for floor placement; opposite for wall placement.\n    return hitMatrix.elements[5] > 0.75 !== this.placeOnWall ?\n        hitPosition.setFromMatrixPosition(hitMatrix) :\n        null;\n  }\n\n  public moveToFloor(frame: XRFrame) {\n    const hitSource = this.initialHitSource;\n    if (hitSource == null) {\n      return;\n    }\n\n    const hitTestResults = frame.getHitTestResults(hitSource);\n    if (hitTestResults.length == 0) {\n      return;\n    }\n\n    const hit = hitTestResults[0];\n    const hitPoint = this.getHitPoint(hit);\n    if (hitPoint == null) {\n      return;\n    }\n\n    this.placementBox!.show = true;\n\n    // If the user is translating, let the finger hit-ray take precedence and\n    // ignore this hit result.\n    if (!this.isTranslating) {\n      if (this.placeOnWall) {\n        this.goalPosition.copy(hitPoint);\n      } else {\n        this.goalPosition.y = hitPoint.y;\n      }\n    }\n\n    hitSource.cancel();\n    this.initialHitSource = null;\n    this.dispatchEvent({type: 'status', status: ARStatus.OBJECT_PLACED});\n  }\n\n  private onSelectStart = (event: Event) => {\n    const hitSource = this.transientHitTestSource;\n    if (hitSource == null) {\n      return;\n    }\n    const fingers = this.frame!.getHitTestResultsForTransientInput(hitSource);\n    const scene = this.presentedScene!;\n    const box = this.placementBox!;\n\n    if (fingers.length === 1) {\n      this.inputSource = (event as XRInputSourceEvent).inputSource;\n      const {axes} = this.inputSource!.gamepad!;\n\n      const hitPosition = box.getHit(this.presentedScene!, axes[0], axes[1]);\n      box.show = true;\n\n      if (hitPosition != null) {\n        this.isTranslating = true;\n        this.lastDragPosition.copy(hitPosition);\n      } else if (this.placeOnWall === false) {\n        this.isRotating = true;\n        this.lastAngle = axes[0] * ROTATION_RATE;\n      }\n    } else if (fingers.length === 2) {\n      box.show = true;\n      this.isTwoFingering = true;\n      const {separation} = this.fingerPolar(fingers);\n      this.firstRatio = separation / scene.scale.x;\n    }\n  };\n\n  private onSelectEnd = () => {\n    this.isTranslating = false;\n    this.isRotating = false;\n    this.isTwoFingering = false;\n    this.inputSource = null;\n    this.goalPosition.y +=\n        this.placementBox!.offsetHeight * this.presentedScene!.scale.x;\n    this.placementBox!.show = false\n  };\n\n  private fingerPolar(fingers: XRTransientInputHitTestResult[]):\n      {separation: number, deltaYaw: number} {\n    const fingerOne = fingers[0].inputSource.gamepad!.axes;\n    const fingerTwo = fingers[1].inputSource.gamepad!.axes;\n    const deltaX = fingerTwo[0] - fingerOne[0];\n    const deltaY = fingerTwo[1] - fingerOne[1];\n    const angle = Math.atan2(deltaY, deltaX);\n    let deltaYaw = this.lastAngle - angle;\n    if (deltaYaw > Math.PI) {\n      deltaYaw -= 2 * Math.PI;\n    } else if (deltaYaw < -Math.PI) {\n      deltaYaw += 2 * Math.PI;\n    }\n    this.lastAngle = angle;\n    return {\n      separation: Math.sqrt(deltaX * deltaX + deltaY * deltaY),\n      deltaYaw: deltaYaw\n    };\n  }\n\n  private processInput(frame: XRFrame) {\n    const hitSource = this.transientHitTestSource;\n    if (hitSource == null) {\n      return;\n    }\n    if (!this.isTranslating && !this.isTwoFingering && !this.isRotating) {\n      return;\n    }\n    const fingers = frame.getHitTestResultsForTransientInput(hitSource);\n    const scene = this.presentedScene!;\n    const scale = scene.scale.x;\n\n    // Rotating, translating and scaling are mutually exclusive operations; only\n    // one can happen at a time, but we can switch during a gesture.\n    if (this.isTwoFingering) {\n      if (fingers.length < 2) {\n        // If we lose the second finger, stop scaling (in fact, stop processing\n        // input altogether until a new gesture starts).\n        this.isTwoFingering = false;\n      } else {\n        const {separation, deltaYaw} = this.fingerPolar(fingers);\n        if (this.placeOnWall === false) {\n          this.goalYaw += deltaYaw;\n        }\n        if (scene.canScale) {\n          const scale = separation / this.firstRatio;\n          this.goalScale =\n              (scale < SCALE_SNAP_HIGH && scale > SCALE_SNAP_LOW) ? 1 : scale;\n        }\n      }\n      return;\n    } else if (fingers.length === 2) {\n      // If we were rotating or translating and we get a second finger, switch\n      // to scaling instead.\n      this.isTranslating = false;\n      this.isRotating = false;\n      this.isTwoFingering = true;\n      const {separation} = this.fingerPolar(fingers);\n      this.firstRatio = separation / scale;\n      return;\n    }\n\n    if (this.isRotating) {\n      const angle = this.inputSource!.gamepad!.axes[0] * ROTATION_RATE;\n      this.goalYaw += angle - this.lastAngle;\n      this.lastAngle = angle;\n    } else if (this.isTranslating) {\n      fingers.forEach(finger => {\n        if (finger.inputSource !== this.inputSource) {\n          return;\n        }\n\n        let hit = null;\n        if (finger.results.length > 0) {\n          hit = this.getHitPoint(finger.results[0])\n        }\n        if (hit == null) {\n          hit = this.getTouchLocation();\n        }\n        if (hit == null) {\n          return;\n        }\n\n        this.goalPosition.sub(this.lastDragPosition);\n\n        if (this.placeOnWall === false) {\n          const offset = hit.y - this.lastDragPosition.y;\n          // When a lower floor is found, keep the model at the same height, but\n          // drop the placement box to the floor. The model falls on select end.\n          if (offset < 0) {\n            this.placementBox!.offsetHeight = offset / scale;\n            this.presentedScene!.setShadowOffset(offset);\n            // Interpolate hit ray up to drag plane\n            const cameraPosition = vector3.copy(scene.getCamera().position);\n            const alpha = -offset / (cameraPosition.y - hit.y);\n            cameraPosition.multiplyScalar(alpha);\n            hit.multiplyScalar(1 - alpha).add(cameraPosition);\n          }\n        }\n\n        this.goalPosition.add(hit);\n        this.lastDragPosition.copy(hit);\n      });\n    }\n  }\n\n  private moveScene(delta: number) {\n    const scene = this.presentedScene!;\n    const {position, yaw} = scene;\n    const boundingRadius = scene.boundingSphere.radius;\n    const goal = this.goalPosition;\n    const oldScale = scene.scale.x;\n    const box = this.placementBox!;\n\n    if (!goal.equals(position) || this.goalScale !== oldScale) {\n      let {x, y, z} = position;\n      x = this.xDamper.update(x, goal.x, delta, boundingRadius);\n      y = this.yDamper.update(y, goal.y, delta, boundingRadius);\n      z = this.zDamper.update(z, goal.z, delta, boundingRadius);\n      position.set(x, y, z);\n\n      const newScale =\n          this.scaleDamper.update(oldScale, this.goalScale, delta, 1);\n      scene.scale.set(newScale, newScale, newScale);\n\n      if (!this.isTranslating) {\n        const offset = goal.y - y;\n        if (this.placementComplete && this.placeOnWall === false) {\n          box.offsetHeight = offset / newScale;\n          scene.setShadowOffset(offset);\n        } else if (offset === 0) {\n          this.placementComplete = true;\n          box.show = false;\n          scene.setShadowIntensity(AR_SHADOW_INTENSITY);\n        }\n      }\n    }\n    box.updateOpacity(delta);\n    scene.updateTarget(delta);\n    // yaw must be updated last, since this also updates the shadow position.\n    scene.yaw = this.yawDamper.update(yaw, this.goalYaw, delta, Math.PI);\n  }\n\n  /**\n   * Only public to make it testable.\n   */\n  public onWebXRFrame(time: number, frame: XRFrame) {\n    this.frame = frame;\n    ++this.frames;\n    const refSpace = this.threeRenderer.xr.getReferenceSpace()!;\n    const pose = frame.getViewerPose(refSpace);\n\n    if (pose == null && this.tracking === true && this.frames > INIT_FRAMES) {\n      this.tracking = false;\n      this.dispatchEvent({type: 'tracking', status: ARTracking.NOT_TRACKING});\n    }\n\n    const scene = this.presentedScene;\n    if (pose == null || scene == null || !scene.element.loaded) {\n      this.threeRenderer.clear();\n      return;\n    }\n\n    if (this.tracking === false) {\n      this.tracking = true;\n      this.dispatchEvent({type: 'tracking', status: ARTracking.TRACKING});\n    }\n\n    // WebXR may return multiple views, i.e. for headset AR. This\n    // isn't really supported at this point, but make a best-effort\n    // attempt to render other views also, using the first view\n    // as the main viewpoint.\n    let isFirstView: boolean = true;\n    for (const view of pose.views) {\n      this.updateView(view);\n\n      if (isFirstView) {\n        this.moveToFloor(frame);\n\n        this.processInput(frame);\n\n        const delta = time - this.lastTick!;\n        this.moveScene(delta);\n        this.renderer.preRender(scene, time, delta);\n        this.lastTick = time;\n\n        scene.renderShadow(this.threeRenderer);\n      }\n\n      this.threeRenderer.render(scene, scene.getCamera());\n      isFirstView = false;\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}